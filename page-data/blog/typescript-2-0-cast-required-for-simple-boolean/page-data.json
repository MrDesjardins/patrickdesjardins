{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-2-0-cast-required-for-simple-boolean",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript 2.0 cast required for simple boolean?","date":"September 27, 2016"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript 2.0 cast required for simple boolean?\",\n  \"date\": \"2016-09-27\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"TypeScript is awesome to help you develop web application with significant amount of client-side script. It had on top of JavaScript some strong types and once compiled bring back everything to Javascript. Many huge project, like Angular 2 is using TypeScript. At Microsoft, Visual Studio Team Services is also using TypeScript. Few days ago, the TypeScript team released version 2.0 which bring some existing code to fail. Here is a snippet that illustrate the problem. The following code doesn't compile, right at the IF line. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var bool: boolean = true;\\nif (bool === false) { \\n  console.log(\\\"not true\\\"); \\n} else { \\n  console.log(\\\"not false\\\"); \\n} \\n\")), mdx(\"p\", null, \"However, the following code works: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var bool = true;\\n\\nif (bool === false) { \\n  console.log(\\\"not true\\\");\\n} \\nelse { \\n  console.log(\\\"not false\\\"); \\n} \\n\")), mdx(\"p\", null, \"Or this one works: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var bool: boolean = true;\\n\\nif ((bool as boolean) === false) { \\n  console.log(\\\"not true\\\"); \\n}\\nelse { \\n  console.log(\\\"not false\\\"); \\n} \\n\")), mdx(\"p\", null, \"Before I start explaining, let's be clear : I think the way it was working was good and I am not convinced that this new behavior will help reducing the amount of errors.\"), mdx(\"p\", null, \"So, how come \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var bool: boolean = true;\"), \" doesn't work when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var bool = true;\"), \" works? The second one infer the type from the value. And, if you play with it in the official \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play/index.html#src=%2F%2F----------%20Example%201%20Wrong%20now%0D%0Avar%20bool%3A%20boolean%20%3D%20true%3B%0D%0A%0D%0Aif%20(bool%20%3D%3D%3D%20false)%20%7B%0D%0A%20%20%20%20console.log(%22not%20true%22)%3B%0D%0A%7D%0D%0Aelse%20%7B%20%0D%0A%20%20%20%20console.log(%22not%20false%22)%3B%0D%0A%7D%0D%0A%2F%2F----------%20Example%202%20Good%20but%20from%20that%20new%20logic%20should%20be%20wrong%20too%20like%20example%201%0D%0Avar%20bool2%20%3D%20true%3B%20%2F%2FCursor%20hover%20show%20that%20bool%20is%20boolean.%20This%20time%2C%20it's%20fine.%0D%0A%0D%0Aif%20(bool2%20%3D%3D%3D%20false)%20%7B%0D%0A%20%20%20%20console.log(%22not%20true%22)%3B%0D%0A%7D%0D%0Aelse%20%7B%20%0D%0A%20%20%20%20console.log(%22not%20false%22)%3B%0D%0A%7D%0D%0A%0D%0A%2F%2F----------%20%20Example%203%20Boolean%20to%20boolean...%20complicated%20for%20nothing%3F%0D%0Avar%20bool3%3Aboolean%20%3D%20true%3B%0D%0A%0D%0Aif%20((bool3%20as%20boolean)%20%3D%3D%3D%20false)%20%7B%0D%0A%20%20%20%20console.log(%22not%20true%22)%3B%0D%0A%7D%0D%0Aelse%20%7B%20%0D%0A%20%20%20%20console.log(%22not%20false%22)%3B%0D%0A%7D%0D%0A%0D%0A%2F%2F----------%20%20Example%204%0D%0Avar%20bool4%3Aboolean%20%3D%20true%3B%0D%0Abool4%20%3D%20returnMethodToFalse(bool4)%3B%20%2F%2FThat%20is%20fine%20even%20if%20it%20return%20false%0D%0Aif%20(bool4%20%3D%3D%3D%20false)%20%7B%0D%0A%20%20%20%20console.log(%22not%20true%22)%3B%0D%0A%7D%0D%0Aelse%20%7B%20%0D%0A%20%20%20%20console.log(%22not%20false%22)%3B%0D%0A%7D%0D%0A%0D%0Afunction%20returnMethodToFalse(b%3Aboolean)%3Aboolean%7B%0D%0A%20%20%20%20return%20false%3B%0D%0A%7D\"\n  }, \"TypeScript Playground\"), \". You can see that the inferred type is boolean. \"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"243px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/c141817d0cb7019d9499b0c9cf8048cb/8aea6/inferredBoolean.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"44.855967078189295%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB20lEQVQoz22SsW7UQBCG/RhI9AE6CgqKSEggGloapIiapwBR0fAovAVCkA50iZJcyOV8Pt/5bK937V17ffba/tD5EhCIXxrt7L+jf/TPrAcgTIkoNIXWuytdVwGWvu/o++GG+xM7DD0M+ye6WxLwWueIckNpK4SM2Tow5iOBfwddHBJHzwnCpyyXhxT6CUY/Yj4/YB3dI1w+IFjcRVefkNpymQR427bFTxXV1pJXa6wDXb4nEx5l5Y1nKh6SJC+w9TOa5iVx/Jo0PWITHZElbyjtNxZJxPFsgmeblqUq6NzA7NKRJuD7r/hx5jGZeiTSQ+sPZAKWAcxmYGswtieUBj+zrKTgKr4eRzRa3s2w63oy4bAWCv2WdXzAJnmMqe7Ttu9GPs9b0rRBG0PdlFRbjSwTCqtIjaDt2r3lpSwY6GGMgb/R/5P/r+YWw14wygvKumfuQ1ltWcxmBEHAIpiPm1dKoZRA5R3z+YAfwsJ35FojCzkKDTeNvMY5MlNSb3uEBOcaolXIeh0Shgu0zslzhZSCsmpJ4o4wbNmsaowx5Eruv1fn6Fy7W0rDxTql/20HsnTDdHrO+cWUq8spJ5NTZJry5fNXzs5PaHJBcvqdWil0sEJc/0RcnCGzlF+UpZiOXjnJ0gAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"inferredBoolean\",\n    \"title\": \"inferredBoolean\",\n    \"src\": \"/static/c141817d0cb7019d9499b0c9cf8048cb/8aea6/inferredBoolean.png\",\n    \"srcSet\": [\"/static/c141817d0cb7019d9499b0c9cf8048cb/8aea6/inferredBoolean.png 243w\"],\n    \"sizes\": \"(max-width: 243px) 100vw, 243px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"In fact, the one without type is a bug and in version 2.1 will be fixed to also fail. But why? The culprit is under the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"boolean type\"), \" which doesn't exist in JavaScript. TypeScript creates an union of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true | false\"), \". However, in the example, we only set it to true. The compiler figure out that the real type of this variable is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"true\"), \", not true or false. TypeScript 2.0 supports literal types \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \". TypeScript only narrows union types. What means narrowing? Narrowing is limiting the value space that a variable can host based on some checks like typeof, instanceof, equality, etc.. Narrow type can be boolean as we just saw but also enum.\"), mdx(\"p\", null, \"You can still trick TypeScript compiler by using function that alter the value. But it still flacky. For example, the following code set the type to boolean, set the value to true and alter it to false within a function. Written this way, TypeScript figures out that the value can be true or false, hence keep the legacy boolean validation as correct. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var bool: boolean = true; \\nlet f = (() => { bool = false; })();\\n\\nif (bool === false) { \\n  console.log(\\\"bool is false\\\"); \\n} \\nelse { \\n  console.log(\\\"bool is true\\\"); \\n} \\n\")), mdx(\"p\", null, \"On the other hand, if you try to write the same code differently, this one get lost and won't let you compile: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var bool: boolean = true; \\nlet f = (() => { bool = false; }); f();\\n\\nif (bool === false) { \\n  console.log(\\\"bool is false\\\"); \\n} else { \\n  console.log(\\\"bool is true\\\"); \\n} \\n\")), mdx(\"p\", null, \"The last piece of code is harder for TypeScript to understand if the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"f\"), \" will be called. The first code is for sure to be executed. Does that mean that if we were to compare with true that it would fail? The answer is yes. The bool type is true. \"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"243px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/c141817d0cb7019d9499b0c9cf8048cb/8aea6/inferredBoolean.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"44.855967078189295%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB20lEQVQoz22SsW7UQBCG/RhI9AE6CgqKSEggGloapIiapwBR0fAovAVCkA50iZJcyOV8Pt/5bK937V17ffba/tD5EhCIXxrt7L+jf/TPrAcgTIkoNIXWuytdVwGWvu/o++GG+xM7DD0M+ye6WxLwWueIckNpK4SM2Tow5iOBfwddHBJHzwnCpyyXhxT6CUY/Yj4/YB3dI1w+IFjcRVefkNpymQR427bFTxXV1pJXa6wDXb4nEx5l5Y1nKh6SJC+w9TOa5iVx/Jo0PWITHZElbyjtNxZJxPFsgmeblqUq6NzA7NKRJuD7r/hx5jGZeiTSQ+sPZAKWAcxmYGswtieUBj+zrKTgKr4eRzRa3s2w63oy4bAWCv2WdXzAJnmMqe7Ttu9GPs9b0rRBG0PdlFRbjSwTCqtIjaDt2r3lpSwY6GGMgb/R/5P/r+YWw14wygvKumfuQ1ltWcxmBEHAIpiPm1dKoZRA5R3z+YAfwsJ35FojCzkKDTeNvMY5MlNSb3uEBOcaolXIeh0Shgu0zslzhZSCsmpJ4o4wbNmsaowx5Eruv1fn6Fy7W0rDxTql/20HsnTDdHrO+cWUq8spJ5NTZJry5fNXzs5PaHJBcvqdWil0sEJc/0RcnCGzlF+UpZiOXjnJ0gAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"inferredBoolean\",\n    \"title\": \"inferredBoolean\",\n    \"src\": \"/static/c141817d0cb7019d9499b0c9cf8048cb/8aea6/inferredBoolean.png\",\n    \"srcSet\": [\"/static/c141817d0cb7019d9499b0c9cf8048cb/8aea6/inferredBoolean.png 243w\"],\n    \"sizes\": \"(max-width: 243px) 100vw, 243px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Overall, this change is weird. Why would you take the time to define a type to boolean \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(true | false)\"), \" and let TypeScript overwrites your decision to decide either it should be true only or false only. It's also bringing some issues if you are using TypeScript's enum. For example, \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"enum MyEnum { Choice1, Choice2, Choice3 } \\n\")), mdx(\"p\", null, \" This translate into Choice1 being 0, Choice2 1 and Choice3 = 2. The problem is that 0 is false in JavaScript. The first check is to be sure we do not pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \". Since MyEnum.Choice1 is 0, which is false, it will never goes into the if of the following code. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function isChoice1(yourChoice: MyEnum) { \\n  if (yourChoice) {\\n     return yourChoice === MyEnum.Choice1; \\n  } \\n  return false; \\n} \\n\")), mdx(\"p\", null, \"This code won't compile because the triple equal is not about being \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yourChoice\"), \" being a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MyEnum\"), \" but \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yourChoice\"), \" being of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Choice2 | Choice3\"), \".\"), mdx(\"p\", null, \"Overall, this change will probably give you some headache first. You can always quickly fix it by casting to the type you desire. In the long run, you'll get more used about this control flow TypeScript analysis and will develop new habits.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"89360f13-c7fa-531c-adfd-ce931dd3c68f","totalPages":75}},
    "staticQueryHashes": ["3159585216"]}