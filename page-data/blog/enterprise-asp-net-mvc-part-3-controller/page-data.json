{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/enterprise-asp-net-mvc-part-3-controller",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Enterprise Asp.Net MVC Part 3: Controller","date":"October 31, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Enterprise Asp.Net MVC Part 3: Controller\",\n  \"date\": \"2012-10-31\",\n  \"categories\": [\"asp-mvc\", \"c-sharp\", \"enterprise\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this third part, we will discuss about controller. We aren't done yet with the model (still require to add more validation) but let's talk about the controller. In Asp.Net MVC, the controller act has the gate for the Http Request and answer back to any request with a Http Response. That's it. It's role should be limited to this task to respect the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://en.wikipedia.org/wiki/Single_responsibility_principle\"\n  }, \"Single Responsability Principle\"), \".\"), mdx(\"p\", null, \"But, we need to do a lot of thing when a client send information to the server. We need to convert the data in input to object, we need to convert this information to the model domain, we need to get into the database to load information and maybe to save information, we need to manipulate the data and we need to send back an answer. How can the controller be clean and in the same time be able to do all those things? Well, we will need to use the principle of seperation of concern and to split every task into multiple classes.\"), mdx(\"p\", null, \"We will start with the model binding, which is the first step of any request.\"), mdx(\"h2\", null, \"Auto-mapping\"), mdx(\"p\", null, \"In Asp.Net Mvc, the transformation of HTTP Get parameter or HTTP Post parameters into C# code is called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Model Binding\"), \". The Model binding by default try to convert any data to primitive type or try to instantiate your model object if the request contain a Json object that fit the schema of your classes. That mean that you can simply use Asp.Net MVC to send back all properties values of your model back to the server and Asp.Net MVC is bright enough to build a new object for you. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" [HttpPost] public ActionResult Create(WorkoutModel model) { //1)Validate model //2)Do manipulation //3)Save into the database\\n\\nreturn View(\\\"Create);//4)Return a response to the client } \\n``` The problem with this approach is, it works fine if you use Model object to send information to the view but we are using ViewModel (this was an architecture decision we took in the first part of this series). ViewModel give us the leverage to add additional information like a list of exercises that could be used in the workout, etc. So, before the task 1 of validating the model, we need to convert back the view model into model object. This is where **automapper** come to the rescue.\\n\\nAn automapper is a library that map property from an object to an other one. In our example, we will use [AutoMapper](http://automapper.org/). It's a free, open source, and widely used automapper. It can be configurable or by default map property name automatically. I won't show you how to use automapper in this article but you can find good example in this blog or anywhere on the web.\\n\\nSo, once we have receive the view model back to from the view to the controller, we need to automap the view model to the model. That mean that every time we use a controller action that we need to do this task. This can be repetitive and error prone. That's why a better approach is to implement a \\\"Model\\\" object. A little bit like Microsoft did with Asp.Net MVC with the View. We will create a Model property that will hold the converted view model. To do so, we will need to modify the BaseController.\\n\\n### Automapper and BaseController\\n\\nWe will modify the BaseController and override the method **OnActionExecuting**. This will give us the opportunity to modify the code before entering the code of the action defined inside the controller.\\n\\n![](images/workoutcontroller1.png)\\n\\nThis is an overview of what we are going to do. First, we will have a concrete controller for every entity. In our case, the WorkoutController. Each controller inherit of the BaseController which is generic with 2 types. The first one is the model type, and the second is the view model type. The BaseController contain a reference to a IMapperFactory, which is a layer of abstraction to the AutoMapper implementation. We will come back later with the IMapperFactory. Finally, the BaseController contain a property of TModel type. That mean that for the WorkoutController that we will be able to use \\\"this.Model\\\" to get the model from the view model. For another entity, the Model will be of the entity type because it will use the TModel type defined by the BaseController. Here is the code that reflect the illustration above.\\n\\n\\n```csharp\\n public class WorkoutController : BaseController<Workout, WorkoutViewModel> {\\n\\npublic WorkoutController(IMapperFactory mapperFactory):base(mapperFactory) { }\\n\\npublic ActionResult Index() { }\\n\\n[HttpGet] public ActionResult Details(int id) { }\\n\\n[HttpGet] public ActionResult Create() {\\n\\n}\\n\\n[HttpPost] public ActionResult Create(WorkoutViewModel viewModel) { }\\n\\n[HttpGet] public ActionResult Edit(int id) { }\\n\\n[HttpPost] public ActionResult Edit(WorkoutViewModel viewModel) { } }\\n\\npublic abstract class BaseController<TModel, TViewModel>:Controller { private readonly IMapperFactory_mapperFactory; protected TModel Model { get; private set; }\\n\\nprotected BaseController(IMapperFactory mapperFactory) {_mapperFactory = mapperFactory; }\\n\\nprotected override void OnActionExecuting(ActionExecutingContext filterContext) { base.OnActionExecuting(filterContext); if(filterContext.ActionParameters.Any()) { var possibleViewModel = filterContext.ActionParameters.FirstOrDefault(x => x.Value.GetType() == typeof(TViewModel)); if (possibleViewModel.Value!=null) { var viewModel = (TViewModel) possibleViewModel.Value; var model = (TModel) Activator.CreateInstance(typeof (TModel)); Model =_mapperFactory.Map(viewModel, model); } } } } \\n\")), mdx(\"p\", null, \"Anytime, inside the Update or Create, instead of using the viewModel parameter which is of WorkoutViewModel type, you can use the base.Model. This way to code give us few advantages. First, the controller is clean. No mapping is done on any concrete controller. Second, we still have access to the view model if required. Third, we do not repeat work on all controllers.\"), mdx(\"h2\", null, \"Service layer\"), mdx(\"p\", null, \"Now that we have the data from the view, we need to do some manipulation. We will skip the validation process because it will be in another part of this series. Let's jump to the service layers. The service layer is a layer between the service layer is above the controller and could be used not only by the web controller but by the web api controller or any other application. It's the layer between the user interaction and the repository. It's the one that can contact the repository, the cache, or manipulate many entity to return a unique one. The service layer will be used by the controller to access the repository and to build the view model. For example, it will load a specific workout if the user call the Edit action of the Workout controller. Not only it will load the workout, but it will give us the view model filled correctly with the extra properties that could contain additional choices to be selected (like a list of exercise) and additional localized text for example.\"), mdx(\"p\", null, \"So, we need to modify the WorkoutController to have a service reference. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class WorkoutController : BaseController<Workout, WorkoutViewModel> { public WorkoutController(IMapperFactory mapperFactory):base(mapperFactory) { } //... \\n``` will become: \\n```csharp\\n public class WorkoutController : BaseController<Workout, WorkoutViewModel> { private readonly IWorkoutService_service; public WorkoutController(IWorkoutService service, IMapperFactory mapperFactory):base(mapperFactory) {_service = service; } //... \\n\")), mdx(\"p\", null, \"As you can see, the IWorkoutService has been added. This will give us the possibility to inject the service into the controller. Every controller will have its own service.\"), mdx(\"p\", null, \"Because most of the service will look the same we can create a base service class, that I'll call IService. The IService will contain the primitive call that are concerning getting the model, saving the model and deleting the model. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public interface IService<TModel, TViewModel> { IEnumerable<TViewModel> GetAll(); TViewModel Get(TModel model); int Create(TModel model); int Update(TModel model); int Delete(TModel model); }\\n\\npublic interface IWorkoutService : IService<Workout, WorkoutViewModel> { } \\n\")), mdx(\"p\", null, \"We could add in IWorkoutService more specific method. For example, one could require to have a specicial Get that will return a extended view model with more data. Or, someone might want to have to model from the Get instead of the view model. This type of architecture let a flexibility.\"), mdx(\"p\", null, \"If we check the concrete implementation of IWorkoutService we will see all repository access and the automapper to convert the model to view model. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class WorkoutService : BaseService, IWorkoutService { public WorkoutService(IRepositoryFactory repositoryFactory, IMapperFactory mapperFactory) : base(repositoryFactory, mapperFactory) { }\\n\\n#region Implementation of IService<Workout>\\n\\npublic IEnumerable<WorkoutViewModel> GetAll() { var listModel = Repository.Workout.GetAll().ToList(); return Mapper.Map<List<Workout>,List<WorkoutViewModel>>(listModel); }\\n\\npublic WorkoutViewModel Get(Workout model) { var modelToBound = Repository.Workout.Get(model.Id); return Mapper.Map<Workout, WorkoutViewModel>(modelToBound); }\\n\\npublic int Create(Workout model) { return Repository.Workout.Insert(model); }\\n\\npublic int Update(Workout model) { return Repository.Workout.Update(model); }\\n\\npublic int Delete(Workout model) { return Repository.Workout.Delete(model); }\\n\\n#endregion } \\n\")), mdx(\"p\", null, \"As you can see, we are using the IMapperFactory to map data and not directly the automaper. This abstraction give us the possibility to mock the mapping easily later. Also, you can see that we are doing the same with the repository. We are using IRepositoryFactory which is not tightly bound to any repository, neither bound to the workout. That mean that workout could load exercises without problem. The detail about the repository will be defined in another article.\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"We have seen that we can have clean controller and the use of service help us to separate the request from the repository. We also have seen that it's better to use interface instead of concrete classes because it gives us the possibility to mock later on, give us a layer of abstraction between concrete implementation of the controller and from the repository, mapper and so on. In the next article of this series we will discuss about the repository and Entity Framework in an enterprise Asp.Net MVC web application. We will come back with controller in the article concerning validation of the model. Indeed, the controller will have its role with validation and we will see how to implement a solution that will still respect the single responsibility principle.\"), mdx(\"h3\", null, \"Series Articles\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-part-1-mvc-the-planification\"\n  }, \"Article #1: Asp.Net MVC Enterprise Quality Web Application\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-2-building-the-model\"\n  }, \"Article #2: Asp.Net MVC Enterprise Quality Web Application Model\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-3-controller\"\n  }, \"Article #3: Asp.Net MVC Enterprise Quality Web Application Controller\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-4-repository\"\n  }, \"Article #4: Asp.Net MVC Enterprise Quality Web Repository Layer\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-5-database-context-and-impersonate-data\"\n  }, \"Article #5: Asp.Net MVC Enterprise Quality Web with Entity Framework\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-6-the-three-layers-of-validation\"\n  }, \"Article #6: Asp.Net MVC Enterprise Quality Layers\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-7-securing-action-with-role-authorization\"\n  }, \"Article #7: Asp.Net MVC Enterprise Quality Web Security\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"ea57ab7b-27a3-5510-ac29-462ca8f1908e","totalPages":70}},
    "staticQueryHashes": ["3159585216"]}