{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/entity-framework-and-the-missing-class-entityconfiguration",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Entity Framework and the missing class EntityConfiguration","date":"March 17, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Entity Framework and the missing class EntityConfiguration\",\n  \"date\": \"2012-03-17\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Many blogs were written with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EntityConfiguration\"), \" class which doesn't exist in EF4.1 release version and above.\"), mdx(\"p\", null, \"If you need to do the mapping of your properties with table columns, you should not use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EntityTypeConfiguration\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ComplexTypeConfiguration\"), \" class. Those classes are in the namespace \\\"System.Data.Entity.ModelConfiguration\\\".\"), mdx(\"p\", null, \"This will let you in your DbContext class to override the method \\\"OnModelCreating\\\" and to set the configuration desired.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" protected override void OnModelCreating(DbModelBuilder modelBuilder) { //... modelBuilder.Configurations.Add(new MyClassConfiguration()); base.OnModelCreating(modelBuilder); }\\n\\n//In an other class: public class MyClassConfiguration: EntityTypeConfiguration<MyClass> { public MyClassConfiguration() { ToTable(\\\"MySuperOtherNameTable\\\"); Property(c => c.Code).HasColumnName(\\\"Code_Col1\\\"); Property(c => c.Name\\\"Name_FR_CANADA\\\"); } } \\n\")), mdx(\"p\", null, \"This let you have Entity Framework on a database that has been constructed without having the same name of your model. This use the Fluent interface of Entity Framework to accomplish this task. EF let you do it by attribute also (this will be discussed later). Of course, this require more manual labour but can be great to by pass some objects, one object or even a part of an object. Indeed, this can be use only on few properties of your object and let Entity Framework handle the rest of your object automatically.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"e87cc7ad-14c5-5a98-8989-7d23d53a4ed0","totalPages":71}},
    "staticQueryHashes": ["3159585216"]}