{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-transfer-files-between-computers-using-HDMI-Part-5-instruction-header",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to Transfer Files Between Computers Using HDMI (Part 5: Instruction Header)","date":"May 31, 2023"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to Transfer Files Between Computers Using HDMI (Part 5: Instruction Header)\",\n  \"date\": \"2023-05-31\",\n  \"categories\": [\"rust\", \"hdmi\", \"video\", \"encoding\", \"steganography\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is the fifth article about how to transfer a file using only video from one computer to another. Using a capture card and a HDMI output we can play a video that contain the content of a file and read the video on the other end. Once the video is received we can extract the content and have the file.\"), mdx(\"h1\", null, \"Current Situation\"), mdx(\"p\", null, \"At this point, we are able to transfer a single file that contain few words. We stubble into several issues: data transfer quality issue, rgb losing accuracy on bits, video encoding and duplicate data. Now, we need to tackle a bigger file.\"), mdx(\"h1\", null, \"Case 1: 53 megs zip file\"), mdx(\"p\", null, \"The first case was to inject into a video a zip file containing several pictures. The size was 53 megs and took about 4 minutes 20 seconds to inject into a video. The time is reasonable but make me think that many optimization could be applied to improve the performance. The generated video file is a 188 megs video of 7 seconds. The configuration is\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"cargo run -- -m inject -i outputs/Picture.zip -o outputs/out_zip_1px.mp4 --fps 30 --height 1080 --width 1920 --size 1 -a bw\\n\")), mdx(\"p\", null, \"I ran on the target computer:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"ffmpeg -r 30 -f dshow -s 1920x1080 -vcodec mjpeg -i video=\\\"USB Video\\\" -r 30 out_picturezip_1px.mp4\\n\")), mdx(\"p\", null, \"And it failed with a video of 75 megs and an extracted zip file of 8kb. However, I noticed that the source computer was lagging while playing the video. I suspect that many frames were not displayed, thus not recorded by the capture card.\"), mdx(\"p\", null, \"Other than trying to make the source computer run faster, I decided to give a try with a size of 5. The rational is that when extracting I noticed that the red frame were at 99.8 red, thus some information was missing as 100% would be that all the frame were red meaning all the black and white pixel that display.\"), mdx(\"p\", null, \"Increasing from 1 pixel for each bit to 5 has a couple of side effects which the main one being that intead of 4 minutes it was still running 30 minutes later. I had to stop the process and start improving the code to be able to iterate faster. But before, I tried to inject a 22megs zip file with a size of 5 took 7 minutes 14 seconds.\"), mdx(\"p\", null, \"A first change to increase the speed was to run the tool using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--release\"), \" flag (use this argument after the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo run\"), \". The 7 minutes went down to 2 minutes 12 seconds.\"), mdx(\"h1\", null, \"Case 2: Picture File Failure\"), mdx(\"p\", null, \"I decided to step back and try more on a single machine without the additional step of the display card. So far, I've been focusing on text which was fine but a zip file didn't work, nor a picture. What about doing a picture locally?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"cargo run -- -m inject -i outputs/test4.jpg -o outputs/test4_out_5px.mp4 --fps 30 --height 1080 --width 1920 --size 5 -a bw -p true\\ncargo run -- -m extract -i outputs/test4_out_5px.mp4 -o outputs/test4_extracted.jpg --fps 30 --height 1080 --width 1920 --size 5 -a bw\\n\")), mdx(\"p\", null, \"57 megs video for 10 second for a 2.99 meg picture. The extraction command 137kb! Something was off!\"), mdx(\"p\", null, \"At this point, my guts feeling was that the file was parsed and stopped because the end of file character was detected (the 0x04). With text, the character makes sense but with ZIP or picture or other format the character might be used. A modification to ensure that the end of the content into a frame was needed further than a single character. A quick search in a HEX editor on the video shows a lot of the character everywhere!\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"images/hdmi-file-transfer-article4_eof_char.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"The solution might be as easy as to have several eof characters next to each other. For example, having 50 eof would mean that it is really the end of the content. However, this is is easy to say, header to implement. The issue is current the code handle 1 video frame at a time.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rs\"\n  }, \"let rgb = get_pixel(source, x, y, info_size);\\nrgbs.push(vec![rgb[0], rgb[1], rgb[2]]);\\nlet bit_value = get_bit_from_rgb(rgb);\\nmutate_byte(&mut data, bit_value, bit_index);\\nbit_index = if bit_index == 0 { 7 } else { bit_index - 1 };\\nif bit_index == 7 {\\n    if data != EOF_CHAR { // <---- This need to change\\n        result.bytes.push(data);\\n        data = 0;\\n    } else {\\n        return result; \\n    }\\n}\\n\")), mdx(\"p\", null, \"A frame could be almost full, having only few character lefts to add the eof character and would need 49 spaces on the next frame. The actual code does not handle context between frame parsing. So, some changes would be needed.\"), mdx(\"h1\", null, \"Solutions\"), mdx(\"p\", null, \"After thinking everything straight, I notice that we could reserve the first few pixels to inject the number of bytes to extract. Instead of only encrypting the message (or picture) we could have the first 64 bytes to tell us the number of bytes to extract. For example, if we know that the message is 4 characters, instead of injecting 32 bits (black and white) we would have 64+32 bits. The video would be bigger but a relative addition when injecting a large file as the 64 bytes would remain constant. I'll go with 64 since it gives us a large number for large file.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"906de93d-fde8-5f04-8470-8de718723880","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}