{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/microsoft-net-4-5-1-binding-redirect",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Microsoft .Net 4.5.1 Binding Redirect","date":"September 24, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Microsoft .Net 4.5.1 Binding Redirect\",\n  \"date\": \"2013-09-24\",\n  \"categories\": [\"c-sharp\", \"visual-studio\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"With the new version of the Microsoft .Net, the 4.5.1, you will be able to use assembly that as been compiled with an other framework version dependency. For example, a project that use a library that itself use a library that we might use in the project but with an other version won't work normally. But, with the new feature called binding redirect, an entry inside the web.config (or app.config) is added to tell the .Net virtual machine to use for specific library the version of the dependency.\"), mdx(\"p\", null, \"Here is an example of the web.config:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \" <dependentAssembly> <assemblyIdentity name=\\\"assemblyWithDependencyProblem\\\" publicKeyToken=\\\"32ab4ba45e0a69a1\\\" culture=\\\"en-us\\\" /> <bindingRedirect oldVersion=\\\"1.0.0.0\\\" newVersion=\\\"2.0.0.0\\\" /> </dependentAssembly> \\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" Project A --> Library A --> Dependency 1 (version1) |---------> Dependency 2 (version2) \\n\")), mdx(\"p\", null, \"The example above would have an entry in the web.config (or app.config) that tell the dependency to use version 1 if used by Library A and use the version 2 when directly used by the project.\"), mdx(\"p\", null, \"It might not be an impressive feature because it's not visual but it's very useful. Often, library from the .Net framework could be problematic but this is a thing of the past.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"a0d4ad76-85f0-567a-9b20-d8aca4a9bdc9","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}