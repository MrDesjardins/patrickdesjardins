{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-react-reasons-not-to-desctruct-props",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Reasons for not using Property Destructuring in React when using TypeScript","date":"January 26, 2024"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Reasons for not using Property Destructuring in React when using TypeScript\",\n  \"date\": \"2024-01-26\",\n  \"categories\": [\"typescript\", \"react\", \"best-practices\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I have been using React with TypeScript for over seven years. With the transition toward the function component, I see a widely used pattern in JavaScript React emerging into TypeScript React but without a solid gain for the developer experience. I am talking about the use of property destruction in the function parameter.\"), mdx(\"p\", null, \"In this article, I'll be looking at the experience in TypeScript. Using JavaScript, destructuring properties explicitly tell the object's available properties. Thus, it has the benefit of documenting the component properties in JavaScript. In TypeScript, the interface already fulfills that role.\"), mdx(\"h1\", null, \"Reason 1: Component Signature Readability\"), mdx(\"p\", null, \"The first reason why property destructuring shouldn't be automatically selected is it makes the component signature-less readable. When you have a function with many parameters, it is hard to know what each parameter is.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export interface MyComponentProps {\\n  configuration: ConfigType;\\n  metadata: MetadataType;\\n  variant: Variant;\\n  color: PrimaryColor;\\n  link: string;\\n  onClick: () => void;\\n  onAction: (action: Action) => void;\\n  state: State;\\n  title: string;\\n}\\n\\nexport function MyComponent({\\n  configuration,\\n  metadata,\\n  variant,\\n  color,\\n  link,\\n  onClick,\\n  onAction,\\n  state,\\n  title,\\n}: MyComponentProps): ReactElement {\\n  return (\\n    <div>\\n      <h1>{title}</h1>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"Compared to:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\",\n    \"metastring\": \"{13}\",\n    \"{13}\": true\n  }, \"export interface MyComponentProps {\\n  configuration: ConfigType;\\n  metadata: MetadataType;\\n  variant: Variant;\\n  color: PrimaryColor;\\n  link: string;\\n  onClick: () => void;\\n  onAction: (action: Action) => void;\\n  state: State;\\n  title: string;\\n}\\n\\nexport function MyComponent(props: MyComponentProps): ReactElement {\\n  return (\\n    <div>\\n      <h1>{props.title}</h1>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"The readability gets worse if the type is not defined in an interface. Here is an example of NodeJS React component:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export default async function MyComponent({\\n  params: { segmentId },\\n}: {\\n  params: { segmentId: string };\\n}): Promise<ReactElement | undefined> {}\\n\")), mdx(\"h1\", null, \"Reason 2: Variable Origin\"), mdx(\"p\", null, \"React component tends to get large with state and effects. When you have a large component, it is hard to know where the variable comes from. Is it a prop, a state, or a variable and the parameters of an event? While looking at the component is the key, it is easier to know where the variable comes from when you don't use property destruction\\u2014keeping the object you know with certainty that the variable is coming from the props. The following code is short, but if it had 400 lines, it would be more work to find out where the value is coming from. Doing a pull request review is a case where the whole file is not always visible, and having the object clarify at first glance where the variable is coming from.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\",\n    \"metastring\": \"{4}\",\n    \"{4}\": true\n  }, \"export function MyComponent(props: MyComponentProps): ReactElement {\\n  return (\\n    <div>\\n      <h1>{props.title}</h1>\\n    </div>\\n  );\\n}\\n\")), mdx(\"h1\", null, \"Reason 3: Reusability with Children Components and Functions\"), mdx(\"p\", null, \"Another reason is that once the properties are out of the object, you must rebuild an object if you need to pass the object to a child component. This is not a big deal, but it is an extra step that is not required. Destructuring can be handy to pass a partial parent prop to a child component.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent(props: MyComponentProps): ReactElement {\\n  const childProps: MyChildWithPartialProps = { // Valid destructuring case\\n    state: props.state,\\n    title: props.title,\\n  };\\n  return (\\n    <div>\\n      <MyChild {...props} />\\n      <MyChildWithPartial {...childProps} />\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"On the same line of thought, if you have a function that handles data from the props, instead of passing back several destructed variables to a function, you can pass the whole object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent(props: MyComponentProps): ReactElement {\\n  //...\\n  const filteredData = filterData(props);\\n  return (\\n    //...\\n  );\\n}\\n\")), mdx(\"h1\", null, \"Reason 4: Name Conflict\"), mdx(\"p\", null, \"Using the object prevents property conflict with variables inside the React component. A standard solution is to rename when destructing objects, decreasing readability. Instead, using the object isolate variable, which would use the same name of one of the component properties.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent({\\n  configuration,\\n  metadata,\\n  variant,\\n  color,\\n  link,\\n  onClick,\\n  onAction,\\n  state,\\n  title: componentTitle,\\n}: MyComponentProps): ReactElement {\\n  //...\\n  const title = getTitle();\\n  //..\\n  return (\\n    <div>\\n      <h1>{componentTitle}</h1>\\n      <h2>{title}</h2>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"Versus:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent(props: MyComponentProps): ReactElement {\\n  //...\\n  const title = getTitle();\\n  //..\\n  return (\\n    <div>\\n      <h1>{props.title}</h1>\\n      <h2>{title}</h2>\\n    </div>\\n  );\\n}\\n\")), mdx(\"h1\", null, \"Reason 5: Abuse of Property Destructuring with Deep Nestling\"), mdx(\"p\", null, \"The word abuse is a little intense, but nothing restrains someone from getting deep into an object to extract value.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent({\\n  title :{\\n    translation: {\\n      image: {\\n        alternate: {\\n          title\\n        }\\n      }\\n    }\\n  },\\n  },\\n}): ReactElement {\\n  return (\\n    <div>\\n      <h1>{title}</h1>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"Versus:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent(props: MyComponentProps): ReactElement {\\n  return (\\n    <div>\\n      <h1>{props.translation.image.alternate.title}</h1>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"A bonus issue is that the code will throw an error if the object is null or undefined. With properties, the optional chaining operator will not crash but will set the value to null or undefined.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent(props: MyComponentProps): ReactElement {\\n  return (\\n    <div>\\n      <h1>{props.translation.image?.alternate?.title ?? \\\"No title\\\"}</h1>\\n    </div>\\n  );\\n}\\n\")), mdx(\"h1\", null, \"Reason 6: Developer Experience\"), mdx(\"p\", null, \"When developing with TypeScript and an IDE that supports autocomplete, using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props.\"), \" gives all the possible properties of the object. Autocomplete of the whole object is not present when destructing the object. The IDE will not know the type of the object and will not give the properties. You need to adjust the destructed object to add a missing property, which can involve renaming because of name conflict. Instead, you can use properties and not have additional work to do.\"), mdx(\"p\", null, \"Debugging is a similar experience. If you destruct you are blind to potential properties that may have been helpful as you do not have access to the original property. Using the object, you can see all the properties and values selected in the destruction.\"), mdx(\"p\", null, \"Another point about developer experience is renaming. If you rename a variable inside the function from a destructed object, you create an alias on the destructed object and not modify the original object. On the other hand, modifying the interface of the props of the component does not change the variable name inside the function; it alters the destructed object.\"), mdx(\"h1\", null, \"Reason 7: Performance\"), mdx(\"p\", null, \"Each time you are destructuring an object, you create a variable and an object. The variables go into the heap and then are released later. That is not needed. Similarly, suppose you pass down the property to a child component. In that case, every render of the parent component creates variables losing the reference, and thus, the child component needs to evaluate the object each time. The creation of objects is not a big deal, React handles that case well, but it is not needed.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"This article has TypeScript in the title because I understand, coming from a typeless language, that destructuring the object is a way to get what property the object offers. In TypeScript, the type is already known and destructuring the object does not give this benefit. Assigning default value is an argument that favors destructuring, but its optional property can be handled gracefully inside the component. For example, in the deep nestling of property, we saw how the React component shows \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"No title\"), \" without polluting the component signature. The component signature should be simple and straightforward.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"5ce98f91-1602-5b0c-896b-9f79127cad70","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}