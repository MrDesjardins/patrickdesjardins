{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-react-reasons-not-to-desctruct-props",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Reasons for not using Property Destructuring in React when using TypeScript","date":"January 26, 2024"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Reasons for not using Property Destructuring in React when using TypeScript\",\n  \"date\": \"2024-01-26\",\n  \"categories\": [\"typescript\", \"react\", \"best-practices\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I have been using React with TypeScript for over seven years and with the transition toward function component I see a pattern that is most of the time not the best practice. I am talking about the use of property destruction in the function parameter.\"), mdx(\"h1\", null, \"Reason 1: Component Signature Readability\"), mdx(\"p\", null, \"The first reason why property destructuring shouldn't be automatically selected is it makes the component signature less readable. When you have a function with a lot of parameters, it is hard to know what each parameter is.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export interface MyComponentProps {\\n  configuration: ConfigType;\\n  metadata: MetadataType;\\n  variant: Variant;\\n  color: PrimaryColor;\\n  link: string;\\n  onClick: () => void;\\n  onAction: (action: Action) => void;\\n  state: State;\\n  title: string;\\n}\\n\\nexport function MyComponent({\\n  configuration,\\n  metadata,\\n  variant,\\n  color,\\n  link,\\n  onClick,\\n  onAction,\\n  state,\\n  title,\\n}: MyComponentProps): ReactElement {\\n  return (\\n    <div>\\n      <h1>{title}</h1>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"Compared to:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\",\n    \"metastring\": \"{13}\",\n    \"{13}\": true\n  }, \"export interface MyComponentProps {\\n  configuration: ConfigType;\\n  metadata: MetadataType;\\n  variant: Variant;\\n  color: PrimaryColor;\\n  link: string;\\n  onClick: () => void;\\n  onAction: (action: Action) => void;\\n  state: State;\\n  title: string;\\n}\\n\\nexport function MyComponent(props: MyComponentProps): ReactElement {\\n  return (\\n    <div>\\n      <h1>{props.title}</h1>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"The readability gets worst if the type is not defined in an interface. Here is an example of NodeJS React component:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export default async function MyComponent({\\n  params: { segmentId },\\n}: {\\n  params: { segmentId: string };\\n}): Promise<ReactElement | undefined> {}\\n\")), mdx(\"h1\", null, \"Reason 2: Variable Origin\"), mdx(\"p\", null, \"React component tends to get large with state and effects. When you have a large component, it is hard to know where the variable is coming from. Is it a prop, a state, or a variable and parameters of an event. While looking in the component is the key, it is easier to know where the variable is coming from when you don't use property destruction. Keeping the object you know with certainty that the variable is coming from the props. The following code is short but in the case it had 400 lines, it would more work to find out where the value is coming from. Doing pull request review is a case where the whole file is not visible all the time and having the object clarify at first glance where the variable is coming from.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\",\n    \"metastring\": \"{4}\",\n    \"{4}\": true\n  }, \"export function MyComponent(props: MyComponentProps): ReactElement {\\n  return (\\n    <div>\\n      <h1>{props.title}</h1>\\n    </div>\\n  );\\n}\\n\")), mdx(\"h1\", null, \"Reason 3: Reusability with Children Components and Functions\"), mdx(\"p\", null, \"Another reason is once the properties are out the object, if you need to pass the object to a child component that you need to rebuild an object. This is not a big deal but it is an extra step that is not needed. Actually, destruction can be handy to pass a partial parent props to a child component.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent(props: MyComponentProps): ReactElement {\\n  const childProps: MyChildWithPartialProps = {\\n    state: props.state,\\n    title: props.title,\\n  };\\n  return (\\n    <div>\\n      <MyChild {...props} />\\n      <MyChildWithPartial {...childProps} />\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"On the same line of thought, if you have function that handle data from the props, instead of passing back several descructed variables to a function you can pass the whole object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent(props: MyComponentProps): ReactElement {\\n  //...\\n  const filteredData = filterData(props);\\n  return (\\n    //...\\n  );\\n}\\n\")), mdx(\"h1\", null, \"Reason 4: Name Conflict\"), mdx(\"p\", null, \"Using the object prevent conflict of property with variables inside the React component. A common solution is to rename when destructing the object which decrease the readability. Instead, using the object isolate variable who would use the same name of one of the component properties.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent({\\n  configuration,\\n  metadata,\\n  variant,\\n  color,\\n  link,\\n  onClick,\\n  onAction,\\n  state,\\n  title: componentTitle,\\n}: MyComponentProps): ReactElement {\\n  //...\\n  const title = getTitle();\\n  //..\\n  return (\\n    <div>\\n      <h1>{componentTitle}</h1>\\n      <h2>{title}</h2>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"Versus:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent(props: MyComponentProps): ReactElement {\\n  //...\\n  const title = getTitle();\\n  //..\\n  return (\\n    <div>\\n      <h1>{props.title}</h1>\\n      <h2>{title}</h2>\\n    </div>\\n  );\\n}\\n\")), mdx(\"h1\", null, \"Reason 5: Abuse of Property Destructuring with Deep Nestling\"), mdx(\"p\", null, \"The word abuse is a little strong but nothing restraint someone to get deep in an object to extract value.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent({\\n  title :{\\n    translation: {\\n      image: {\\n        alternate: {\\n          title\\n        }\\n      }\\n    }\\n  },\\n  },\\n}): ReactElement {\\n  return (\\n    <div>\\n      <h1>{title}</h1>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"Versus:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent(props: MyComponentProps): ReactElement {\\n  return (\\n    <div>\\n      <h1>{props.translation.image.alternate.title}</h1>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"A bonus issue is that if the object is null or undefined, the code will throw an error. With properties the optional chaining operator will not crash but set the value to null or undefined..\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export function MyComponent(props: MyComponentProps): ReactElement {\\n  return (\\n    <div>\\n      <h1>{props.translation.image?.alternate?.title ?? \\\"No title\\\"}</h1>\\n    </div>\\n  );\\n}\\n\")), mdx(\"h1\", null, \"Reason 6: Developer Experience\"), mdx(\"p\", null, \"When developing with TypeScript and an IDE that support autocomplete, using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props.\"), \" gives all the possible properties of the object. This is not the case when descructing the object. The IDE will not know the type of the object and will not give the properties. Actually, you need to adjust the desctructed object to add a property missing which can involve renaming because of name conflict. Instead, you can use properties and not having additional work to do.\"), mdx(\"p\", null, \"Debugging is a similar experience. If you destruct you are blind of potential properties that may have been helpful as you do not have access to the original property. Using the object, you can see all the properties and their values that has been selected in the destruction.\"), mdx(\"p\", null, \"Another point about developer experience is renaming. If you rename a variable inside the function that is from a destructed object you endup creasing an alias on the descructed object and not modifying the original object. On the other way around, modifying the interface of the props of the component does not change the variable name inside the function, it alters the descructed object.\"), mdx(\"h1\", null, \"Reason 7: Performance\"), mdx(\"p\", null, \"Each time you are destructuring an object, you create variable and object. The variables goes into the heap and then released later. That is not needed. Similarly if you pass down the property to a child component, every render of the parent component creates a variables loosing the reference and thus the child component need to evaluate each time the object. This is not a big deal, React handles well that case but it is not needed.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"This article has TypeScript in the title because I understand coming from a typeless language that descructing the object is a way to get what property the object offers. In TypeScript, the type is already known and descructing the object does not give this benefit. Assigning default value is an argument that favor destructuring but it optional property can be handled gracefully inside the component. For example, in the deep nestling of property, we saw how the React component shows \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"No title\"), \" without polluting the component signature. The component signature should be simple and clear.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"5ce98f91-1602-5b0c-896b-9f79127cad70","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}