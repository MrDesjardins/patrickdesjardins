{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/validation-with-viewmodel",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Validation with ViewModel","date":"January 14, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Validation with ViewModel\",\n  \"date\": \"2013-01-14\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This post won't explain how to do it with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-6-the-three-layers-of-validation\"\n  }, \"enterprise pattern\"), \" but will focus of some solutions available to validate your Model/ViewModel with Asp.Net MVC. This article won't focus of the advantage to use ViewModel instead of directly use Model object to the view. The article will show you how to validate your view model without having to repeat yourself in several place with your validation. We want to respect the DRY concept which specify that we should never repeat our self.\"), mdx(\"p\", null, \"First of all, Asp.Net MVC will call the data annotation and if the class inherit from IValidatableObject the method Validate. The problem as you can see is that the ViewModel which is bound to the controller doesn't have data annotation, neither inherit from IValidatableObject. Also, the mapping from the View Model to the Model occurs later in the process. This mean that we will need to manually call the validation to trigger the validation process which has been done to the view model.\"), mdx(\"p\", null, \"Second, the error which are associated to properties may not be link directly by the model to the view model. For example, your view model may have a property FullName which use the FirstName and LastName property. During the validation process, if an error occur on FirstName or LastName, the error will be associated to those property name and not FullName. This result that the error won't be displayed around the control in the view.\"), mdx(\"p\", null, \"They are several solution. The easiest is to only display errors in the summary. We simply need to set ExcludePropertyErrors to false in the summary.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" @Html.ValidationSummary(false) \\n\")), mdx(\"p\", null, \"By default, if no parameter is provided, the value is also false. So, you do not need to explicitly write false. Here is the ValidationExtensions.cs code for the two methods.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static MvcHtmlString ValidationSummary(this HtmlHelper htmlHelper) { return ValidationSummary(htmlHelper, false /* excludePropertyErrors */ ); }\\n\\npublic static MvcHtmlString ValidationSummary(this HtmlHelper htmlHelper, bool excludePropertyErrors) { return ValidationSummary(htmlHelper, excludePropertyErrors, null /* message */); } \\n\")), mdx(\"p\", null, \"A second solution is to map the property from the model to the view model.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://blogs.msdn.com/b/simonince/archive/2010/12/07/view-model-versus-domain-entity-validation-with-mvc.aspx\"\n  }, \"ScottGu\"), \" has a post that contain a helper class that does the job.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static class ControllerExtensions { public static bool TryValidateAndTranslate(this Controller controller, object model, string prefix, object propertyMap) { return TryValidateAndTranslate(controller, model, prefix, new RouteValueDictionary(propertyMap)); }\\n\\npublic static bool TryValidateAndTranslate(this Controller controller, object model, string prefix, RouteValueDictionary propertyMap) { ModelMetadata metadata = ModelMetadataProviders.Current.GetMetadataForType(() =&gt; model, model.GetType());\\n\\nforeach (ModelValidationResult validationResult in ModelValidator.GetModelValidator(metadata, controller.ControllerContext).Validate(null)) { var propertyName = CreatePropertyName(validationResult.MemberName, prefix, propertyMap); controller.ModelState.AddModelError(propertyName, validationResult.Message); }\\n\\nreturn controller.ModelState.IsValid; }\\n\\nprivate static string CreatePropertyName(string memberName, string prefix, RouteValueDictionary propertyMap) { string propertyName = null; object output = null; if (propertyMap.TryGetValue(memberName, out output)) propertyName = String.Format(\\\"{0}.{1}\\\", prefix, output.ToString()); else propertyName = String.Empty;\\n\\nreturn propertyName; } } \\n\")), mdx(\"p\", null, \"From there, you need to call the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TryValidateAndTranslate\"), \" method. The method will loop all validations associated to the object which can be data annotation validation or validation written inside the Validate method of IValidatableObject. The ModelValidator.GetModelValidator method is in fact used by the framework when you are using TryValidateModel.\"), mdx(\"p\", null, \"The usage of this method should be inside the method of the controller where the form is posted. Just after the mapping from the ViewModel to the Model.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" { //... action method\\n\\n//... map view model to model\\n\\nif (!this.TryValidateAndTranslate( modelObject, \\\"ModelClassName\\\", new { FirstName = \\\"FullName\\\", Property2 = \\\"Property2\\\" })) return View(viewModel);\\n\\n//... else return where you want to go when everything is without error } \\n\")), mdx(\"p\", null, \"If something is wrong, we display the view again with the view model, otherwise, we redirect to the list view or to any view you want where no error is found. As you can see, last parameter let you specify that the validation on FirstName property should be mapped to FullName. Of course, a better approach would be to setup in a central place all those mapping. The example is really just informative because you should try to map those property with something like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./?s=automapper\"\n  }, \"AutoMapper\"), \" and reuse the mapping from it.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"c45f711a-d868-5c82-a0cd-78aafc2ad999","totalPages":73}},
    "staticQueryHashes": ["3159585216"]}