{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/detecting-a-new-version-of-your-react-redux-app-in-15-minutes",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Detecting a New Version of your React-Redux App in 15 minutes","date":"September 12, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Detecting a New Version of your React-Redux App in 15 minutes\",\n  \"date\": \"2018-09-12\",\n  \"categories\": [\"general\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"While I am well aware of the feature of notifying to the user that a new version is ready to be served, I never implemented a solution myself.\\xA0Gmail and many websites do it to allow the user to refresh the website which brings the new JavaScript, CSS and other assets. It is a great way to encourage users to refresh the page once in a while. With Web application, it occurs that some users do not refresh so often. Myself, I rarely refresh my Gmail webpage until I see the notification.\"), mdx(\"p\", null, \"This week, someone raised the point that it would be interesting to have this feature on the application I am working on at Netflix. I wish I had time to do it, but instead of procrastinating, I decided to give it a try. The idea was to implement a way as cheap as possible since I have a backlog that is gargantuan.\\xA0\"), mdx(\"p\", null, \"If you recall, a few days ago, I discussed \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"burning-the-last-git-commit-into-your-telemetry-log\"\n  }, \"how to burn the Git hash into your React application\"), \". The article described how to inject in the environment variable the Git hash of the actual build. It is done at compilation time and the React has a way to read the information from JavaScript. In my case, the version is stored in an environment variable named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"REACT.APP_VERSION\"), \". It is accessible at runtime. That being said, the version remains on the client browser until the user fetches the new JavaScript file that has a new value which happens only on a new build. The idea is to leverage the fact that if the client keeps the version until a new version is available, on a refresh, then checking once in a while for a version change is a matter of comparing the Git hash on the client machine to the actual head of the repository.\"), mdx(\"p\", null, \"The idea can be broke down in few steps:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"On build, burn the Git Hash into the JavaScript\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"On build, generate a file with the Git Hash\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Fetch once in a while from the server a file that has the latest Git\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"If the Git Hash from the JavaScript environment variable is different from the file on the server, show a message to the user to refresh\")), mdx(\"p\", null, \"The first step has been \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"burning-the-last-git-commit-into-your-telemetry-log\"\n  }, \"already discussed\"), \", but in short, it consists to change the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm run build\"), \" to take the head Git hash and to pass it down to React.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" \\\"build\\\": \\\"REACT_APP_VERSION=$(git rev-parse --short HEAD) react-scripts-ts build\\\"\\n\")), mdx(\"p\", null, \"The second step require a change on the build system. At Netflix, we are using Jenkins. I added a Bash Script step that look like the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"CommitHash=$(git rev-parse --short HEAD) \\necho \\\"HASH\\\" \\necho $CommitHash \\necho $CommitHash > \\\"public/version.json\\\" \\necho \\\"VERSION FILE BEGIN\\\" cat public/version.json \\necho \\\"VERSION FILE END\\\" \\n\")), mdx(\"p\", null, \"The step number is open to how you want to handle it. I personally want to avoid \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setTimout\"), \". I rather have a Redux Middleware that will check once in a while. The middleware holds the time of the last check and on every action, verify that the time has elapsed from the threshold that you set. I have mine to 5 minutes. Every 5 minutes, or more depending of when the user does an action, it fetches the static file. As you can see in the previous step, the Git Hash is stored in a file under the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public\"), \" folder which is accessible with a simple Ajax call. If the string is different from the JavaScript environment variable, an action is dispatched that shows a message to the user to refresh the page.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \" const diff = this.currentTimeSinceEpoch() - this.lastCheck; \\n if (diff > SECONDS_BETWEEN_VERSION_CHECK) { \\n   this.lastCheck = this.currentTimeSinceEpoch(); \\n   (async () => { \\n     const currentVersion = process.env.REACT_APP_VERSION === undefined ? \\\"dev\\\" : process.env.REACT_APP_VERSION; \\n     try { \\n        const file = await AjaxLibraryThatYouUse<string>({ \\n         request: { url: \\\"/version.json\\\" \\n         } \\n        }); \\n        const newVersion = file.result; \\n        if (newVersion !== currentVersion) { \\n          next(SharedActions.actionInfoMessage(\\\"New version available!\\\")); \\n        } \\n      } catch (error) { \\n        // Track error here \\n      } \\n    })(); \\n  } \\n\")), mdx(\"p\", null, \"The solution took less than writing this article! It might not be a push notification, neither having a complete Rest API. It is not the most elegant because we fetch every 5 minutes, but at the end of the day, a new feature is born in 15 minutes of work. Now, I'm back to my backlog!\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"82dce3e5-77c7-5a77-97ee-1415fe9a50ba"}},
    "staticQueryHashes": ["3159585216"]}