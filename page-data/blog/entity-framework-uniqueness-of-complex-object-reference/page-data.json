{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/entity-framework-uniqueness-of-complex-object-reference",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Entity Framework Uniqueness of Complex Object reference","date":"November 29, 2016"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Working with Entity Framework and Complex object can be challenging. For example, they must be defined even if in your code you set them as null. Another limitation of complex object is that you cannot have two of them referencing the same object. You will get the following error when saving:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The entity of type 'xxx' references the same complex object of type 'zzz' more than once. Complex objects cannot be referenced multiple times by the same entity.\")), mdx(\"p\", null, \"This can happen really easily. Imagine this scenario where you have an entity that has two properties of a complex type \\\"Money\\\". \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class House{ public Money CurrentPrice{get;set;} public Money BoughtPrice{get;set;} } \\n``` If you just buy the house, the current price and bought price will be the same. You may just set the same Money instance to both properties. However, it will fail. It fails not because they have the same inner value (let's say the same decimal) but fails because both properties are linked to the same complex object.\\n\\nThe quick fix is to clone the price before saving the entity. By cloning each properties, they will be of the same complex type, but both objects will have be from a different object. Since complex type is simple by nature, like cannot reference other entities, the cloning is usually very simple if not just using the basic **MemberwiseClone**.\\n\\nThis is one of many traps that you may figure out only once you hit the database with the specific code of having the same reference. Do not overlook that scenario and always make sure that complex objects come with a unique instance before saving your changes with Entity Framework.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"Entity Framework Uniqueness of Complex Object reference\\\",\\\"date\\\":\\\"2016-11-29\\\",\\\"categories\\\":[\\\"entity-framework\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"17a38356-ac98-5f41-82c2-4de826e92d50","totalPages":69}},
    "staticQueryHashes": ["3159585216"]}