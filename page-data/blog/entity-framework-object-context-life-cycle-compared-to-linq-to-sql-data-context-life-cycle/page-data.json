{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/entity-framework-object-context-life-cycle-compared-to-linq-to-sql-data-context-life-cycle",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Entity Framework Object Context Life Cycle compared to Linq to Sql Data Context Life Cycle","date":"September 22, 2011"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Entity Framework Object Context Life Cycle compared to Linq to Sql Data Context Life Cycle\",\n  \"date\": \"2011-09-22\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Entity Framework Object Context\"), mdx(\"p\", null, \"The object created from the Entity Model that hold all objects has a life cycle like all other objects. But, this one should catch more your attention because it can come very big with all the object's state tracking that it has to remember. Moreover, it caches values. So, I do not have to tell you that with a medium or big application that the ram memory can come very high.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ObjectContext\"), \" class inherit from \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IDisposable\"), \" interface so you can, and should, use USING statement when using Entity Framework. The problem with this approach is that the object tracking is loss. So, it solves only the problem concerning the memory. If you are getting information and know that you gonna change it than is better not to use USING, but still use .Dispose at the end. But, if you get information only or you update right away the information, it's better to use USING.\"), mdx(\"h3\", null, \"States\"), mdx(\"p\", null, \"Entity Framework has 5 possibles states. The first one is when new object is adding. The state is than \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Added\"), \". Once saved the state of this object come to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Unchanged\"), \". When an object is deleted, its state changes to Deleted until the object context saves it to the database. It's than to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Detached\"), \". The Modified state is a little bit more tricky. When using Entity Object (Not POCO) when a scalar object is changed, the state automatically change to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Modified\"), \". For POCO, it requires to have a call to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DetectChanges\"), \" to be able to mark the object as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Modified\"), \". When an object is loaded from the object context, it's default state is unchanged.\"), mdx(\"p\", null, \"Here is a complete example that show with the Northwind database and Entityframework the state change from the creating to the removing phase.\"), mdx(\"p\", null, \"Lets take this code that create a new Order for a Customer and then remove it. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var db = new NorthwindEntities(); //Add a new Order var firstCustomer = db.Customers.First(); Debug.WriteLine(\\\"---Customer loaded---\\\"); Debug.WriteLine(\\\"FirstCustomer:\\\" + db.ObjectStateManager.GetObjectStateEntry(firstCustomer).State); var newOrder = new Orders(); // db.CreateObject<Orders>(); would do the samethiing Debug.WriteLine(\\\"---Orders Created---\\\"); Debug.WriteLine(\\\"FirstCustomer:\\\" + db.ObjectStateManager.GetObjectStateEntry(firstCustomer).State); Debug.WriteLine(\\\"newOrder: N/A because not yet inside the ObjectContext so not state yet. Could attach before adding to get state but not applicable now because the key is generated by the db and can't attack without key.\\\"); Debug.WriteLine(\\\"newOrder:\\\" + db.ObjectStateManager.GetObjectStateEntry(newOrder).State); firstCustomer.Orders.Add(newOrder); Debug.WriteLine(\\\"---Orders added---\\\"); Debug.WriteLine(\\\"FirstCustomer:\\\" + db.ObjectStateManager.GetObjectStateEntry(firstCustomer).State); Debug.WriteLine(\\\"newOrder:\\\" + db.ObjectStateManager.GetObjectStateEntry(newOrder).State); db.SaveChanges(); Debug.WriteLine(\\\"---Object Context save---\\\"); Debug.WriteLine(\\\"FirstCustomer:\\\" + db.ObjectStateManager.GetObjectStateEntry(firstCustomer).State); Debug.WriteLine(\\\"newOrder:\\\" + db.ObjectStateManager.GetObjectStateEntry(newOrder).State); Debug.WriteLine(\\\"---Remove the created object---\\\"); firstCustomer.Orders.Remove(newOrder); Debug.WriteLine(\\\"FirstCustomer:\\\" + db.ObjectStateManager.GetObjectStateEntry(firstCustomer).State); Debug.WriteLine(\\\"newOrder:\\\" + db.ObjectStateManager.GetObjectStateEntry(newOrder).State); db.SaveChanges(); Debug.WriteLine(\\\"---Object Context save---\\\"); Debug.WriteLine(\\\"FirstCustomer:\\\" + db.ObjectStateManager.GetObjectStateEntry(firstCustomer).State); Debug.WriteLine(\\\"newOrder:\\\" + db.ObjectStateManager.GetObjectStateEntry(newOrder).State); \\n\")), mdx(\"p\", null, \"The output of this code is :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"---Customer loaded--- FirstCustomer:Unchanged ---Orders Created--- FirstCustomer:Unchanged newOrder: N/A because not yet inside the ObjectContext so not state yet. Could attach before adding to get state ---Orders added--- FirstCustomer:Unchanged newOrder:Added ---Object Context save--- FirstCustomer:Unchanged newOrder:Unchanged ---Remove the created object--- FirstCustomer:Unchanged newOrder:Modified ---Object Context save--- FirstCustomer:Unchanged newOrder:Unchanged \\n\")), mdx(\"p\", null, \"We could also explore the state with the event. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var db = new NorthwindEntities(); db.ObjectStateManager.ObjectStateManagerChanged += new System.ComponentModel.CollectionChangeEventHandler(ObjectStateManager_ObjectStateManagerChanged); //Get existing Customer that has Order var customersWithOrder = db.Customers.Where(customer => customer.Orders.Count>15); //Add a new Order var firstCustomer = db.Customers.First(); var newOrder = new Orders(); // db.CreateObject<Orders>(); would do the samethiing firstCustomer.Orders.Add(newOrder); db.SaveChanges(); firstCustomer.Orders.Remove(newOrder); db.DeleteObject(newOrder); db.SaveChanges(); \\n\")), mdx(\"p\", null, \"This produce: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" -->LifeCycle.Customers-->Add -->LifeCycle.Orders-->Add -->LifeCycle.Orders-->Add -->LifeCycle.Orders-->Add -->LifeCycle.Orders-->Add -->LifeCycle.Orders-->Add -->LifeCycle.Orders-->Add -->LifeCycle.Orders-->Add -->LifeCycle.Orders-->Add -->LifeCycle.Orders-->Remove -->LifeCycle.Orders-->Remove \\n\")), mdx(\"p\", null, \"I prefer the first output because it's more clear.\"), mdx(\"h3\", null, \"Thread\"), mdx(\"p\", null, \"The ObjectContext class is not tread safe. You must have one object context per thread or to create you own thread synchronization process.\"), mdx(\"h2\", null, \"Linq to Sql Data Context\"), mdx(\"p\", null, \"As the ObjectContext, the DataContext class hold the track of each object state. It knows what has been modified, deleted or added. Also, Linq to Sql uses state even if nothing has changed to the object. When loaded, the object will be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Unchanged\"), \" or if you create a new object or deserialize an object, it will be a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Untracked\"), \".\"), mdx(\"p\", null, \"When an object is attached, by default its state will be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"PossiblyModified\"), \" and this is until the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SubmitChange\"), \". The next three states are very common \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ToBeInserted\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ToBeModified\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ToBeDeleted\"), \". The last possible state is when an object has been \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SumbitChange\"), \" when it was \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ToBeDeleted\"), \". When this happen, the object is still in the DataContext but with the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Deleted\"), \" state.\"), mdx(\"h3\", null, \"Thread\"), mdx(\"p\", null, \"The Linq to Sql DataContext class is not thread safe. It should not be static, neither\"), mdx(\"h2\", null, \"Where and when should EF or Linq2Sql live?\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://blogs.msdn.com/b/mattwar/archive/2004/03/05/about-me.aspx\"\n  }, \"Matt Warren\"), \", software achitect at Microsoft on the C# programming language product team and member of the team that created LINQ to SQL \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://social.msdn.microsoft.com/forums/en-US/linqprojectgeneral/thread/3ae5e457-099e-4d13-9a8b-df3ed4ba0bab/\"\n  }, \"explains\"), \" this question with a design pattern. Theses ORM should be treated as the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://martinfowler.com/eaaCatalog/unitOfWork.html\",\n    \"title\": \"Martin Fowler's Enterprise Design Pattern Unit Of Work\"\n  }, \"Unit of Work pattern\"), \".\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"A Unit of Work keeps track of everything you do during a business transaction that can affect the database. When you're done, it figures out everything that needs to be done to alter the database as a result of your work.\")), mdx(\"p\", null, \"That's it. The ORM object should live until the business task is done. For example, you need to edit a employee, you create the object when loading it, it's alive until it's saved or the task is cancelled. It does not remain until the application close in the memory.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"a3e52450-0b3e-58a0-aea5-2c3947ad86f6","totalPages":71}},
    "staticQueryHashes": ["3159585216"]}