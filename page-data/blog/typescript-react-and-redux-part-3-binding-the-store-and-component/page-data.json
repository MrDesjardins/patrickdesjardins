{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-react-and-redux-part-3-binding-the-store-and-component",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript, React and Redux Part 3 : Binding the Store and Component","date":"September 20, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript, React and Redux Part 3 : Binding the Store and Component\",\n  \"date\": \"2017-09-20\",\n  \"categories\": [\"react\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In the previous article, we saw how to create a store in Redux and how to bind this one with the React-Redux library. We created a simple reducer, but an important piece was missing. In this article, we will define how to bind the store and the component. This will be useful to have Redux updating React components, but also to have the component to raise an event in the action creator.\"), mdx(\"p\", null, \"We previously created the index.tsx which is the entry point of the web application. This one was creating the store, using the provider wrapper around the container component \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app\"), \" and was hooking the component to an HTML tag. We never defined the container component \\\"app\\\".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const store = createStore(appReducer); ReactDOM.render(\\n  <Provider store={store}> \\n    <App /> \\n  </Provider>, document.getElementById(\\\"main\\\")\\n); \\n\")), mdx(\"p\", null, \"A container component is different from a presentation component. This one is aware of Redux and its goal is to connect React and Redux. It must be a stateless component, which means that the container component doesn't have any state -- it's just a function : the render function. In the following code, you can see the stateless function. It uses many presentation component. You can also see that it receives by parameter IAppProps which is the property. This will be injected by Redux with data from the store.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const App = (props: IAppProps) => (\\n<div> <HeaderPanel /> \\n  <div className=\\\"container\\\"> \\n    <div className=\\\"row\\\"> \\n      <Filters \\n        filters={props.model.filters} \\n        onApply={() => { \\n          console.log(\\\"to do soon\\\"); \\n        }} \\n        filterChange={(filters: IFilters) => { \\n          console.log(\\\"filter changed\\\"); \\n          props.filterChange(filters); }} \\n      /> \\n      <ResultPanel results={props.model.results} /> \\n      </div> \\n    </div> \\n  </div> ); \\n\")), mdx(\"p\", null, \"If we look at the interface signature, we can see that the IAppProps contains the IAppState which is exactly the type used by the reducer to initialize the store.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface IAppProps extends IAppDispatch { \\n  model: IAppState; \\n} \\n\")), mdx(\"p\", null, \"You can also notice that the interface extends IAppDispatch. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface IAppDispatch { \\n  onApply: () => void; \\n  filterChange: (filters: IFilters) => void; } \\n\")), mdx(\"p\", null, \"This interface contains all method callback passed down the presentation containers. It allows to have a good separation of concerns and have these presentation containers not aware of Redux's action creator and reducer.\"), mdx(\"p\", null, \"Now, at the heart of the goal of this article, how do we bind the state to the props used as parameter of this stateless container? We know the we should return inject an IAppProps and we know we have the store having a IAppState. What needs to be done is a mapping function that will transform one to the other.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const mapStateToProps = (state: IAppState) => { return { model: state, } as IAppProps }; \\n\")), mdx(\"p\", null, \"The second goal is how do we map the actions received by callback methods to the action creator. Very similar to the prop-state. We need a mapping function. The dispatch interface we defined as IAppDispatch is used to bind these actions to a concrete method in the actions creator. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const mapDispatchToProps = (dispatch: Dispatch<IAppState>): IAppDispatch => { \\n  return { \\n    onApply: () => { \\n      dispatch(updateFilter()); \\n    }, \\n    filterChange: (filters: IFilters) => { \\n      dispatch(filterChanged(filters)); \\n      } \\n    } as IAppDispatch; }; \\n\")), mdx(\"p\", null, \"We finally needs to not return the simple stateless function, but to return the result of the Redux function connect. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export default connect(mapStateToProps, mapDispatchToProps)(App); \\n\")), mdx(\"p\", null, \"At that point, if the store is updated, the information will flow to the container component. If something happen, the action will be dispatched to the action creators and the reducer. In this article, we closed the loop by creating a simple React and Redux application that allow to have a simple action dispatched through an action creator to a reducer to modify the store to update our component. In the next article, we will see how to execute more than a single action from a single call to an action creator. This will be useful for scenario like requesting data where we expect the action creator to dispatch a loading state to have the user interface showing a loading animation and to invoke another dispatch when the data is received which stop the loading animation and load the information on the screen.\"), mdx(\"h3\", null, \"Articles of the series:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-react-and-redux-part-1-the-big-picture\"\n  }, \"TypeScript, React and Redux\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-react-and-redux-part-2-creating-the-store-and-the-reducer\"\n  }, \"TypeScript and Redux Store\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-react-and-redux-part-3-binding-the-store-and-component\"\n  }, \"TypeScript Redux Store Binding\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-react-and-redux-part-4-multiple-returns-from-action-creator\"\n  }, \"TypeScript Redux Action Creators\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-react-and-redux-part-5-reducer-with-different-actions\"\n  }, \"TypeScript, React and Redux Part 5 : Reducer with Different Actions\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"9f793769-b47d-5348-9996-cdbbb7668ef6","totalPages":73}},
    "staticQueryHashes": ["3159585216"]}