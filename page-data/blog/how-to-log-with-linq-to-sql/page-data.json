{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-log-with-linq-to-sql",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to log with Linq to Sql?","date":"August 27, 2011"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to log with Linq to Sql?\",\n  \"date\": \"2011-08-27\",\n  \"categories\": [\"linq-to-sql\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"It's possible to log all SQL queries generated by Linq to Sql with C# code. This can be useful when debugging or to optimize how the Linq is done.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" DataClasses1DataContext db = new DataClasses1DataContext(); \\n StringWriter sw = new StringWriter(); \\n db.Log = sw;\\n\\nthis.gridLinqToSql.DataSource = db.Customers.Where(c => c.CustomerID.StartsWith(\\\"A\\\")); \\nthis.gridLinqToSql.DataBind(); //Here is when the Linq query will be executed.\\n\\nsqlLinqToSql.Text = sw.GetStringBuilder().ToString(); // Here is the output of the SQL commands\\n\")), mdx(\"p\", null, \"Linq to Sql use a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DataContext\"), \" object that is generated with the .dbml file. \"), mdx(\"p\", null, \"For example, in this test project, the .dbml file name is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DataClasses1.dbml\"), \". \"), mdx(\"p\", null, \"From there, this object contain a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Log\"), \" property that takes a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TextWriter\"), \". \"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://msdn.microsoft.com/en-us/library/system.io.textwriter.aspx\"\n  }, \"TextWriter\"), \" class comes from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.IO\"), \" namespace and it's an abstract class.\"), mdx(\"p\", null, \"The namespace contain two concrete classes that inherit from this class. \"), mdx(\"p\", null, \"The first one is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://msdn.microsoft.com/en-us/library/system.io.stringwriter.aspx\"\n  }, \"StringWriter\"), \"\\xA0that has been used in the example above.\\nThis class has a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://msdn.microsoft.com/en-us/library/system.text.stringbuilder.aspx\"\n  }, \"StringBuilder\"), \"\\xA0and when using the property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GetStringBuilder()\"), \" of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StringWriter\"), \" let you get a reference on it. From there, using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ToString()\"), \" method give a String with all the SQL used to get the information.\"), mdx(\"p\", null, \"The result looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" SELECT [t0].[CustomerID], [t0].[CompanyName], [t0].[ContactName], [t0].[ContactTitle] \\n FROM [dbo].[Customers] AS [t0] \\n WHERE [t0].[CustomerID] LIKE @p0\\n\\n-- @p0: Input NVarChar (Size = 4000; Prec = 0; Scale = 0) [A%] \\n-- Context: SqlProvider(Sql2005) Model: AttributedMetaModel Build: 4.0.30319.1 \\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Log\"), \" return the SQL statement (or many SQL statement if many calls has been done) with a parameter way (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@p...\"), \").\\nAfter the SQL Statement, each parameter details is written. For example, you can find the type and the size of a SQL parameter.\"), mdx(\"p\", null, \"To conclude, using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Log\"), \" property is interesting to get the SQL detail without using a SQL Profiler. \"), mdx(\"p\", null, \"Of course, a good practice would be to not log all the queries in production\\xA0environment.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"480d0179-8c32-56c0-8950-9f1652322918","totalPages":75}},
    "staticQueryHashes": ["3159585216"]}