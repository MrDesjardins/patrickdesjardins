{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/typescript-testing-private-members",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript: Testing Private Members","date":"July 31, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript: Testing Private Members\",\n  \"date\": \"2018-07-31\",\n  \"categories\": [\"jest\", \"test\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"how-to-unit-test-private-method\"\n  }, \"wrote about three years ago on how to test private member\"), \". One article was more specific to C# and the two others more abstract and on TypeScript, but still relevant today. In this article, I'll explain how I am testing private members without using any hack with Jest.\"), mdx(\"p\", null, \"The goal of having private and public members is to mark a clear separation about what is restricted as internal use of the object that defines the member from what can be consumed from outside the scope of the object. The idea makes sense. The usage of the keyword \\\"private\\\" does not necessary. Using \\\"private\\\" does not work because you will not be able to test internal logic, neither mock them in your testing -- it is blocked at the scope of the object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"class MyClass1 { \\n  private variable1: string = \\\"init\\\"; \\n  public function2(p1: number, p2: number): void { \\n    // Code here... \\n    if (this.function1(p1)) { \\n      // More code here ... \\n    } \\n    // Code here... \\n  } \\n  private function1(p1: number): boolean { } \\n} \\n\")), mdx(\"p\", null, \"There are some workarounds. One popular approach is to avoid testing these functions directly. The problem is that you have code that is not tested. An alternative is to test these private functions through public function. The problem is that you are using a function to proxy all the logic which make all test less \\\"unit test\\\" and fragile because these tests become dependant on another piece of code. If the logic of the private function remains the same, but the public function change, the code that is testing the private function will fail. It sways the simplicity into a nightmare. If the private function returns a boolean value, but the public function returns a void type, testing the return of the private function requires to understand the behavior of the public function that use it to extrapolate a behavior that corresponds to the return value. The proxy function, the public function, might be only a single one or many. When there is only a single function, the choice is limited and can push you in a corner without escape. When many functions, the selection of which one can also be problematic. In the end, the goal is to unit test, not to have many hurdles before even testing.\"), mdx(\"p\", null, \"Another option is to cast to any and access the function. The problem is that any refactoring on the name will make the function to be \\\"undefined.\\\" It leads to issues of typing when the ground change that is the role of having a typed language in the first place.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"describe(\\\"MyClass1\\\", () => { \\n  describe(\\\"test the private function #1\\\", () => { \\n    it(\\\"public proxy function\\\", () => { \\n      const x = new MyClass1(); \\n      expect(x.function2(1, 2)).toBe(\\\"????\\\"); \\n      }); \\n    it(\\\"cast with any\\\", () => { \\n      const x = new MyClass1() as any; \\n      expect(x.function1(1)).toBeTruthy(); \\n    }); \\n  }); \\n}); \\n\")), mdx(\"p\", null, \"So, if we have all these solutions with weaknesses, what is the best solution? The best solution that I have been used for a while now is this one: do not use private. Instead, you should use interface. The idea is that the concrete object will never be used directly, hence can have its members public. The usage across the whole application is done with an interface that exposes the members that the consumers can interact. Here is the same code as above but with the pattern of using an interface instead of private.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface IMyClass1 { \\n  function2(p1: number, p2: number): void; \\n}\\n\\nclass MyClass1 implements IMyClass1 { \\n  private variable1: string = \\\"init\\\"; \\n  public function2(p1: number, p2: number): void { \\n    // Code here... \\n    if (this.function1(p1)) { \\n      /// More code here ... \\n    } \\n    // Code here... \\n  } \\n  public function1(p1: number): boolean { } \\n}\\n\\ndescribe(\\\"MyClass1\\\", () => { \\n  let x: MyClass1; \\n  beforeEach(() => { x = new MyClass1(); }); \\n  describe(\\\"function1 with an integer\\\", () => { \\n    it(\\\"returns true\\\", () => { \\n      expect(x.function1(1)).toBeTruthy(); \\n    }); \\n  }); \\n}); \\n\")), mdx(\"p\", null, \"It works perfectly in term of testability. The unit test code has access to all members because everything is public. It is easy to invoke all members directly but also to mock these and still keep and the type from TypeScript. In the application, we use the interface everywhere. The only place where we use the concrete class is during the initialization. Every declaration uses the interface -- no exception.\"), mdx(\"p\", null, \"Furthermore, a class is easily mockable with framework because you can access every public function and assign them a mock/spy/stub that allows to control specific branches of the code as well as managing the scope of the test to be as much as a single unit. The key of an efficient test is to have every block of code tested as a unit and then moving from bottom to top with more and more integration tests.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"describe(\\\"MyClass1\\\", () => { \\n  let x: MyClass1; \\n  beforeEach(() => { \\n    x = new MyClass1(); \\n    x.function1 = jest.fn(); \\n  }\\n  ); \\n  describe(\\\"function2\\\", () => { \\n    it(\\\"calls function1\\\", () => { \\n      x.function2(1,2); \\n      expect(x.function1).toHaveBeenCalledTimes(1); \\n      }); \\n    }); \\n  }); \\n\")), mdx(\"p\", null, \"Last but not the least, functions that are directly sitting in a module are very hard to unit test. It is not possible to mock or spy their dependencies. The lack of access sway my design to always encapsulate every function into a class.\"), mdx(\"p\", null, \"In summary, encapsulation does not require to rely solely on public, private and protected keywords. The usage of an interface is powerful by adding the protection to what can be accessed while allowing developers to have a sane and simple way to test correctly without using a detour to obtain the desired piece of code.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"23688ce0-f11b-50a7-86a7-55185bb7149c"}},
    "staticQueryHashes": ["3159585216"]}