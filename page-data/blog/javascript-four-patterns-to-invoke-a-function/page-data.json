{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/javascript-four-patterns-to-invoke-a-function",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Four Patterns to Invoke a Function","date":"May 25, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Four Patterns to Invoke a Function\",\n  \"date\": \"2017-05-25\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"There are four ways to call a function in JavaScript. In this article, we will see them all and see the pros and cons of each of them.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Function invocation pattern\"), \" This is when a function is not attached to anything, it's floating which in fact is attached to \\\"window\\\" when in a browser if this one is created not within an object. Here is two examples:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var f1 = function () {\\n  console.log(\\\"F1\\\");\\n};\\nf1();\\nwindow.f1();\\nfunction f2() {\\n  console.log(\\\"F2\\\");\\n}\\nf2();\\nwindow.f2();\\n\")), mdx(\"p\", null, \"However, if a function is not bound to an object but created withing a function, this one belong to the function. Still, it is not attached to anything.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var myObject = {\\n  function2: function () {\\n    console.log(\\\"Function2\\\");\\n    var function2_1 = function () {\\n      console.log(\\\"Function2_1\\\");\\n    };\\n    function2_1();\\n  },\\n};\\nmyObject.function2();\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Method invocation pattern\"), \" Method invocation pattern is when a function is attached to an object that is not instantiated with the \\\"new\\\" keyword.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var myObject = {\\n  function2: function () {\\n    console.log(\\\"Function2\\\");\\n  },\\n};\\nmyObject.function2();\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Constructor invocation pattern\"), \" I already covered in previous article about prototype. Invoking with a constructor trigger the prototype chain for the created object. Constructor function are created with the keyword \\\"new\\\".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var MyClass1 = function () {\\n  this.function2 = function () {\\n    return \\\"F2\\\";\\n  };\\n};\\n\\nMyClass1.prototype.function1 = function () {\\n  return \\\"F1\\\";\\n};\\n\\nvar instance = new MyClass1();\\nconsole.log(instance.function1());\\nconsole.log(instance.function2());\\n\")), mdx(\"p\", null, \"As you can see, you can invoke method from the instance or the prototype.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Apply invocation pattern\")), mdx(\"p\", null, \"The last pattern is to use a function to call a function! This is possible because every object has some default function attached to their prototype, like the one that interest us which is \\\"apply\\\".\"), mdx(\"p\", null, \"The following example shows how to invoke with apply. Both call to the apply function uses the class' prototype which call the function and apply. The difference is that one pass the method which has a member assigned with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \", while the second call an anonymous object. The importance is to have a \\\"m1\\\" member because function1 access it in its prototype.\"), mdx(\"p\", null, \"The important detail about \\\"apply\\\" is the parameter. The first one is the pointer \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \", the others are the the function arguments.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var MyClass1 = function () {\\n  this.m1 = \\\"Member Value\\\";\\n};\\n\\nMyClass1.prototype.function1 = function () {\\n  return \\\"From function1 here is the m1 value : \\\" + this.m1;\\n};\\n\\nvar instance = new MyClass1();\\nvar objectOnTheFly = { m1: \\\"on-the-fly\\\" };\\nconsole.log(MyClass1.prototype.function1.apply(MyClass1()));\\nconsole.log(MyClass1.prototype.function1.apply(objectOnTheFly));\\n\")), mdx(\"p\", null, \"In this example, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" got assigned dynamically and the function uses the value by accessing with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \". In this article we saw 4 different ways to invoke function in JavaScript.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"b23a7d6c-6a20-51a9-92b0-9913ea163c69","totalPages":70}},
    "staticQueryHashes": ["3159585216"]}