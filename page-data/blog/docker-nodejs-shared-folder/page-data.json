{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/docker-nodejs-shared-folder",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to configure Docker to have a shared folder between two containers?","date":"May 9, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to configure Docker to have a shared folder between two containers?\",\n  \"date\": \"2022-05-09\",\n  \"categories\": [\"typescript\", \"docker\", \"nodejs\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this article, I explain how to configure Docker to have two independent services in two different containers, but both of them reference a shared folder.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"repository\\n   |----> service1\\n   |----> service2\\n   |----> shared\\n\")), mdx(\"p\", null, \"The article focus on:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Docker configuration\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"TypeScript configuration\")), mdx(\"p\", null, \"The challenge with sharing a folder when using a different container is to bring the shared folder into the respective containers and have TypeScript working at design time (inside your developer editor) and at compilation. The solution revolves around the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"path\"), \" capability of TypeScript, allowing to create aliases. With aliases, you can import modules from an absolute point instead of a relative path. The relativity issue is to refer to a folder that is outside the container realm. Hence, to refer to a folder outside the Docker's context, we need to use TypeScript \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"path\"), \".\"), mdx(\"h1\", null, \"TypeScript Configuration\"), mdx(\"p\", null, \"The first step is to go into each service tsconfig.json and add the path. In my case, both services are at the same level: sibling to the shared folder. Thus, they have inside their tsconfig.json the same new configuration:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"\\\"baseUrl\\\": \\\"./\\\",\\n\\\"paths\\\": {\\n  \\\"@shared/*\\\": [\\\"../shared/*\\\"]\\n}\\n\")), mdx(\"p\", null, \"There is a caveat in the configuration of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"paths,\"), \" and it is that you \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"must\"), \" have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"baseUrl\"), \". In both services, the base is the root of the folder. So, what the configuration means is that any time we are using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import {xyz} from \\\"@shared/folder/file\\\"\"), \" that the import will refer to the file from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"baseUrl\"), \" and then apply the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@shared\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import {xyz} from \\\"@shared/folder/file\\\"   ---> import {xyz} from \\\"./..shared/folder/file\\\"\\n\")), mdx(\"h1\", null, \"Absolute Reference\"), mdx(\"h2\", null, \"ViteJS\"), mdx(\"p\", null, \"Once the TypeScript configuration is in place, the next hurdle is to have the code that executes to know what to do with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"paths\"), \". The generated Javascript remains with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@shared\"), \" prefix. While TypeScript compilers (build time and design time) can interpret the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"paths\"), \", the browser or Node does not.\"), mdx(\"p\", null, \"One of the services was using ViteJS. There is a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/aleclarson/vite-tsconfig-paths\"\n  }, \"plugin\"), \" for ViteJS that can be used. In my case, it didn't work. So, I had to resolve the path manually. In the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"vite.config.js\"), \", you need to add a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve\"), \". For simplicity, I removed the rest of the configuration so you will have more than the required configuration for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"paths\"), \". As you can see, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"paths\"), \" in ViteJS is named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"alias\"), \". The configuration is very similar to TypeScript.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"export default (conf: any) => {\\n  return defineConfig({\\n    resolve: {\\n      alias: [{ find: \\\"@shared\\\", replacement: path.resolve(__dirname, \\\"../shared\\\") }],\\n    },\\n  });\\n};\\n\")), mdx(\"p\", null, \"If you are using Webpack instead of ViteJS, something similar would be needed.\"), mdx(\"h2\", null, \"NodeJS\"), mdx(\"p\", null, \"The other service was a NodeJS Express server. A similar configuration was needed. This time, the configuration is with Node. Here are the two commands I had to modify. One modifies the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nodemon\"), \", the other one \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node\"), \". In the end, the same idea: rely on a code modifier that will hand the path.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"\\\"start:development\\\": \\\"npx tsc -v && npx tsc && concurrently \\\\\\\"npx tsc -w --preserveWatchOutput\\\\\\\" \\\\\\\"npx nodemon --inspect=0.0.0.0:9229 --watch ./build -r ts-node/register/transpile-only -r tsconfig-paths/register ./build/app/src/index.js\\\\\\\"\\\",\\n\\\"start:production\\\": \\\"node -r ts-node/register/transpile-only -r tsconfig-paths/register build/node/src/index.js\\\"\\n\")), mdx(\"p\", null, \"The fix was to add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-r tsconfig-paths/register\"), \" which will apply the transformation.\"), mdx(\"h1\", null, \"Docker\"), mdx(\"p\", null, \"Finally, the shared folder must be included in both Docker containers. Because in development, we want to be able to quickly modify, add or remove code, we want to rely on Docker's volume. However, when we deploy for production, we must \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"copy\"), \" the shared folder into the container as a sibling to keep the reference intact.\"), mdx(\"p\", null, \"The configuration of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"docker-compose.yml\"), \" maps the local development path \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"./services/shared\"), \" to the docker folder \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/node/shared\"), \", which is a sibling to the actual code in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/node/app\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"volumes:\\n  - \\\"./services/shared:/node/shared:delegated\\\"\\n\")), mdx(\"p\", null, \"The configuration within each \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DockerFile\"), \". Next to the command that copied the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"service1\"), \", a new entry for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shared\"), \" is added.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"COPY services/service1 /node\\nCOPY services/shared /shared\\n\")), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"Sharing interfaces, classes, types, constants, or logics between a frontend and a backend service is natural. Leveraging the possibility to reuse code because both projects are using the same languages is a huge time saver. Even if Docker divides the two services, it is possible to keep sharing by allowing during development a common volume. Copying the shared folder into each container at production time is the key. Once the configuration of TypeScript and your builder, like ViteJS, the future will be smooth and enjoyable and will foster a great habit of code sharing because the hurdle to execute is reduced to none. You can see an example of the pattern described in this article in my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/realtimepixel\"\n  }, \"Real Time Pixel repository\"), \".\"), mdx(\"h1\", null, \"References\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.jamestharpe.com/docker-include-files-outside-build-context/\"\n  }, \"https://www.jamestharpe.com/docker-include-files-outside-build-context/\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://mitchellsimoens.com/blog/2019/08/07/why-typescript-paths-failed-me\"\n  }, \"https://mitchellsimoens.com/blog/2019/08/07/why-typescript-paths-failed-me\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://stackoverflow.com/questions/68241263/absolute-path-not-working-in-vite-project-react-ts\"\n  }, \"https://stackoverflow.com/questions/68241263/absolute-path-not-working-in-vite-project-react-ts\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"edb81fc1-a769-571f-839b-c4819f6c3e67","totalPages":73}},
    "staticQueryHashes": ["3159585216"]}