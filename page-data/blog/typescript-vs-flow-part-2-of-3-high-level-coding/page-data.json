{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-vs-flow-part-2-of-3-high-level-coding",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript vs Flow (Part 2 of 3) - High Level Coding","date":"August 23, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript vs Flow (Part 2 of 3) - High Level Coding\",\n  \"date\": \"2017-08-23\",\n  \"categories\": [\"flow\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is the second article of three about differences between TypeScript and Flow. You can read the first part about high level of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./typescript-vs-flow-part-1-of-3-who-they-are\"\n  }, \"TypeScript vs Flow in this article.\"), \" The investigation I conducted was done on August 9 and August 10, 2017. It's a domain where it evolves a lot and my conclusion could change in few months or years. The first article goal was to bring fundamentals around what are TypeScript and Flow.\"), mdx(\"p\", null, \"This article will focus on high-level coding feature that differentiates TypeScript and Flow. The get differences, I had to sample a subset of all the feature and the reason is that both support a lot of them and I have limited time. How I decided these features was to go with Flow first by using their documentation. My plan was to convert one TypeScript project already written to Flow and while doing so, I added features that were used which resulted to the features comparison matrix of this article. The result is of the 40 features tested is:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"11 features lean on TypeScript\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"4 features lean on Flow\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"18 features that are neutrally equal\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"1 feature that is subjective who is better\")), mdx(\"p\", null, \"Let's spread the 40 features in a table to illustrate these details and then talk about them.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Feature\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"TypeScript\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Flow\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Winner?\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Interface\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type (Alias)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Subtype\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Implementation\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Encapsulation (private, protected, public)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"No\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"TypeScript\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Enum\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"No\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"TypeScript\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$key (utility type)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"No\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Flow\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$diff (utility type)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"No\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Flow\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"* (utility type)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"No\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Flow\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type Casting\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"DefinitionFile or Librairie Definition\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Non standard JS\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Get definition file\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"NPM\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"cli\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"TypeScript\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Readonly\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"No (see covariance)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"TypeScript\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"React props/states\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"maybe/optional parameter\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes (separate null/undefined)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Optional properties\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes (same syntax)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes (diff syntax)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Infer type\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Contravariant\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Covariance\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"No (see readonly)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Flow\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Abstract\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"No\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"TypeScript\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Decorator\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"No\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"TypeScript\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Quick initialization (by ctor params)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"No\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"TypeScript\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Static\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Not all scenarios\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"TypeScript\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Sealed\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes by default\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes by default\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Unsealed\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Must cast\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Object defined by {}\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Tuple\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Soundness\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Not completely\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"???\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Type of typing\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Structural typing\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Nominally typing\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"TS is following JS\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Generic Class\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Generic Interface\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Generic Function\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Generic Type\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Yes\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Both\")))), mdx(\"p\", null, \"That's a lot of information and at the same time, just a sample of what Flow and TypeScript can offer. I'll try to cover the difference without focusing on the resemblances and more about what makes them apart.\"), mdx(\"h2\", null, \"Encapsulation\"), mdx(\"p\", null, \"Encapsulation or \\\"modifier\\\" is the first difference. I'll talk about the lack of private, public, protected keyword all at once. This level of protection doesn't exist in JavaScript, but TypeScript allows it if interested, otherwise, it's all open (public). TypeScript enforces it at the syntax level put the transpiled JavaScript doesn't have any trace of the encapsulation notion. For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nclass MyClass {\\n    private privateMember: string;\\n    public publicMember: string;\\n    protected protectedMember: string;\\n    constructor(message: string) {\\n        this.privateMember = message;\\n        this.publicMember = \\\"public\\\";\\n        this.protectedMember = \\\"protected\\\";\\n    }\\n}\\n\\n\")), mdx(\"p\", null, \"Transpile to:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nvar MyClass = (function () {\\n    function MyClass(message) {\\n        this.privateMember = message;\\n        this.publicMember = \\\"public\\\";\\n        this.protectedMember = \\\"protected\\\";\\n    }\\n    return MyClass;\\n}());\\n\\n\")), mdx(\"p\", null, \"The encapsulation is not propagated in JavaScript, but could have been there with some \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./javascript-private-variable\"\n  }, \"closure\"), \". In all circumstances, Flow decided to not enforce the encapsulation at all. The repercussion is interesting. First, the code becomes harder to maintain because it allows people to access members directly. A common scenario is to inject by constructor some specific class that represent services. You want to control the integrity when the class is instantiated, but if the injected objects are public, they could be modified by anyone in the lifetime of the object. There is much other justification why having a stronger encapsulation is good which will be the subject of future articles.\"), mdx(\"h2\", null, \"Enum\"), mdx(\"p\", null, \"Enum is a convenient way to organize potential value for a type. For example, with TypeScript you can write an enum that will hold a specific group of language the following way:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nenum Language {\\n    English,\\n    French\\n}\\n\\n\")), mdx(\"p\", null, \"This syntax allows to assign easily with a good Intellisense support, but also enforce passing only the value from the enum by parameter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nvar myLanguage = Language.English;\\nfunctTakeOnlyLanguage(myLanguage);\\nfunction functTakeOnlyLanguage(param: Language){\\n    // ...\\n}\\n\\n\")), mdx(\"p\", null, \"The notion of Enum doesn't exist in Flow \", \"[2]\", \". They have a workaround which more verbose \", \"[3]\", \" than the TypeScript keyword. Here is the same representation with Flow.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nexport const LANGUAGES_VALUE = {\\n    French: \\\"French\\\",\\n    English: \\\"English\\\"\\n};\\nexport type Language = $Values&lt;typeof LANGUAGES_VALUE&gt;;\\n\\nvar myLanguage = LANGUAGES_VALUE.English;\\nfunctTakeOnlyLanguage(myLanguage);\\nfunction functTakeOnlyLanguage(param: Language){\\n    // ...\\n}\\n\\n\")), mdx(\"p\", null, \"Using this type and constant with Flow require to have a special import when using.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nimport { LANGUAGES_VALUE } from \\\"../general/Language\\\";\\nimport type { Language } from \\\"../general/Language\\\";\\n\\n\")), mdx(\"p\", null, \"The Flow version requires a little more work since you need to define the const and then use a \\\"magic utility type\\\" to create a type, and after you need two imports which one is non-standard. The use of \\\"magic\\\" seems pejorative, but it's how it is called. Also, it might be the configuration issue between my VsCode and Flow during my investigation, but the type of Language was \\\"any\\\", hence the Intellisense wasn't great. Overall, TypeScript have an edge here on a simple thing that makes developer life just a little easier.\"), mdx(\"h2\", null, \"Utility Type\"), mdx(\"p\", null, \"Flow is having something TypeScript does not literally have called utility type \", \"[3]\", \" or magic utility type. We already saw the potential with Enum with the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"$keys\"), \" one. TypeScript lets you do something similar with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"keyof\"), \".\"), mdx(\"p\", null, \"Flow has also $Diff<a,b> which returns a type that is the difference between two types. There is also few others which are not all implemented. </a,b>\"), mdx(\"p\", null, \"So, at first glance, it's a pro and I marked it as well. However, the more I was thinking about it and the more I was wondering why Flow has these utility method. It should belong somewhere else than inside a type checker tool. These utility methods would dwell well in a Babel plugin, or in a library like lodash, or directly in TypeScript. I do not have the full context, but it seems that it was added to fulfill a need with React which is a close team Flow is working with.\"), mdx(\"h2\", null, \"Getting Definition Files\"), mdx(\"p\", null, \"Getting definition files is different between TypeScript and Flow. The reason is that Flow doesn't use the same definition file than TypeScript. There is no way to translate one to the other, and both persist their definition files in an independent repository. This creates fragmentation in the community that needs to create two kinds of definition file. As mentioned in the first part, TypeScript has above three thousand definition files while Flow has reached few week ago three hundred. Besides the number of libraries, the major difference is how to get the definition files. TypeScript has a long history of ways to do it. At the time I am writing this article, we are at the third iteration which seem to be stable and better in many ways. It's now using NPM, a tool that every JavaScript developers have familiarity since it is the most common way to get library. It makes sense to have the definition file by the same way. Using NPM allows using the same syntax and configuration file (package.json). This is convenient to store data, but also convenient to get the definition file from a repository that you do not own. By installing with \\\"npm install\\\" you are getting all the libraries as well as all the definition files.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nnpm install --save-dev @types/redux\\n\\n\")), mdx(\"p\", null, \"With Flow, getting library definition is not hard, but it's not a paved way what we are used to ride on. It requires using a cli (command line)\", \"[4]\", \". This cli is available from npm (npm install -g flow-typed) and from there, you can use flow-typed to get a library that will be installed into a flow-typed folder at the root of your project. One requirement is that you must specify a version.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nflow-typed install redux@2.3.x\\n\\n\")), mdx(\"p\", null, \"If you get a project and needs to get the library, you will need to use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"npm install\"), \" but also \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"flow-typed install\"), \". Since we need to handle the second tool, Flow doesn't gain a point in that comparison. TypeScript matured into using NPM and that choice simplify the access to third party definition file.\"), mdx(\"h2\", null, \"Readonly\"), mdx(\"p\", null, \"TypeScript has the keyword \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"readonly\"), \". Flow does not. However, Flow has something similar which is the \\\"+\\\" sign for covariance. The goal is to do like in C# or another language which is to set a value directly in the class where we the field is declared or when in the constructor when the class is instantiated. At the end, the value cannot change. This allows having values that are set dynamically and only once.\"), mdx(\"p\", null, \"Flow doesn't have the keyword read only. It has the concept of covariance that TypeScript doesn't have. To mimic this behavior, in Flow it requires having a \\\"+\\\" sign in front of the variable. The difference is small for a field but subtle. For example, it works well if you know the value and assigns it directly to the field of the class. However, if you want to assign it in the constructor, it won't work in Flow. Let's see some code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nclass Person {\\n  +name: string;\\n  constructor(name: string) {\\n    this.name = name; // This doesn't work in Flow\\n  }\\n}\\n\\n\")), mdx(\"p\", null, \"But the equivalence work in TypeScript:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nclass Person {\\n  readonly name: string;\\n  constructor(name: string) {\\n    this.name = name\\n  }\\n}\\n\\n\")), mdx(\"p\", null, \"The case of read only is simpler with TypeScript and work like many other languages, hence seem to be slightly favorable for TypeScript.\"), mdx(\"h2\", null, \"Optional Parameter and Optional Field\"), mdx(\"p\", null, \"Both have a different way to achieve optional value to be provided for parameter of a function or to have a field defined (in an interface for example). TypeScript use the question mark in both cases.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\n// Optional Field\\ninterface IInterface{ propertyName?: string } //Allow null amp;amp;amp;amp; undefined\\n\\n// Optional Parameter\\nfunction myFunc( param?: string ) //Allow null amp;amp;amp;amp; undefined\\n\\n\")), mdx(\"p\", null, \"This is different from Flow which will not be that loose. With Flow, you can pass nothing (which is undefined) but cannot explicitly pass null for something optional.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\n// Optional Field\\ninterface IInterface{ propertyName?: string } //Allow undefined\\n\\n// Optional Parameter\\nfunction myFunc( param?: string ) //Allow undefined\\n\\n\")), mdx(\"p\", null, \"If you want to pass null, you need to use the concept of \\\"maybe\\\" which is unique to Flow. The syntax is also with the question mark, but this time before the type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\n// Optional Parameter\\nfunction myFunc( param: ?string ) //Allow null amp;amp;amp;amp; undefined\\n\\n\")), mdx(\"p\", null, \"This goes in the sense that Flow is more \\\"sound\\\" than TypeScript. Flow has more control about what you want to pass. TypeScript is following JavaScript and is less strict in that matter. At the end, both sides can be pros or cons. TypeScript shines by having a single place to put the question mark and it's always the same logic which is that it allows value, null and undefined. On the other hand, Flow has more option by being able to allow value an undefined as well as null if using the maybe type. However, the syntax is very similar to the other type of optional which can cause confusion. At the end, they have different pros and cons and I consider no winner.\"), mdx(\"h2\", null, \"Abstract\"), mdx(\"p\", null, \"Abstract is available in TypeScript; it's not in Flow. Abstract is an object oriented concept, and it wasn't available 3 years and half ago when I started using TypeScript and it was a tool that I missed. Since about 2 years, it's available and I used it few times. I do not want to explain why it can be useful or not in this comparison article, but it's a concept that some kind of developers like while other doesn't. TypeScript doesn't force you to use it, and give you the ability to if you want. By giving the developer the choice instead of not providing it, TypeScript wins.\"), mdx(\"h2\", null, \"Decorator\"), mdx(\"p\", null, \"TypeScript requires having a configuration flag to true in the tsconfig.json. Flow requires having a babel plugin. It needs a little more work, like getting the right package, but nothing significant. I started using the babel decorator, but was getting a warning message that conducted me to using the decorator-legacy.\"), mdx(\"p\", null, \"From there, Flow was giving an error saying that this feature was experimental. Flow, at this time, doesn\\u2019t support decorator \", \"[5]\", \". I ended up by having to ignore the EcmaScript proposal in the .flowconfig file. TypeScript won. However, if you are not using Angular2+ or MobX than you might do not mind. However, more and more libraries and frameworks use decorator which is nice to have some type checking as well.\"), mdx(\"h2\", null, \"Quick Initialization\"), mdx(\"p\", null, \"I'll be brief. Since Flow doesn't have encapsulation than it's obvious that quick initialization doesn't exist in Flow. This feature allows to not declare inside a class the field and avoid having line of code to set the constructor's argument to the field manually. This is handy and a recent addition to TypeScript. It's clean up the code by still having a great encapsulation. TypeScript wins by default.\"), mdx(\"h2\", null, \"Statics\"), mdx(\"p\", null, \"On this one, I wasn't very thorough. I had code that was defining readonly static field in TypeScript and couldn't have them static (without readonly) in Flow. So, I had to choose about having the value defined once or the field to be static. TypeScript acted more like I was used to see in Java or C#. Because of that, I'm giving a weak win to TypeScript.\"), mdx(\"h2\", null, \"Type of Typing\"), mdx(\"p\", null, \"TypeScript is using a structural typing \", \"[6]\", \". Flow is following nominally typing\", \"[7]\", \". It means that for TypeScript, if you have two interfaces or classes with the same members but with a different name, hence are a different type, they are assignable. This is to mimic how JavaScript works. However, Flow is nominally typed which means that every class or interface defined is unique and cannot be assigned to another one even if they have the same members. I could elaborate more, but I suggest you read the TypeScript documentation about type compatibility. So who is winning? It\\u2019s a hard one. Flow wins if we want something more strict. TypeScript wins if we want not to invent a new language on top of JavaScript. To be noted is that, even if JavaScript doesn\\u2019t have keywords for encapsulation and abstraction, the language allow it with closures and other JavaScript tricks. So at the end, TypeScript seems to be the winner since it doesn\\u2019t try to change the nature of JavaScript, which Flow is doing\\u2026and maybe for the best? I guess that is debatable.\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"This part is getting long. I\\u2019ll end it here. In the first part, we saw some fundamental differences between TypeScript and Flow. In this second part, we saw that the two type checkers are pretty close in features. Even if I write about the differences, there were so many similarities that I got impressed and surprised. In the last and third part, I\\u2019ll take the time to show in terms of code the similarities and differences. Before closing this part two, if you are still hesitating on which one to use, you won\\u2019t find more answers in the third part. The next article will confirm the idea that both of them are pretty similar. I suggest that you read again the first part and this one to make your decision and read the third one only for your curiosity.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Parts of the serie:\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-vs-flow-part-3-of-3-syntax-difference\"\n  }, \"TypeScript vs Flow (Part 1 of 3) \\u2013 Who are they?\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-vs-flow-part-2-of-3-high-level-coding\"\n  }, \"TypeScript vs Flow (Part 2 of 3) \\u2013 High Level Coding\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-vs-flow-part-3-of-3-syntax-difference\"\n  }, \"TypeScript vs Flow (Part 3 of 3) \\u2013 Syntax Difference\"))), mdx(\"h2\", null, \"References\"), mdx(\"p\", null, \"[1]\", \" -\\n\", \"[2]\", \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/facebook/flow/issues/627\"\n  }, \"https://github.com/facebook/flow/issues/627\"), mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"[3]\", \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://flow.org/en/docs/types/utilities/\"\n  }, \"https://flow.org/en/docs/types/utilities/\"), mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"[4]\", \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/flowtype/flow-typed/blob/master/README.md\"\n  }, \"https://github.com/flowtype/flow-typed/blob/master/README.md\"), mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"[5]\", \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/facebook/flow/issues/3405\"\n  }, \"https://github.com/facebook/flow/issues/3405\"), mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"[6]\", \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/type-compatibility.html\"\n  }, \"https://www.typescriptlang.org/docs/handbook/type-compatibility.html\"), mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"[7]\", \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://flow.org/en/docs/types/classes/\"\n  }, \"https://flow.org/en/docs/types/classes/\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"f40c179c-e224-5e3e-9140-09ab9897fd54","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}