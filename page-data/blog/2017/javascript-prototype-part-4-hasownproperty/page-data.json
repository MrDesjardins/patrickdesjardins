{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2017/javascript-prototype-part-4-hasownproperty/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Prototype Part 4 : hasOwnProperty","date":"May 23, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Prototype Part 4 : hasOwnProperty\",\n  \"date\": \"2017-05-23\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"hasOwnProperty is a function from Object's prototype, hence every thing in JavaScript has access to it. It allows to know if a member is directly having the member specified by string.\"), mdx(\"p\", null, \"Let's take this simple example where a property \\\"m1\\\" is defined 4 times at each level (child, child prototype, base and base prototype).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var BaseClass1 = function () {\\n  this.m1 = \\\"m1 base\\\";\\n};\\nBaseClass1.prototype.m1 = \\\"m1 proto base\\\";\\nvar ChildClass1 = function () {\\n  BaseClass1.call(this); // Call the constructor of the base class\\n  this.m1 = \\\"m1 child\\\";\\n};\\nChildClass1.prototype = Object.create(BaseClass1.prototype);\\nChildClass1.prototype.m1 = \\\"m1 child proto\\\";\\nChildClass1.prototype.constructor = BaseClass1;\\nvar instance1 = new ChildClass1();\\n\\nconsole.log(instance1.hasOwnProperty(\\\"m1\\\"));\\n\")), mdx(\"p\", null, \"The output is \\\"true\\\". This is because the instance1 has a property \\\"m1\\\". If we remove \\\"m1\\\" from the child class, the value will be \\\"true\\\". The question is, is it true because of the child prototype or the base class? The answer is the base class. Prototype definition wouldn't be counted has own property. So, the following code return false:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var BaseClass1 = function () {\\n  //this.m1 = \\\"m1 base\\\";\\n};\\nBaseClass1.prototype.m1 = \\\"m1 proto base\\\";\\nvar ChildClass1 = function () {\\n  BaseClass1.call(this);\\n  // Call the constructor of the base class\\n  //this.m1 = \\\"m1 child\\\";\\n};\\nChildClass1.prototype = Object.create(BaseClass1.prototype);\\nChildClass1.prototype.m1 = \\\"m1 child proto\\\";\\nChildClass1.prototype.constructor = BaseClass1;\\nvar instance1 = new ChildClass1();\\nconsole.log(\\\"Result \\\" + instance1.hasOwnProperty(\\\"m1\\\"));\\n\")), mdx(\"p\", null, \"If we want to use hasOwnProperty on the prototype we will see that it returns false. However, it's possible to use the method \\\"call\\\" to execute from the base object into an instance, like the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var BaseClass1 = function () {\\n  this.m1 = \\\"m1 base\\\";\\n};\\nBaseClass1.prototype.m1 = \\\"m1 proto base\\\";\\nvar ChildClass1 = function () {\\n  BaseClass1.call(this); // Call the constructor of the base class\\n  this.m1 = \\\"m1 child\\\";\\n};\\n\\nChildClass1.prototype = Object.create(BaseClass1.prototype);\\nChildClass1.prototype.m1 = \\\"m1 child proto\\\";\\nChildClass1.prototype.constructor = BaseClass1;\\nvar instance1 = new ChildClass1();\\n\\nconsole.log(\\\"Result 1\\\" + BaseClass1.hasOwnProperty(\\\"m1\\\"));\\nconsole.log(\\\"Result 2\\\" + Object.prototype.hasOwnProperty.call(instance1, \\\"m1\\\"));\\n\")), mdx(\"p\", null, \"This will return false for the first result, and true for the result #2. The first one is false because it's not using the instance, but the prototype. The second is true because it uses the object and use call which pass the \\\"this\\\" context to be the instance1 which is having m1 (in the child and base).\"), mdx(\"p\", null, \"How can this be useful? Well, it can be useful to determine which member is from the object and which is part of the prototype hierarchy. In the following example, you will see that we will loop through the instance and get members from the child, child prototype, base, base prototype as well as a constructor.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var BaseClass1 = function () {\\n  this.m2 = \\\"m1 base\\\";\\n};\\nBaseClass1.prototype.m3 = \\\"m1 proto base\\\";\\nvar ChildClass1 = function () {\\n  BaseClass1.call(this); // Call the constructor of the base class\\n  this.m4 = \\\"m1 child\\\";\\n};\\nChildClass1.prototype = Object.create(BaseClass1.prototype);\\nChildClass1.prototype.m1 = \\\"m1 child proto\\\";\\nChildClass1.prototype.constructor = BaseClass1;\\nvar instance1 = new ChildClass1();\\n\\nfor (name in instance1) {\\n  console.log(name + \\\": \\\" + instance1[name]);\\n}\\n\")), mdx(\"p\", null, \"The result is:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\"m2: m1 base\\\"\\n\\\"m4: m1 child\\\"\\n\\\"m1: m1 child proto\\\"\\n\\\"constructor: function () { this.m2 = 'm1 base'; }\\\"\\n\\\"m3: m1 proto base\\\"\\n\\n\")), mdx(\"p\", null, \"By introducing a condition that use hasOwnProperty we can be sure to just get m2 and m4 (child and base) without prototype.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var BaseClass1 = function () {\\n  this.m2 = \\\"m1 base\\\";\\n};\\nBaseClass1.prototype.m3 = \\\"m1 proto base\\\";\\nvar ChildClass1 = function () {\\n  BaseClass1.call(this); // Call the constructor of the base class\\n  this.m4 = \\\"m1 child\\\";\\n};\\nChildClass1.prototype = Object.create(BaseClass1.prototype);\\nChildClass1.prototype.m1 = \\\"m1 child proto\\\";\\nChildClass1.prototype.constructor = BaseClass1;\\nvar instance1 = new ChildClass1();\\n\\nfor (name in instance1) {\\n  if (instance1.hasOwnProperty(name)) {\\n    console.log(name + \\\": \\\" + instance1[name]);\\n  }\\n}\\n\")), mdx(\"p\", null, \"Which returns: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\"m2: m1 base\\\" \\\"m4: m1 child\\\"\\n\")), mdx(\"p\", null, \"In this article we saw the power of hasOwnProperty that can help to distinct which members of an object is from the object and inheritance against which members if from the prototype chain.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"b1537db3-5961-53ab-8b80-4a7b44ac9c0c","slug":"2017/javascript-prototype-part-4-hasownproperty","__params":{"slug":"2017"}}},
    "staticQueryHashes": ["3159585216"]}