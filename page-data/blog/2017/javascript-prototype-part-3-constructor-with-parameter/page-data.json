{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2017/javascript-prototype-part-3-constructor-with-parameter/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Prototype Part 3 : Constructor with Parameter","date":"May 17, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Prototype Part 3 : Constructor with Parameter\",\n  \"date\": \"2017-05-17\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Adding a parameter to a constructor in JavaScript is not complicated if you already have your object setup. It's also not much more work to have some values passed to the base class.\"), mdx(\"p\", null, \"The base class and the child class need to define their arguments they want to allow. To demonstrate, we will have 2 parameters for the child which one of this parameter will be set to the base class.\"), mdx(\"p\", null, \"The main change is to change the function that represent the class by adding a parameter. In the following code, we can see that BaseClass1 class function is now having a function with baseMember has a parameter. We can also see the ChildClass1 to have a function with two. The result is that we can now create with \\\"new\\\" an instance and specifying two parameters.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var BaseClass1 = function (baseMember) {\\n  this.baseMember = baseMember;\\n};\\n\\nvar ChildClass1 = function (childMember, baseMember) {\\n  BaseClass1.call(this, baseMember); // Call the constructor of the base class\\n  this.childMember = childMember;\\n};\\n\\nChildClass1.prototype = Object.create(BaseClass1.prototype);\\n\\nChildClass1.prototype.constructor = BaseClass1;\\nvar instance1 = new ChildClass1(\\\"C\\\", \\\"B\\\");\\nconsole.log(\\\"instance1.childMember: \\\" + instance1.childMember);\\nconsole.log(\\\"instance1.baseMember: \\\" + instance1.baseMember);\\n\")), mdx(\"p\", null, \"The output will be :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" \\\"instance1.childMember: C\\\" \\\"instance1.baseMember: B\\\"\\n\")), mdx(\"p\", null, \"As you may have realize, since we are using a function to create class in JavaScript, this bring some limitations. The main one is that you can only have a single constructor. It means that if you need to pass different type of information you need to check the type of the object passed or have optional parameter.\"), mdx(\"p\", null, \"Checking the type can be done with typeof to see if it's a number, string, array or an object. It's also possible to use instanceof to do logic depending of a specific type of object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var ChildClass1 = function (childMember, notalwaysprovided) {\\n  if (typeof childMember === \\\"string\\\") {\\n    console.log(\\\"The name was from a string with the value : \\\" + childMember);\\n  } else {\\n    console.log(\\n      \\\"The name was from an object with the value :\\\" + childMember.name\\n    );\\n  }\\n  console.log(\\n    \\\"This parameter is not always provided: \\\" +\\n      (notalwaysprovided || \\\"Default Value\\\")\\n  );\\n};\\nvar instance1 = new ChildClass1(\\\"Name1\\\", \\\"second optional param\\\");\\nvar instance2 = new ChildClass1({ name: \\\"Name2\\\" });\\n\")), mdx(\"p\", null, \"The output is : ```\\n\\\"The name was from a string with the value : Name1\\\" \\\"This parameter is not always provided: second optional param\\\" \\\"The name was from an object with the value :Name2\\\" \\\"This parameter is not always provided: Default Value\\\"\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"fbf04b79-1ac9-5b20-aa10-009c216a1f37","slug":"2017/javascript-prototype-part-3-constructor-with-parameter","__params":{"slug":"2017"}}},
    "staticQueryHashes": ["3159585216"]}