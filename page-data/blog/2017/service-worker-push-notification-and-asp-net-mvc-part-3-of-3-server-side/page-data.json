{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2017/service-worker-push-notification-and-asp-net-mvc-part-3-of-3-server-side/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Service Worker, Push Notification and Asp.Net MVC – Part 3 of 3 Server Side","date":"January 23, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Service Worker, Push Notification and Asp.Net MVC – Part 3 of 3 Server Side\",\n  \"date\": \"2017-01-23\",\n  \"categories\": [\"asp-mvc\", \"asp-net\", \"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I previously discussed about how to configure a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./service-worker-push-notification-and-asp-net-mvc-part-1-of-3-client-side\"\n  }, \"web push notification from the client side perspective\"), \" as well as how to send the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./service-worker-push-notification-and-asp-net-mvc-part-2-of-3-server-side\"\n  }, \"notification from an ASP.Net code\"), \" which could be sent from Azure Webjobs. The remaining part is how do you send to multiple devices of one user. If you have a single browser used by a user, the initial solution is good. However, the reality is that users use multiple devices. Users can use not only different browsers on different machines but also jump from computer to phone and so on. The idea is to register subscription by device and not by user.\"), mdx(\"p\", null, \"Google Firebase documentation explains briefly the \\\"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://firebase.google.com/docs/cloud-messaging/js/send-multiple\"\n  }, \"Device group messaging\"), \"\\\" but the page talks more about Topic. I couldn't figure out how to use the device group messaging but could use Topic for the same matter. The idea is to use a single topic per user and send a message to this topic.\"), mdx(\"p\", null, \"The first big change is to add a subscribe method and unsubscribe that work with the topic api.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public bool UnRegisterTopic(string userIdentifierForAllDevices, string singleDeviceNoticationKey) {\\n  var serverApiKey = ConfigurationManager.AppSettings[\\\"FirebaseServerKey\\\"];\\n  var firebaseGoogleUrl = $\\\"https://iid.googleapis.com/iid/v1/{singleDeviceNoticationKey}/rel/topics/{userIdentifierForAllDevices}\\\";\\n\\n  var httpClient = new WebClient();\\n  httpClient.Headers.Add(\\\"Content-Type\\\", \\\"application/json\\\");\\n  httpClient.Headers.Add(HttpRequestHeader.Authorization, \\\"key=\\\" + serverApiKey);\\n\\n  object data = new { };\\n  var json = JsonConvert.SerializeObject(data);\\n  Byte[] byteArray = Encoding.UTF8.GetBytes(json);\\n  var responsebytes = httpClient.UploadData(firebaseGoogleUrl, \\\"DELETE\\\", byteArray);\\n  string responsebody = Encoding.UTF8.GetString(responsebytes);\\n  dynamic responseObject = JsonConvert.DeserializeObject(responsebody);\\n\\n  return responseObject.success == \\\"1\\\";\\n}\\n\\npublic bool RegisterTopic(string userIdentifierForAllDevices, string singleDeviceNoticationKey) {\\n  var serverApiKey = ConfigurationManager.AppSettings[\\\"FirebaseServerKey\\\"];\\n  var firebaseGoogleUrl = $\\\"https://iid.googleapis.com/iid/v1/{singleDeviceNoticationKey}/rel/topics/{userIdentifierForAllDevices}\\\";\\n\\n  var httpClient = new WebClient();\\n  httpClient.Headers.Add(\\\"Content-Type\\\", \\\"application/json\\\");\\n  httpClient.Headers.Add(HttpRequestHeader.Authorization, \\\"key=\\\" + serverApiKey);\\n\\n  object data = new{};\\n  var json = JsonConvert.SerializeObject(data);\\n  Byte[] byteArray = Encoding.UTF8.GetBytes(json);\\n  var responsebytes = httpClient.UploadData(firebaseGoogleUrl, \\\"POST\\\", byteArray);\\n  string responsebody = Encoding.UTF8.GetString(responsebytes);\\n  dynamic responseObject = JsonConvert.DeserializeObject(responsebody);\\n\\n  return responseObject.success == \\\"1\\\";\\n }\\n\")), mdx(\"p\", null, \"There is quite repetition in that code and you can improve it easily. The biggest change is the URL. Not only the URL domain is different (before \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://fcm.googleapis.com/fcm/send\"\n  }, \"https://fcm.googleapis.com/fcm/send\"), \" and now \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://iid.googleapis.com/\"\n  }, \"https://iid.googleapis.com/\"), \"), it has different route portions. The first part is the device notification key which is the token generated by the client side from the method \\\"getToken\\\". The second portion of the route is the user identifier which I use as topic. If you really need topic across users, you can just use a string with the category needed. In my case, it is just the unique GUID of the user. This POST HTTP call will register the device for the user by a topic which is the user ID.\"), mdx(\"p\", null, \"To send a message to the user, on all devices, the code needs also to change.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public bool QueueMessage(string to, string title, string message, string urlNotificationClick) {\\n  if (string.IsNullOrEmpty(to)) {\\n     return false;\\n  }\\n  var serverApiKey = ConfigurationManager.AppSettings[\\\"FirebaseServerKey\\\"];\\n  var firebaseGoogleUrl = \\\"https://fcm.googleapis.com/fcm/send\\\";\\n\\nvar httpClient = new WebClient();\\nhttpClient.Headers.Add(\\\"Content-Type\\\", \\\"application/json\\\");\\nhttpClient.Headers.Add(HttpRequestHeader.Authorization, \\\"key=\\\" + serverApiKey);\\nvar timeToLiveInSecond = 24 * 60; // 1 day\\nvar data = new {\\n  to = \\\"/topics/\\\" + to ,\\n  data = new {\\n    notification = new {\\n      body = message,\\n      title = title,\\n      icon = \\\"/Content/Images/Logos/BourseVirtuelle.png\\\",\\n      url = urlNotificationClick,\\n      sound = \\\"default\\\"\\n    }\\n  },\\n  time_to_live = timeToLiveInSecond };\\n\\n  var json = JsonConvert.SerializeObject(data);\\n  Byte[] byteArray = Encoding.UTF8.GetBytes(json);\\n  var responsebytes = httpClient.UploadData(firebaseGoogleUrl, \\\"POST\\\", byteArray);\\n  string responsebody = Encoding.UTF8.GetString(responsebytes);\\n  dynamic responseObject = JsonConvert.DeserializeObject(responsebody);\\n\\nreturn responseObject.success == \\\"1\\\"; }\\n\")), mdx(\"p\", null, \"What has changed from sending to a single user? The field \\\"to\\\" which is sending to topics. The \\\"to\\\" in the method signature is still the user unique identifier, but instead of sending directly to it, we use it has a topic. We do not use the token generated by the front end since a new one got generated per device, we only use the user id which is the topic.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"0a712f21-113c-5f44-86ae-418bbfad6257","slug":"2017/service-worker-push-notification-and-asp-net-mvc-part-3-of-3-server-side","__params":{"slug":"2017"}}},
    "staticQueryHashes": ["3159585216"]}