{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-abstract-classes",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript Abstract Classes","date":"May 11, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The current version of TypeScript 1.4 does't not have the notion of abstraction. This is not convenient for object oriented programmer that want to dive into TypeScript. However, it is possible to simulate the abstraction by combining overriding and exception.\"), mdx(\"p\", null, \"Before going with the detail, why would we want abstract with TypeScript? Imagine that you want to force some logic to be called every time a concrete implementation is called. The way to do it is to call the method from the base class that has the the implementation of the method, this one call the abstract method of the child class. Here is C# code for this pattern.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" class Program { static void Main(string[] args) { var rendering = new ChildClass(); rendering.Render(); Console.ReadLine(); } }\\n\\npublic abstract class BaseClass { protected abstract void RenderChildImplementation();\\n\\npublic void Render() { Console.WriteLine(\\\"Base Start\\\"); RenderChildImplementation(); Console.WriteLine(\\\"Base End\\\"); } }\\n\\npublic class ChildClass:BaseClass { protected override void RenderChildImplementation() { Console.WriteLine(\\\"- Child -\\\"); }\\n\\n} \\n\")), mdx(\"p\", null, \"The output is what expected, the base class control the final output by having the child implementation between its tags.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"135px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/febbfc7001a7222b0f69ffc2cbf64118/d76be/Abstract.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"70.37037037037037%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACeElEQVQ4y82R20vTcRjGfxsO8xBiN3YhalJuWls2rGg60XloKw+MWaFzmzNs5jwxTbIounDKpjlFzMPMRFLyopAKugiMLAs3NWVIB/xfPrGfGhWVXnbx8D7v8/2+D8/LKyx46ljxmlnzVBHsvkLQW81qn5WVXutOtYj8dwR39NUd7OrCgttGaLiBV08fs/x6npUhJy9vmXjTVcVidzUBr5V3bjNv3WaxD3qtLHabxfrRY2Gpp5r3PdUseywsus0IgSEn68NNDLx4ztrWFqsjLqaaLjLdWobPUcKzzgrmOkzMtRuZbTcyf/sSM21G/A2ljDeVMthQyqyrnGmXkYnmMoSl+3WEfDVsTrj4OnWTbyP1bA5eJTRQK64Q8FhY67ez4asVtWWvjXVfLQGvjZW+Gj712wn57AR6bXzwWBGCwy1i7BlXOcP2HMYcRYw5CvFfLxaTPekw4a8vYrROx3h9EZONeh46z/Oo0SBi0hnu9du8UY+w/qCZ6U4LlfZrZChPclyVyamsMwiCQOoxOXkFxWQoM1Gps0Rdo83jQMxB8f2P2PS3Mei4wFF5Bgp5GtqcHLKzNRyKj+dISgpK5QlUKiUKhRx5WhqHExKIjooSh6USCRKJ8AuEz5M36KrSih9kERFoNBpKSkooKCggNTUVnU4n8vB7XFwcEonk7+nCCI21MtpsRKU+TUx0NElJSSQnJxMbG4tarSY3N5fExETS09ORSqX/NgtjY6SFqY5KzLZa8vPz0Gq1FBYWIpPJUCgUYjqDwYBerycyMnJvwy+THdy7fG57ZVmEmGI3SbiGjcN8z1V/Nrxj2r6qZD8D+zG8W3H2x9X+O8PvvI7uo2WjOu4AAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Abstract\",\n    \"title\": \"Abstract\",\n    \"src\": \"/static/febbfc7001a7222b0f69ffc2cbf64118/d76be/Abstract.png\",\n    \"srcSet\": [\"/static/febbfc7001a7222b0f69ffc2cbf64118/d76be/Abstract.png 135w\"],\n    \"sizes\": \"(max-width: 135px) 100vw, 135px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"When you want to use this pattern with TypeScript, you have some limitation. First of all, protected method does not yet exist (but will be there soon) and the abstract concept does not exist and is not planned to be part of TypeScript soon. The workaround is to use exception for method that should not be called from the outside and to use override methods to simulate the abstraction. ```typescript\\nexport class BaseClass {\"), mdx(\"p\", null, \"public render() { console.log('Base Start'); this.renderAbstract(); console.log('Base Start'); }\"), mdx(\"p\", null, \"renderAbstract() { throw new Error('This method is abstract and must be overrided.'); }\"), mdx(\"p\", null, \"} export class ChildClass extends BaseClass {\"), mdx(\"p\", null, \"public renderAbstract(): void { console.log('- Child -'); } } \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" This is far from being perfect since it is possible to call the renderAbstract() method directly from the implementation if you have instantiated the ChildClass, however, most of the case you should work with the BaseClass (or an interface) and abstract out this renderAbstract. Also, I have the convention to use a suffix \\\"Abstract\\\" to make sure not to call this one. Soon, with the keyword protected, this will be solved. The renderAbstract method will be changed to protected and even without the abstract, this code will work as supposed to.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"TypeScript Abstract Classes\\\",\\\"date\\\":\\\"2015-05-11\\\",\\\"categories\\\":[\\\"javascript\\\",\\\"typescript\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"8b03f822-26ed-5947-96f1-7c4ee8669519","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}