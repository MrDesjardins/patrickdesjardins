{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/rust-how-to-use-mpsc-unbounded-to-share-data-between-rust-threads",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to use mpsc::unbounded to share data between Rust threads","date":"November 26, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to use mpsc::unbounded to share data between Rust threads\",\n  \"date\": \"2022-11-26\",\n  \"categories\": [\"rust\", \"thread\", \"mpsc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Moving information between threads is always a delicate task. This is because so many issues can occur, and Rust is built around safety; hence it has a safe way to send information between two threads.\"), mdx(\"p\", null, \"One way is to rely on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"futures\"), \" crate and use a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"unbounded\"), \". The documentation is fuzzy around how to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"future::mpsc::unbounded,\"), \" and I'll try to provide an easy example to grasp the whole idea.\"), mdx(\"p\", null, \"First, before getting too deep with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"future::mpsc::unbounded\"), \", know that there is also \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"future::mpsc::channel\"), \". Channel is similar but is for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"bounded\"), \" communication. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"bounded\"), \" has a single channel per sender, while the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"future::mpsc::unbounded\"), \" has a single channel for every sender. The example uses the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"future::mpsc::unbounded\"), \" with an internal buffer in case the receiver is not fetching the data fast enough.\"), mdx(\"h1\", null, \"Main Loop Function\"), mdx(\"p\", null, \"The example consists of three functions. The first one, the main one, is the entry one that will spawn two threads.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"fn main() {\\n    let (broker_sender, broker_receiver) = mpsc::unbounded::<String>();\\n    task::spawn(receive_loop(broker_receiver));\\n    task::block_on(send_loop(broker_sender));\\n}\\n\")), mdx(\"p\", null, \"The loop uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"task::spawn\"), \" that starts a thread without blocking the execution of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"main\"), \" function and starting the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"receive_loop\"), \" function into a separate thread. It allows getting into the second line that blocks the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"main\"), \" function to keep the program running while also running a second function, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"send_loop\"), \" to run into another thread. \"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mpsc::unbounded::<String>\"), \" create a sender and receiver that can be shared between the two threads.\"), mdx(\"h1\", null, \"send_loop Function\"), mdx(\"p\", null, \"The send loop is a function that takes the user input from the command line and adds the value into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"broker_sender\"), \" that gets the string into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mpsc::unbounded\"), \" to have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"receive_loop\"), \" read it later. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"async fn send_loop(mut broker: mpsc::UnboundedSender<String>) -> () {\\n    loop {\\n        let mut user_input = String::new();\\n\\n        print!(\\\"> \\\");\\n        io::stdout().flush().unwrap();\\n        io::stdin().read_line(&mut user_input).unwrap();\\n        let user_input_clean = user_input.trim();\\n        broker.send(user_input_clean.to_string()).await.unwrap();\\n    }\\n}\\n\")), mdx(\"p\", null, \"The function has an infinite loop, waiting for the user's inputs. Then, it waits to read the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stdin\"), \", which takes the user line that is all the characters until the enter key is pressed. Finally, the last line gets the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mpsc::UnboundedSender<String>\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"send\"), \" the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \" using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"await.unwrap\"), \", which asynchronously puts the value into the communication pipeline. It still needs to be consumed.\"), mdx(\"h1\", null, \"receive_loop Function\"), mdx(\"p\", null, \"The last step is the receiving function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"async fn receive_loop(mut broker: mpsc::UnboundedReceiver<String>) -> () {\\n    let ten_millis = time::Duration::from_millis(500);\\n    loop {\\n        if let Ok(wrapper_msg) = broker.try_next() {\\n            println!(\\\"New message: {}\\\", wrapper_msg.unwrap());\\n        }\\n        thread::sleep(ten_millis)\\n    }\\n}\\n\")), mdx(\"p\", null, \"The function also has an infinite loop. It reads the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mpsc::UnboundedReceiver<String>\"), \" where the value is sitting from the previous function. The code above takes the value by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"try_next\"), \", which returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Result\"), \". The function does not look for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Err\"), \" path because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"try_next\"), \" spams an error anytime the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mpsc::UnboundedReceiver\"), \" is empty. However, when data is ready to be read, the value goes into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wrapper_msg\"), \", an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Option\"), \" type. Hence, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"unwrap\"), \" is called to read the string.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"A final observation is that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mpsc::UnboundedSender\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mpsc::UnboundedReceiver\"), \" shared between the two functions required to be mutable. You can see the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mut\"), \" in both parameters. Without the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mut\"), \", the code throws a compilation error:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"cannot borrow `broker` as mutable, as it is not declared as mutable\\ncannot borrow as mutable\\n\")), mdx(\"p\", null, \"The reason seems to be that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"try_next\"), \" has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&mut self\"), \"  in its \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.rs/futures-channel/0.3.25/src/futures_channel/mpsc/mod.rs.html#1131\"\n  }, \"definition\"), \". From my limited knowledge of Rust, the reason of why the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"try_next\"), \" seems to be that at the end, it has a queue where it needs to change its value (mutate) with the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.rs/futures-channel/0.3.25/src/futures_channel/mpsc/mod.rs.html#1031\"\n  }, \"unpark_one\"), \". \"), mdx(\"p\", null, \"There is a very low amount of examples on the Internet using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mpsc::unbounded\"), \". I hope these small examples gave you help on how to use Rust Future mpsc to pass information between threads.\"), mdx(\"p\", null, \"The code in this article relies on these two dependencies:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"futures = \\\"0.3.25\\\"\\nasync-std = \\\"1.12.0\\\"\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"241c75e5-2c06-5cc4-8100-1b302f2197aa","totalPages":75}},
    "staticQueryHashes": ["3159585216"]}