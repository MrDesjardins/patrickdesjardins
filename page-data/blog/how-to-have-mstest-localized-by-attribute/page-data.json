{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-have-mstest-localized-by-attribute",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to have MsTest localized by Attribute?","date":"January 12, 2016"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to have MsTest localized by Attribute?\",\n  \"date\": \"2016-01-12\",\n  \"categories\": [\"test\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Working with multiple languages requires to test in multiple languages too. A simple use case is if you have custom Asp.Net routing that you might want to test where an English route goes and the same for a French one. This goes beyond just text, but also how to handle numbers and datetime. The traditional way to do unit test in multiple localisations is to set the current thread at the beginning of the test, do the logic, assert and set the thread back to the original value.\"), mdx(\"p\", null, \"The problem is that in all your code you need to set the thread manually. It would be better to have an attribute on the top of the test method and have this one handling the thread culture. Unfortunately, MSTest \\\"TestMethod\\\" attributes is sealed which mean you cannot inherit of this one. The work around is to create a custom attribute. However, this come with the challenge to hook into MsTest pipeline to have MsTest reads the attribute and act accordingly. This is what we will discuss in this article, how to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ContextAttribute\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IMessageSink\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IContributeObjectSink\"), \" and so on.\"), mdx(\"p\", null, \"First, let's create a standard attribute that we will use on top of our test that need localization. We will use this one in combination of the TestMethod. The use will looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" [TestMethod] [LocalizedTest(LocalizedSection.EN_NAME)] public void MyTest() { //... Your test } \\n\")), mdx(\"p\", null, \"The attribute has a parameter which is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Culture Name\"), \" that we want to have the thread. The culture name is \\\"en-us\\\" for USA English or \\\"fr-ca\\\" Canadian French.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class LocalizedTestAttribute:Attribute { public string CultureName {get; set;} public LocalizedTestAttribute(string cultureName) { this.CultureName = cultureName; } } \\n\")), mdx(\"p\", null, \"A second attribute is required to be at the top of the class tested. This is the way to notify the Microsoft test framework that we want to hook inside the pipeline of tasks that the testing framework is going while executing tests. This attribute inherit from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ContextAttribute\"), \", from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.Runtime.Remoting.Contexts\"), \" namespace. The role of that class is to define a collection of possible hooks. In that case, we have only one hook that we call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LocalizedTestMessage\"), \". Those hooks are called \\\"messages\\\". I am using a helper named TestProperty which handle generic code for every message. This generic class is inspired by the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://mstestextensions.codeplex.com/SourceControl/latest#Trunk/Source/MSTestExtensions/TestAspect.cs\"\n  }, \"MsTestExtension\"), \" source code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class LocalizedTestContextAttribute: ContextAttribute { public LocalizedTestContextAttribute():base(\\\"LocalizedTest\\\") {\\n\\n}\\n\\npublic override void GetPropertiesForNewContext(IConstructionCallMessage msg) {\\n   if (msg == null) throw new ArgumentNullException(\\\"msg\\\"); \\n  msg.ContextProperties.Add(new TestProperty<LocalizedTestMessage>()); //We add 1 new message into the test pipeline \\n} }\\n\\npublic class TestProperty<T> : IContextProperty, IContributeObjectSink where T : IMessageSink, ITestMessage, new() {\\n\\nprivate readonly string_name = typeof(T).AssemblyQualifiedName;\\n\\n[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)] public bool IsNewContextOK(Context newCtx) { return true; }\\n\\n[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)] public void Freeze(Context newContext) { }\\n\\npublic string Name { [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)] get { return_name; } }\\n\\n[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)] public IMessageSink GetObjectSink(MarshalByRefObject obj, IMessageSink nextSink) { T testAspect = new T(); testAspect.AddMessageSink(nextSink); return testAspect; } }\\n\\npublic interface ITestMessage { void AddMessageSink(IMessageSink messageSink); } \\n\")), mdx(\"p\", null, \"Finally, we need to have our LocalizedTest message hook (message) defined. This class defines what is done before and after the execution of the test. This class is able to access the tested method to check if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LocalizedTest\"), \" attribute is defined on the class. If yes, it proceeds, otherwise it executes the method without changing anything. When the attribute is present, it backup the current thread culture, get the culture name from the attribute and set it to the test thread. It executes the test, and set back the original thread.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class LocalizedTestMessage : BaseTestMessage<LocalizedTestAttribute>, IMessageSink, ITestMessage { private IMessageSink nextSink;\\n\\n[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)] public IMessage SyncProcessMessage(IMessage msg) { if (msg == null) throw new ArgumentNullException(\\\"msg\\\"); CultureInfo currentCultureInfo = null; CultureInfo currentUICultureInfo = null;\\n\\n//Before test get value to set back after test \\nLocalizedTestAttribute localizationAttribute = base.GetAttribute(msg); if (localizationAttribute != null) { currentCultureInfo = System.Threading.Thread.CurrentThread.CurrentCulture; currentUICultureInfo = System.Threading.Thread.CurrentThread.CurrentUICulture; System.Threading.Thread.CurrentThread.CurrentCulture = new System.Globalization.CultureInfo(localizationAttribute.CultureName); System.Threading.Thread.CurrentThread.CurrentUICulture = System.Threading.Thread.CurrentThread.CurrentCulture; }\\n\\n//Execute test \\nIMessage returnMessage = nextSink.SyncProcessMessage(msg);\\n\\n//After test set back value \\nif (localizationAttribute != null && currentCultureInfo!= null && currentUICultureInfo!=null) { System.Threading.Thread.CurrentThread.CurrentCulture = currentCultureInfo; System.Threading.Thread.CurrentThread.CurrentUICulture = currentUICultureInfo; } return returnMessage; }\\n\\n[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)] public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink) { throw new InvalidOperationException(); }\\n\\npublic IMessageSink NextSink { [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)] get { return nextSink; } }\\n\\npublic void AddMessageSink(IMessageSink messageSink) { nextSink = messageSink; } }\\n\\npublic abstract class BaseTestMessage<TAttribute> where TAttribute : Attribute {\\n\\n[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)] protected TAttribute GetAttribute(IMessage message) { string typeName = (string)message.Properties[\\\"__TypeName\\\"]; string methodName = (string)message.Properties[\\\"__MethodName\\\"]; Type callingType = Type.GetType(typeName); MethodInfo methodInfo = callingType.GetMethod(methodName); object[] attributes = methodInfo.GetCustomAttributes(typeof(TAttribute), true); TAttribute attribute = null; if (attributes.Length > 0) { attribute = attributes[0] as TAttribute; } return attribute; } } \\n\")), mdx(\"p\", null, \"It would be even better if we could avoid having two different attributes on each test but this is a solution that still let us avoid having to handle thread on every test. It's also important to notice that this is only good for MsTest. If you are using other testing framework like nUnit or xUnit that this will not work. However, these frameworks have other mechanism to handle pre and post tests too. The documentation is very slim on Microsoft about there infrastructure classes. It comes from a pre-era where Microsoft where less open that it is now.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"2498e166-f0d2-50f9-9beb-b0009fa622f3","totalPages":75}},
    "staticQueryHashes": ["3159585216"]}