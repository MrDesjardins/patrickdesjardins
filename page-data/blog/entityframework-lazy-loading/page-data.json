{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/entityframework-lazy-loading",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Entity Framework explicit loading, lazy loading and eager loading","date":"September 4, 2011"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Entity Framework explicit loading, lazy loading and eager loading\",\n  \"date\": \"2011-09-04\",\n  \"categories\": [\"entity-framework\", \"sql\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Entityframework set lazing loading to false as a default mechanism for loading its entity data. In other words, this mean that the default value is set to eager loading or explicit loading. This behavior can be modified by the developer if a need is required by changing the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Lazy Loading Enable\"), \" of the conceptual model's property or by code by changing the the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"OptionContext\"), \" property \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"LazyLoadingEnabled\"), \".\"), mdx(\"p\", null, \"To understand correctly how the lazy loading works, let get an example from the NorthWind database. The model generated from this database give us a Customer entity that contain orders (of type Order).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"var db = new NorthWindContainer(); //Instantiate the Object Context db.ContextOptions.LazyLoadingEnabled = false; //Default value var collectionData = db.Customers.First().Orders; Console.WriteLine(\\\"All orders from the first customer using lazy loaded to \\\" + db.ContextOptions.LazyLoadingEnabled); foreach (var order in collectionData) { Console.WriteLine(order.OrderID); } Console.WriteLine(collectionData.Count + \\\" shown\\\"); \\n\")), mdx(\"p\", null, \"In the example above, line 3 get all orders from the first customer. The lazy loading of the Object Context is set the false (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://msdn.microsoft.com/en-us/library/system.data.objects.objectcontextoptions.lazyloadingenabled.aspx\",\n    \"title\": \"Default value for the LazyLoadingEnabled of the ObjectContext\"\n  }, \"the default value\"), \"). The console will show nothing from the loop and a count of 0. This is because the lazy loading is not enabled.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" SELECT TOP (1) [c].[CustomerID] AS [CustomerID], [c].[CompanyName] AS [CompanyName], [c].[ContactName] AS [ContactName], [c].[ContactTitle] AS [ContactTitle], [c].[Address] AS [Address], [c].[City] AS [City], [c].[Region] AS [Region], [c].[PostalCode] AS [PostalCode], [c].[Country] AS [Country], [c].[Phone] AS [Phone], [c].[Fax] AS [Fax] FROM [dbo].[Customers] AS [c] \\n\")), mdx(\"p\", null, \"As you can see, the SQL reflect the result that we have. Nothing to take the orders.\"), mdx(\"p\", null, \"In fact, in this mode, to be able to get all the data a new line must have been written between the request to get all orders and the display. The following code contain the Load() method that will go to the database to load orders.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"var db = new NorthWindContainer(); db.ContextOptions.LazyLoadingEnabled = false; //Default value var collectionData = db.Customers.First().Orders; collectionData.Load(); //Explicit loading Console.WriteLine(\\\"All orders from the first customer using lazy loaded to \\\" + db.ContextOptions.LazyLoadingEnabled); foreach (var order in collectionData) { Console.WriteLine(order.OrderID); } Console.WriteLine(collectionData.Count + \\\" shown\\\"); \\n\")), mdx(\"p\", null, \"This mean that when using the default value (eager loading/explicit loading) the value loaded is only the one of the object and not the object of the class. To load the object of the class, the developer needs to use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Load()\"), \" on the desired object. This can be interesting if the object is big and you do not need to load the whole object.\"), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Load\"), \" method is called. This mean that it's an explicit loading. Eager loading does not require the call to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Load\"), \" method. Further example will show you. For the moment, let check the SQL statement generated to see how it reflect the change.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" SELECT TOP (1) [c].[CustomerID] AS [CustomerID], [c].[CompanyName] AS [CompanyName], [c].[ContactName] AS [ContactName], [c].[ContactTitle] AS [ContactTitle], [c].[Address] AS [Address], [c].[City] AS [City], [c].[Region] AS [Region], [c].[PostalCode] AS [PostalCode], [c].[Country] AS [Country], [c].[Phone] AS [Phone], [c].[Fax] AS [Fax] FROM [dbo].[Customers] AS [c]\\n\\nexec sp_executesql N'SELECT [Extent1].[OrderID] AS [OrderID], [Extent1].[CustomerID] AS [CustomerID], [Extent1].[EmployeeID] AS [EmployeeID], [Extent1].[OrderDate] AS [OrderDate], [Extent1].[RequiredDate] AS [RequiredDate], [Extent1].[ShippedDate] AS [ShippedDate], [Extent1].[ShipVia] AS [ShipVia], [Extent1].[Freight] AS [Freight], [Extent1].[ShipName] AS [ShipName], [Extent1].[ShipAddress] AS [ShipAddress], [Extent1].[ShipCity] AS [ShipCity], [Extent1].[ShipRegion] AS [ShipRegion], [Extent1].[ShipPostalCode] AS [ShipPostalCode], [Extent1].[ShipCountry] AS [ShipCountry] FROM [dbo].[Orders] AS [Extent1] WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'ALFKI'\\n\\n\\n\")), mdx(\"h3\", null, \"Using Lazy Loading\"), mdx(\"p\", null, \"But, this is pretty manual task and if want to use lazy loading instead of explicit loading it's possible. This will give the control of loading objects of the class to the system.\"), mdx(\"p\", null, \"The C# code will be like this: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"var db = new NorthWindContainer(); //Instantiate the Object Context db.ContextOptions.LazyLoadingEnabled = true; //Default value var collectionData = db.Customers.First().Orders; Console.WriteLine(\\\"All orders from the first customer using lazy loaded to \\\" + db.ContextOptions.LazyLoadingEnabled); foreach (var order in collectionData) { Console.WriteLine(order.OrderID); } Console.WriteLine(collectionData.Count + \\\" shown\\\"); \\n\")), mdx(\"p\", null, \"This produce exactly the same output for the SQL.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" SELECT TOP (1) [c].[CustomerID] AS [CustomerID], [c].[CompanyName] AS [CompanyName], [c].[ContactName] AS [ContactName], [c].[ContactTitle] AS [ContactTitle], [c].[Address] AS [Address], [c].[City] AS [City], [c].[Region] AS [Region], [c].[PostalCode] AS [PostalCode], [c].[Country] AS [Country], [c].[Phone] AS [Phone], [c].[Fax] AS [Fax] FROM [dbo].[Customers] AS [c]\\n\\nexec sp_executesql N'SELECT [Extent1].[OrderID] AS [OrderID], [Extent1].[CustomerID] AS [CustomerID], [Extent1].[EmployeeID] AS [EmployeeID], [Extent1].[OrderDate] AS [OrderDate], [Extent1].[RequiredDate] AS [RequiredDate], [Extent1].[ShippedDate] AS [ShippedDate], [Extent1].[ShipVia] AS [ShipVia], [Extent1].[Freight] AS [Freight], [Extent1].[ShipName] AS [ShipName], [Extent1].[ShipAddress] AS [ShipAddress], [Extent1].[ShipCity] AS [ShipCity], [Extent1].[ShipRegion] AS [ShipRegion], [Extent1].[ShipPostalCode] AS [ShipPostalCode], [Extent1].[ShipCountry] AS [ShipCountry] FROM [dbo].[Orders] AS [Extent1] WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'ALFKI'\\n\\n\\n\")), mdx(\"h3\", null, \"Caching\"), mdx(\"p\", null, \"Also, if we run the all examples in the same method we will realize that even if the collectionData is accessed twice that the database will be called once because the object context has cached the collection. Here is a snippet of 3 calls. One with the lazy loading to false with a load call. One other with the lazy loading to true and one with false without the load. Interestingly, the last one will display value because the collection was already loaded.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var db = new NorthWindContainer(); db.ContextOptions.LazyLoadingEnabled = false; //Default value var collectionData = db.Customers.First().Orders; collectionData.Load(); Console.WriteLine(\\\"All orders from the first customer using lazy loaded to \\\" + db.ContextOptions.LazyLoadingEnabled); foreach (var order in collectionData) { Console.WriteLine(order.OrderID); } Console.WriteLine(collectionData.Count + \\\" shown\\\");\\n\\ndb.ContextOptions.LazyLoadingEnabled = true; collectionData = db.Customers.First().Orders; Console.WriteLine(\\\"All orders from the first customer using lazy loaded to \\\" + db.ContextOptions.LazyLoadingEnabled); foreach (var order in collectionData) { Console.WriteLine(order.OrderID); } Console.WriteLine(collectionData.Count + \\\" shown\\\");\\n\\ndb.ContextOptions.LazyLoadingEnabled = false; //Default value collectionData = db.Customers.First().Orders; Console.WriteLine(\\\"All orders from the first customer using lazy loaded to \\\" + db.ContextOptions.LazyLoadingEnabled + \\\" back to False\\\"); foreach (var order in collectionData) { Console.WriteLine(order.OrderID); } Console.WriteLine(collectionData.Count + \\\" shown\\\");\\n\\nConsole.ReadLine(); \\n\")), mdx(\"h2\", null, \"Advanced example and eager loading\"), mdx(\"p\", null, \"Previous example does not show the real power of eager loading. Let go back quickly to the lazy loading code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var db = new NorthwindEntities(); db.ContextOptions.LazyLoadingEnabled = true; //Default value\\n\\nforeach (var customer in db.Customers) { Debug.WriteLine(\\\"Customer \\\" + customer.CustomerID); foreach (var order in customer.Orders) { Debug.WriteLine(\\\"|-->Order \\\" + order.OrderID); } } \\n``` This will produce 1 SQL to retrieve all Customers and then 1 SQL for each order. This is a problem called \\\"N+1\\\". You will have 1 initial SQL hit and additional hit for each customer. This lead to huge performance problem. The magic of lazy loading suddenly disappear. Of course, lazy loading is useful in some moment like accessing only 1 object and its objects like in all previous example. The same thing occur with explicit loading. To make it works, the Load should have been called between the two foreachs.\\n\\n\\n```csharp\\n var db = new NorthwindEntities(); db.ContextOptions.LazyLoadingEnabled = false;\\n\\nforeach (var customer in db.Customers) { Debug.WriteLine(\\\"Customer \\\" + customer.CustomerID); customer.Orders.Load(); //Explicit loading foreach (var order in customer.Orders) { Debug.WriteLine(\\\"|-->Order \\\" + order.OrderID); } } \\n``` The N+1 problem is still there. With eager loading, this would result to a single query. To notify which object to load inside the class, the use of _Include_ is required. Here is an example:\\n\\n```csharp\\nvar db = new NorthwindEntities(); db.ContextOptions.LazyLoadingEnabled = true; var customers = db.Customers.Include(\\\"Orders\\\"); foreach (var customer in customers) { Debug.WriteLine(\\\"Customer \\\" + customer.CustomerID); foreach (var order in customer.Orders) { Debug.WriteLine(\\\"|-->Order \\\" + order.OrderID); } } \\n\")), mdx(\"p\", null, \"Line 2 and line 3 have changed. The line 2 tell to use eager loading while the line 3 indicates that it needs to load to object Orders inside the Customers. This produce a single SQL.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" SELECT [Project1].[C1] AS [C1], [Project1].[CustomerID] AS [CustomerID], [Project1].[CompanyName] AS [CompanyName], ... FROM ( SELECT [Extent1].[CustomerID] AS [CustomerID], [Extent1].[CompanyName] AS [CompanyName], [Extent1].[ContactName] AS [ContactName], ... 1 AS [C1], [Extent2].[OrderID] AS [OrderID], [Extent2].[CustomerID] AS [CustomerID1], [Extent2].[EmployeeID] AS [EmployeeID], ... FROM [dbo].[Customers] AS [Extent1] LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID] ) AS [Project1] ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC \\n\")), mdx(\"p\", null, \"This LEFT OUTER JOIN (also known as LEFT JOIN) do what you would have been doing in SQL to get additional information if available.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"76db19ac-9007-5a5e-9947-2a997b08f2d2"}},
    "staticQueryHashes": ["3159585216"]}