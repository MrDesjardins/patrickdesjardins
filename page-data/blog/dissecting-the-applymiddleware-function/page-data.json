{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/dissecting-the-applymiddleware-function",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Dissecting the applyMiddleware Function","date":"January 16, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dissecting the applyMiddleware Function\",\n  \"date\": \"2018-01-16\",\n  \"categories\": [\"redux\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \" is probably the most popular \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./dissecting-redux-compose\"\n  }, \"store enhancer\"), \"[\", \"1\", \"]\", \".\\nMost people don't realize that a middleware is a concept built as a store enhancer and in this article, we will see how the concept of middleware leverages Redux's store enhancer hook on the store to allows creating custom code to be executed between the dispatch of an action and the time the action reaches the reducers.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \" is called when the store is created by the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./dissecting-the-createstore-of-redux\"\n  }, mdx(\"em\", {\n    parentName: \"a\"\n  }, \"createStore\"), \" function\"), \"[\", \"2\", \"]\", \". The first parameter are the reducers, and the second parameter is the composition of store enhancer. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \" is most of the time called with the compose function and allows to setup many middlewares. Here is a basic setup with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"createStore\"), \" where we can see how the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \" is invoked.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const store = createStore( reducers, compose( applyMiddleware(middleware1, middleware2, middleware2), aSecondStoreEnhancerHere ) ) \\n\")), mdx(\"p\", null, \"If we recall from the article entitled \\\"dissecting the createstore\\\"\", \"[\", \"2\", \"]\", \", the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"createStore\"), \" function call at some point the composition of enhancers like the code below this paragraph. For the sake of simplicity, we will assume that we are not composing store enhancer but only have one which will be the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \". The only difference with the composition is that the composition would be called one after the other one in sequence. The main idea to grasp at the moment is not the possibility of calling several enhancers one after the other but that the enhancer calls the store and that the return function of the enhancer is called with the reducers and the preloaded state.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"return enhancer(createStore)(reducer, preloadedState) \\n\")), mdx(\"p\", null, \"This is crucial to visualize. The enhancer is a function that takes as a parameter the store and outputs a function that will be executed by the createStore with two parameters which is the reducer and preloaded state. This function will return at its turn the store and how to dispatch action to this one.\"), mdx(\"p\", null, \"This is why the applyMiddleware has the following shapes:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export default function applyMiddleware(...middlewares) { \\n  return (createStore) => (...args) => {\\n    // Code removed for brevity\\n    return { ...store, dispatch };\\n  } \\n} \\n\")), mdx(\"p\", null, \"If we deconstruct or de-generalize the code of the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"createstore\"), \" to be using directly the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \" store enhancer we would end up with the following code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"return applyMiddleware(createStore)(reducer, preloadedState)\\n\\n//Or:\\n\\nconst createStoreFromApplyMiddleware = applyMiddleware(createStore); \\nreturn createStoreFromApplyMiddleware(reducer, preloadedState); \\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \" code first task is to call the actual createStore function which returns the store. The second task is to get a reference to the dispatch function. This will be used in the third task which is to create the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"middlewareAPI\"), \" object who is sent to every middleware.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const store = createStore(...args);\\nlet dispatch = store.dispatch;\\nlet chain = [];\\n\\nconst middlewareAPI = { \\n  getState: store.getState, \\n  dispatch: (...args) => dispatch(...args) \\n} \\n// To be continued, removed for brivety \\n\")), mdx(\"p\", null, \"Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \" is having a collection of middleware, the store \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \" store enhancer will call each of them with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"middlewareAPI\"), \" and return all the middleware return values into a chain of result. The chain of results is then composed and invoked with the store's dispatch which allows every middleware to be executed with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" argument that will move the next composed middleware and still have them access the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"middlewareAPI\"), \" which contains the dispatch of the store and the current state of the reducer.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"chain = middlewares.map(middleware => middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) \\n\")), mdx(\"p\", null, \"At the end, the whole store enhancer is about 20 lines of code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export default function applyMiddleware(...middlewares) { \\n  return (createStore) => \\n    (...args) => { \\n      const store = createStore(...args);\\n      let dispatch = store.dispatch;\\n      let chain = [];\\n\\n      const middlewareAPI = { \\n        getState: store.getState, \\n        dispatch: (...args) => dispatch(...args) \\n      }; \\n      chain = middlewares.map(middleware => middleware(middlewareAPI));\\n      dispatch = compose(...chain)(store.dispatch);\\n\\n      return { ...store, dispatch } \\n  } \\n} \\n\")), mdx(\"p\", null, \"As we can see, it's possible to have different behavior like altering the dispatch function in the actual case with the middleware. The function is actually called once at the creation of the store which set up the chain to be called once a dispatch is executed. Since the code is overriding the dispatch and returning a wrapper of composed functions (middleware), every time something is dispatched it will be pass-through all the middleware. The capability to alter dispatch in a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./how-to-have-a-hook-before-a-redux-store-notify-its-subscriber-with-typescript\"\n  }, \"store enhancer allows injecting code to be executed after a store\"), \"[\", \"3\", \"]\", \" is being modified. The code below is an excerpt that illustrates how the compose function could be replaced and used to be returned allowing a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"hook\"), \" function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function dispatch(...args) { \\n  const dispatchResult = store.dispatch(dispatchArgs); \\n  hook(notifyListeners, store); \\n  return dispatchResult; \\n} \\n\")), mdx(\"p\", null, \"In this article, we have brushed the store enhancer of middleware. In the next article, we will see how middlewares actual work and see in detail how the popular Thunk middleware brings asynchronous capability.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"1: \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./blog/dissecting-redux-compose\"\n  }, \"Redux Compose\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"2: \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./dissecting-the-createstore-of-redux\"\n  }, \"Create Store\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"3: \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./how-to-have-a-hook-before-a-redux-store-notify-its-subscriber-with-typescript\"\n  }, \"Redux Store Notify\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"5aed6840-09ad-5e35-aaa7-bc21cbbcf07d","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}