{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/never-use-primitive-type-for-any-entities",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Never use Primitive Type for any Entities","date":"March 24, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Never use Primitive Type for any Entities\",\n  \"date\": \"2015-03-24\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I see in a lot of system an abuse of primitive types. Instead of using a class for an entity, the use of primitive is used. Often, when additional needs is required, additional primitives are used which duplicate. Here is some basic example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class Item { public double Price{get;set;} public string Name{get;set;} } \\n``` The problem is obvious, the _Item_ class should not be in a primitive type for the _Price_. The first reason is if later we need to have **additional information**, like for example the currency, you will be stuck with a second property. The problem become even more obvious if you have several money element for the same class. The class become clutters of properties. It is also way easier in the future to add additional property or method without having to change a lot of place in your software -- you change at one place, the class.\\n\\n\\n```csharp\\n public class Item { public double Price{get;set;} public int CurrencyTypeForPrice{get;set;} public double SuggestedPrice{get;set;} public int CurrencyTypeForSuggestedPrice{get;set;} public string Name{get;set;} } \\n\")), mdx(\"p\", null, \"The second problem is when your application become big and you realize that you should have used decimal instead of double that you have to change at several places instead to a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"single class\"), \". The third problem is about \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"operations\"), \". How can you compare two prices? You have to compare the double properties (the price) with the int property (the currency type) every time. Rather than having a class with the operator equal overriding that does it at one place, you have to do it everywhere.\"), mdx(\"p\", null, \"The forth problem is about passing information by parameter. When you have a single class, for example a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Money\"), \" class instead of a decimal + type for currency, it is way cleaner to use. The fifth reason is when you are using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Asp.Net MVC and Template\"), \". You can create a visual editor and display template for your entity type. For example, you could create a Money.cshtml which shows the right control for the user to allow him to select from a drop down the currency. Without a specific class for your entity you would have to create an Html helper that take two parameters: the amount and the currency.\"), mdx(\"p\", null, \"Finally, you can add additional \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"validation\"), \". If you entity is for money than you can say that your money must always be positive. This also imply the advantage to be able to unit test at a single place instead of everywhere when you use your money logic.\"), mdx(\"p\", null, \"To conclude, you can see that their is several advantages like when refactoring your entity, when adding operations or when using framework like Asp.Net MVC. A cleaner code and less repetition is also very interesting. None but not the less, having a class instead of a primitive type allow you to unit tests logic on any logic about your entity.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"9de4cff3-81d9-517a-bbf0-b1c627bcad4a","totalPages":71}},
    "staticQueryHashes": ["3159585216"]}