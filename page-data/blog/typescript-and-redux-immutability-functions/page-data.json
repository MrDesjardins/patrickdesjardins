{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/typescript-and-redux-immutability-functions",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript and Redux Immutability Functions","date":"June 5, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript and Redux Immutability Functions\",\n  \"date\": \"2018-06-05\",\n  \"categories\": [\"redux\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The actual system I am working in my daily job is using TypeScript, React and Redux. I am not relying on any framework to do the immutability.\\nI am using pure JavaScript cloning mechanism and have unit tests for each of my reducer that makes sure that the instance returned is not the same.\\nIt works great, it's easy to understand, and doesn't require any dependencies.\\nHowever, few utility functions ease the whole process mostly when using dictionary which is present everywhere since I an normalizing my data in the Redux store to avoid having any duplicated values.\"), mdx(\"p\", null, \"First, I am using an alias for the index signature just to avoid repeating the square brackets syntax everywhere. This doesn't provide much but is worth mentioning because all the future function I'll share use this interface.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface GenericMap<T> { [id: string]: T; } \\n\")), mdx(\"p\", null, \"The first useful function is to add into an array an object without mutating this one. This function relies on the array's function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"slice\"), \" to return a copy of the array. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export function addInArrayIfNotPresent<T>(array: T[], item: T): T[] { \\n  let returnArray: T[] = []; \\n  if (array !== undefined) { \\n    returnArray = array.slice(); \\n    if (array.indexOf(item) === -1) { \\n      returnArray.push(item); \\n    } \\n  } \\n  return returnArray; \\n}\\n\\n// Usage: const newReferenceArrayWithItemsAdded = addInArrayIfNotPresent(existingArray, itemsToAdd); \\n\")), mdx(\"p\", null, \"The second function is to add a new element in a map without mutating the existing dictionary. This is useful because it handles the cloning and swap the value into the cloned dictionary.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export function alterImmutablyMap<T>(stateMap: GenericMap<T>, key: number | undefined, modelMember: T): GenericMap<T> { \\n  if (key !== undefined) { \\n    const cloneStateMap = Object.assign({}, stateMap); \\n    cloneStateMap[key] = modelMember; \\n    return cloneStateMap; \\n    } \\n    return stateMap; \\n  }\\n\\n// Usage: const newDictionary = alterImmutablyMap(existingDictionary, key, value); \\n\")), mdx(\"p\", null, \"The third function allows changing a property of an existing object in a dictionary. The function is useful if the user change a single property and you do not want to change to extract the current object and manually clone it to set the new value into a new clone of the object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export function alterImmutablyMapMember<T, K extends keyof T>(stateMap: GenericMap<T>, key: number | undefined, modelMember: K, value: T[K]): GenericMap<T> { \\n  if (key !== undefined) { \\n    if (stateMap[key] !== undefined) { \\n      const cloneStateMap = Object.assign({}, stateMap); \\n      const modelFromState = Object.assign({}, cloneStateMap[key]) as T; \\n      if (modelFromState !== undefined) { \\n        modelFromState[modelMember] = value; \\n        cloneStateMap[key] = modelFromState; \\n      } \\n      return cloneStateMap; \\n    } \\n  } \\n  return stateMap; \\n} \\n// Usage: const newDictionary = alterImmutablyMapMember(existingDictionary, key, member, value); \\nconst newDictionary2 = alterImmutablyMapMember(existingDictionary, 1, \\\"name\\\", \\\"Patrick\\\"); // Change the item 1's property name to Patrick \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"bae0a452-3124-56b1-be67-ad8fdee17f75"}},
    "staticQueryHashes": ["3159585216"]}