{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-communicate-from-your-website-to-a-chrome-extension",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to communicate from your website to a Chrome Extension","date":"August 6, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to communicate from your website to a Chrome Extension\",\n  \"date\": \"2018-08-06\",\n  \"categories\": [\"extension\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.chrome.com/extensions/messaging\"\n  }, \"Passing a message\"), \" from a website to a Chrome Extension is not routine job. Not only the communication between a specific piece of code from the browser to a specific browser is unusual, it is also confusing by the potential type of extension. In this article, I'll focus on an extension that goes into the Chrome Extension Developer tools. Similar to the \\\"Elements\\\" or \\\"Network\\\" tab, the extension will have its own tab that will be populated by the website. To be more accurate, it could be any website using a specific library.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"601px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/b0f3af7540288ad452a314adaef75264/d8f62/ChromeExtensionDeveloperTools.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"25%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAnUlEQVQY04VQyw7EIAj0///Rc2ts7Nv6aJ3NkGD20t1JiAgDDJgQAq7rQkoJ0zTBWovjOCQWY8S6rnieB/d9Y57nHn8zQwLRWhNjMV9FzrnnOPQfDLsS53mKsm3bsO+7TGMTKqS/LItwmHPOYRxHeO8xDIP8yesNqeqbzCQbUxFjtVaUUmRdDuGfxjOor5t1hXpHLeSqGleynufXyh/gw4ZMqrm27AAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"ChromeExtensionDeveloperTools\",\n    \"title\": \"ChromeExtensionDeveloperTools\",\n    \"src\": \"/static/b0f3af7540288ad452a314adaef75264/d8f62/ChromeExtensionDeveloperTools.png\",\n    \"srcSet\": [\"/static/b0f3af7540288ad452a314adaef75264/5a46d/ChromeExtensionDeveloperTools.png 300w\", \"/static/b0f3af7540288ad452a314adaef75264/0a47e/ChromeExtensionDeveloperTools.png 600w\", \"/static/b0f3af7540288ad452a314adaef75264/d8f62/ChromeExtensionDeveloperTools.png 601w\"],\n    \"sizes\": \"(max-width: 601px) 100vw, 601px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The illustration is the concept of what is happening. The reality is a little bit more complicated. There is more communication boundary that is required which can be confusing at first. The documentation is great but it lacks guidance for a first time user. The following illustration is what happens in term of communication and with that in mind, the flow should be easier to understand.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"621px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/b25d19d702ae98732be11e1d96b88834/3075e/ChromeExtensionDeveloperTools-RealityView.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"35.66666666666667%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABFklEQVQoz32QSY6EMAxFc/9FoToNqjuwQKwYNoAYlIgwzxjc+lGn1YtWW7L8eXiKRdd1fF0XH8fB53lyXdcspTT6OA5CHMfRzbLMQZ5Sisqy5KqqjBdFYeI4jqaPmKaJn+cxTkRs7b5vBALfts2VUr6gwfDvW5saaDBooZTiZVlYa22mQA/DwNgc24BJKT9BELz7vuemaQgReW3b/kTUYDmB5wE2TWPgPM+mGZKklARW1/XH9/23HQJmG63rapbBEHBhb2jviLXhuB0REfg0TW5Zli+w67oIQ+H7vput8ArU4lug4B8zR32ex9VaO5ahMczWYjtrIgxDzvOc0zT9yynLMo7j2PU8z4EGQ02SJOAcRRH/7vEFe+ISASvbo9EAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"ChromeExtensionDeveloperTools RealityView\",\n    \"title\": \"ChromeExtensionDeveloperTools RealityView\",\n    \"src\": \"/static/b25d19d702ae98732be11e1d96b88834/3075e/ChromeExtensionDeveloperTools-RealityView.png\",\n    \"srcSet\": [\"/static/b25d19d702ae98732be11e1d96b88834/5a46d/ChromeExtensionDeveloperTools-RealityView.png 300w\", \"/static/b25d19d702ae98732be11e1d96b88834/0a47e/ChromeExtensionDeveloperTools-RealityView.png 600w\", \"/static/b25d19d702ae98732be11e1d96b88834/3075e/ChromeExtensionDeveloperTools-RealityView.png 621w\"],\n    \"sizes\": \"(max-width: 621px) 100vw, 621px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Your library that is sending information to your extension is very simple. It consists of using the \\\"window.postMessage\\\" to send an object. The extension will read and parse your payload depending on the source. For my library and extension, named \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/dataaccessgateway\"\n  }, \"Data Access Gateway\"), \", I decided to have the source name \\\"dataaccessgateway-agent\\\". The name could be anything. Keep in mind that later, you will reuse the name at the extension code to verify that the message is coming from your source.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"window.postMessage({ source: \\\"dataaccessgateway-agent\\\", payload: requestInfo }, \\\"*\\\"); \\n\")), mdx(\"p\", null, \"The payload may be anything you want but make sure it remains with an object that is not constructed (with \\\"new). For example, if in your payload you have a date, make sure they are not in the payload as an actual Date object but in a more primitive form (string or number). Otherwise, you will receive an exception.\"), mdx(\"p\", null, \"The next step is to configure the manifest file for the extension. The critical detail is to specify two JavaScript files: the background and content_script. The former run regardless of which website is active. It runs in the background of the Chrome Extension from when the extension is loaded until it is unloaded. The latter is a script that the extension injects into the webpage. The injection can be targetted to a specific page or to run on all webpage. In my case, the extension must receive a message from a library, hence I do not know which website might use it and I allow the injection in every page. Because we are having this requirement to be available on every page, the security and the communication is more overwhelming that most information you can find in the basic documentation. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{ \\n  \\\"name\\\": \\\"Data Access Gateway Developer Tool\\\", \\n  \\\"version\\\": \\\"1.0\\\", \\n  \\\"description\\\": \\\"Data Access Gateway Developer Tool that allows getting insight about how the data is retrieved\\\", \\n  \\\"manifest_version\\\": 2, \\n  \\\"permissions\\\": [ \\\"storage\\\", \\\"http://*/*\\\", \\\"https://*/*\\\", \\\"<all_urls>\\\" ], \\n  \\\"background\\\": { \\n    \\\"scripts\\\": [ \\\"background.js\\\" ], \\n    \\\"persistent\\\": false }, \\n    \\\"icons\\\": { \\\"16\\\": \\\"images/dagdl16.png\\\", \\\"32\\\": \\\"images/dagdl32.png\\\", }, \\n    \\\"minimum_chrome_version\\\": \\\"50.0\\\", \\n    \\\"devtools_page\\\": \\\"index.html\\\", \\n    \\\"content_security_policy\\\": \\\"script-src 'self' 'unsafe-eval'; object-src 'self'\\\", \\n    \\\"content_scripts\\\": [ \\n      { \\n        \\\"matches\\\": [ \\\"<all_urls>\\\" ], \\n        \\\"js\\\": [ \\\"contentScript.js\\\" ], \\n        \\\"run_at\\\": \\\"document_start\\\" \\n      } \\n    ] \\n  } \\n\")), mdx(\"p\", null, \"The manifest file asks for permissions and specifies the \\\"index.html\\\" which is the file loaded when the Chrome Developer Tool panel is open. We will come back later on the HTML file. The important part is the background and contentScript.js. Both files can be renamed as you wish. Before moving on, it is important to understand that the communication flows in this particular order: postMessage -> contentScript.js -> background.js -> dev tools HTML page. The core of the code will be in the HTML page and the remaining is just a recipe that must be followed to be compliant with Chrome's security.\"), mdx(\"p\", null, \"The contentScript.js is the file injected into the webpage. The sole purpose of this file is to listen for message passed by \\\"window.postMessage\\\", to check the payload and make sure this is the one we are interested in and move along to Chrome's runtime. The following code registers a \\\"message\\\" listener when the webpage loads. The script captures \\\"postMessage\\\" and checks for the source. When is the agent name defined in the previous step, we invoke the sendMessage from the Chrome's runtime. The invocation passes the message to the background.js file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"window.addEventListener(\\\"message\\\", (event) => { // Only accept messages from the same frame \\n  if (event.source !== window) { \\n    return; \\n  }\\n\\n  var message = event.data;\\n\\n  // Only accept messages that we know are ours \\n  if (typeof message !== \\\"object\\\" || message === null || !!message.source && message.source !== \\\"dataaccessgateway-agent\\\") { \\n    return; \\n  } \\n  chrome.runtime.sendMessage(message); \\n}); \\n\")), mdx(\"p\", null, \"The next step is to listen to the Chrome's runtime messages. More code is required. There is a collection of tabs which will handle multiple tabs situation to know where it comes from. There are two listeners. One handle incoming new message and one for new Chrome's tab. The message dispatches the message to the proper tab, the other listener subscribes to and unsubscribe the tab.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"let tabPorts: { [tabId: string]: chrome.runtime.Port } = {}; \\nchrome.runtime.onMessage.addListener((message, sender) => { \\n  const port = sender.tab && sender.tab.id !== undefined && tabPorts[sender.tab.id]; \\n  if (port) { \\n    port.postMessage(message); \\n  } \\n  return true; \\n});\\n\\nchrome.runtime.onConnect.addListener((port: chrome.runtime.Port) => { \\n  let tabId: any; \\n  // chrome.runtime.onMessage.addListener \\n  port.onMessage.addListener(message => { \\n    if (message.name === \\\"init\\\") \\n    { \\n      // set in devtools.ts \\n      if (!tabId) { \\n        // this is a first message from devtools so let's set the tabId-port mapping \\n        tabId = message.tabId; \\n        tabPorts[tabId] = port;\\n      }\\n    } \\n  }); \\n  port.onDisconnect.addListener(() => { \\n    delete tabPorts[tabId]; \\n    }); \\n}); \\n\")), mdx(\"p\", null, \"The post.postMessage send the payload for the last time. This time, it will be within reach of your Chrome Developer Tools extension. You may remember that in the manifest file we also specified an HTML file. This file can have a JavaScript file specified that will listen to the messages from the background.js script. I am developing the Data Access Gateway Chrome Extension with React, so the index.html starts the index.jsx, this one attach the app.jsx which will have in its constructor the listener.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"this.port = chrome.runtime.connect({ name: \\\"panel\\\" });\\n\\nthis.port.postMessage({ name: \\\"init\\\", tabId: chrome.devtools.inspectedWindow.tabId });\\n\\nthis.port.onMessage.addListener((message: Message) => { \\n  if (message.source === \\\"dataaccessgateway-agent\\\") { \\n    // Do what you want with the message object \\n    // E.g. this.setState(newState);\\n  } \\n});\\n\\nchrome.devtools.panels.create( \\\"Data Access Gateway\\\", \\\"images/dagdl32.png\\\", \\\"index.html\\\" ); \\n\")), mdx(\"p\", null, \"Still quite a few lines of code before actually doing something in the Chrome's extension. The first one is to connect to the tab (port). Then, initializing the communication by sending a post message. Finally, on the connected port to start listening to incoming messages. Finally, we invoke the creation of the panel. As you might have seen, the \\\"addListener\\\" is strongly typed with the object I sent from the initial library call -- that is right! TypeScript is supported in each of these steps. You can see all the detail, in TypeScript, in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/dataaccessgatewaychromeextension\"\n  }, \"GitHub Repository of the Data Access Gateway Chrome Extension\"), \".\"), mdx(\"p\", null, \"To conclude, the transportation of your object from your library (or website) to the Chrome's Developer panel is not straightforward. It requires multiple steps which can fail in several places. A trick I learned while developing the extension is that \\\"console.warn\\\" is supported. You can trace and ensure that the data is passing as expected. Also, another debugging trick, you should undock the extension (to have the Developer Tool in a separate window) which will allow you to do \\\"command+i\\\" on Mac or \\\"f12\\\" on Windows to debug the Chrome's developer tool. This is the only way to not only see your tracing but to set a breakpoint in your code.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"2188175d-dcbd-5f20-9756-b249dbb6eb59","totalPages":73}},
    "staticQueryHashes": ["3159585216"]}