{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/dissecting-redux-compose",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Dissecting Redux Compose Function","date":"January 23, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dissecting Redux Compose Function\",\n  \"date\": \"2018-01-23\",\n  \"categories\": [\"redux\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Redux is one of the most popular state management in the JavaScript ecosystem since few months. In this article, we will dissect the method that composes all middleware named \\\"compose\\\". The role of this method is to aggregate all functions that will have the opportunity to be executed everytime an action is being dispatched. It's a door open to do something before passing to the next function (middleware). It's the only opportunity to modify data before reaching the reducers and the store. The method is used once. It is in the popular method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \" that we will see in a future article. For the moment, just keep in mind that compose function is taking all middleware to place them in a queue where the data will flow sequentially before reaching\"), mdx(\"p\", null, \"Before analyzing the method, let's look at all of it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export default function compose(...funcs) { \\n  if (funcs.length === 0) { \\n    return arg => arg;\\n  }\\n\\n  if (funcs.length === 1) { \\n    return funcs[0];\\n  }\\n\\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\\n} \\n\")), mdx(\"p\", null, \"That's it!. And this can be even simpler because the two first ifs are for cases that are rarely used which is composing nothing (no middleware) or composing a single middleware. In the first case, we return a new function that returns the first parameter. For example: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"compose()(\\\"a\\\", \\\"b\\\", \\\"c\\\") // Return \\\"a\\\" \\n\")), mdx(\"p\", null, \"This example composes nothing. It might seem that we have 3 parameters, but in fact, compose returns a function that has three arguments. When composing middleware, we will place the middleware inside the compose function, not using the middleware as a parameter of the returned function. This is important to understand that the compose function returns a new function and not a value. The condition statement that looks for a length of one simply return the first parameter of the compose function. This is also rarely used as having a single middleware is rare and wouldn't require using at all the compose function at the first place -- you could just use the middleware directly.\"), mdx(\"p\", null, \"Having the two ifs analyzed let's jump on the last line which is the confusing one. The last line is the line that is mostly to be used because most application using Redux has several middlewares. The first thing to notice is the use of the JavaScript function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \". The reduce function is applied to an array and call a callback with two parameters which are the accumulated value followed by the value of the array. The callback is executed the same amount of the length of the array. So, if you have 3 middlewares, the reduce function will call three times the callback. Here is a simple example to grasp the concept. The example takes an array and reduces it by summing every number. The callback function is anonymous and will be called 3 times (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"length-1\"), \"). The first time the parameter \\\"acc\\\" and \\\"value\\\" will be 0,1; then 1,2; then 3,3. When every element of the array has proceeded, it returns the value which is 6.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"console.log([0, 1, 2, 3].reduce( function(acc, value){\\n   return acc + value; \\n   } \\n  ) \\n); \\n\")), mdx(\"p\", null, \"The first confusion with the compose function is that the reduce function is returning (...args) which is not clear. It's a little bit simpler to remove the arrow function to use traditional functions. Here is the same function written with functions. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export default function compose(...funcs) { \\n  if (funcs.length === 0) { \\n    return arg => arg;\\n  }\\n\\n  if (funcs.length === 1) { \\n    return funcs[0];\\n  }\\n\\n  return funcs.reduce(combineMiddleware);\\n}\\n\\nfunction combineMiddleware(functionWrapper, middlewareToAdd){ \\n  return function(...nextFunction){ \\n    console.log(\\\"What is nextFunction:\\\", ...nextFunction); \\n    return functionWrapper(middlewareToAdd(...nextFunction)); \\n  }; \\n} \\n\")), mdx(\"p\", null, \"The compose function is calling reduce on a named function \\\"combineMiddleware\\\". At that point, it should be clear that compose method returns a function since the reduce function returns an aggregation of an array and that the array is an array of function hence the result will be a single function. What remains unclear is how we aggregate since we won't be summing numbers this time.\"), mdx(\"p\", null, \"The combineMiddleware function will return a new function. Since the reduce function takes the return of the callback for the accumulation, this new function will be used on the next invocation. At that point, invoking compose with 3 functions would return a function returned by combineMiddleware. Nothing would happen. Let's create three fake functions and add some log statements to follow what is really happening.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function compose(...funcs) { \\n  if (funcs.length === 0) { \\n    return arg => arg;\\n  }\\n\\n  if (funcs.length === 1) { \\n    return funcs[0];\\n  }\\n\\n  return funcs.reduce(combineMiddleware);\\n}\\n\\nfunction combineMiddleware(functionWrapper, middlewareToAdd){ \\n  console.log(\\\"Combined!!!\\\", middlewareToAdd); \\n  return function(...nextFunction){ \\n    console.log(\\\"What is nextFunction:\\\", ...nextFunction); \\n    return functionWrapper(middlewareToAdd(...nextFunction)); \\n  }; \\n}\\n\\nconst a = function(next){ console.log(\\\"Outside A\\\", next); \\nreturn function(previousReturnedValue) { \\n  console.log(\\\"Inside A\\\", previousReturnedValue); \\n  return next(previousReturnedValue + 'a'); \\n  }; \\n}; \\n\\nconst b = function(next){ \\n  console.log(\\\"Outside B\\\", next); \\n  return function(previousReturnedValue) { \\n    console.log(\\\"Inside B\\\", previousReturnedValue); \\n    return next(previousReturnedValue + 'b'); \\n  }; \\n};\\n\\nconst c = function(next){ \\n  console.log(\\\"Outside C\\\", next); \\n  return function(previousReturnedValue) { \\n    console.log(\\\"Inside C\\\", previousReturnedValue); \\n    return next(previousReturnedValue + 'c'); \\n  }; \\n}; \\n\\nconst final = function(next){ \\n  console.log(\\\"Final\\\", next); \\n  return next; \\n};\\n\\nconsole.log(\\\"Compose Output\\\", compose(a, b, c)); \\n\")), mdx(\"p\", null, \"We have the same compose, this time with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log\"), \" that will output what is the next function.\\nThere are also three functions that return a function. This is how middlewares are constituted and since the compose function takes a function it is compatible.\\nThe idea is that each function takes a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" parameter which is a pointer to the \\\"next middleware\\\" allowing the actual middleware, the inner function to be executed and returning the value transformed to the next one. In this example, we compose A-B-C. The compose will wrap the function to have C wrapping B wrapping A which will start with the value passed down (not provided yet). So, it is actually doing: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return function(A(B(C(\\\"Data here))))\"), \". The console output looks like the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"  //Combined!!! \\n  \\u0192 (next){ \\n   console.log(\\\"Outside B\\\", next); \\n   return function(previousReturnedValue) { \\n     console.log(\\\"Inside B\\\", previousReturnedValue); \\n     return next(previousReturnedValue + 'b'); \\n    }; \\n\\n  // Combined!!! \\n  \\u0192 (next){ \\n    console.log(\\\"Outside C\\\", next); \\n    return function(previousReturnedValue) { \\n      console.log(\\\"Inside C\\\", previousReturnedValue); \\n      return next(previousReturnedValue + 'c'); \\n    }; \\n\\n  // Compose Output \\n  \\u0192 (...nextFunction){ \\n    console.log(\\\"What is nextFunction:\\\", ...nextFunction); \\n    return functionWrapper(middlewareToAdd(...nextFunction));\\n  } \\n\")), mdx(\"p\", null, \"So, what is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nextFunction\"), \" is the final function passed as a parameter to the returned function of \\\"compose\\\". In Redux, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \" function will use it to pass the store.dispatch down (we will see in a future article). As expected, the combineMiddleware method output twice since we have 3 functions. We can see the final output being the function returned by combineMiddleware function. The next function returns the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"functionWrapper\"), \" which is the function A, that call the function B with .\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"..nextFunction\"), \" that is function C.\"), mdx(\"p\", null, \"If change the last output statement to have the compose function execute the returned function, we will see more the flow of the execution.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"console.log(\\\"Compose Output\\\", compose(a, b, c)); // Change this line by: \\nconsole.log(\\\"Compose Output\\\", compose(a, b, c)(final)); \\n\")), mdx(\"p\", null, \"The output is different this time but calls twice \\\"What is next function\\\" since we have 4 functions having the \\\"final\\\" one that will be wrapped also but executed. The major change is that every function gets called.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"  //Combined!!! \\n  \\u0192 (next){ \\n    console.log(\\\"Outside B\\\", next); \\n    return function(previousReturnedValue) { \\n      console.log(\\\"Inside B\\\", previousReturnedValue); \\n      return next(previousReturnedValue + 'b'); \\n    }; \\n\\n  // Combined!!! \\n  \\u0192 (next){ \\n    console.log(\\\"Outside C\\\", next); \\n    return function(previousReturnedValue) { \\n      console.log(\\\"Inside C\\\", previousReturnedValue); \\n      return next(previousReturnedValue + 'c'); \\n    }; \\n\\n  // What is nextFunction: \\n  \\u0192 (next){ \\n    console.log(\\\"Final\\\", next); \\n    return next; \\n  } \\n  \\n  // Outside C \\n  \\u0192 (next){ \\n    console.log(\\\"Final\\\", next); \\n    return next;\\n   } \\n   \\n  // What is nextFunction: \\n  \\u0192 (previousReturnedValue) { \\n    console.log(\\\"Inside C\\\", previousReturnedValue); \\n    return next(previousReturnedValue + 'c'); \\n  }\\n  \\n  // Outside B \\n  \\u0192 (previousReturnedValue) { \\n    console.log(\\\"Inside C\\\", previousReturnedValue);\\n     return next(previousReturnedValue + 'c'); \\n  } \\n  \\n  //Outside A \\n  \\u0192 (previousReturnedValue) { \\n    console.log(\\\"Inside B\\\", previousReturnedValue); \\n    return next(previousReturnedValue + 'b'); \\n  }\\n\\n  // Compose Output \\n  \\u0192 (previousReturnedValue) { \\n    console.log(\\\"Inside A\\\", previousReturnedValue); \\n    return next(previousReturnedValue + 'a'); \\n  } \\n\")), mdx(\"p\", null, \"The last output is still a function, but this time, not the combine wrapper but the function A. This is interesting since every function was also a function but with a pointer to the next one. It means that that the returned function \\\"A\\\" will be executed and since this one call next (which in that case is \\\"B\\\") the cascade will continue until the \\\"final\\\" function is called. The final function also calls next and for the moment doesn't do much. In fact, we can remove the \\\"return next\\\" from function \\\"final\\\" and to have the same output.\"), mdx(\"p\", null, \"Let's alter another time the last line.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"console.log(\\\"Compose Output\\\", compose(a, b, c)(final)(\\\"!\\\")); \\n\")), mdx(\"p\", null, \"This time, we execute the composition of functions completely. We are passing down the exclamation point. As we saw in the last trace, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"previousReturnedValue\"), \" is added before the function, hence we can expect to have the result \\\"!ABC\\\";\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"  // Same trace until the last output Inside A ! Inside B !a Inside C !ab Final !abc Compose Output !abc \\n\")), mdx(\"p\", null, \"As we notice, the function A is called first and call the function B and C and final. Removing the \\\"return next\\\" from the final function will print \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \".\"), mdx(\"p\", null, \"If we move back to Redux and how it uses the compose function we see that the applyMiddleware use it this way: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"dispatch = compose(...chain)(store.dispatch) \\n\")), mdx(\"p\", null, \"This allows having the consumer of a configured Redux to call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dispatch(ACTION)\"), \" and have action passed down. As we can see, the compose takes \\\"chain\\\" which is an array of the middleware configured and pass down as the \\\"final\\\" the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"store.dispatch\"), \". It means that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"store.dispatch\"), \" will call the result of all the middleware.\"), mdx(\"p\", null, \"In this article, we have dissected the small function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"compose\"), \" of Redux. We saw that its goal is to wrap multiple functions and weave them together with a callback that allows chaining the result of each of them to finally be able to execute a final function on the cascade of results. For Redux, it will allow developers to dispatch action to reducers and having the dispatched action to alter the flow between the time the action is executed and persisted.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"f8f064b6-0194-51ab-91d3-4cfbabea6b37","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}