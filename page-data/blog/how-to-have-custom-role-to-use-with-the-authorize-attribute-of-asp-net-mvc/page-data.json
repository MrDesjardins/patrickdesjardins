{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-have-custom-role-to-use-with-the-authorize-attribute-of-asp-net-mvc",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to have custom role to use with the Authorize attribute of Asp.Net MVC","date":"November 12, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to have custom role to use with the Authorize attribute of Asp.Net MVC\",\n  \"date\": \"2012-11-12\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you are developing a website with Asp.Net MVC you might use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[Authorize]\"), \" attribute over actions of your controllers. The Authorize attribute let you mark the method access to a user or a group of user (called role).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"[Authorize(Roles = \\\"groupName1, groupeName2\\\")] \\npublic ActionResult Creation() { \\n  //... \\n} \\n\")), mdx(\"p\", null, \"The code in the example above illustrate the authorization of the creation method to the groupeName1 and groupeName2.\"), mdx(\"p\", null, \"The Authorize method use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IPrincipal\"), \" to get the current username logged. It use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IsInRole\"), \" method. Here is a part of the code from the MVC framework.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public bool IsInRole(string role) { \\n  if (_Identity == null) \\n    throw new ProviderException(SR.GetString(SR.Role_Principal_not_fully_constructed));\\n\\n  if (!_Identity.IsAuthenticated || role == null) \\n    return false; \\n\\n  role = role.Trim(); \\n  \\n  if (!IsRoleListCached) {\\n    _Roles.Clear();\\n\\n    string[] roles = Roles.Providers[_ProviderName].GetRolesForUser(Identity.Name); \\n    foreach(string roleTemp in roles) \\n    if (_Roles[roleTemp] == null)\\n      _Roles.Add(roleTemp, String.Empty);\\n\\n    _IsRoleListCached = true;\\n    _CachedListChanged = true; \\n  } \\n  return_Roles[role] != null; \\n} \\n\")), mdx(\"p\", null, \"As we can see, it first check if the user is authenticated, if not, then no need to check anything. Then, it checks with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Roles.Providers[].GetRolesForUser(...)\"), \".\"), mdx(\"p\", null, \"This code call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RoleProvider\"), \" to get the complete list of roles for the logged user and check if the role specified by the attribute is inside the collection. If it is, then the access is granted, otherwise, a 401 errors will raise.\"), mdx(\"p\", null, \"So, to create a custom role provider, you need to create a new class that inherit from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.Web.Security.RoleProvider\"), \". This will let you override two important methods:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"bool IsUserInRole(string username, string roleName)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"string[] GetRolesForUser(string username)\"))), mdx(\"p\", null, \"The first one will call the second one. The second one, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GetRolesForUser\"), \" is the one used by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IPrincipal\"), \" (and by this mean used by the attribute Authorized).\"), mdx(\"p\", null, \"From here, you can do what ever you want to do. For example, in a project, I had to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WindowsTokenRoleProvider\"), \" but to check for a specific suffix. If the user had the suffix \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_PROJECTNAME\"), \" than it was a possible role, other roles were not checked. That mean that if the user ABC has \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"admin_PROJECT1\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"admin_PROJECT3\"), \" and that this user log to the PROJECT3 that it shouldn't be authorized. Fine, but the problem was that I couldn't simply add the attribute over the method with the full name for some reason. I had to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[admin]\"), \" and not \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[admin_PROJECT3]\"), \". So, the task was to implement a custom \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RoleProvider\"), \", get the list of all available role for the user and then filter by project to return in fact a list of role for the project. Of course, I had to also remove the suffix to be able to return a clean list that would be comparable with the role name like \\\"admin\\\".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class MyRoleProvider:System.Web.Security.RoleProvider { \\n  private readonly WindowsTokenRoleProvider_windows;\\n\\n  public MyRoleProvider() {\\n    _windows = new WindowsTokenRoleProvider(); \\n  }\\n\\n  public override void Initialize(string name, NameValueCollection config) { \\n    base.Initialize(name, config); //config can access attribute specified in the web.config \\n  }\\n\\n  public override bool IsUserInRole(string username, string roleName) { \\n    return GetRolesForUser(username).FirstOrDefault(s => s == roleName)!=null; \\n  }\\n\\n  public override string[] GetRolesForUser(string username) { \\n    var sufix = \\\"PROJECT1\\\"; \\n    return_windows.GetRolesForUser(username).ToList().Where(s => s.EndsWith(sufix)).Select(s => s.Replace(sufix, string.Empty).ToArray(); \\n  } \\n} \\n\")), mdx(\"p\", null, \"Here is a short example, in fact the sufix was taken from a configuration file. From there, it's possible to use the attribute with the role without having to specify anything about the sufix. The sufix can be set to the configuration file. This could be useful for different deployment server where in some server user have different role. You could set \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"admin_Testing\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"admin_Production\"), \" where you can set developer to \\\"Patrick\\\" a developer the role of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"admin_Testing\"), \" but not to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"admin_Production\"), \". In the web.config, you just set \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_Testing\"), \" for the testing environment and on the production \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_Production\"), \". So, if Patrick log to the testing environment, he should be able to do what ever this role give him access but no when he goes into production.\"), mdx(\"p\", null, \"The MyRoleProvider is specified in the web.config under system.web \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<roleManager enabled=\\\"true\\\" defaultProvider=\\\"MyRoleProvider\\\"> \\n <providers> \\n <clear /> \\n <add name=\\\"MyRoleProvider\\\" type=\\\"YourNameSpace.RoleProvider.MyRoleProvider\\\" /> \\n </providers> \\n</roleManager> \\n\")), mdx(\"p\", null, \"The add of the provider element can have custom attribute to add information that can be read by the Role Provider inside the Initialize method.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"abaa5da9-3ee7-58c1-b0b8-a57562b5a0e3","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}