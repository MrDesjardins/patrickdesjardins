{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2015/how-to-debug-entity-framework-migration-seeding/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to Debug Entity Framework Migration Seeding","date":"March 4, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to Debug Entity Framework Migration Seeding\",\n  \"date\": \"2015-03-04\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Debugging Entity Framework\\u2019s Migration Seeding can be confusing because you cannot just set a breakpoint and execute the Migration command to update your database. You must use a second Visual Studio to debug the first one. The easiest way is to use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"System.Diagnostics.Debugger.Launch\"), \" method. By calling that method, inside your code, a second Visual Studio will open and debug the first one that is executing the migration command. The second Visual Studio will be in debug mode. The trick is to keep this one attached to the first one until you are completely done. That mean that you can debug the first one with break point, stop it if you have error, edit the code, run the migration command again, etc. All that without stopping the second Visual Studio. If you stop the second Visual Studio that is attached to the first one, you will have to reattach which can take several times. However, by keeping the second Visual Studio always attached on the first one, you do not have any waiting time.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" if (System.Diagnostics.Debugger.IsAttached == false) System.Diagnostics.Debugger.Launch(); \\n\")), mdx(\"p\", null, \"The code shows what you should copy paste, right before where you expect the problem.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"38e0257f-f438-53f2-b057-7ed9d5df948a","slug":"2015/how-to-debug-entity-framework-migration-seeding","__params":{"slug":"2015"}}},
    "staticQueryHashes": ["3159585216"]}