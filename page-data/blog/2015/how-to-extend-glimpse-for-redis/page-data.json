{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2015/how-to-extend-glimpse-for-redis/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to Extend Glimpse for Redis","date":"October 12, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to Extend Glimpse for Redis\",\n  \"date\": \"2015-10-12\",\n  \"categories\": [\"asp-net\", \"redis\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://getglimpse.com/\"\n  }, \"Glimpse\"), \" is the best real time profiler/diagnostic add-on you can have for your Asp.Net MVC solution. I will not describe in that article all the capabilities but in one sentence, Glimpse allows to have for you Asp.Net MVC project all times for each calls like filter, action, db call, etc. Unfortunately, no extension has been done for Redis. Nevertheless, creating a custom extension for the Timeline is not too hard. However, the documentation is very dry and it is not obvious about what you can extend or not. This is really sad and the extensibility model of Glimpse is pretty limited. For example, you cannot extend the HUD.\"), mdx(\"p\", null, \"The objective of the Glimpse's extension we are building in this article is to add in Glimpse's timeline every cache calls starting time, ending time, duration and what was the method name and key used. Here is the end result: \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"400px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/patrickdesjardins/static/4199c4ff10892bb80a374c059fbcf0a8/e17e5/GlimpseExtension-400x288.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"72%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACg0lEQVQ4y4WSW4+bVhRG+f//oQ9V31q1mkh96Es7GVVJM5lM5fEABowPV2PuGBtjbvaqwE5mGkXKw9I6B4lvH+29pQfZ5lEXaH7IMkiw0x2yHbL0YvysvJCWbLYVblLgpturX/DSLU6ST5ZUzccwQ1StxLS22G5JnJZ8fF7jZw3n05njsSGMM84n4DtImvnEk+Lz8G+AvAhRjQh3HSHcNXnssHPvSFd/4j3/zsb9A8u+wXHeTNhXv0aayQuE4xGmCXGeE2U56zAlSwuyLKcoCrI8p6oq7NhG5AIjMi6ODayrx7se6UjqMmGxtNCFz8rZYNobLD8iKyrabqDp+olj29F3Z4aOif4rfz5LspWgmzaG8FENC1lbYawc4qIi27ccmo5j21NP7qjblrrtpu+j69duOqSZ5mIIdwoz7TXC3Uw99KKShX+kPAwc2zN1c+JwPLGvx9cOU5GJa8HLuUdSFBl16TBXl2img77yEG5IUe5Iwg/Emzui4I7AvyVP37HfvqcoxFTgEvQqsO2R5s/PKIaNogvmqoFqGBjCYX/Y4Ylf0OUfyMJfidc/s0t/Iw1ueLif0Q4n6uZzK3rqa1uk+8c5i6XNk6IjazZ37yw+zVy8dUGRfSQK/iIJ35KEt6TRLYF3i6IYdMP5S9j/Xvhprk2Bsmai6C73jyFzNcQPdtTNwP7QUZQ1UbIl2x4oq3biMqBxEO2LmxZptnDRV840lHF9DCEQrk9V1zTdMP3Y9qfJ40D6Aboe2u7bSLow0UwXbeWwMMfgywqV+8MU+LIuJ3aFRRr9TRr/Qxq//ybSfK1gigBdjC+9sLQ8trvD1JNx30ba5oxfWdxkP/Im/+kLN1+d/wM3Gw85/SITMQAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"GlimpseExtension 400x288\",\n    \"title\": \"GlimpseExtension 400x288\",\n    \"src\": \"/patrickdesjardins/static/4199c4ff10892bb80a374c059fbcf0a8/e17e5/GlimpseExtension-400x288.png\",\n    \"srcSet\": [\"/patrickdesjardins/static/4199c4ff10892bb80a374c059fbcf0a8/5a46d/GlimpseExtension-400x288.png 300w\", \"/patrickdesjardins/static/4199c4ff10892bb80a374c059fbcf0a8/e17e5/GlimpseExtension-400x288.png 400w\"],\n    \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The first thing is that extension will be not for Redis particularity but for any cache system. I have in the project I have a Cache.cs class that is abstract. My Redis implementation inherit from that cache. That class contains a lot of method like Set, Get, Delete etc. Here is the set method. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public void Set<T>(string key, T objectToCache, TimeSpan? expiry = null) { if (string.IsNullOrEmpty(key)) { throw new ArgumentNullException(\\\"key\\\"); } if (this.isCacheEnable) { var serializedObjectToCache = Serialization.Serialize(objectToCache); if (!this.ExecuteUnderCircuitBreaker(()=>this.SetStringProtected(key, serializedObjectToCache, expiry),key)) { Log.Error(string.Format(\\\"Cannot Set {0}\\\", key)); } } } \\n\")), mdx(\"p\", null, \"As you can see, the method serializes the object to cache, and calls the SetStringProtected method. Something particular is the method is called within a function called ExecuteUnderCircuitBreaker which is a design pattern. Whatever this pattern, every calls to the cache go through this function. At the end, if we remove all the circuit breaker pattern we can add the entry point for the Glimpse's extension.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" protected bool ExecuteUnderCircuitBreaker(Action action, string key, [CallerMemberName]string callerMemberName=\\\"\\\") { using (var glimpse = new GlimpseCache(key, callerMemberName)) { //Code removed here about circuit breaker action(); } } \\n\")), mdx(\"p\", null, \"The important part for the moment is that every calls for the cache are proxied by this method which execute the Redis action between a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GlimpseCache\"), \" object creation and disposition. The GlimpseCache class start a timer when the class is constructed and stop the timer when it is disposed.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class GlimpseCache:IDisposable { private readonly GlimpseCacheCommandTracer tracer; public GlimpseCache(string key, string commandName) { this.tracer = new GlimpseCacheCommandTracer(); tracer.CommandStart(commandName, key); }\\n\\npublic void Dispose() { if (tracer != null) { tracer.CommandFinish(); } } } \\n``` The core code is in the **GlimpseCacheCommadnTracer**. The tracer will use the IMessageBroker and IExecutionTimer to know the configuration. This will get from the configuration file (web.config) Glimpse's configurations but also if this one is active or not. It will also give you a hook to the timer start and stop. This will allow us to get into the timeline by publishing an event. This class also configure how to display the information. You can define the label, the color and the highlight.\\n\\n\\n```csharp\\n public class GlimpseCacheCommandTracer { private IMessageBroker messageBroker; private IExecutionTimer timerStrategy;\\n\\nprivate IMessageBroker MessageBroker { get { return messageBroker ?? (messageBroker = GlimpseConfiguration.GetConfiguredMessageBroker()); } set { messageBroker = value; } }\\n\\nprivate IExecutionTimer TimerStrategy { get { return timerStrategy ?? (timerStrategy = GlimpseConfiguration.GetConfiguredTimerStrategy()()); } set { timerStrategy = value; } } private const string LABEL = \\\"Cache\\\"; private const string COLOR = \\\"#555\\\"; private const string COLOR_HIGHLIGHT = \\\"#55ff55\\\"; private string command; private string key; private TimeSpan start;\\n\\npublic void CommandStart(string command, string key) { if (TimerStrategy == null) return; this.start = TimerStrategy.Start(); this.command = command; this.key = key; }\\n\\npublic void CommandFinish() { if (TimerStrategy == null || MessageBroker == null) return;\\n\\nvar timerResult = TimerStrategy.Stop(start);\\n\\nvar message = new CacheTimelineMessage(this.command, this.key) .AsTimelineMessage(command + \\\": \\\" + key, new TimelineCategoryItem(LABEL, COLOR, COLOR_HIGHLIGHT)) .AsTimedMessage(timerResult);\\n\\nMessageBroker.Publish(message); } } \\n\")), mdx(\"p\", null, \"The command finish method is called by the disposable method stop the timer for this event and build the message to be added to the timeline. In that example, we display the command and the key. The third and last class you need is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CacheTimelineMessage\"), \". This is the class that inherit from Glimpse's MessageBase and ITimelineMessage. This is what will be used to display information in the timeline.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class CacheTimelineMessage : MessageBase, ITimelineMessage { public string Command { get; set; } public string Key { get; set; }\\n\\n#region From Interface public TimelineCategoryItem EventCategory { get; set; } public string EventName { get; set; } public string EventSubText { get; set; } public TimeSpan Duration { get; set; } public TimeSpan Offset { get; set; } public DateTime StartTime { get; set; } #endregion public CacheTimelineMessage(string command, string key) { this.Command = command; this.Key = key;\\n\\n} } } \\n\")), mdx(\"p\", null, \"I am pretty sure we can do something better and even maybe show more information, but I am satisfy with the insight that I can have now with this few lines of code to Glimpse.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"2b416312-ed43-587d-9c77-685b876f7f0c","slug":"2015/how-to-extend-glimpse-for-redis","__params":{"slug":"2015"}}},
    "staticQueryHashes": ["3159585216"]}