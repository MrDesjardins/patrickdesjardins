{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2015/entity-framework-many-to-many-relationship/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Entity Framework Many to Many Relationship","date":"November 23, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The theory for many to many relationship is simple: you map two entities with key that you define on each side and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Entity Framework\"), \" generate the table that you have assigned the name with. Something like the code below works perfectly. The problem occurs when you want to save entities later.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" this.HasMany(d => d.Moderators).WithMany(d => d.ContestsUserModerate).Map(ul=> { ul.MapRightKey(\\\"ApplicationUserModeratorId\\\"); ul.MapLeftKey(\\\"ContestId\\\"); ul.ToTable(\\\"ContestModerators\\\", Constants.SchemaNames.User); }); \\n\")), mdx(\"p\", null, \"The problem is is you save the entity on which you configured the many to many relationship than you might get problem with Entity Framework trying to insert the two entities you are trying to maps. The problem is that if you have entity A that try to have B than A.B is having the entity and not a foreign key attribute. The same is true for B.A which is having a collection of A. In both case, it's a collection of entities. The problem is bigger than just trying to insert those entity cause you could just write in your save method a code to mark those collection's entities the status to UnChanged. But, the problem is that if you have rich entities than this one will contains other entities. So you have to go through all of its entities and handle all states of each properties or nullify all properties and use the foreign key properties. This is simply not viable for big classes.\"), mdx(\"p\", null, \"The solution is to forget about the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Map\"), \" method of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Entity Framework\"), \" and to create your own association entity.\"), mdx(\"p\", null, \"For example, the previous code we were having an Entity called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Contest\"), \" that try to get a many to many to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ApplicationUser\"), \". So, you create a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ContestApplicationUser\"), \" class. Than, you have in both entities (Contest and ApplicationUser) a collection of the new class you just created : \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ContestApplicationUser\"), \". You need to create a configuration for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ContestApplicationUser\"), \" which will define the primary key which should be the primary key of both entities. This can be done by specifying in an anonymous class both primary key of your classes. Finally, you need to specify that both properties are required in the class and that this one has a relationship to the specific entity they both represent.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class ContestApplicationUserConfiguration : AssociationConfiguration<ContestApplicationUser> { public ContestApplicationUserConfiguration() : base(Constants.SchemaNames.Contest) { this.HasKey(c => new { UserId = c.UserId, ContestId = c.ContestId }); this.HasRequired(d => d.Contest).WithMany(d => d.Users).HasForeignKey(d => d.ContestId); this.HasRequired(d => d.User).WithMany(d => d.Contests).HasForeignKey(d => d.UserId); } } \\n\")), mdx(\"p\", null, \"The AssociationConfiguration class is a class I created that simply an helper that create the table name with the type of the entity. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public abstract class AssociationConfiguration<T> : EntityTypeConfiguration<T> where T : class { protected AssociationConfiguration(string schemaName) { ToTable(typeof(T).Name, schemaName); } } \\n``` From here, it's very simple to save any new associations. You just need to instantiate the class, _ContestApplicationUser_ and you just fill up the two properties for the foreign keys. On the other way around, when you load the entities with the collection you will include the collection and the other side.\\n\\n\\n```csharp\\n .Include(d => d.Users) .Include(d => d.Users.Select(f=>f.User)) \\n``` No more hassle when saving and still the full ledge entity when loading. One caveat of this solution is that you cannot insert new association before having both of the entity already inserted.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"Entity Framework Many to Many Relationship\\\",\\\"date\\\":\\\"2015-11-23\\\",\\\"categories\\\":[\\\"entity-framework\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"a4db6042-cb99-5fc2-ad60-314bce98954d","slug":"2015/entity-framework-many-to-many-relationship","__params":{"slug":"2015"}}},
    "staticQueryHashes": ["3159585216"]}