{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-object-spread-properties",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript Object Spread Property","date":"March 15, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript Object Spread Property\",\n  \"date\": \"2017-03-15\",\n  \"categories\": [\"javascript\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you see three little dots, you saw the object spread property. This property allows to do many different operations, like the Rest one. It allows you to do merge of objects, to do shallow copy of objects, transform an array into multiple fields of an object, be used as function arguments to allow array or to assign values to an array.\"), mdx(\"h3\", null, \"Shallow Copy\"), mdx(\"p\", null, \"If you want to have a copy of all values but a different object, you can use the spread operator.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const user = { firstName: \\\"Patrick\\\", lastName : \\\"Desjardins\\\", isMarried: true }; \\nconst shallowCopy = { ...user }; \\n\")), mdx(\"p\", null, \"This will create a copy. It means that if you compare user to shallowCopy (triple equal), it won't be the same object.\"), mdx(\"h3\", null, \"Merge\"), mdx(\"p\", null, \"One of the very interesting feature of the spread operator is the capability to merge object. To do the merge, you need to create a new variable that will get assigned by a new object (curly braces) that will take the spread operator followed by the name of the object. Then, a comma with the spread operator and the second object. The new object will get all fields of the first object followed by the second object. If the second object has the same fields has the first one, then this one will override the value.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const defaultUser = { firstName: \\\"NotDefined\\\", lastName: \\\"NotDefined\\\", hasPaid: false };\\n\\nconst user = { firstName: \\\"Patrick\\\", isMarried: true }; \\nconst finalUser = { ...defaultUser , ...user }; \\n\")), mdx(\"p\", null, \"In this example, the final user first name is \\\"Patrick\\\", the last name is \\\"NotDefined\\\" and the \\\"hasPaid\\\" is false. Also, it contains the field set in the second object that wasn't set in the first one \\\"isMarried\\\" to \\\"true\\\". Like the shallow copy, this is shallow which mean that if you are limited to the object and not object of object. For example, if user has an array of object for the dependents that he may have, the list of dependencies won't get merged.\"), mdx(\"h3\", null, \"Array to object\"), mdx(\"p\", null, \"This is a shortcut to the well known trick of using apply to pass an array of parameter to a function that takes parameters. Instead of using yourFunction.apply(this, yourList) you can use yourFunction(...yourList).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function yourFunction(x:number, y:number, z:number): void { \\n  //Use variable x, y and z. \\n} \\nvar args:number[] = [0, 1, 2]; \\nyourFunction(...args); \\n\")), mdx(\"h3\", null, \"Function Parameter\"), mdx(\"p\", null, \"In the same way of \\\"array to object\\\" works, you can directly use the spread operator in the parameter. This is done by using the spread operator in front of the name of the parameter. This allow to pass parameter which will be stored into an array automatically.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function yourFunction(...x: number[]) { \\n  console.log(JSON.stringify(x)); \\n} \\nyourFunction(1, 2, 3); \\n\")), mdx(\"h3\", null, \"Destructuring\"), mdx(\"p\", null, \"This is a good scenario where you know some inputs but want to also take all other inputs that the user set into a subsequent array. For example, you know that the user can pass an array where the first parameter is the unique identifier, followed by a modified date and all other data will be new values to add. You could use the following code to have an array of data to add and two variables to manipulate into a query to save new data.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var [id, date, ...valuesToAdd] = [1, 2, 3, 4]; \\nconsole.log(id === 1); //true \\nconsole.log(date === 2); //true \\nconsole.log(valuesToAdd[0] === 3); //true \\nconsole.log(valuesToAdd[1] === 4); //true \\n\")), mdx(\"p\", null, \"We could replace \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var [id, date, ...valuesToAdd] = [1, 2, 3, 4];\"), \" by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var [id, date, ...valuesToAdd] = anotherArray;\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"anotherArray\"), \" wouldn't be affected by the operation.\"), mdx(\"h3\", null, \"Assign values to array\"), mdx(\"p\", null, \"This could also be called merging array. You take a first array, by adding it as an element with the spread operator inside the square bracket of the new array. This array element with the spread operator will transform all values of this array and make it like if you were using every values of this one as parameter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var list = [1, 2]; var list2 = [...list, 3, 4]; console.log(list); // [1,2] console.log(list2); // [1,2,3,4] \\n\")), mdx(\"p\", null, \"In this article we saw how you can use the spread property into multiple scenarios. Like any new language features, it's always important to know when to use it and to not abuse it.\"), mdx(\"iframe\", {\n    style: {\n      \"height\": \"166px\"\n    },\n    width: \"100%\",\n    height: \"166\",\n    scrolling: \"no\",\n    frameBorder: \"no\",\n    src: \"https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/312649588color=00aabbauto_play=falsehide_related=falseshow_comments=trueshow_user=trueshow_reposts=false\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"ceab2812-0a56-5603-802b-d0c09dc0e78e","totalPages":69}},
    "staticQueryHashes": ["3159585216"]}