{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/enterprise-asp-net-mvc-part-8-asp-net-cache-before-repository",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Enterprise Asp.Net MVC Part 8: Asp.Net cache before repository","date":"February 27, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Enterprise Asp.Net MVC Part 8: Asp.Net cache before repository\",\n  \"date\": \"2014-02-27\",\n  \"categories\": [\"asp-mvc\", \"asp-net\", \"enterprise\", \"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"At some point in the life of your software the performance can become an issue. If you have optimized your queries or your Entity Framework configuration, than the next step is to think about keeping some data in memory or in an external cache. This has the advantage to have the data already available.\"), mdx(\"p\", null, \"First of all, we need to have some infrastructure classes and interface because we want to have something flexible and not tightly bound to Asp.Net since this will be used in the Data Access Layer. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public interface ICacheConfiguration { bool IsActivate(); } \\n``` The first interface configures the cache. So far, to keep it simple, only one property is set. It is about its activation. Caching system must always have a possibility to be desactivated. The reason is that if your data become not what you expect that you can turn off the cache and use the main persistence. If the problem is solved, than it means that the problem is the cache. Otherwise, the problem is with the persistence or the logic that use the data. \\n```csharp\\n public interface ICacheProvider { void Set<T>(T objectToCache) where T : ICachableModel;\\n\\nvoid Set(string key, Object objectToCache);\\n\\nT Get<T>(T key) where T : ICachableModel;\\n\\nobject Get(string key);\\n\\nobject Delete(string key);\\n\\nT Delete<T>(T objectTodelete) where T : ICachableModel;\\n\\nbool IsInCache(string key);\\n\\nbool IsInCache<T>(T objectToVerify) where T : ICachableModel; } \\n``` This second interface allows you to have something in front of the technology used. You can have a memory cache, an external caching system or to have an Azure cache behind this interface.\\n\\n\\n```csharp\\n public interface ICachableModel { string GetCacheKey(); } \\n\")), mdx(\"p\", null, \"Most of the methods are defined twice. One use a string key, and the other use a ICachableModel. This interface allows to have the model class to have its logic to built its unique key.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class MemoryCache:ICacheProvider { private readonly ObjectCache cache; private readonly CacheItemPolicy defaultPolicy; private readonly ICacheConfiguration configuration;\\n\\npublic MemoryCache(ICacheConfiguration configuration) { this.configuration = configuration; this.cache = new System.Runtime.Caching.MemoryCache(Constants.Configurations.CacheNameConfiguration); this.defaultPolicy = new CacheItemPolicy(); }\\n\\npublic void Set<T>(T objectToCache) where T : ICachableModel { if (configuration.IsActivate()) { cache.Set(objectToCache.GetCacheKey(), objectToCache, defaultPolicy); } }\\n\\npublic void Set(string key, object objectToCache) { if (configuration.IsActivate()) { cache.Set(key, objectToCache, defaultPolicy); } }\\n\\npublic T Get<T>(T objectToCache) where T : ICachableModel\\n\\n{ if (configuration.IsActivate()) { return (T) cache.Get(objectToCache.GetCacheKey()); } else { return default(T); } }\\n\\npublic object Get(string key) { if (configuration.IsActivate()) { return cache.Get(key); } else { return null; } }\\n\\npublic object Delete(string key) { if (configuration.IsActivate()) { return cache.Remove(key); } else { return null; } }\\n\\npublic T Delete<T>(T objectTodelete) where T : ICachableModel { if (configuration.IsActivate()) { return (T) cache.Remove(objectTodelete.GetCacheKey()); } else { return default(T); } }\\n\\npublic bool IsInCache(string key) { if (configuration.IsActivate()) { return cache.Contains(key); } else { return false; } }\\n\\npublic bool IsInCache<T>(T objectToVerify) where T : ICachableModel { if (configuration.IsActivate()) { return cache.Contains(objectToVerify.GetCacheKey()); } else { return false; } } } \\n``` This implementation uses the System.Runtime.Caching as you can see, it also use the configuration to disable the cache. This way to proceed does not affect any of the caller code. In fact, all method return the default value when the cache does not find the value. This should tell to the called to continue with the default persistence strategy.\\n\\nThe caller should be in the Services classes if you have followed previous post about Enterprise Asp.Net MVC application.\\n\\n\\n```csharp\\n var cacheResult = (YouEntity)this.cache.Get(\\\"YouUniqueKey123\\\"); if (cacheResult == null) { var repositoryResult = yourRepository.GetYourEntity(); this.cache.Set(\\\"YouUniqueKey123\\\", repositoryResult); return repositoryResult; } else { return cacheResult; } \\n\")), mdx(\"p\", null, \"This create a simple architecture for caching. It has the flexibility to use the concrete cache you want and to have high cohesive classes. Configurations could have additional information about how many time the entity must stay in cache, the information about external cache like which IP or PORT to use for MemCached for example.\"), mdx(\"h3\", null, \"Series Articles\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-part-1-mvc-the-planification\"\n  }, \"Article #1: Asp.Net MVC Enterprise Quality Web Application\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-2-building-the-model\"\n  }, \"Article #2: Asp.Net MVC Enterprise Quality Web Application Model\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-3-controller\"\n  }, \"Article #3: Asp.Net MVC Enterprise Quality Web Application Controller\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-4-repository\"\n  }, \"Article #4: Asp.Net MVC Enterprise Quality Web Repository Layer\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-5-database-context-and-impersonate-data\"\n  }, \"Article #5: Asp.Net MVC Enterprise Quality Web with Entity Framework\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-6-the-three-layers-of-validation\"\n  }, \"Article #6: Asp.Net MVC Enterprise Quality Layers\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-7-securing-action-with-role-authorization\"\n  }, \"Article #7: Asp.Net MVC Enterprise Quality Web Security\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"55cdbfa8-a4e1-5215-ac5b-e50483e43e12","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}