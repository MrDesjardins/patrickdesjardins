{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/c-using-statement-inside-or-outside-the-class-namespace",
    "result": {"data":{"mdx":{"frontmatter":{"title":"C# Using Statement Inside or Outside the Class Namespace","date":"November 10, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"C# Using Statement Inside or Outside the Class Namespace\",\n  \"date\": \"2014-11-10\",\n  \"categories\": [\"c-sharp\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \".Net works with library that you can reference in the projet and then use in any code file. The keyword \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"using\"), \" is the one to use inside the C# file to be able to use classes from an external library or a different namespace from the one the code belong in the file. Of course, if you do not want to use the using statement, you can when using a class from another namespace specify the name with the whole namespace path.\"), mdx(\"p\", null, \"For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var x = new OtherLibrary.OtherNameSpace.Xyz.TheClass(); \\n\")), mdx(\"p\", null, \"Having the whole namespace in the code can become cumbersome. This is why the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"using\"), \" statement exist. By default, the using is at the top of the file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"using System; namespace MyNameSpace {\\n\\npublic class MyClass { //... } } \\n\")), mdx(\"p\", null, \"But this could also be different by having the System namespace directly inside the namespace. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"namespace MyNameSpace { using System; public class MyClass { //... } } \\n\")), mdx(\"p\", null, \"But what is the difference? The difference is the priority of how the .Net will use external dependencies. The priority is to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"using\"), \" inside the namespace and then to the one of the file. This is why having the using inside the namespace can be more safe in a way that you can be sure that no other library can hijack a namespace and break your code. For example, you could create a class named Math, and still be in your namespace and having this one be used instead of System.Math. But, to remove this possibility, if you set \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"using System;\"), \" inside your namespace than you are sure to have the real Math class to be used (or to have a conflict during compilation file if both are explicitly marked with using).\"), mdx(\"p\", null, \"A rule of thumb is to set the using inside your namespace, this way you have less chance of having a behavior that you do not expect. If you want to change the default behavior of Visual Studio when you are creating a new class or interface, you need to go to the template folder and edit the class and interface template. This folder is for Visual Studio 2013 inside Program File under the Common7 folder. Here is my path which is the default installation path of Visual Studio 2013.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"C:\", \"\\\\\", \"Program Files (x86)\", \"\\\\\", \"Microsoft Visual Studio 12.0\", \"\\\\\", \"Common7\", \"\\\\\", \"IDE\", \"\\\\\", \"ItemTemplates\", \"\\\\\", \"CSharp\", \"\\\\\", \"Code\", \"\\\\\", \"1033\")), mdx(\"p\", null, \"If you are using ReSharper, you can also modify the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Code Editing\"), \" > \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"C#\"), \" \", \">\", \" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Formatting Style\"), \" > \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Namespace Imports\"), \". You can select \\\"Add Using directive to the deepest scope\\\" and you will have your using inside the namespace when you clean full format.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"e6d584c7-3863-56cf-a264-947c04d2d84c","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}