{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-index-signature-dynamic-properties",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript Index Signature Dynamic Signature Property with version 4.4","date":"January 14, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript Index Signature Dynamic Signature Property with version 4.4\",\n  \"date\": \"2022-01-14\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"JavaScript as a way to key-value in a dictionary/map way that is very flexible. It works by using a string for the name of the property, and then you can assign a value. TypeScript is providing type association to the value, but before 4.4 you could not.\"), mdx(\"p\", null, \"We can summarize what was possible before TypeScript version 4.4 with index signature with the following example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface KeyValue {\\n  [k: string]: string; // Very wide\\n}\\n\")), mdx(\"p\", null, \"As it appears, you can specify the key to be a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" or a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \" but not specific other names. Concerning the value, it could be anything. You could still write a specific key by directly writing the name. In the following example, we accept any number or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"test\\\"\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface KeyValue {\\n  [k: number]: string; // Allows any key as a number\\n  [\\\"test\\\"]: string; // Allows the key \\\"test\\\"\\n}\\nconst kv1: KeyValue = {\\n  1: \\\"good\\\",\\n  \\\"test\\\": \\\"sure\\\"\\n};\\n\")), mdx(\"p\", null, \"What is new with TypeScript version 4.4 is defining a pattern instead of being widely open to accept any string or specify the exact string. A use case is with HTML where there is a known set of attribute but also the standard allows anything with a prefix of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data-\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface HtmlAttributes {\\n  color?: string;\\n  left?: number;\\n  top?: number;\\n}\\n\\ninterface DivHtmlAttributes extends HtmlAttributes {\\n  [other: `data-${string}`]: unknown;  \\n}\\n\\nlet myDiv: DivHtmlAttributes = {\\n  color: \\\"red\\\",\\n  \\\"data-blah\\\": true\\n};\\n\")), mdx(\"p\", null, \"The syntax might not be something that you are naturally using to define a type. It relies on the backticks with the string you desire to be required and between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${}\"), \" the dynamic portion type; in that case, it is a string.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"ed4727bb-43f6-5e2e-9a9e-ee99ed194366","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}