{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/entity-framework-5-0-and-timespan-type",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Entity Framework 5.0 and Timespan type","date":"October 22, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Entity Framework 5.0 and Timespan type\",\n  \"date\": \"2012-10-22\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Entity Framework version 5, like its previous version doesn't map timespan. The following error will raise when you try to.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"There is no store type corresponding to the conceptual side type 'Edm.Time(Nullable=True,DefaultValue=,Precision=)' of primitive type 'Time'.\")), mdx(\"p\", null, \"I thought that Entity Framework 5 was able with SQL Server 2008 R2 to map Timespan to Time. I was wrong. However, theirs a work around.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public Int64 TimeBetweenExercicesTicks{ get; set; }\\n\\n[NotMapped] \\npublic TimeSpan TimeBetweenExercices { \\n  get { return TimeSpan.FromTicks(TimeBetweenExercicesTicks); } \\n  set { TimeBetweenExercicesTicks= value.Ticks; } \\n} \\n\")), mdx(\"p\", null, \"First, you should want to still use in your code the TimeSpan type because it's convenient to manipulate time. But, on the other side Entity Framework doesn't map the type. Fortunately, we can map the ticks and simply ignore the property with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeSpan\"), \" type.\"), mdx(\"p\", null, \"The example above shows you this scenario where an entity required to have the time between two exercices. In fact, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeBetweenExercices\"), \" is not mapped to the database but the underlying property TimeBetweenExercicesTicks. Since an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Int64\"), \" can be mapped and that we do not loss any precision by converting ticks to/from timespan, that we can use this time.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"3ad15ee8-2b4f-55b1-a1b9-7647642ffb78","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}