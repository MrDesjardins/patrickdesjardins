{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/dissecting-the-createstore-of-redux",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Dissecting the createStore of Redux","date":"January 30, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dissecting the createStore of Redux\",\n  \"date\": \"2018-01-30\",\n  \"categories\": [\"redux\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Creating a store in Redux is something at the core of the experience of the framework. In most cases, developers use the createStore function to specify the list of reducer and enhancer (middleware). In this article, we will see what is really happening when calling the function.\"), mdx(\"p\", null, \"First of all, it's important to know that this function can take two or three parameters even if it's mostly used with two. The first four lines of the function handle the situation. If you pass two parameters the second parameter will be the list of enhancers. If you use three parameters, the third one is the list of enhancers and the second parameter is the default state. In my opinion, this is an error of conception and the second and third parameters should be inverted which would remove the gymnastics required. The next validation is to make sure that the enhancer is a function. I said \\\"list of enhancers\\\" but it takes a function, how so? Has described in the previous article about the dissection of the compose method, Redux work with functions that call functions in a chain. Enhancers work this way as well. So, it means that to pass a collection of enhancer, you will need to compose them. This will give the capability to Redux to call the first method with a parameter and have the information pass through the list.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export default function createStore(reducer, preloadedState, enhancer) { \\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') { \\n    enhancer = preloadedState;\\n    preloadedState = undefined;\\n  }\\n\\n  if (typeof enhancer !== 'undefined') { \\n    if (typeof enhancer !== 'function') { \\n      throw new Error('Expected the enhancer to be a function.') \\n    }\\n\\n    return enhancer(createStore)(reducer, preloadedState) \\n  } \\n  // ... function keeps going but cut for brevity \\n\")), mdx(\"p\", null, \"The function is quite big, therefore I cut it down for the moment. The last line above is invoking recursively the createStore function has a parameter. However, this time the enhancer function is invoked by the enhancer. As we just mention, the enhancer is a function that calls another function and so on to finally come back and actually return the store which is the remaining of the function that we will see soon. However, before moving on the rest of the function, let's settle few things. The enhancer role is similar to a middleware which is to be a sequence of function to modify a behavior of Redux. However, this one goal is to modify the store. The most popular one is applyMiddleware which we will discuss later. applyMiddleware is a store enhancer. It enhances the store by providing a way to hook middleware between dispatch of action the reducer.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const store = createStore( reducer, compose( applyMiddleware(thunk), DevTools.instrument() ) ) \\n\")), mdx(\"p\", null, \"The code above should be familiar. The first parameter is the reducer and the second one is the store enhancer which contains two stores enhancer: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Devtool.instrument\"), \".\\nLet's continue the dissection of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createStore\"), \" function. Before going any further, the code validates that reducer is a function. Once again, reducers are also composable function! Which mean that every reducer will call each of them in sequence. \"), mdx(\"p\", null, \"There are some variables that hold all reducers, the list of listeners and the state. The reducers list is required since everytime something will be dispatched, the action must go through the list. The list of listeners is used to inform any changes and the state is the final state at the end of a loop through all the reducers.\\nThe getState function lets you have access to Redux state, the subscribe method allows subscription to get notified when changes happen. Most React developer use the React-Redux package that subscribes beneath the scene and it renders the attached React control for you. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"\\n  if (typeof reducer !== 'function') { \\n    throw new Error('Expected the reducer to be a function.') \\n  }\\n\\n  let currentReducer = reducer;\\n  let currentState = preloadedState ;\\n  let currentListeners = [];\\n  let nextListeners = currentListeners;\\n  let isDispatching = false;\\n\\n  function getState() { \\n    return currentState; \\n  }\\n\\n  function subscribe(listener) { \\n    // Removed for brevity \\n  }\\n\\n  function dispatch(action) { \\n    // Removed for brevity \\n  }\\n\\n  if (typeof action.type === 'undefined') { \\n    throw new Error( 'Actions may not have an undefined \\\"type\\\" property. ' + 'Have you misspelled a constant?' );\\n  }\\n\\n  if (isDispatching) { \\n    throw new Error('Reducers may not dispatch actions.');\\n  }\\n\\n  try { \\n    isDispatching = true;\\n    currentState = currentReducer(currentState, action);\\n  } finally { \\n    isDispatching = false;\\n  }\\n\\n  const listeners = currentListeners = nextListeners \\n  for (let i = 0; i < listeners.length; i++) { \\n    const listener = listeners[i];\\n    listener(); \\n  }\\n\\n  return action;\\n} \\n\")), mdx(\"p\", null, \"Finally, the dispatch method calls currentReducer(currentState, action) which is a pointer to the first reducer functions that will call one after the other each composed function with the current state and action. This is why reducers have the signature:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function yourReducer(state = initialState, action) { \\n  // Reducer logic here return state \\n} \\n\")), mdx(\"p\", null, \"The dispatch method invokes all listener to be notified. That's it. The last detail around this method is how is constituted a store enhancer. We can deduct from how it's invoked that the function takes in parameter a single argument which is the createStore function itself which is a function that returns the store object we just analyzed. The enhancer lets you alter everything about the store. In this article, we saw that createStore function lets you create a basic store which is a bare function that accepts subscribers that are triggered when the dispatch method is called. Between the invocation of dispatch and the notification, it calls a reducer function (that can be composed). This is it! In the next article, we will see the store enhancer called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \" which is an enhancer that brings the notion of middleware in Redux.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"0e0f974c-e1b9-52e2-a1a0-9ac40983b0f9","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}