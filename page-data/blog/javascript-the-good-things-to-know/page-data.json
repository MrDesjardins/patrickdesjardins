{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/javascript-the-good-things-to-know",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript The Good Things to Know","date":"October 31, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript The Good Things to Know\",\n  \"date\": \"2014-10-31\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Null and array\"), mdx(\"p\", null, \"The type \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \" or the type \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"array\"), \" are in fact of type object. You can verify this by using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"typeof\"), \". \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"console.log(typeof(null)); \\nconsole.log(typeof([1,2,3]); \\n\")), mdx(\"h2\", null, \"Variables Name\"), mdx(\"p\", null, \"Variables name can have illegal character if used with quote when defined. For example, you can use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"numeric\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"alphanumeric character\"), \" with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"underscore\"), \" but you cannot use directly a dash for example. The variable name this-is-illegal is not legal but if you define your object with the property name \\\"this-is-illegal\\\" it works. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var yourObject = { \\\"this-is-illegal\\\":\\\"but it works because of the quote\\\", this_is_legal : \\\"and does not require quote\\\" }; \\n\")), mdx(\"p\", null, \"Even if the illegal character can be by-passed by the first approach, using quote, it is not recommended to write you code this way. Retreving the value require to use the array notation instead of the dot notation. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var v1 = yourObject[\\\"this-is-illegal\\\"]; //instead of var v1 = yourObject.this_is_legal; \\n\")), mdx(\"h2\", null, \"arguments variable\"), mdx(\"p\", null, \"Every function can access the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"arguments\"), \" keyword. This variable is not an official JavaScript array (lack of Array method) but can access every elements with the square bracket.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function add(a,b) { return a + b; // or return arguments[0] + arguments[1]; } \\n\")), mdx(\"p\", null, \"But this goes far beyond that. You can define your function to not have any arguments and use it with multiple arguments. The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"arguments\"), \" variable will hold all arguments passed to the function and not only those officially specified.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function add() { \\n  var index var sum = 0; \\n  for (index = 0; index < arguments.length; index += 1) { \\n    sum += arguments[index]; \\n  } \\n  return sum \\n} \\nvar result = add(1,2,3,4,5); // 15 \\n\")), mdx(\"h2\", null, \"Default Initialization\"), mdx(\"p\", null, \"If you are not sure if a variable has already been initialized you can use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"|| operator\"), \" to check and assign. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var variableWithValueForSure = anotherVariable.variable1 || \\\"defaultValue\\\"; \\n\")), mdx(\"p\", null, \" What it does is that it check if the first expression returns \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"undefined\"), \". If it is undefined, than this one return \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"false\"), \". Since it returns \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"false\"), \", the next expression is evaluate which set the value. In the case it is not \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"undefined\"), \", this one return not \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"true\"), \" but the value directly. This is why, often in JavaScript we see the same variable doing this trick to itself to be sure that it is defined. The next example ensures that the variable \\\"me\\\" is defined and not undefined. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var me = me || {}; \\n\")), mdx(\"h2\", null, \"Object and Dynamic Variables\"), mdx(\"p\", null, \"It is possible to add variables at anytime with JavaScript. You just need to set a value to have the variable defined inside your object. This is also true for functions. ```typescript\\nvar obj = { variable1 : 1 }; obj.newVariable = 2; //newVariable is added to the object obj \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\n## References is used not copy\\n\\nEvery time you set an existing object to another variable this one pass its reference. This is true for function parameters but also for variable inside a function. \\n```typescript\\nvar x1 = x2; //x1 and x2 are the same now \\nx2.v1 = 'value1'; //x1.v1 is also at 'value1' \\n\")), mdx(\"h2\", null, \"Prototype\"), mdx(\"p\", null, \"Prototype is the concept in JavaScript that allow you to share information through different object of the same type. When calling a function or variable on an object, if this one does not find the function or variable it go check if it can find it in its prototype. If it does not find it it goes to the prototype of the prototype and so on until it reach object.prototype. If nothing is found, it return \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"undefined\"), \".\"), mdx(\"h2\", null, \"hasOwnProperty\"), mdx(\"p\", null, \"If you want to loop your object proprety (variables and functions) than you will stumble into prototype properties which you may not want to see. If you want to see only method that you have defined for the object and not those ones from the prototype you must use the function \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"hasOwnProperty('propertyToCheck')\"), \". \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var propertyName ; \\nfor (propertyName in yourObject) { \\n  if (yourObject.hasOwnProperty(propertyName])) { \\n    //Do what you want with the property that is inside YourObject and not inside the its prototype \\n  } \\n} \\n\")), mdx(\"p\", null, \"We used the for in statement to loop through all properties. This give us property in an non-specific order. If you want to have properties in the order defined in the code you must use a for with a integer that loop every properties in an array.\"), mdx(\"h2\", null, \"Delete keyword\"), mdx(\"p\", null, \"Using delete can remove a property. For example, if you define a property named \\\"prop1\\\" and you execute delete on it, this one will return undefined exepted if the prototype has a \\\"prop1\\\" method. Because of the nature of the prototyoe\"), mdx(\"h2\", null, \"Adding Method to Prototype\"), mdx(\"p\", null, \"You can add methods to an object with the prototype. You just need to use the prototype keyword after the type you want to enhance. The example below add a trim method to any string. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"String.prototype['trim'] = function () { \\n  return this.replace(/^\\\\\\\\s+|\\\\\\\\s+$/g, ''); \\n}; // This add the trim method to all String type. \\n\")), mdx(\"h2\", null, \"Variables Declaration\"), mdx(\"p\", null, \"In JavaScript it is better to define variable in the beginning of the function instead of the best practice that suggest to declare the variable the nearest of its use. The reason is that JavaScript scope works differently than other languages. JavaScript variables defined in a scope can access others variables outside its scopes. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var Program = function() { \\n  var var1 = 1; \\n  var Program2= function() { \\n    var1 = var1 + 1; // This can access var1 function which is not the case in other scoped language.\\n  } \\n  Program2(); // Call f2 function \\n  //The value of var 1 is 2; \\n} \\n\")), mdx(\"p\", null, \" For example, this does not work in C#: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"\\nclass Program { \\n  private int a;\\n\\n  private class Program2 { \\n    public Program2() {\\n       a = a + 1; // Do not compile \\n    } \\n  } \\n} \\n\")), mdx(\"h2\", null, \"Apply Keyword\"), mdx(\"p\", null, \"You can call any function with by following this function with the method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"apply\"), \". This one takes two parameters. The first one is the value you want to set to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \" for the method you call. The value can be set to null if you do not want to pass a value to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \" of the function. The second parameter is an array. This array are converted into the function parameter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function add(a,b) { return a + b; } \\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"//Can be called this way: \\nvar result1 = add(1,2); //3 \\n//or \\nvar result2 = add.apply(null,[1,2]); //3 \\n\")), mdx(\"h2\", null, \"Exceptions\"), mdx(\"p\", null, \"You can throw exception and catch them. The exception throw an object you want. You can use any thing. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"throw {name: 'Error Name', message : 'message you want'}; \\n\")), mdx(\"p\", null, \" Thrown statement are read by catch block. If you want to catch multiple exception, than you must do a if statement on a property you want, for example the name. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"try { \\n throw {\\n   name: 'StackOverFlow', message : 'message you want'\\n   }; \\n} catch(e) { \\n if(e.name === 'StackOverFlow') { \\n   console.log('***' + e.name + ': ' + e.message + '***'); \\n } \\n console.log(e.name + ': ' + e.message); \\n} \\n\")), mdx(\"h2\", null, \"Chaining Calls\"), mdx(\"p\", null, \"It is always good to return the this keyword if your method return nothing. This allow to do chaining calls. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var Human= function() { \\n  this.name = 'Not Defined'; \\n  this.gender = 'm'; \\n};\\n\\nHuman.prototype.setName = function(name) { \\n  this.name = name; \\n  return this; \\n};\\n\\nHuman.prototype.setGender = function(gender) { \\n  this.gender = gender; \\n  return this; \\n}; \\n\")), mdx(\"p\", null, \"This allow us to chain because every function return the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \" reference. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var patrick = new Humain() \\n  .setName('patrick') \\n  .setGender('male'); \\n\")), mdx(\"h2\", null, \"Javascript Encapsulation with Closure\"), mdx(\"p\", null, \"JavaScript provides Encapsulation with something named \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Closure\"), \". Since everything in JavaScript uses function, this one too. The principle of closure is to encapsulate every variables and methods into a cohesive function. This allow us to scope what is private to the object from what is public. It is very similar to object oriented class. Private methods and variables are not returned by the closure while public methods and variable are. Let's start with an example to demystify the concept of closure. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var referenceToTheObject = (function () { \\n  var privateVariable = 0; \\n  return { publicMethod1: function () { } ,\\n  publicMethod2: function () { } \\n  }; \\n}()); \\n\")), mdx(\"p\", null, \"This is interesting because in fact, we are invoking an anonymous function (see the line before the last one). This function return an object with two public functions. As you must know now, these function can call any methods and variables in their outer scope. This mean that both public method can call each others but also the private variable. The private variable is not reachable outside the anonymous function because it is not returned by the anonymous function.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"c47c31cf-305f-5d2a-a6c9-d909433b84ed","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}