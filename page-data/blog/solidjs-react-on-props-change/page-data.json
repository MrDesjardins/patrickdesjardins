{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/solidjs-react-on-props-change",
    "result": {"data":{"mdx":{"frontmatter":{"title":"SolidJS: How to React on Property Change","date":"March 7, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"SolidJS: How to React on Property Change\",\n  \"date\": \"2022-03-07\",\n  \"categories\": [\"solidjs\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this article, we will show a couple of ways to react to a change of property with SolidJS. There are many types of reactions:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We can recompute another variable. For example, a value is built upon a property.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We can execute code. For example, clearing a list or a canvas.\")), mdx(\"h1\", null, \"Derived Signal\"), mdx(\"p\", null, \"The first case is called a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.solidjs.com/tutorial/introduction_derived\"\n  }, \"derived signal\"), \". It is a well-documented case where you have a computed value that depends on another. However, the documentation is around derived signals and not props. But, the reality is that it behaves the same way hence the same mindset should be observed. By that, the derived value will automatically be recomputed when the property changes.\"), mdx(\"p\", null, \"If we use an example with a single component that passes a single property, we can change the name every second.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface HelloWorldProps {\\n  name: string;\\n}\\n\\nconst HelloWorld = (props: HelloWorldProps) => {\\n  return <h1>Hello, {props.name}!</h1>;\\n};\\n\\nconst names = [\\\"World\\\", \\\"Test\\\", \\\"You\\\"];\\nconst App: Component = () => {\\n  const [index, setIndex] = createSignal(0);\\n  onMount(() => {\\n    const id = setInterval(() => {\\n      setIndex((prev) => {\\n        return prev + 1;\\n      });\\n    }, 1000);\\n    onCleanup(() => clearInterval(id));\\n  });\\n  return <HelloWorld name={names[index() % names.length]} />;\\n};\\n\\nrender(() => <App />, document.getElementById(\\\"app\\\"));\\n\")), mdx(\"p\", null, \"A derived property could be added in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HelloWorld\"), \" component.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const HelloWorld = (props: HelloWorldProps) => {\\n  const derivedName = () => `[${props.name}]`;\\n  return <h1>Hello, {derivedName()}!</h1>;\\n};\\n\")), mdx(\"p\", null, \"In this example, the component will have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"derivedName\"), \" function called every time the property is changing. However, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HelloWorld\"), \" itself is rendered only once. For example, writing this variation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const HelloWorld = (props: HelloWorldProps) => {\\n  console.log(\\\"HelloWorld Rendered\\\");\\n  const derivedName = () => {\\n    console.log(\\\"Derived Name Called\\\");\\n    return `[${props.name}]`;\\n  };\\n  return <h1>Hello, {derivedName()}!</h1>;\\n};\\n\")), mdx(\"p\", null, \"The console output looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"HelloWorld Rendered \\nDerived Name Called (67 times)\\n\")), mdx(\"p\", null, \"So, the function is not re-created every second; only the function is called because it derives from the changing property.\"), mdx(\"h1\", null, \"Executing code\"), mdx(\"p\", null, \"In the previous case, we were computing a value, but what if you need to execute a piece of code if the a property change? Similar to React, it is possible using an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"effect\"), \". With SignalJS, we need to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createEffect\"), \". What is excellent and confusing if you are coming from React Hooks, is that you do not need to explicitly specify in the creation of the effect which variable to look at. SolidJS framework handles the reactivity based on what is being used within the effect.\"), mdx(\"p\", null, \"For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"createEffect(() => {\\n  document.bgColor = document.bgColor === \\\"red\\\" ? \\\"white\\\" : \\\"red\\\";\\n});\\n\")), mdx(\"p\", null, \"The background will flip to red since the effect will be executed once when the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HelloWorld\"), \" is rendered (first execution of the component). What if we want to change the color every time the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props.name\"), \" change? For that, we need to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"use\"), \" the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props.name\"), \" inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createEffect\"), \". For example, adding a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log\"), \" using the property causes the SignalJS framework to know about the property. And, every change of the property must run the effect and hence make the color swap.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"createEffect(() => {\\n  console.log(props.name); // Make the createEffect to be called at every change of the property \\\"name\\\"\\n  document.bgColor = document.bgColor === \\\"red\\\" ? \\\"white\\\" : \\\"red\\\";\\n});\\n\")), mdx(\"p\", null, \"So, there is a caveat here, what if we want to change the background without using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log\"), \"? Removing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log\"), \" makes the component renders once, as we saw earlier. So, you can cheat your way to use the variable without assigning.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"createEffect(() => {\\n  props.name; // Make the effect to depend on the property\\n  document.bgColor = document.bgColor === \\\"red\\\" ? \\\"white\\\" : \\\"red\\\";\\n});\\n\")), mdx(\"p\", null, \"However, there is an utility function that can be used that make the code cleaner.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"  createEffect(\\n    on(\\n      () => props.name,\\n      () => {\\n        document.bgColor = document.bgColor === \\\"red\\\" ? \\\"white\\\" : \\\"red\\\";\\n      }\\n    )\\n  );\\n  return <h1>Hello, {derivedName()}!</h1>;\\n};\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on\"), \" function takes a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"function\"), \" that returns the property you want to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"watch\"), \". In that example, the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"() => props.name\"), \" cause the effect to be evaluated every time the reference of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" is changing. The second function of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on\"), \" is the code you would put directly in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createEffect\"), \". For one rare time, SolidJS is more complex than React, and the documentation about \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on\"), \" covers the case of a signal, not props which is confusing.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"You can find all the code in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codesandbox.io/s/solidjs-props-5omf9f?file=/src/index.tsx:393-551\"\n  }, \"CodeSandBox.io\"), \". SolidJS offers simplicity by removing the burden of using a Linter to avoid stale data in React by analyzing what is used within the body of the effect or by being smart enough to update the derivative function. The simplicity comes with the caveat that you may expect an effect to be called but it won't. For example, if you debug and use property in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log\"), \", the effect will suddenly behave differently. Or, if you remove the line in the last example that does nothing to the property, you will end up with a stale background color instead of an alternating one.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"5bbbd5aa-7fce-5e0c-a8fc-cfbbb60a061d","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}