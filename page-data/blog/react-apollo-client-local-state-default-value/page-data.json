{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/react-apollo-client-local-state-default-value",
    "result": {"data":{"mdx":{"frontmatter":{"title":"React Apollo Client Local State with Default Value on Fragment","date":"February 2, 2023"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"React Apollo Client Local State with Default Value on Fragment\",\n  \"date\": \"2023-02-02\",\n  \"categories\": [\"react\", \"apollo\", \"graphql\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The best approach is to rely on the local state if you need to add additional value to an existing GraphQL entity from your GraphQL server. Apollo has several patterns, and in this article, I am showing how to use the local state using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InMemoryCache\"), \" and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"writeFragment\"), \" method.\"), mdx(\"h1\", null, \"When to use the GraphQL Apollo Local State?\"), mdx(\"p\", null, \"The main reason to add a local state to the GraphQL Apollo is to attach information not needed on the server but needed on the client side. The main justification to use the GraphQL Apollo local state instead of a variable or a React's state is to still impacts all queries on your client side on value change. The concept is you are attaching a new \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"field\"), \" on one of your GraphQL entities (defined by the GraphQL server). By using the GraphQL client, if the local state change, a trigger to render all React hooks that use that entity occurs -- similar to if a refetch data or a new query comes with a response that alters an entity. Hence, if you change the value of the local state you can ensure the user interface updates. Furthermore, because it uses the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InMemoryCache\"), \" of GraphQL, the local state is normalized inside the Apollo storage. Thus, you do not have to manage duplication if the entity is used on several queries.\"), mdx(\"p\", null, \"For example, if you have an entity called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Movie\"), \" and want to add a property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isStreaming\"), \" that indicates if the movie is playing or not. You may not want that information persisted on the server and only on the client side. However, if you change that boolean value from one value to another, you want the user interface to render differently. Using a state might work, but once you have a collection of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Movie\"), \", the object used in many React components will be complicated to keep in synchronization. Thus, having it in a single place and being reactive to change is an elegant solution.\"), mdx(\"p\", null, \"I recommend using Apollo local state only for information that strongly depends on the property type you add. Otherwise, another alternative, like client-side state management (for example, Redux) or to have a component state (for example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \") is less entangled.\"), mdx(\"h1\", null, \"Step to Add a Field to a Type\"), mdx(\"h2\", null, \"Modifying your GraphQL Schema\"), mdx(\"p\", null, \"The first step to adding your new piece of data is to include the field in your GraphQL schema. In my case, I have a generated server-side unified file that has all the types of the GraphQL server. To keep the server-side schema separated, the best is to define a separate GraphQL file (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".graphql\"), \") for the local state. After that, specifying the exact type again is tolerated. The re-defined type only needs the local fields. Apollo will merge all types even if defined multiple types.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\"\n  }, \"type Movie {\\n  isStreaming: Boolean!\\n}\\n\")), mdx(\"p\", null, \"In our example, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Movie\"), \" type has many fields, but we only define the local state field in this new file.\"), mdx(\"p\", null, \"Then, you need to go into the fragment (or query) where you are fetching the field and add the new field to be fetched. The need of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@client\"), \" is required. It indicates that the field is not on the server.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\",\n    \"metastring\": \"{4}\",\n    \"{4}\": true\n  }, \"fragment MovieFragment on Movie {\\n  id\\n  title\\n  isStreaming @client\\n}\\n\")), mdx(\"h2\", null, \"Modifying your CodeGen Configuration File\"), mdx(\"p\", null, \"If you are using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://the-guild.dev/graphql/codegen/docs/integrations/apollo-local-state\"\n  }, \"The Guild CodeGen\"), \", there is an easy way for the generator to include the local state field. First, you must add a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schema\"), \" to your local GraphQL file you did in the previous step. That's it. Second, you auto-generated TypeScript. Now, the output will have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isStreaming\"), \" field but will not query the field in the auto-generated \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gql\"), \" statement.\"), mdx(\"h2\", null, \"Default Value\"), mdx(\"p\", null, \"Any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" that asks for your fragment (or query) that has the field will now fetch the data but still, need a default value for these fields. Until the value is written explicitly by you (we will cover that in a few), the value is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \". To define a default value, you must change the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InMemoryCache\"), \" to add a policy for your GraphQL type.\"), mdx(\"p\", null, \"The concept is that you can determine how each field behaves in reading and writing. In that case, we specify our field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"read\"), \" property to return \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" if the field is new (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \"). Otherwise, it returns the value determined by us.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\",\n    \"metastring\": \"{10}\",\n    \"{10}\": true\n  }, \"// Snip...\\nnew ApolloClient({\\n  link: // Snip,\\n  cache: new InMemoryCache({\\n    typePolicies : {\\n      Movie: {\\n        fields:{\\n          isStreaming :{\\n            read(existingValue) {\\n              return existingValue ?? false;\\n            }\\n          }\\n        }\\n      }\\n    }\\n  });\\n\")), mdx(\"h2\", null, \"Updating the Value\"), mdx(\"p\", null, \"The last step is to update the value locally. A change should not generate a GraphQL mutation because the field is unknown to the server. However, we want to have the same effect: on change it impacts everywhere the field was used. In our case, every React component that relies on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MovieFragment\"), \" must be updated for a new render.\"), mdx(\"p\", null, \"There are a few options; the one I prefer relies on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"writeFragment\"), \" because its foundation is the same as the data from the server. The method does not rely on external reactivity systems or third-party state management tools. It is also a single instruction using the Apollo Client.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"// Snip\\nconst client = useApolloClient();\\n// Snip\\nclient.writeFragment({\\n  id: `${existingEntity.__typeName}:${existingEntity.id}`,\\n  fragment: MovieFragmentDoc,\\n  data: {\\n    ...existingMovie,\\n    isStreaming: true,\\n  },\\n});\\n\")), mdx(\"p\", null, \"The example above shows how to set the value to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \". Few details that are critical to have the mechanism working:\\nThe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" field must have the format of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<entity name>:<entity id>\"), \". You can write it the way I did, which works for every type.\\nPass the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fragment\"), \", which is a breeze if you are using CodeGen since it has it for you auto-generated.\\nYou pass the object with the value that you want to give.\\nYou must pass a complete object; hence take the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"existingMovie\"), \" coming from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" from your component.\"), mdx(\"p\", null, \"When this line is executed, if you have a breakpoint to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"read\"), \" function defined in this article, you will break the amount of time the field is used across your application to evaluate the value of the changing field. Exactly what we want.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"The documentation around this feature is present but needs clarification about the default value and how to ensure the field is updated. Also, I have not seen any mention of leveraging The Guilt Code Generator. I hope this article helps some of you.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"5d622279-c20c-57fe-ae67-92e89e47c82c","totalPages":75}},
    "staticQueryHashes": ["3159585216"]}