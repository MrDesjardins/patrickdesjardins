{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/simple-pattern-to-use-highchart-and-react",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Simple Pattern to use Highchart and React","date":"June 12, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Simple Pattern to use Highchart and React\",\n  \"date\": \"2018-06-12\",\n  \"categories\": [\"react\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"At the time I am compositing this entry, Highchart doesn't collaborate naturally in a React project. There is an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/kirjs/react-highcharts\"\n  }, \"open source project\"), \" available but it is not part of the official release. However, using directly the library from Highchart into your TypeScript and React project is not a huge burden. In this article, we will see how to create a React component that uses Highchart.\"), mdx(\"p\", null, \"The first step is to get the official library and the definition file. The types are not in the main repository and are a major version late. However, it was enough in my experience to work. You need to NPM install \\\"highcharts\\\" and \\\"@types/highcharts\\\".\"), mdx(\"p\", null, \"You will need to create a new TSX file and import one or many packages. The number of packages depends on what you want to do with HighChart. If you need to use the exporting capability, you will need to import an additional module. If you need the offline flavor of exporting, you will need also to import a package. For the completeness of the example, let's get them all.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import Highcharts, { CSSObject, Options, SeriesObject, PlotBands } from \\\"highcharts\\\"; \\nimport Exporter from \\\"highcharts/modules/exporting\\\"; \\nimport OE from \\\"highcharts/modules/offline-exporting\\\"; \\n\")), mdx(\"p\", null, \"The Exporting and OE are functions. They must be applied to the HightCharts function right below you imports. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"Exporter(Highcharts); \\nOE(Highcharts); \\n\")), mdx(\"p\", null, \"The next step is to create a React component that will have a componentDidUpdate, a render, and a componentDidMount. Also, the component must have one reference to Highchart and one other reference to the HTML container. The container may be used for adding dynamic animation with CSS and also to indicate where to inject the Highchart component. The Highchart component reference will be used to push data or user's options during the lifetime of the component. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"private hightChartContainer: HTMLDivElement | null = null; \\nprivate highChartControl: Highcharts.ChartObject | undefined = undefined; \\n\")), mdx(\"p\", null, \"The render function creates the container that hosts the Highchart control.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"public render(): JSX.Element { \\n  const isChartVisible = this.props.source.graphData !== undefined; \\n  const chart = <div style={{ display: (isChartVisible ? \\\"block\\\" : \\\"none\\\") }} ref={(div) => { this.hightChartContainer = div; }} />; \\n  return <> <div \\n    style={{ display: (isChartVisible ? \\\"none\\\" : \\\"flex\\\"), }}> Loading your data \\n    </div> {chart} \\n  </>; } \\n\")), mdx(\"p\", null, \"The render will be executed once and then the componentDidMount function is executed once as well. Meanwhile, the componentDidMount function does the heavy lifting by instantiating the Highchart component. In reality, this function is way bigger than what I am providing. It contains all the configuration you can apply to a Highchart.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"public componentDidMount() { \\n  const that = this; \\n  if (this.hightChartContainer !== null) { \\n    Highcharts.setOptions(theme); \\n    const options: Options = { \\n      chart: { \\n        type: \\\"line\\\", }, \\n      series: [], \\n      }; \\n    this.highChartControl = Highcharts.chart(this.hightChartContainer, options); \\n    if (this.props.source.graphData !== undefined) { \\n      this.componentDidUpdate(); \\n    } \\n  } \\n} \\n\")), mdx(\"p\", null, \"Finally, the componentDidUpdate has the role to push the values to the chart. The componentDidMount sets the series to an empty array because the data might not yet be available. However, the componentDidUpdate will be called every time new properties change which make it a good place to update the chart.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"public componentDidUpdate() { \\n  if (this.hightChartContainer !== null && this.highChartControl !== undefined && this.props.source.graphData !== undefined) { \\n    const data = this.props... // Get your data \\n    const series: GraphData[] = []; \\n    while (this.highChartControl.series.length > 0) { \\n      this.highChartControl.series[0].remove(false); \\n    }\\n\\n    // Values dimension represent each series \\n    scenarioUpdate.addMarker(\\\"CreateSeries\\\"); \\n    rawValues.forEach((value: number[], index: number) => { \\n      const time = data.start + index * data.step; \\n      for (let iSerie = 0; iSerie < value.length; iSerie++) { \\n        if (index === 0) { // Only first time we create series \\n          series.push({ seriesName: data.legend[iSerie], seriesValues: [] }); \\n        } \\n        series[iSerie].seriesValues.push({ time: time, value: value[iSerie] }); \\n      } \\n    });\\n\\n    let loopCount = 0; \\n    series.forEach((serieData: GraphData, index: number) => { \\n      if (this.highChartControl !== undefined) { \\n        const values = serieData.seriesValues\\n          .map((d: GraphDataValue) => { loopCount++; return [d.time, d.value]; }); \\n        this.highChartControl.addSeries({}, false, false); \\n        this.highChartControl.series[index].setData(values, false, false, false); \\n        this.highChartControl.series[index].update({ name: serieData.seriesName }, false); \\n      } \\n    });\\n\\n    window.requestAnimationFrame(() => { \\n      window.requestAnimationFrame(() => { \\n        if (this.highChartControl !== undefined) { \\n          this.highChartControl.reflow(); \\n          this.highChartControl.redraw(); \\n        } \\n      }); \\n    }); \\n  } \\n} \\n\")), mdx(\"p\", null, \"Once again, I removed a lot of the code from which I have been inspired. The goal here is to create all your series but before creating series, we remove all the existing one. In the end, we reflow and redraw which animated the graph. Indeed, a good \\\"shouldComponentUpdate\\\" is required to avoid updating for no reason.\"), mdx(\"p\", null, \"It might look like a lot of code but in reality, it is so close to the Highcharts documentation that it is easy to maintain. The key concept is to have the container that host Highchart build one time and to update the existing one.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"0b72e4aa-f819-5d11-a9bb-65f98827c3c4","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}