{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/javascript-part-6-create-instance-without-new-functional-approach",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Part 6 : Create Instance without new or object.create (Functional Approach)","date":"June 8, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Part 6 : Create Instance without new or object.create (Functional Approach)\",\n  \"date\": \"2017-06-08\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"We saw in a previous article how to create a new object with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new\"), \", and also without \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new\"), \". Both of them were using the prototype chain for inheritance. Here is a way to avoid using the prototype chain and be able to use object literal with function only to create instance.\"), mdx(\"p\", null, \"Let's start without any inheritance with a first object that we will create from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"myFactory\"), \" function. This one take parameters like a normal constructor. It could be a single string like in this example, or a more complex object. What is important is that factory create a new literal object which is private until we return this one. Within this factory, every \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \" will be private, hence having a good advantage against the classical approach where every variable attache to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" are public. On this functional approach, we hook all public method to the returned value, in that case the container.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var myFactory = function (p1) {\\n  var privateContainer = {};\\n  var private = \\\"Private\\\";\\n  privateContainer.publicMethod = function () {\\n    console.log(\\n      \\\"Can access private variable like : \\\" + private1 + \\\" or the param \\\" + p1\\n    );\\n  };\\n  return privateContainer;\\n};\\n\\nvar instance1 = myFactory(\\\"i1\\\");\\nvar instance2 = myFactory(\\\"i2\\\");\\n\\ninstance1.publicMethod();\\ninstance2.publicMethod();\\n\")), mdx(\"p\", null, \"If we want to inherit, we need to assign members to the object literal by using the base class factory. There is many ways to do it. The way presented is that every public members of the base class will be exposed through the child class. This is done by adding the children members to the base instance instead of adding the, to an empty object. However, we could have kept the empty literal object and create public method that proxied the base class if we wanted to manually decide which public property of the base class to expose.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var myBaseFactory = function (p2) {\\n  var privateContainer = {};\\n  var private = \\\"PrivateBase\\\";\\n  privateContainer.publicMethodInBase = function () {\\n    console.log(\\n      \\\"[BASE] Can access private variable like : \\\" +\\n        private +\\n        \\\" or the param \\\" +\\n        p2\\n    );\\n  };\\n  return privateContainer;\\n};\\n\\nvar myFactory = function (p1) {\\n  var privateContainer = myBaseFactory(\\\"Base!\\\" + p1);\\n  var private = \\\"Private\\\";\\n  privateContainer.publicMethod = function () {\\n    console.log(\\n      \\\"Can access private variable like : \\\" + private + \\\" or the param \\\" + p1\\n    );\\n  };\\n  return privateContainer;\\n};\\n\\nvar instance1 = myFactory(\\\"i1\\\");\\nvar instance2 = myFactory(\\\"i2\\\");\\n\\ninstance1.publicMethod();\\ninstance1.publicMethodInBase();\\ninstance2.publicMethod();\\ninstance2.publicMethodInBase();\\n\")), mdx(\"p\", null, \"Here is the output:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\"Can access private variable like : Private or the param i1\\\" \\n\\\"[BASE] Can access private variable like : PrivateBase or the param Base!i1\\\" \\n\\\"Can access private variable like : Private or the param i2\\\" \\n\\\"[BASE] Can access private variable like : PrivateBase or the param Base!i2\\\"\\n\")), mdx(\"p\", null, \"This way offer a clean and simple way to create instances without the complexity of the prototype chain. It has the disadvantage of not sharing with the prototype, hence will be more heavy in term of memory. It has the advantage to encapsulate functions and variables inside the factory and to not expose them.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"6950734d-21d2-501f-adad-bcd848f2cbc4","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}