{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-transfer-files-between-computers-using-HDMI-Part-4-hdmi-failure",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to Transfer Files Between Computers Using HDMI (Part 4: HDMI Failure)","date":"May 23, 2023"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to Transfer Files Between Computers Using HDMI (Part 4: HDMI Failure)\",\n  \"date\": \"2023-05-23\",\n  \"categories\": [\"rust\", \"hdmi\", \"video\", \"encoding\", \"steganography\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Reading the video without going by the video card and the HDMI cable was a success. However, when it was the time to send the video in these additional steps, the video received was corrupted. The failure was subtle as the footage could play and had the red frame and some colors on the top. However, the accuracy of the color was altered, making the data unreadable on extraction.\"), mdx(\"h1\", null, \"Hypothesis\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pixel color are unreliable\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pixel color bleeds into their neighbor\")), mdx(\"h1\", null, \"First Change: Each character in 1 pixel is 0 or 1.\"), mdx(\"p\", null, \"To create room for inaccuracy, we can have black or white pixel instead of relying on the 255 values possible for the R, G and B. The problem is the video will be a lot bigger. Each character is 8 bits, and we were able to store in 1 pixel 3 characters. Now, by using only black or white color, we can represent 0 and 1 value. It means we need 8 pixels for a single character (1 character = 1 byte = 8 bits). It is 24x less efficient.\"), mdx(\"p\", null, \"Some calculation shows that using HD resolution at 30fps we have 1920x1080x30/8 byte per second or: 7 776 000 bytes per second or 7.7 megs/second. Far from our 100 megs/second but still viable if we can extract the content without alteration. \"), mdx(\"p\", null, \"The change will fix the first hypothesis that the color is unreliable. With the black/white approach, even if a pixel is not a totally white value with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(255,255,255)\"), \" or totally black \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(0,0,0)\"), \", we can go to the closest value. For example, if there is a pixel with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(10,13,32)\"), \" we can say that it is closer to white and thus the value represent a bit with a value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \".\\nThe first change requires adding a new option to the CLI, which would let us switch between different algo. We had the first one that I now call \\\"RGB\\\" and in this first change, we add a \\\"bw\\\" for the black and white algorithm.\"), mdx(\"h2\", null, \"Result of the modification\"), mdx(\"p\", null, \"The first change resulted, as expected in a bigger file, and the visual was more apparent: the end-of-file character is represented like any other character with 8 pixels that keep filling the frame until the end for the small test. Thus, it visually looks like lines.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"./images/hdmi-file-transfer-video-frame-bw-lines.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"A new error message appears when extracting the text. Instead of the previous \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mcbpc damaged\"), \", this time it is about a market bit missing.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"Running `target/debug/hdmifiletransporter -m extract -i outputs/out_from_hdmi_bw_1.avi -o outputs/text_bw_1.txt --fps 30 --height 1080 --width 1920 --size 1 -a bw`\\n[mpeg4 @ 0x55aa4bc17100] 1. marker bit missing in 3. esc\\n[mpeg4 @ 0x55aa4bc17100] Error at MB: 8038\\n\")), mdx(\"h2\", null, \"Hypothesis of Failure\"), mdx(\"p\", null, \"The first change might fail because of the way I am using ffmpeg. I am recording, and I am killing the process once I see on the source computer a couple of red screen. However, VLC, Windows Media Player and Clipchamp can all read the file. So it does not look to be corrupted.\"), mdx(\"p\", null, \"While investigating, I found out that the count of frame recorded was 304 (about 10 seconds of recording), but the count of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"relevant frame\"), \" which are between two red frames, were always zero. Indeed! The black and white algorithm reads the pixel and constantly moves the color to white or black, so the red color was never picked up. While it does not explain the error seen, it shows a problem to fix. An alteration on the code to proceed the pixel differently was required.\"), mdx(\"h1\", null, \"Second Change: Handling the Starting and Ending Frame\"), mdx(\"p\", null, \"As mentioned, the red frame was not handled with the black-and-white algorithm. The change was to reach each frame with the full color and return a frame information that contained the black and white data as well as a boolean flag indicating if the frame was a \\\"red one\\\", also known as the \\\"starting frame\\\". The code changed for the RGB (color) algorithm as well to ensure similarity in the flow.\"), mdx(\"p\", null, \"Once the change was made, I pulled the change in the second computer and ran the video while recording with the second one.\"), mdx(\"h2\", null, \"Hypothesis of Failure\"), mdx(\"p\", null, \"This time, the generated file couldn't be opened at all.\"), mdx(\"p\", null, \"A step back to ffmpeg:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"ffmpeg -r 30 -f dshow -s 1920x1080 -vcodec mjpeg -i video=\\\"USB Video\\\" -r 30 out.mp4\\n\")), mdx(\"p\", null, \"We might have an issue with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"vcodec\"), \" used. The choice was because the capture card stream data using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mjpeg\"), \" (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ffmpeg -f dshow -list_options true -i video= \\\"USB Video\\\"\"), \"). Maybe, we should capture in raw and then manipulate the data received and figure out which option is the best. I found out in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://ffmpeg.org/ffmpeg.html#Stream-copy\"\n  }, \"ffmpeg documentation an option called stream copy\"), \".\"), mdx(\"p\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-codec:v copy\"), \" we tell \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ffmpeg\"), \" to copy all the video frame \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"ffmpeg -f vfwcap -r 30 -i video= \\\"USB Video\\\" -codec:v copy rawvideo.nut\\n\")), mdx(\"p\", null, \"Then, we need to use the raw format and convert it into a video format that the video player can read The input (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-i') is the raw video from the previous step. The \"), \"-codec:v\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"is the desired output video format. The\"), \"-crf 0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"means to be lossless. The\"), \"-preset` indicates how the compression ratio occurs. Slower it goes, the less erroneous the compression. \"), mdx(\"p\", null, \"You can get more information in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://trac.ffmpeg.org/wiki/Encode/H.264\"\n  }, \"H.264 ffmpeg documentation\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"ffmpeg -i rawvideo.nut -codec:v libx264 -crf 0 -preset medium -pix_fmt yuv420p -movflags +faststart output.mkv\\n\")), mdx(\"p\", null, \"At this point, I was getting several issues. The first one was the size of the video recorded was humongous with several megs for few seconds. Then, the process of creating the data was very slow. For example, the second command to get the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mkv\"), \" took over 20 minutes for less than 10 seconds.\"), mdx(\"h1\", null, \"Third Change: Step Back\"), mdx(\"p\", null, \"At this point, I decided to use the approach of having big pixels. Since the beginning, a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"size\"), \" parameter gives the option to generate many pixels for the same information. Hence, instead of using the value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \" and having the whole bit value into 1 pixel, using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"20\"), \", you can get 20x20 pixels to hold the black or white color. The reading uses an average which then can be easily distinguishable when we have two values that are far away. Now that the bits were quickly visible I noticed something off.\"), mdx(\"h2\", null, \"Hypothesis of Failure\"), mdx(\"p\", null, \"The hypothesis was that the drawing into the video using the black and white algorithm was quickly true: the data was not appropriately written with 1 bit off every byte, making the extraction impossible.\"), mdx(\"h1\", null, \"Fourth Change: Duplicate Red Frame\"), mdx(\"p\", null, \"The code was modified, and unit tests added. Finally, the command to read the pixel came back to the first one:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"ffmpeg -r 30 -f dshow -s 1920x1080 -vcodec mjpeg -i video=\\\"USB Video\\\" -r 30 out_bw_red_fix_2.mp4\\n\")), mdx(\"p\", null, \"The result was extracted using: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"cargo run -- -m extract -i outputs/out_bw_red_fix_2.mp4 -o outputs/text1.txt --fps 30 --height 1080 --width 1920 --size 1 -a bw\\n\")), mdx(\"p\", null, \"However, the file was empty. After some debugging, I discovered that the logic of finding the red frame that set the start and the end had a flaw: If the ffmpeg recorsd twice the same red frame next to each other (duplicate reading), it would have zero frames of data. This discovery also found that good frame were duplicated. While the generated video had no duplicated frame, the transmission and recording caused the frame to duplicate here and there. The fix was to ensure we ignore the data of a frame if the content is exactly the same as the previous one.\"), mdx(\"p\", null, \"To achieve this validation, a quick CRC32 can be applied to the frame's byte and ensure that no consecutive checksum is the same.\"), mdx(\"h1\", null, \"Working Solution or Not?\"), mdx(\"p\", null, \"This time we go with a size of 10 with the duplication fix applied.\"), mdx(\"p\", null, \"On the source computer:\\n\\\"`sh\\ncargo run -- -m inject -i testAssets/text1.txt -o outputs/out_bw_no_dup.mp4 -o --fps 30 --height 1080 --width 1920 --size 10 -a bw\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\nThe video plays fullscreen and on the target computer:\\n\\n```sh\\ncd outputs\\nffmpeg -r 30 -f dshow -s 1920x1080 -vcodec mjpeg -i video=\\\"USB Video\\\" -r 30 out_bw_no_dup.mp4\\ncargo run -- -m extract -i outputs/out_bw_no_dup.mp4 -o outputs/text1.txt --fps 30 --height 1080 --width 1920 --size 10 -a bw\\n\")), mdx(\"p\", null, \"It worked!\"), mdx(\"p\", null, \"The same test with a size of 1 pixel was also working!\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"The next article will get into a more realistic use case: one big zip file. Using something outside text will reveal not only a massive flaw of one of the decisions taken at the inception of this project but will expose why only the black-and-white solution will work in the future.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"b0d16f6a-1840-5dfb-ba7e-63bed2f2ba89","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}