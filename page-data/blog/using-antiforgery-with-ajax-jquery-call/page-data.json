{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/using-antiforgery-with-ajax-jquery-call",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Using Antiforgery with Ajax Jquery Call","date":"June 25, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Using Antiforgery with Ajax Jquery Call\",\n  \"date\": \"2015-06-25\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Using Antiforgery is pretty straightforward with normal form. You need to add an attribute on the top of the action and use a simple Html helper inside your form. The attribute will check for a specific value in session that has been calculated to be unique for the form. The Html helper create an hidden field with the value. Once the request is sent to the server, a comparison between the hidden field and the value in session is done. If they are not equal, an exception is thrown. This is a security mechanism that increase the security against malicious use of your cookie. For example, no one can just force a user to post a form that use the cookie for credential because this one will miss the antiforgery token. That said, with Ajax you have to do a little bit more.\"), mdx(\"p\", null, \"First, you still need to add the antiforgery token at the top of your controller's action.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"[HttpPost] \\n[ValidateAntiForgeryToken] \\npublic ActionResult SymbolChangeList(SymbolToRenameAddViewModel symbolToSave) { \\n  //... \\n} \\n\")), mdx(\"p\", null, \"The helper is also required. You have different option. First, you can re-use an existing antiforgery html helper if your page already have a form that is currently use this mechanism. For example, the login/logout form at the top of your site is using this by default. However, I prefer to create one for the Ajax call. It allows me to create an unique html's container to have an easy access to it in JavaScript.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-html\"\n  }, \"<div id=\\\"anti-forgery-token\\\"> @Html.AntiForgeryToken() </div> \\n\")), mdx(\"p\", null, \"From there, you just need to add the value of the hidden field inside your post arguments.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"$.ajax({ url: \\\"/yourpage/here\\\", type: 'POST', data: { idSymbolRename: id, /*Others variables to send */,__RequestVerificationToken: $('#anti-forgery-token [name=__RequestVerificationToken]').val() }, cache: true, dataType: 'json', success: function (json) { \\n  // Success code here \\n  }, \\n  error: function (xmlHttpRequest, textStatus, errorThrown) { \\n    // Error code here\\n     } \\n}); \\n\")), mdx(\"p\", null, \"As you see, we need to specify a value for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__RequestVerificationToken\"), \" value and we get this one from the generated hidden field from the Html Helper.\"), mdx(\"p\", null, \"This code does not require a lot of modification from any Ajax call done with JQuery. The only detail that change is that you need to add the request verification token into the data sent to the server and you are up to go with a protected Post method.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"255ad81e-829b-53ff-a103-efc9df678080","totalPages":75}},
    "staticQueryHashes": ["3159585216"]}