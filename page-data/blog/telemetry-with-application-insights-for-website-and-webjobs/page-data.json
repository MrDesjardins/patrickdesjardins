{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/telemetry-with-application-insights-for-website-and-webjobs",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Telemetry with Application Insights for Website and Webjobs","date":"February 23, 2016"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you have a website and also some WebJobs you may want have both of them use the same library for your telemetry. Once idea is to create a shared project that both project refers. This shared project can have a class that abstract your abstraction. The real implementation can use Microsoft Azure Application Insights to send telemetries to Azure. As you may have read in the official documentation is that your website needs to have the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Microsoft.ApplicationInsights.Web\"), \" package, and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Microsoft.ApplicationInsights.WindowsServer\"), \". What you need to know is that the shared project also need to have the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Web\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"WindowsServer\"), \" package but the WebJobs also need to have the WindowsServer package. If you don't, your will get some exception on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Telemetry.Active...\")), mdx(\"p\", null, \"Finally, you should always give some time for the telemetry to be sent after it is flushed. Here is a snippet of the method that send the constructed telemetry from my Telemetry class in the shared project. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" private void Send(string eventName, Dictionary<string, string> properties, Dictionary<string, double> metrics) { this.telemetry.TrackEvent(eventName , properties , metrics ); this.telemetry.Flush(); System.Threading.Thread.Sleep(5000); } \\n``` The 5 seconds sleep is more than enough. You can have less. The important is just giving enough time to the telemetry to be sent to Azure.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"Telemetry with Application Insights for Website and Webjobs\\\",\\\"date\\\":\\\"2016-02-23\\\",\\\"categories\\\":[\\\"asp-net\\\",\\\"azure\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"fde608e8-7e4a-5e70-b932-eb7ad0ec7aac","totalPages":70}},
    "staticQueryHashes": ["3159585216"]}