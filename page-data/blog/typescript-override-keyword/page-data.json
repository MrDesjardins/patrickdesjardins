{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-override-keyword",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript Class Override Keyword Increase Maintainability","date":"February 11, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript Class Override Keyword Increase Maintainability\",\n  \"date\": \"2022-02-11\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"TypeScript added the keyword \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"override\"), \" with version 4.3. The keyword allows to mark a function in a class which marks the function to be expected to be redefined in a subclass. Before that keyword, or if you do not use it today (at version 4.5) the code still compiles. You can define the same functions in a sub-class without issue.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"class BaseClass {\\n    public show() {\\n        console.log(\\\"Show\\\");\\n    }\\n\\n}\\nclass ChildClass extends BaseClass {\\n    public show() {\\n        console.log(\\\"Overriden the show method\\\");\\n    }\\n}\\nconst c = new ChildClass();\\nc.show();\\n\")), mdx(\"p\", null, \"The code above displays the text from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ChildClass\"), \". The problem is not on the actual code but in the future code. With the current implementation of the code, we can update \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BaseClass\"), \" to the following list and have the code still compile.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"class BaseClass {\\n    public showRenamed() {\\n        console.log(\\\"Show\\\");\\n    }\\n\\n}\\nclass ChildClass extends BaseClass {\\n    public show() {\\n        console.log(\\\"Overriden the show method\\\");\\n    }\\n}\\nconst c = new ChildClass();\\nc.show();\\n\")), mdx(\"p\", null, \"The problem with the above code is that the intention was to rename the method, but the child class has not changed. Therefore, the code is legit but does not reflect the intent. Now, the code has two methods instead of one. However, if we rewind to the former code and add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"override\"), \" keyword.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{8}\",\n    \"{8}\": true\n  }, \"class BaseClass {\\n    public show() {\\n        console.log(\\\"Show\\\");\\n    }\\n}\\n\\nclass ChildClass extends BaseClass {\\n    public override show() {\\n        console.log(\\\"Overriden the show method\\\");\\n    }\\n}\\nconst c = new ChildClass();\\nc.show();\\n\")), mdx(\"p\", null, \"However, now, if we rename the base class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"show\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"showRenamed\"), \" we will get TypeScript warns us with an error.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This member cannot have an 'override' modifier because it is not declared in the base class 'BaseClass'.\")), mdx(\"p\", null, \"Great! Now, we are safe to rename base class methods and get a warning. Of course, as you can figure out, the only class that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"extends\"), \" a class can use that feature. Small note, if you are using a code editor that supports TypeScript, when using the renaming feature, the code would have been appropriately renamed before the use of override. The big difference is that now we can explicitly mention that we expect the method to be available in the base class.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"166cea0d-041e-529d-80ea-88a8aa5de4b8","totalPages":70}},
    "staticQueryHashes": ["3159585216"]}