{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-dynamic-discriminant-with-template-string",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript Dynamic Discriminant with Template String","date":"January 31, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript Dynamic Discriminant with Template String\",\n  \"date\": \"2022-01-31\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"An improvement with TypeScript 4.5 compared to 4.4 is the ability to discriminate on a dynamically constructed type with a pattern. Template string type has been around for a few versions, but it was impossible to narrow down until 4.5. Before getting into the specific, here is an example of two interfaces: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Weapon\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Magic\"), \". The discriminant, the common property, is called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kind\"), \". However, the type is not unique for the interface; it is dynamically adjustable. Hence, we can have data coming from the backend, giving us several weapons of a different kind that share the same schema (interface).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface Weapon {\\n    kind: `Weapon_${string}`;\\n    range: number;\\n    damage: number;\\n}\\n\\nexport interface Magic {\\n    kind: `Magic_${string}`;\\n    costMana: number;\\n    multiplier: number;\\n}\\n\\nexport function attack(attackerItem: Weapon | Magic) {\\n    if (attackerItem.kind === \\\"Weapon_\\\") {\\n        console.log(\\\"Range:\\\" + attackerItem.range);\\n    } else if (attackerItem.kind === \\\"Magic_\\\") {\\n        console.log(\\\"Mana:\\\" + attackerItem.costMana)\\n    }\\n}\\n\")), mdx(\"p\", null, \"The code above compiles prior to TypeScript version 4.5 until the line compares the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kind\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attach\"), \" function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"if (attackerItem.kind === \\\"Weapon_\\\") {\\n\")), mdx(\"p\", null, \"With TypeScript 4.5, it is possible to write the static portion of the type, and TypeScript will narrow down to the type allowing to use of the properties that are unique for the specific interface. So, in that example, the first condition is for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"weapon\"), \", and the code compiles (and has auto-complete) for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"range\"), \", which is not available for the second condition.\"), mdx(\"p\", null, \"Small detail, you \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"must\"), \" specify the whole static part and not rely on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"else\"), \". The following code does not compile.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export function attack(attackerItem: Weapon | Magic) {\\n    if (attackerItem.kind === \\\"Weapon_\\\") {\\n        console.log(\\\"Range:\\\" + attackerItem.range);\\n    } else {\\n        console.log(\\\"Mana:\\\" + attackerItem.costMana)\\n    }\\n}\\n\")), mdx(\"p\", null, \"Another detail is that you cannot specify only a portion of the static name of the type. For example, the following code does not work.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export function attack(attackerItem: Weapon | Magic) {\\n    if (attackerItem.kind === \\\"Weapon\\\") {\\n        console.log(\\\"Range:\\\" + attackerItem.range);\\n    } else if (attackerItem.kind === \\\"Magic\\\") {\\n        console.log(\\\"Mana:\\\" + attackerItem.costMana)\\n    }\\n}\\n\")), mdx(\"p\", null, \"Even though, as a human, we can figure out that we do not need the underscore to identify the type, TypeScript requires to have the whole string. Since we could have a type named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeAA\"), \", it makes sense, and having a partial \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Type\"), \" would break.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"c38aa839-2815-5098-b31b-4412a66d18f6","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}