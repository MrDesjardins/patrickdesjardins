{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/handling-multiple-repository-with-entity-framework",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Handling multiple repository with Entity Framework","date":"March 24, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Handling multiple repository with Entity Framework\",\n  \"date\": \"2012-03-24\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you are using 1 dbcontext per repository, you may end by having problem with your reference between each of your object. Let say that you have an object A with an object B and A is handled by RepoA and you change the object B which is handled by the context inside repoB than you won't have any changes done. This is because the dbcontext contain only reference for RepoA in RepoA and it's not aware of what has been changed in the other dbcontext in RepoB.\"), mdx(\"p\", null, \"The best way to solve this issue is to share the dbcontext between all your repositories. This can be easily done if you are using a repository factory (Abstract Factory pattern). When you create your repository factory you should create the database context and set it to all repository when they are instantiated.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class RepositoryFactory : IRepositoryFactory { private IClassA a; private IClassB b; private IClassC c;\\n\\nprivate readonly DatabaseContext dbContext;\\n\\npublic RepositoryFactory() { this.dbContext = new DatabaseContext(); }\\n\\npublic IClassA RepoA { get { return a ?? (a = new RepoA(this.dbContext)); } }\\n\\npublic IClassB RepoB { get { return b ?? (b = new RepoB(this.dbContext)); } }\\n\\npublic IClassC RepoC { get { return c ?? (c = new RepoC(this.dbContext)); } } } \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"d02a2297-a260-53c5-94cf-0257d2f2c14c","totalPages":68}},
    "staticQueryHashes": ["3159585216"]}