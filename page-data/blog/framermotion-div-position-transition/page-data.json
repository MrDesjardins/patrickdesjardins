{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/framermotion-div-position-transition",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Using Framer Motion to transition (position) between two React components","date":"October 4, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Using Framer Motion to transition (position) between two React components\",\n  \"date\": \"2022-10-04\",\n  \"categories\": [\"typescript\", \"react\", \"framer\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar CodeSandbox = makeShortcode(\"CodeSandbox\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this article, we will see how to have an HTML div at a specific boundary (x, y, width and height) and moving it to a second boundary to actually load another component. Visually the transparent to the user we will mount/unmount behind the curtain! Confusing! In other words, we have two React components and one is visible to the user. At some point in time, the user interact to have this visible component move to a second location where it goes away to reveal a new React components. A use case is that you have a HTML div showing information and you click \\\"edit\\\" to give the posibility to change the content. This editing mode might be bigger than the original content and also you may want the content to be in the middle of your screen.\"), mdx(\"p\", null, \"The challenge is to handle the back and forth between the two React component. At one time, one is mounted while the other unmounted and they swap their state. Using React Framer Motion, we can leverage the capability of animating using their state management of when a component is mounted and unmounted.\"), mdx(\"h1\", null, \"Basic Animation\"), mdx(\"p\", null, \"Let start with a foundation with basic code. The first snippet of code is mostly what you can have with Framer Motion using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"motion.div\"), \" inside two React components.\"), mdx(CodeSandbox, {\n    codeSandboxId: \"framer-motion-transition-div-part-1-zxn7pi\",\n    mdxType: \"CodeSandbox\"\n  }), mdx(\"p\", null, \"The application consists of a top and bottom panel. The top host one of our two components and the bottom has a single button that toggle between the two components. The toggle mount and unmount each component.\"), mdx(\"h1\", null, \"Initial, animated and exit\"), mdx(\"p\", null, \"A next step is to remove setting the position and dimension with styles but to rely solely on Framer Motion. To do so, let's refactor our code to have all the position inside an object. It will simplify the repetition into a central place. Then, let's inject all the position into our two boxes. That way, both know each other boundary. The code set the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initial\"), \" which is the position when mounted. For \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Box1\"), \" component, we set the initial to be the other box: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Box2\"), \". That way, when we mount the first box we start at box two position and dimension. We do the opposite for box two. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"animate\"), \" is the final position. For \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Box1\"), \" we use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"boxInfo.box1\"), \" and for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Box2\"), \" the final position that is inside \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"boxInfo.box2\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"exit\"), \" is the transition when unmount is called which is the same as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initial\"), \".\"), mdx(CodeSandbox, {\n    codeSandboxId: \"framer-motion-transition-div-part-2-p4cp2h\",\n    mdxType: \"CodeSandbox\"\n  }), mdx(\"h1\", null, \"Scaling\"), mdx(\"p\", null, \"The problem with the actual code is that we have Box 1 and Box 2 that are swapping. However, it does not scale well if we have 10 boxes which has two states meaning 20 configurations.\"), mdx(\"p\", null, \"Let's change our TypeScript interface, our model, to support a collection of Box that has two states.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface BoxInfo {\\n  left: number;\\n  top: number;\\n  width: number;\\n  height: number;\\n}\\n\\nexport interface BoxState {\\n  name: string;\\n  state1: BoxInfo;\\n  state2: BoxInfo;\\n}\\n\\nexport interface BoxProps {\\n  boxState: BoxState;\\n}\\n\")), mdx(\"p\", null, \"Creating two differents boxes can be done using a collection:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const data = {\\n  boxInfos: [\\n    {\\n      name: \\\"Alpha\\\",\\n      state1: {\\n        left: 10,\\n        top: 10,\\n        width: 100,\\n        height: 100\\n      },\\n      state2: {\\n        left: 120,\\n        top: 50,\\n        width: 100,\\n        height: 150\\n      }\\n    },\\n    {\\n      name: \\\"Beta\\\",\\n      state1: {\\n        left: 170,\\n        top: 10,\\n        width: 100,\\n        height: 100\\n      },\\n      state2: {\\n        left: 20,\\n        top: 150,\\n        width: 100,\\n        height: 100\\n      }\\n    }\\n  ]\\n};\\n\")), mdx(\"p\", null, \"and the mounting and unmounting\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"<div className=\\\"Main\\\">\\n  <div className=\\\"BoxContainer\\\">\\n    {data.boxInfos.map((box, index) => {\\n      return box1 ? (\\n        <Box1 key={index} boxState={box} />\\n      ) : (\\n        <Box2 key={index} boxState={box} />\\n      );\\n    })}\\n  </div>\\n</div>\\n\")), mdx(\"p\", null, \"The animation works as expected between the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Box1\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Box2\"), \". Indeed, for now, both React component are almost the same expect the background color. However, let's imagine that they are two distinct components with more than just some visual change. \"), mdx(CodeSandbox, {\n    codeSandboxId: \"framer-motion-transition-div-part-3-83wsne\",\n    mdxType: \"CodeSandbox\"\n  }), mdx(\"p\", null, \"Still, something is off. First, the initial/animate/exit is repetitive regardless of the unique feature of each box. The next step will be to extract the commonality between the two.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1122px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/de3df5aaaa6ab3af16571ba10e7e5cee/62a6a/framermotion-reverted-code.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"74.66666666666667%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACyklEQVQ4y2WTu44jRRiFJ0NiYdfuS/W1uqq7qu2+jz1jewaxiACtSMgQlw1WiGRfgHfgBSBCZCQkSEQQEvNUH+pqe7wSQQWl+nR0/jrnv0mzHFkalDaoXFPZhqJQxElKkiTEkSASgpnbbBvMpiHLJFmuidOMMBTnExLHMTdRFFG2I+Mw8XJ/T9/02LqnqSdkUfHe+yuefbDm2Ycrnq8FsRnY2J5DOzE0HXXd0252FIXGD3xuZmVlN0zjwGRKjJQorZ2YrSRvvznw2ccdn5waPn3Y8vqrV3z7xSNfvzqSxzlSKYwxpFnmXDpBEYZ0fcvQtehSE8U5p87j1Hv8+dOX/PPbW/74+Q1//fKGv3/9nn9//44ff/ic4xBRFjm+Lwh8/yq4uNyibUOcSPI04OWtx9oLeL4KebEOeLHyWa1DVp4gNy2x3HDoEg6dj+eHhEGwCAohCIKAylqG1rCpch6nlLsuo8gT9xaGAVEkECJ0d2MtU28xOuejKeHxNiNJYvfmBH3fp+t69mPDrlM8TIpDL5lajS5SfD9g5i7sMAzcTVt2reJhnNmCoVHOgBOcrc51MLZCZjGpypeTRE+uLlwoBGbbYkyJTKMnNokX9smhNRX7wbBrNeOxZTi21JV0HbwIXtjaGu5H6xwOp87xRmXufREMArZzp6zFqASrM3SR0Jic8jzy3NfLfzdt70SrM1sVKY2V15GDMHShzIHYMqPRFU1ZuTE8b6nD4jB0W1EZw9ZI6jKn0Za2NC40zz+H4nkefd9x2HXc9YpjX3PX1uz68n+hzOw4Dpz2Lfuu4NhvuO9qbjt9cbj0UGpDKhWFUmitSJPYOZx3+d1QhIgcm+QF6szOlXE7H4ml2PP/1Fa7EExZUOrCjRYE4bmH4ZNgEsdsrMZWhWO1kmc2uPYwyzIqlaJlQhxfCzwXeha5phyR57ljlUyIRPgOu0z6H+bLncJCDD3mAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"framermotion reverted code\",\n    \"title\": \"framermotion reverted code\",\n    \"src\": \"/static/de3df5aaaa6ab3af16571ba10e7e5cee/62a6a/framermotion-reverted-code.png\",\n    \"srcSet\": [\"/static/de3df5aaaa6ab3af16571ba10e7e5cee/5a46d/framermotion-reverted-code.png 300w\", \"/static/de3df5aaaa6ab3af16571ba10e7e5cee/0a47e/framermotion-reverted-code.png 600w\", \"/static/de3df5aaaa6ab3af16571ba10e7e5cee/62a6a/framermotion-reverted-code.png 1122w\"],\n    \"sizes\": \"(max-width: 1122px) 100vw, 1122px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The wrapper is called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BoxWrapper\"), \" and has the role to handle the position and dimension of the actual React component.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export default function App() {\\n  const [firstState, setFirstState] = useState(true);\\n  return (\\n    <div className=\\\"App\\\">\\n      <div className=\\\"Main\\\">\\n        <div className=\\\"BoxContainer\\\">\\n          {data.boxInfos.map((box, index) => {\\n            return (\\n              <BoxWrapper firstState={firstState} boxState={box}>\\n                {firstState ? (\\n                  <Box1 key={index} boxState={box} />\\n                ) : (\\n                  <Box2 key={index} boxState={box} />\\n                )}\\n              </BoxWrapper>\\n            );\\n          })}\\n        </div>\\n      </div>\\n      ...\\n      ...\\n\")), mdx(\"h1\", null, \"Improving React Framer Motion Translation\"), mdx(\"p\", null, \"There is still quite a bit of redundancy in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BoxWrapper\"), \" and a loading animation that is not needed. Let's take a look of the component:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export interface BoxWrapperProps {\\n  firstState: boolean;\\n  boxState: BoxState;\\n}\\nexport const BoxWrapper = (props: PropsWithChildren<BoxWrapperProps>) => {\\n  const init = props.firstState ? props.boxState.state1 : props.boxState.state2;\\n  const ani = props.firstState ? props.boxState.state2 : props.boxState.state1;\\n  return (\\n    <motion.div\\n      className=\\\"boxWrapper\\\"\\n      initial={{\\n        x: init.left,\\n        y: init.top,\\n        width: init.width,\\n        height: init.height\\n      }}\\n      animate={{\\n        x: ani.left,\\n        y: ani.top,\\n        width: ani.width,\\n        height: ani.height\\n      }}\\n      exit={{\\n        x: init.left,\\n        y: init.top,\\n        width: init.width,\\n        height: init.height\\n      }}\\n      transition={{ duration: 1 }}\\n    >\\n      {props.children}\\n    </motion.div>\\n  );\\n};\\n\")), mdx(\"p\", null, \"The redundancy part is between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initial\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"exit\"), \" are the same. We can extract the boundary information outside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<motion.div>\"), \". Actually, Framer Motion has the concept of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"variants\"), \" that we can leverage in that particular case.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export const BoxWrapper = (props: PropsWithChildren<BoxWrapperProps>) => {\\n  const init = props.firstState ? props.boxState.state1 : props.boxState.state2;\\n  const ani = props.firstState ? props.boxState.state2 : props.boxState.state1;\\n  const variants: Variants = {\\n    init: {\\n      x: init.left,\\n      y: init.top,\\n      width: init.width,\\n      height: init.height,\\n      transition: { duration: 1 }\\n    },\\n    ani: {\\n      x: ani.left,\\n      y: ani.top,\\n      width: ani.width,\\n      height: ani.height,\\n      transition: { duration: 1 }\\n    }\\n  };\\n\\n  return (\\n    <motion.div\\n      className=\\\"boxWrapper\\\"\\n      variants={variants}\\n      initial=\\\"init\\\"\\n      animate=\\\"ani\\\"\\n      exit=\\\"init\\\"\\n    >\\n      {props.children}\\n    </motion.div>\\n  );\\n};\\n\")), mdx(\"p\", null, \"To fix the first mounting animation that start from the state 2 toward state 1, we need to not have an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initial\"), \" state. Instead, setting to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" will skip the animation and go directly to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"animate\"), \" end result.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"export const BoxWrapper = (props: PropsWithChildren<BoxWrapperProps>) => {\\n  const init = props.firstState ? props.boxState.state2 : props.boxState.state1;\\n  const ani = props.firstState ? props.boxState.state1 : props.boxState.state2;\\n\\n  const variants: Variants = {\\n    ex: {\\n      x: init.left,\\n      y: init.top,\\n      width: init.width,\\n      height: init.height,\\n      transition: { duration: 1 }\\n    },\\n    ani: {\\n      x: ani.left,\\n      y: ani.top,\\n      width: ani.width,\\n      height: ani.height,\\n      transition: { duration: 1 }\\n    }\\n  };\\n\\n  return (\\n    <motion.div\\n      className=\\\"boxWrapper\\\"\\n      variants={variants}\\n      initial={false}\\n      animate=\\\"ani\\\"\\n      exit=\\\"ex\\\"\\n    >\\n      {props.children}\\n    </motion.div>\\n  );\\n};\\n\")), mdx(CodeSandbox, {\n    codeSandboxId: \"framer-motion-transition-div-part-5-po75hj\",\n    mdxType: \"CodeSandbox\"\n  }), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"The result is not as expected. When we load the application, the two HTML divs (Box 1 and Box 2) are both in the state 1 position. Clicking the button, change the state to two. Both HTML div are moving to their state 2 positions and size. Under the scene, the two components \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Box1\"), \" are unmounting and two new components of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Box2\"), \" are mounted. It is transparent to the user.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"ad6a4aca-59fe-5a09-b697-3fb8df9449e0","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}