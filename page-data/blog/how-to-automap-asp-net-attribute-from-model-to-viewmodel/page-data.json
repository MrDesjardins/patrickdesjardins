{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/how-to-automap-asp-net-attribute-from-model-to-viewmodel",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to AutoMap Asp.Net Attribute from Model to ViewModel","date":"March 17, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to AutoMap Asp.Net Attribute from Model to ViewModel\",\n  \"date\": \"2015-03-17\",\n  \"categories\": [\"asp-mvc\", \"automapper\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you are using DisplayAttribute and DataAnnotation Attribute with an architecture that use Model and ViewModel, by default, you have to duplicate those attributes. The problem is that you cannot keep all display attribute on the view model only because you want to have you exception to have the display name into it. You also want to have the data annotation on your model because they add validation into the model, not into a class designed for rendering, the view model. That say, Display Attribute and Data Annotation are quite useful in Asp.net because they are using for Label and for client-side validation. So, we need them in both place. The best place is to have the attribute on the Model classes. Mostly because the model classes are the heart of the system where logic of your system live.\"), mdx(\"p\", null, \"With that in mind, we need when transferring the values from the model classes into the view model classes transfer the attributes too. This require some works to change some Asp.Net behaviors and also do some work with AutoMapper to maps more than just the specified properties but also attributes for those specified properties. All code discussed in this article is open sourced in this Git Repository : \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/AutoMapperAttributesMapping\"\n  }, \"https://github.com/MrDesjardins/AutoMapperAttributesMapping\"), \".\"), mdx(\"p\", null, \"The first change is on Asp.Net MVC. We need to define a new \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DataAnnotationsModelMetadataProvider\"), \". The goal of this class is to create a new provider to handle attributes. So every times MVC will access the attributes on the view model, it will call this method. We will access AutoMapper and get from the attributes from the model. As you can notice, we pass inside the constructor a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IConfigurationProvider\"), \" that allow you to pass AutoMapper configuration. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" internal class MappedDataAnnotationsModelMetadataProvider : DataAnnotationsModelMetadataProvider { private readonly IConfigurationProvider mapper;\\n\\npublic MappedDataAnnotationsModelMetadataProvider(IConfigurationProvider mapper) { this.mapper = mapper; }\\n\\nprotected override ModelMetadata CreateMetadata(IEnumerable<Attribute> attributes, Type containerType, Func<object> modelAccessor, Type modelType, string propertyName) { var mappedAttributes = containerType == null ? attributes : mapper.GetMappedAttributes(containerType, propertyName, attributes).ToArray(); var modelMetadata = base.CreateMetadata(mappedAttributes, containerType, modelAccessor, modelType, propertyName); return modelMetadata; } } \\n\")), mdx(\"p\", null, \"This class must be instantiated during the startup of you web project. Ideally in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Global.asax\"), \". I created a class to have a public access which can be called from the global.asax. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class ModelMetadataProviderConfig { public static void RegisterModelMetadataProvider() { ModelMetadataProviders.Current = new MappedDataAnnotationsModelMetadataProvider(Mapper.Engine.ConfigurationProvider); } } \\n\")), mdx(\"p\", null, \"The big piece of code is with AutoMapper. The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DataAnnotationsModelMetaDataProvider\"), \" calls the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetMappedAttributes\"), \" from AutoMapper. This is a custom method that do the mapping for attributes. This method is pretty big and do a lot of looping. The first one is looping all the registered mapping. We need to get from all mapper where we are going to map to the destination one. Since we are using the meta data from the type used inside the view, which is the View Model class, we need to search through the list of mapping for the destination type. This can lead to several mapping, this is why we have a second loop that search for the property name. We make sure that we search only for mapped type, not those ignored. The last loop can be customized for your need. I decided to map attribute that are of type \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ValidationAttribute\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DisplayAttribute\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static IEnumerable<Attribute> GetMappedAttributes(this IConfigurationProvider mapper, Type viewModelType, string viewModelPropertyName, IEnumerable<Attribute> viewModelPropertyAttributes) { if (viewModelType == null) throw new ArgumentNullException(\\\"viewModelType\\\");\\n\\n//For all automapper configurations about the view model we are working with foreach (var typeMap in mapper.GetAllTypeMaps() .Where(i => i.DestinationType == viewModelType)) { //Get the properties from the model we found from automapper var propertyMaps = typeMap.GetPropertyMaps() .Where(propertyMap => !propertyMap.IsIgnored() && propertyMap.SourceMember != null) .Where(propertyMap => propertyMap.DestinationProperty.Name == viewModelPropertyName);\\n\\nforeach (var propertyMap in propertyMaps) { //Only get the attribute from the model if the view model does not define it foreach (Attribute attribute in propertyMap.SourceMember.GetCustomAttributes(typeof(ValidationAttribute), true)) { if (!viewModelPropertyAttributes.Any(i => i.GetType().IsInstanceOfType(attribute) || attribute.GetType().IsInstanceOfType(i))) yield return attribute; } //Only get the attribute from the model if the view model does not define it foreach (Attribute attribute in propertyMap.SourceMember.GetCustomAttributes(typeof(DisplayAttribute), true)) { if (!viewModelPropertyAttributes.Any(i => i.GetType() == attribute.GetType())) yield return attribute; }\\n\\n} }\\n\\n//Add all view model attribute if (viewModelPropertyAttributes != null) { foreach (var attribute in viewModelPropertyAttributes) { yield return attribute; } } } \\n\")), mdx(\"p\", null, \"This method returns a list of attributes that are then set to the ViewModel object with the call to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"base.CreateMetaData\"), \" method. To see the result, you can add a display attribute on the model and see what is happening when you use the Html helper for label.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class UserModel { public int Id { get; set; }\\n\\n[Display(Name = \\\"First Name Here\\\")] public string FirstName { get; set; } public string LastName { get; set; } } public class UserViewModel { public int Id { get; set; } public string FirstName { get; set; } public string LastName { get; set; } } \\n``` The .csHtml: \\n```html  <div class=\\\"row\\\"> <div class=\\\"col-md-6\\\"> @Html.LabelFor(d => d.FirstName) @Html.TextBoxFor(d => d.FirstName) </div> <div class=\\\"col-md-6\\\"> @Html.LabelFor(d => d.LastName) @Html.TextBoxFor(d => d.LastName) </div> </div> \\n\")), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"310px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/patrickdesjardins/static/3f58438c812d7064a51f1fe1a043040a/5fad2/Display.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"21.666666666666668%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAuElEQVQY022P0YqDMBBF/f//KuxD02qhG2N3H5Y+tcZEBI3GxLMkdJcWeuHAcJmZO1NY3XIUJfJTUpUVQuyppeIgBEo1XL6+uTSKGAMhBNZ1fcuyLMzzTBFDwE0OYwzW2kzf92itc911Hffbjc4YhmFgmqYXxnHEe59JgcVge2Rd87HbsRcHjmXFz/WavUadkfLMqayy3+qWGDdW7/8vc87xrGLbttz0rBhjTvOPwVT/8e7dpLQn8Qs/FTB/rO2tegAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Display\",\n    \"title\": \"Display\",\n    \"src\": \"/patrickdesjardins/static/3f58438c812d7064a51f1fe1a043040a/5fad2/Display.png\",\n    \"srcSet\": [\"/patrickdesjardins/static/3f58438c812d7064a51f1fe1a043040a/5a46d/Display.png 300w\", \"/patrickdesjardins/static/3f58438c812d7064a51f1fe1a043040a/5fad2/Display.png 310w\"],\n    \"sizes\": \"(max-width: 310px) 100vw, 310px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"8d0dcc92-7901-501c-bd0b-ec338928e16d"}},
    "staticQueryHashes": ["3159585216"]}