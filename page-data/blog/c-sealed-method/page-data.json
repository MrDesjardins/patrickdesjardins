{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/c-sealed-method",
    "result": {"data":{"mdx":{"frontmatter":{"title":"C# Sealed Method","date":"September 19, 2011"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"C# Sealed Method\",\n  \"date\": \"2011-09-19\",\n  \"categories\": [\"general\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The keyword \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"sealed\"), \" is used in class definition to prevent being derived from. When it's apply to methods, it mean that the method cannot be overrided.\"), mdx(\"p\", null, \"Well, in fact, method can only be overrided when the virtual keyword is used so why \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"sealed\"), \" is required? It's required when a class derive from a class that had a virtual method. This one will override and an overrided method can be also overrided. To prevent that, the override method can use the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"sealed\"), \" keyword.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"class A { public virtual void F() { Console.WriteLine(\\\"A.F\\\"); } public virtual void G() { Console.WriteLine(\\\"A.G\\\"); } } class B: A { sealed override public void F() { Console.WriteLine(\\\"B.F\\\"); } override public void G() { Console.WriteLine(\\\"B.G\\\"); } } class C: B { override public void G() { Console.WriteLine(\\\"C.G\\\"); } } \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"40185f35-4a77-5703-b362-aa23309fab9e","totalPages":70}},
    "staticQueryHashes": ["3159585216"]}