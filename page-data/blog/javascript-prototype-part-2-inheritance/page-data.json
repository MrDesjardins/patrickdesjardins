{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/javascript-prototype-part-2-inheritance",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Prototype Part 2 : Inheritance (Classical Approach)","date":"May 15, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Prototype Part 2 : Inheritance (Classical Approach)\",\n  \"date\": \"2017-05-15\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this article, we will see how to create inheritance with JavaScript's prototype in a classical approach.\"), mdx(\"p\", null, \"We will create a base class and a child class. The base class will have 3 functions on its prototype. We will override one of these functions inside the child class in two different ways. The first one will override by a function attached to the instance, the second one will override the function attached to the prototype.\"), mdx(\"p\", null, \"To have inheritance with JavaScript there is two steps once the class are created.\"), mdx(\"p\", null, \"The first step is to call the base class constructor with the the this parameter. This is done by using the name of the function (the class) followed by \\\"call\\\" with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" as parameter.\"), mdx(\"p\", null, \"The second step is to set the prototype of the child class to an instance of a new base object. This is done my calling assigning the prototype to Object.Create(.prototype). An important detail is that this must be set before you associate any new prototype to the object, otherwise, every prototype defined will be overridden.\"), mdx(\"p\", null, \"The third step is to set the prototype of the child class to be setup to the childclass. That is that the Object.create set the prototype to the base class which need to set back to the child. We can see that without setting this constructor that the value of console.log(ChildClass1.prototype.constructor) is the base class instead of the child class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var BaseClass1 = function () {\\n  this.memberbase = \\\"base\\\";\\n  this.function4 = function () {\\n    return \\\"return function4 from base instance\\\";\\n  };\\n};\\n\\nBaseClass1.prototype.function1 = function () {\\n  return \\\"return function1 from base prototype\\\";\\n};\\n\\nBaseClass1.prototype.function2 = function () {\\n  return \\\"return function2 from base prototype\\\";\\n};\\n\\nBaseClass1.prototype.function3 = function () {\\n  return \\\"return function3 from base prototype\\\";\\n};\\n\\nvar ChildClass1 = function () {\\n  BaseClass1.call(this); // Call the constructor of the base class [Step1]\\n  this.memberclass = \\\"Child\\\";\\n  this.function2 = function () {\\n    return \\\"return function2 from child\\\";\\n  };\\n};\\n\\nChildClass1.prototype = Object.create(BaseClass1.prototype);\\n\\n// [Step2]\\nChildClass1.prototype.constructor = ChildClass1;\\n\\n// [Step3]\\n\\nChildClass1.prototype.function1 = function () {\\n  // Must be after previous line return \\\"return from child\\\";\\n};\\n\\nvar instance1 = new ChildClass1();\\n\\nconsole.log(\\\"instance1.function1: \\\" + instance1.function1()); // override with prototype of child\\nconsole.log(\\\"instance1.function2: \\\" + instance1.function2()); // override with instance function\\nconsole.log(\\\"instance1.function3: \\\" + instance1.function3()); // Use base class function\\nconsole.log(\\\"instance1.function4: \\\" + instance1.function4()); // Use base class function\\n//console.log(ChildClass1.prototype.constructor) // uncomment to see what step 3 change.\\n\")), mdx(\"p\", null, \"The output is :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\"instance1.function1: return from child\\\"\\n\\\"instance1.function2: return function2 from child\\\"\\n\\\"instance1.function3: return function3 from base prototype\\\"\\n\\\"instance1.function4: return function4 from base instance\\\"\\n\\n\")), mdx(\"p\", null, \"What we can see is that the chain of priority when calling a function start with the child instance function, move up to the child prototype function, then to the base prototype function. So, it's possible to redefine a base member in 3 different levels.\"), mdx(\"p\", null, \"The priority will always be : Child instance, Base instance, Child prototype, Base prototype.\"), mdx(\"p\", null, \"We can prove it with this example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var BaseClass1 = function () {\\n  this.function1 = function () {\\n    return \\\"Base Instance\\\";\\n  };\\n};\\n\\nBaseClass1.prototype.function1 = function () {\\n  return \\\"Base Prototype\\\";\\n};\\n\\nvar ChildClass1 = function () {\\n  BaseClass1.call(this); // Call the constructor of the base class\\n  this.function1 = function () {\\n    return \\\"Child Instance\\\";\\n  };\\n};\\n\\nChildClass1.prototype = Object.create(BaseClass1.prototype);\\nChildClass1.prototype.function1 = function () {\\n  // Must be after previous line return \\\"Child Prototype\\\";\\n};\\n\\nChildClass1.prototype.constructor = BaseClass1;\\nvar instance1 = new ChildClass1();\\nconsole.log(\\\"instance1.function1: \\\" + instance1.function1());\\n\")), mdx(\"p\", null, \"This will print : \\\"instance1.function1: Child Instance\\\".\"), mdx(\"p\", null, \"If we remove this instance function, this will print : \\\"instance1.function1: Base Instance\\\"\"), mdx(\"p\", null, \"If we remove the base instance function, this will print: \\\"instance1.function1: Child Prototype\\\"\"), mdx(\"p\", null, \"If we remove the base prototype function, this will print: \\\"instance1.function1: Base Prototype\\\"\"), mdx(\"p\", null, \"In this last example, we were using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object.create\"), \", but also \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"new\"), \" to create the instance that we manipulate the data. If we want to avoid completely the \\\"new\\\", we need to create the child class with Object.Create. This is possible, but will require to change the child class. For example, we won't specify function 1 inside ChildClass1 function, neither call BaseClass with call. The code would look like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var BaseClass1 = function () {\\n  this.function1 = function () {\\n    return \\\"Base Instance\\\";\\n  };\\n};\\n\\nBaseClass1.prototype.function1 = function () {\\n  return \\\"Base Prototype\\\";\\n};\\n\\nvar ChildClass1 = Object.create(BaseClass1.prototype, {\\n  name3: { value: \\\"MyName3\\\" },\\n  function1: {\\n    value: function () {\\n      return \\\"Child Instance\\\";\\n    },\\n  },\\n});\\n\\nChildClass1.function1 = function () {\\n  // Must be after previous line return \\\"Child Prototype\\\";\\n};\\n\\nvar instance1 = Object.create(ChildClass1, {\\n  memberclass: { value: \\\"Child\\\" },\\n});\\n\\nconsole.log(\\\"instance1.function1: \\\" + instance1.function1());\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"2d874f52-7028-5e0a-bba0-bccad3e2b198"}},
    "staticQueryHashes": ["3159585216"]}