{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-register-model-builder-without-having-to-manually-add-them-one-by-one",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to register Model Builder without having to manually add them one by one","date":"January 31, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to register Model Builder without having to manually add them one by one\",\n  \"date\": \"2014-01-31\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When you are using Entity Framework, you must have a class that inherit \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DbContext\"), \" class at some point. Multiple options is offer to you to register to Entity Framework (EF) definition of your entities.\"), mdx(\"p\", null, \"The one we see in tutorial is based on the overridden method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"OnModelCreation\"), \" that has a single parameter of type \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DbModelBuilder\"), \". This is the entry point for all way to proceed with registration. Nevertheless, in tutorial the configuration is done directly in the method. The following code shows how it is usually done. For the purpose of being short, only a single primary key is defined for a single entity. The fact is that method can become very big.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class MyDbContext : DbContext { protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity<YourEntity>().HasKey(d => d.Id); base.OnModelCreating(modelBuilder); } } \\n\")), mdx(\"p\", null, \"This is why, the best practice is to have a single class for every entity configuration. This is done by inheriting every classes by \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EntityTypeConfiguration\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class YourEntityConfiguration : EntityTypeConfiguration<YourEntity> { public YourEntityConfiguration() { this.HasKey(d => d.Id); } } \\n\")), mdx(\"p\", null, \"Once you have your classes defined, the OnModelCreating can register them.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class MyDbContext : DbContext { protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Configurations.Add(new YourEntityConfiguration()); base.OnModelCreating(modelBuilder); } } \\n\")), mdx(\"p\", null, \"The problem is that you have to remember to register the entity and also that this method can become very huge on big project. Concerning the possibility to forget to register, Entity Framework (EF) will raise an exception saying that it does not know the entity type. It is not a big deal and the message is quite easy to understand. However, having to add this line of code become something to do in a big list of things to do. To keep it simpler, Entity Framework team thought that we could simply specify which assembly every configuration are and to look up for every classes that inherit the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EntityTypeConfiguration\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class MyDbContext : DbContext { protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Configurations.AddFromAssembly(Assembly.GetAssembly(GetType())); //Current Assembly base.OnModelCreating(modelBuilder); } } \\n\")), mdx(\"p\", null, \"The above example shows that configurations are added from an assembly. It takes a single parameter that is the assembly to look up. If you want the current assembly, use Assembly.GetAssembly(GetType()).\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"5f795f0c-1314-5a43-82bd-bfc21fa875f1","totalPages":69}},
    "staticQueryHashes": ["3159585216"]}