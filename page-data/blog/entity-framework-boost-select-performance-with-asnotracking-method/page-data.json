{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/entity-framework-boost-select-performance-with-asnotracking-method",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Entity Framework boost select performance with AsNoTracking() method","date":"September 13, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Entity Framework boost select performance with AsNoTracking() method\",\n  \"date\": \"2012-09-13\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Entity Framework provide a method that remove the tracking ability of objects which will increase the performance. Of course, the drawback is that the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DbContext\"), \" won't be able to know if an entity has changed.\"), mdx(\"p\", null, \"Let's start with a simple example. First the model which contain an ID (in BaseEntity) and a FirstName and LastName.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class Customer:BaseEntity { public string FirstName { get; set; } public string LastName { get; set; } } \\n\")), mdx(\"p\", null, \"We will add 5000 rows into the database to be able to get some time information about loading these 5000 customers into the view.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" DECLARE @count INT DECLARE @firstname varchar(100) DECLARE @lastname varchar(100)\\n\\nSET @count = 0\\n\\nWHILE (@count < 5000) BEGIN SET @firstname = 'FirstName' + cast(@count as varchar) SET @lastname = 'LastName' + cast(@count as varchar) INSERT INTO [Autoshop].[dbo].[Customers] ( [FirstName] ,[LastName] ) VALUES ( @firstname , @lastname )\\n\\nSET @count = (@count + 1) END \\n\")), mdx(\"p\", null, \"Finally, we will time the time it takes to Entity Framework to generate the loading of the object into the view.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public ViewResult Index() { var watch = new Stopwatch(); watch.Start(); var customers = db.Customers.Include(c => c.License).ToList(); watch.Stop(); ViewBag.TimeElapsed = watch.ElapsedMilliseconds; return View(customers); } \\n\")), mdx(\"p\", null, \"The result from several test give me (on my machine) \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"237ms\"), \". Now, let's do the same test with AsNoTracking().\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public ViewResult Index() { var watch = new Stopwatch(); watch.Start(); var customers = db.Customers.Include(c => c.License).AsNoTracking().ToList(); watch.Stop(); ViewBag.TimeElapsed = watch.ElapsedMilliseconds; return View(customers); } \\n\")), mdx(\"p\", null, \"Now I have an average on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"108ms\"), \". \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"It's about 2 times faster\"), \" with 5000 rows of a simple Entity.\"), mdx(\"p\", null, \"The Entity Framework's keyword \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AsNoTracking()\"), \" give a big boost of speed if you need to display data without having them tracked by Entity Framework. Most report, list or data that are display to the user as information should use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AsNoTracking()\"), \" since it removes overhead that is not used.\"), mdx(\"p\", null, \"What does AsNoTracking() behind the scene is a good question. First, AsNoTracking came from the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DbExtensions.cs\"), \" file. It's an extension method (static method) that will call the dbQuery.AsNoTracking() if the dbQuery is defined and if yes will call the AsNoTracking of this one which will simply return a new DbQuery with a parameter of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IInternalQuery\"), \" with the speciality of being AsNoTracking. This lead us to some implementation. The one that concern us is the InternalQuery that look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public virtual IInternalQuery<TElement> AsNoTracking() { return (IInternalQuery<TElement>) new InternalQuery<TElement>(this._internalContext, (ObjectQuery) DbHelpers.CreateNoTrackingQuery((ObjectQuery) this._objectQuery)); } \\n\")), mdx(\"p\", null, \"As you can see, it create a new InternalQuery with the second parameter who use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DbHelpers.CreateNoTrackingQuery(...)\"), \". The second parameter should be ObjectQuery, so what does the DbHelpers.CreateNoTrackingQuery to remove the overhead?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public static IQueryable CreateNoTrackingQuery(ObjectQuery query) { IQueryable queryable = (IQueryable) query; ObjectQuery objectQuery = (ObjectQuery) queryable.Provider.CreateQuery(queryable.Expression); objectQuery.MergeOption = MergeOption.NoTracking; return (IQueryable) objectQuery; } \\n\")), mdx(\"p\", null, \"Well it does the samething that if you has set at the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ObjectContext\"), \" property MergeOption to NoTracking. The only advantage is that it doesn't affect every \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DbContext\"), \" but only the query specified. But in Code First, you no longer have access to MergeOption since you are no longer using the ObjectContext but the DbContext. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DbContext\"), \" is a lightweight version of ObjectContext. This is why you should use now the extension AsNoTracking() instead of configuring the ObjectContext (that even if you use DbContext could be accessed).\"), mdx(\"p\", null, \"For the curious, you could access the ObjectContext from the DbContext by casting the dbContext with IObjectContextAdapter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" ObjectContext objectContext = ((IObjectContextAdapter)dbContext).ObjectContext; \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"797b98f9-685b-5890-964e-5af646bad949","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}