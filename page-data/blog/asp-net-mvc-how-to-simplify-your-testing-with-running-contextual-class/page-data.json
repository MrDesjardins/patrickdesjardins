{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/asp-net-mvc-how-to-simplify-your-testing-with-running-contextual-class",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Asp.Net MVC, How to Simplify your Testing with a Running Contextual Class","date":"February 13, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Asp.Net MVC, How to Simplify your Testing with a Running Contextual Class\",\n  \"date\": \"2015-02-13\",\n  \"categories\": [\"asp-mvc\", \"test\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A good practice is to inject a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"running context\"), \" class and a class that has information about the current user. This can be injected by your favorite injector of control container. I like dividing one for the running context and one for the current user. The first one get information about the running context and use the second one. In fact, the running context has many advantages. It allows you to easily separate from any of your code all information about how to get the user and also about the time. The time issue can become a nightmare if you are using directly DateTime.Now all over the place in your code. The problem is that you may have different timezone and you may want to facade the logic that handle it. This is often the cause if you have severs around the world. It is also the simplest way to unit test. If you want to test something about the current date, using the running context to set the \\\"current time\\\" is easier. It allows you to test all different paths. Here is an example in code of both interface. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public interface IRunningContext { string GetUserId(); string GetUserDisplayName(); DateTime GetCurrentTime(); string GetDomainNameWithPort(); }\\n\\npublic interface ICurrentUserInformation { string GetCurrentUserName(); string GetCurrentUserId(); string GetCurrentEmail(); } \\n\")), mdx(\"p\", null, \"The concrete representation of these interfaces could be one for Http that use the HttpContext for the user and the current DateTime for the time. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class HttpContextCurrentUserInformation : ICurrentUserInformation { public string GetCurrentUserName() { return HttpContext.Current.User.Identity.Name; }\\n\\npublic string GetCurrentUserId() { return HttpContext.Current.User.Identity.GetUserId(); }\\n\\npublic string GetCurrentEmail() { return \\\"\\\"; } }\\n\\npublic class HttpRunningContext:IRunningContext { private readonly ICurrentUserInformation currentUserInformation; public HttpRunningContext(ICurrentUserInformation principal) { currentUserInformation = principal; }\\n\\npublic string GetUserId() { return currentUserInformation.GetCurrentUserId(); }\\n\\npublic string GetUserDisplayName() { return currentUserInformation.GetCurrentUserName(); }\\n\\npublic DateTime GetCurrentTime() { return DateTime.Now; }\\n\\npublic string GetDomainNameWithPort() { var stringDomain = HttpContext.Current.Request.Url.Authority; return stringDomain; } } \\n\")), mdx(\"p\", null, \"Having these interface allows to easily mock those interfaces. You can have in your code initialization something that setup your running context. Here is a code with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Moq Mocking Framework\"), \". \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" protected Mock<IRunningContext> runningContext; //... [TestInitialize] public void InitializeBetweenTest() { runningContext = new Mock<IRunningContext>(); runningContext.Setup(d => d.GetCurrentTime()).Returns(new DateTime(2014, 03, 02)); runningContext.Setup(d => d.GetUserId()).Returns(ApplicationUser.SYSTEM_TEST_USER_ID); } \\n\")), mdx(\"p\", null, \"With few line of code, you can test code for different users but also different time without having to do a lots of gymnastic. For example, if you have code that must be executed only between a specific time frame, if you need to test this condition without that pattern, you are almost screw. However, having this interface being mockable allows you to modify the return's value of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetCurrentTime's\"), \" method and you are set.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"dce0a2c8-1563-56cd-baa6-feb71b62778c"}},
    "staticQueryHashes": ["3159585216"]}