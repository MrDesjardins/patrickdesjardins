{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-use-poco-object-with-entity-framework-and-use-lazy-eager-and-explicit-loading",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to use Poco Object with Entity Framework and use lazy, eager, and explicit loading","date":"March 15, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to use Poco Object with Entity Framework and use lazy, eager, and explicit loading\",\n  \"date\": \"2012-03-15\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When using Poco Object you have less stuff automatically done by Entity Framework. This doesn't mean that you have less power of this framework.\"), mdx(\"p\", null, \"You can still use Entity Framework with complex object and this, by using many different loading like lazy loading, eager loading and explicit loading.\"), mdx(\"h1\", null, \"Eager Loading with Poco\"), mdx(\"p\", null, \"Eager Loading with Entity Framework and Poco mean that the object will be loaded with 1 query but you need to specify which related object you want to load.\\nThis is pretty much the most \\\"performant\\\" way to do it if you know that you will use most of the data object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var dbContext = new NDbContext(\\\"...\\\"); \\n dbContext.Configuration.LazyLoadingEnabled = false; \\n var XYZs = dbContext.XYZs.Include(\\\"MyPropertyThatLinkToAnObjectInsideXYZObject\\\");\\n\\nforeach (var x in XYZs) { \\n  dbContext.ObjectContext().LoadProperty(x, o => o.XYZInsideObject); \\n  Console.WriteLine(\\\"x contain the subobject : \\\" + x.XYZInsideObject.Id); \\n} \\n\")), mdx(\"p\", null, \"This will produce only one query to the database that will contain a JOIN between the table of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"XYZ\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"XYZInsideObject\"), \".\"), mdx(\"h1\", null, \"Explicit loading with Poco\"), mdx(\"p\", null, \"Explicit means that you want to load on demand the information of related object. This mean that you load the information only if desired and you need to specify when to load it explicitly.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"var dbContext = new NDbContext(\\\"...\\\"); \\ndbContext.Configuration.LazyLoadingEnabled = true; \\nvar XYZs = dbContext.XYZs;\\n\\nforeach (var x in XYZs) { \\n  dbContext.ObjectContext().LoadProperty(x, o => o.XYZInsideObject); \\n  Console.WriteLine(\\\"x contain the subobject : \\\" + x.XYZInsideObject.Id); \\n} \\n\")), mdx(\"p\", null, \"As you can see, the line 7, it uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectContext()\"), \" this method is created by the developer if required when using Poco. This need to be added to your custom DbContext. Normally, this is generated by Entity Framework but since we work with Poco, it's inside the DbContext created manually.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class NDbContext : DbContext { \\n  public ObjectContext ObjectContext() { \\n    return (this as IObjectContextAdapter).ObjectContext; \\n  } \\n  //... \\n  public DbSet<XYZ> XYZs { get; set; } \\n  //... \\n} \\n\")), mdx(\"p\", null, \"DbContext hide the complexity of the ObjectContext but to use Explicit, it's require to have access to it.\"), mdx(\"h2\", null, \"Lazy loading with Poco object and Entity Framework\"), mdx(\"p\", null, \"POCO entities can have proxy objects that support change tracking or lazy loading (differed loading).\\nThat mean that for using lazy loading you need to activate to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" the property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LazyLoadingEnabled\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ProxyCreationEnabled\"), \".\\nOn particularity is that each navigation properties must be declared as public and virtual. This will work for Property to one object or any property that is inherited from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ICollection<>\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var dbContext = new NDbContext(\\\"...\\\"); \\n dbContext.Configuration.LazyLoadingEnabled = true; \\n dbContext.Configuration.ProxyCreationEnabled = true; \\n /*Default value is true, do not need to set it here*/ \\n var xyzs = dbContext.XYZs;\\n\\nforeach (var x in XYZs) { \\n  Console.WriteLine(\\\"x contain the subobject : \\\" + x.XYZInsideObject.Id); \\n} \\n\")), mdx(\"p\", null, \"If you try the code above with LazyLoadingEnabled to false, the code will crash with a NullReferenceException to the like 9, where the console try to access the property because it's not loaded.\"), mdx(\"h2\", null, \"Entity Framework with Poco\"), mdx(\"p\", null, \"Complex object are well loaded and the way you want with EF. You can lazy load which will create more query to the database as Explicit load or you can Eager load and have less query to the database but more data in the same time. What is great is that you can have all those types of technical stuff under the same project to use the good one for each different task.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"53260440-c099-5927-a780-fd55bf76f26f","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}