{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/javascript-depth-first-traversal",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Depth First Traversal","date":"July 20, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Depth First Traversal\",\n  \"date\": \"2017-07-20\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Traversing a tree by going in one path as down as possible is possible recursively or with an iteration. Let's first create a node function that will hold the information of each node.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var node = function (v, c) {\\n  return { value: v, children: c };\\n};\\n\\nvar node5 = node(\\\"node5\\\");\\nvar node4 = node(\\\"node4\\\");\\nvar node3 = node(\\\"node3\\\");\\nvar node2 = node(\\\"node2\\\", [node5]);\\nvar node1 = node(\\\"node1\\\", [node3, node4]);\\nvar graph = node(\\\"root\\\", [node1, node2]);\\n\")), mdx(\"p\", null, \"The graph is simple, and is the same that we used in the breadth first approach. The algorithm to traverse the tree doesn't need any structure since we will call recursively every children when we find one. This has the advantage to not carry a stack with us, but the disadvantage that we may want to have additional variable to not go too deep in one direction.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function depthFirstRecursive(node, callback) {\\n  callback(node);\\n  if (node.children) {\\n    for (var i = 0; i < node.children.length; i++) {\\n      var child = node.children[i];\\n      if (!child.hasBeenVisited) {\\n        depthFirstRecursive(child, callback);\\n      }\\n    }\\n  }\\n}\\n\\ndepthFirstRecursive(graph, function (node) {\\n  console.log(node.value);\\n});\\n\")), mdx(\"p\", null, \"This output : Root, Node1, Node3, Node4, Node2, Node5\"), mdx(\"p\", null, \"The iterative approach is similar. However, we loop from the length of the children array to zero. We do this if we want to have the exact same output of the recursive one. Without loop in reverse, we still do a depth first but from the right side of the tree first instead of the left side.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function depthFirstIterative(root, callback) {\\n  var stack = [];\\n  stack.unshift(root);\\n  while (stack.length > 0) {\\n    var node = stack.shift();\\n    callback(node);\\n    if (node.children) {\\n      for (var i = node.children.length - 1; i >= 0; i--) {\\n        var child = node.children[i];\\n        if (!child.discovered) {\\n          child.discovered = true;\\n          stack.unshift(child);\\n        }\\n      }\\n    }\\n  }\\n}\\n\\ndepthFirstIterative(graph, function (node) {\\n  console.log(node.value);\\n});\\n\")), mdx(\"p\", null, \"We are using unshift to push any new child at the beginning of the array (stack) and get the data from the beginning of the array to (it's a stack!).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"9f9dc254-7b1c-5906-bf6a-fc4bca5b4317","totalPages":73}},
    "staticQueryHashes": ["3159585216"]}