{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/solidjs-cleanup",
    "result": {"data":{"mdx":{"frontmatter":{"title":"SolidJS: How to Execute Code When UnMounting or when an Effect Ends","date":"March 10, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"SolidJS: How to Execute Code When UnMounting or when an Effect Ends\",\n  \"date\": \"2022-03-10\",\n  \"categories\": [\"solidjs\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I'll cover two scenarios here:\\n1) You want to execute code when your component is unmounted\\n2) You want to execute code when an effect is completed\"), mdx(\"h1\", null, \"UnMount\"), mdx(\"p\", null, \"In React, unmounting code was once upon a time the job of a dedicated method of the component class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"componentWillUnmount\"), \". With React Hooks, the unmounting moved into a function returned by an effect that is executed when mounting. It means that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" does have an empty array of dependencies. In SolidJS, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" does not exist. It is replaced with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createEffect\"), \" and it does not have a return value. Instead, we must add inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createEffect\"), \" an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onCleanup\"), \" function that will be executed when the component is removed from the DOM.\"), mdx(\"p\", null, \"A short example is when a value changes from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \" that the component is not rendered anymore, but \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \" is passed.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{2-4}\",\n    \"{2-4}\": true\n  }, \"const ChildToUnMount = () => {\\n  onCleanup(() => {\\n    console.log(\\\"ChildToUnMount UnMounted\\\");\\n  });\\n  return <div>UnMount Me Please</div>;\\n};\\n\")), mdx(\"p\", null, \"The component has a straightforward \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onCleanup\"), \" function executed only when the parent component removes it from the render function. For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{5}\",\n    \"{5}\": true\n  }, \"const App: Component = () => {\\n  const [val, setVal] = createSignal(0);\\n  return (\\n    <div>\\n      {val() === 0 ? <ChildToUnMount /> : null}\\n      <button\\n        onclick={() => {\\n          setVal((p) => p + 1);\\n        }}\\n      >\\n        Increase\\n      </button>\\n    </div>\\n  );\\n};\\n\")), mdx(\"p\", null, \"Let's explore the second case, which will solidify this first example.\"), mdx(\"h1\", null, \"Effect\"), mdx(\"p\", null, \"If you are coming from React Hooks and use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \", you know that returning a function means that the function is executed once the effect is completed. \"), mdx(\"h2\", null, \"Comparison with React\"), mdx(\"p\", null, \"Let's first establish the situation with React. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" in React is executed after the DOM is updated. If you used React before Hooks, it would have been at the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"componentDidMount\"), \" or once mounted at every update with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"componentDidUpdate\"), \". So, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" runs after each render. You can have the same code directly inside your React Hooks, but that would \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"block\"), \" the render because it is sequential (top to bottom) while rendering. With the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \", the rendering occurs, and then the effects are called.\"), mdx(\"p\", null, \"There is a possibility to return a function in each effect. The function runs when you need to clean up. It is similar to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"componentWillUnmount\"), \" but runs every time the render is about to start again. It allows cleaning up some data before a new render, with new data (new state or props) occurs.\"), mdx(\"p\", null, \"You can visualize the flow being: Mount -> clean effect -> render -> effect\"), mdx(\"p\", null, \"With SolidJS, it is a little bit different. There is no function to return to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createEffect\"), \". Instead, you must use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onCleanup\"), \" function that you can put directly inside your component or inside a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createEffect\"), \" depending on if you want the cleanup to occur during unmounting or before a new render. Here is an example that illustrates the pipeline of events.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import { Component, createEffect, createSignal, onCleanup } from \\\"solid-js\\\";\\nimport { render } from \\\"solid-js/web\\\";\\nexport interface ChildProps {\\n  val: number;\\n}\\nconst Child = (props: ChildProps) => {\\n  console.log(\\\"During render\\\");\\n  createEffect(() => {\\n    console.log(\\\"CreateEffect\\\", props.val);\\n    onCleanup(() => {\\n      console.log(\\\"CreateEffect Cleanup\\\");\\n    });\\n  });\\n  return <div>Value is: {props.val}</div>;\\n};\\nconst App: Component = () => {\\n  const [val, setVal] = createSignal(0);\\n  return (\\n    <div>\\n      <h1>Hello, world!</h1>\\n      <Child val={val()} />\\n      <button\\n        onclick={() => {\\n          setVal((p) => p + 1);\\n        }}\\n      >\\n        Increase\\n      </button>\\n    </div>\\n  );\\n};\\n\\nrender(() => <App />, document.getElementById(\\\"app\\\"));\\n\")), mdx(\"p\", null, \"The logs output this way:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"During render \\nCreateEffect \\n0\\nCreateEffect Cleanup \\nCreateEffect \\n1\\nCreateEffect Cleanup \\nCreateEffect \\n2\\nCreateEffect Cleanup \\nCreateEffect \\n3\\n\")), mdx(\"p\", null, \"We can see that the first log is the one in the function, this is the first render. Because SolidJS does not render the function on properties or state change, it is expected. The DOM is changed with the correct value because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{props.val}\"), \" difference makes the DOM change. Concerning the other logs, we can see that the first \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CreateEffect 0\"), \" is output before pushing the button. IT means that after the first rendering, the DOM is changed, and the effect is called.\"), mdx(\"p\", null, \"Then, if we click the button once, we see the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CreateEffect Cleanup\"), \", which is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onCleanup\"), \" function of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Child\"), \". That is expected. Then, we see the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CreateEffect 1\"), \" as the DOM renders the value 1.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"You can see both examples in the following interactive \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codesandbox.io/s/uncleanup-m6enu9?file=/src/index.tsx\"\n  }, \"CodeSandbox.io\"), \". What is important to remember is that SolidJS provides access for your to have custom code when a component is removed from the DOM or when a component is about to run a new effect. Both rely on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onCleanup\"), \". The point to keep in mind is to remember that there is a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"before\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"after\"), \" the DOM is changed. The \\\"DOM is changed\\\" is important because it is different from \\\"the render executed.\\\" The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onCleanup\"), \" allows you to inject custom code \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"before\"), \" the DOM is changed, the remaining of the component code (render) is executed, and then, there is a possibility to have an injection of code \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"after\"), \" the DOM is rendered.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"c63b7109-6faf-5ef7-9ced-23a95b987f62","totalPages":73}},
    "staticQueryHashes": ["3159585216"]}