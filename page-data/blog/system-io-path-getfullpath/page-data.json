{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/system-io-path-getfullpath",
    "result": {"data":{"mdx":{"frontmatter":{"title":"System.IO.Path.GetFullPath","date":"December 11, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"You manipulate paths and files with System.IO.Path which is better than trying to handle everything by string. Great! You are using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Path.Combine(\\\"c:\", \"\\\\\", \"data\", \"\\\\\", \"\\\",\\\"file.txt\\\")\"), \" everything is fine. You have understand that combining path and file are way easier with Path.Combine. It handles for you every slashes, so you do not have to handle string with substring and indexof. However, the dream stop brutally the day you have something with relative path that goes to parent folder. For example, the example below crash. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" Path.Combine(\\\"c:\\\\\\\\data\\\\\\\\\\\",\\\"..\\\\\\\\file.txt\\\") \\n``` Having double dot return the the c: drive in the example above, but combine will not do it for you. THis is why you need to use **Path.GetFullPath**. \\n```csharp\\n Path.GetFullPath(\\\"c:\\\\\\\\data\\\\\\\\..\\\\\\\\file.txt\\\") \\n``` This will clean the path and output _c:\\\\\\\\file.txt_.\\n\\nThe conclusion is that file path manipulation must still use the System.IO.Path but different methods should be used depending of the case you are encountering.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"System.IO.Path.GetFullPath\\\",\\\"date\\\":\\\"2014-12-11\\\",\\\"categories\\\":[\\\"c-sharp\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"ca0ab313-2c02-5755-892d-b9b95d87e18f","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}