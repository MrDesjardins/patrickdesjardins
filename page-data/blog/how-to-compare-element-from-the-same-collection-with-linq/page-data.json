{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-compare-element-from-the-same-collection-with-linq",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to compare element from the same collection with Linq?","date":"December 11, 2011"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to compare element from the same collection with Linq?\",\n  \"date\": \"2011-12-11\",\n  \"categories\": [\"c-sharp\", \"linq\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Lets imagine that you have a collection with a class containing Images. All images are identified by an unique key and a caption that the user enter. You want to verify that the caption entered by the user is unique to the collection. How to do it?\"), mdx(\"p\", null, \"This can be done with Linq to Object pretty easily by using 2 from statement.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var hasDouble = (from s1 in this.Images from s2 in this.Images where s1.Key != s2.Key && s1.Caption == s2.Caption select new { Image1 = s1, Image2 = s2 }).Any(); \\n\")), mdx(\"p\", null, \"This will loop through all the images and will compare the caption of all shape but not compare node with itself. I have created an anonymous object because in fact, I may want to get those 2 elements that have the same caption. In that case I just need to call the same code and remove the .Any().\"), mdx(\"p\", null, \"This can be translated to Lambda expression. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" (this.Shapes.SelectMany(s1 => this.Images, (s1, s2) => new{s1, s2}) .Where(tt => tt.s1.Key != tt.s2.Key && tt.s1.Caption == tt.s2.Caption) .Select(tt => new { Image1 = tt.s1, Image2 = tt.s2} ) \\n\")), mdx(\"p\", null, \"But for this kind of task, Lambda is more confusing from my point of view.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"ac3023cd-9a73-5b09-8a47-820e7966e2d1","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}