{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-iterators-generator-functions-an-infinite-stream-of-data",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript Iterators, Generator Functions and Infinite Stream of Data","date":"April 7, 2023"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript Iterators, Generator Functions and Infinite Stream of Data\",\n  \"date\": \"2023-04-07\",\n  \"categories\": [\"typescript\", \"iterator\", \"iterative\", \"loop\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"We discussed about \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/blog/understand-typeScript-iterator-and-iterable\"\n  }, \"TypeScript Iterator and Iterable\"), \" in a recent blog article. Today, we introduce generator functions that are a step further into iterable behavior in TypeScript.\"), mdx(\"h1\", null, \"What is a TypeScript Generator Function?\"), mdx(\"p\", null, \"Similar to a normal TypeScript function, a generator returns a value. However, a generator can return many values. A generator function is a function that returns a non-deterministic amount of values until the function calls the known \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \" keyword with the final value that will terminate the iterator.\"), mdx(\"h1\", null, \"What is the Goal of TypeScript Generator Functions?\"), mdx(\"p\", null, \"The goal is to provide a simpler syntax to the language by providing a mechanism for transmitting data without knowing how to navigate the data stream or data structure. The goal perfectly matches the iterable concept where we are not limited to iterating data linearly from one index to another. \"), mdx(\"h1\", null, \"What is the Similitude with TypeScript Iterable?\"), mdx(\"p\", null, \"The main similitude is that the TypeScript Generator Functions rely on an object with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function.\"), mdx(\"p\", null, \"Before elaborating on TypeScript Generator, let's define a simple example. In the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/blog/understand-typeScript-iterator-and-iterable\"\n  }, \"TypeScript Iterator and Iterable\"), \" article, the first example was to iterate on a random amount of data. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"const myIterable: Iterable<number> = {\\n  [Symbol.iterator]: () => {\\n    let index = 0;\\n    const end = 3 + Math.random() * 7; // Max will be 10\\n    const myIterator: Iterator<number> = {\\n      next: () => {\\n        if (index >= end) {\\n          return {\\n            value: null,\\n            done: true,\\n          };\\n        } else {\\n          index++;\\n          return {\\n            value: index - 1, // Value is [0 to 9]\\n            done: index >= end,\\n          };\\n        }\\n      },\\n    };\\n    return myIterator;\\n  },\\n};\\n\\nfor (const c of myIterable) {\\n  console.log(`Value is: ${c}`);\\n}\\n\")), mdx(\"p\", null, \"Let's migrate this example with a TypeScript generator function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function* myGenerator() {\\n  let index = 0;\\n  const end = 3 + Math.random() * 7; // Max will be 10\\n\\n  while (index < end) {\\n    // Smaller here because we will return that last value with return\\n    yield index;\\n    index++;\\n  }\\n  return index;\\n}\\n\\nfor (const c of myGenerator()) {\\n  console.log(`Value is: ${c}`);\\n}\\n\")), mdx(\"p\", null, \"Full code in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codesandbox.io/p/sandbox/blog-iterator-example-3-forked-yeefmd\"\n  }, \"CodeSandBox\"), \".\"), mdx(\"p\", null, \"A few details in this generator function:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The function has a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"*\"), \" after the name. It marks the function has a generator.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The function can use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"yield\"), \" to return value without stopping the function\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"There is a bug in the code above! \")), mdx(\"p\", null, \"The bug in the function above is that the last index is never displayed by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for of\"), \" loop. So let's change the code to clarify the bug.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"// Generator Function\\nfunction* myGenerator() {\\n  let index = 0;\\n  const end = 5;\\n\\n  while (index < end) {\\n    // Smaller here because we will return that last value with a return\\n    yield index;\\n    index++;\\n  }\\n  return index;\\n}\\n\\nconsole.log(\\\"Automatically\\\");\\nfor (const c of myGenerator()) {\\n  console.log(`Value is: ${c}`);\\n}\\n\\nconsole.log(\\\"Manually\\\");\\nconst g = myGenerator();\\nconsole.log(g.next().value); // 0\\nconsole.log(g.next().value); // 1\\nconsole.log(g.next().value); // 2\\nconsole.log(g.next().value); // 3\\nconsole.log(g.next().value); // 4\\nconsole.log(g.next().value); // 5\\nconsole.log(g.next().value); // undefined\\n\")), mdx(\"p\", null, \"The first time, the code prints with the loop. The console shows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"Automatically\\nValue is: 0\\nValue is: 1\\nValue is: 2\\nValue is: 3\\nValue is: 4\\n\")), mdx(\"p\", null, \"The second part shows that we manually call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next().value\"), \". The output shows the value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"5\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"Manually\\n0\\n1\\n2\\n3\\n4\\n5\\n\")), mdx(\"h1\", null, \"Injection of Values inside the Generator Function\"), mdx(\"p\", null, \"In the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/blog/understand-typeScript-iterator-and-iterable\"\n  }, \"TypeScript Iterator and Iterable\"), \" previous article, we discovered that a sibling function to  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \", named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \", allows to inject data back into the iterator. Similarly, the generator function has a mechanism to inject value inside the iterator. However, it is with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" function this time. The following code demonstrates that we can alter the previous example and provide a value to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \". In this modification, when the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" has a value, it is used as the incrementor instead of incrementing of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \". \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function* myGenerator() {\\n  let index = 0;\\n  const end = 8;\\n\\n  while (index < end) {\\n    // Smaller here because we will return that last value with return\\n    const increment = yield index;\\n    index += increment ?? 1; // When not provided, return undefined. Using ?? change undefined to 1.\\n  }\\n  return index;\\n}\\n\\nconst g = myGenerator();\\nconsole.log(g.next().value); // 0\\nconsole.log(g.next().value); // 1\\nconsole.log(g.next(2).value); // 3\\nconsole.log(g.next(3).value); // 6\\nconsole.log(g.next().value); // 7\\nconsole.log(g.next().value); // 8\\n\")), mdx(\"p\", null, \"Because we are passing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2\"), \" instead of doing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1 + 1\"), \", it does \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1 + 2\"), \". Thus, the value returned is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"3\"), \". Then, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next(3)\"), \" tells the code to do \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index += 3\"), \" which makes the value 3+3 to be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"6\"), \". You can see the code in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codesandbox.io/p/sandbox/blog-typescript-generator-function-example-2-forked-od9o2w\"\n  }, \"CodesandBox\")), mdx(\"h1\", null, \"Injecting an Error Inside the Generator Function\"), mdx(\"p\", null, \"Similarly to injecting value inside the generator function, it is possible has the consumer to notify the function that something is wrong by calling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"throw\"), \" function. Again, the goal is to inject logic when something goes wrong. For example, if your server crashes you should close the connection to the source that is yielding results.\"), mdx(\"p\", null, \"Here is a simple example: if there is an exception, the index returns to zero.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function* myGenerator() {\\n  let index = 0;\\n  const end = 8;\\n\\n  while (index < end) {\\n    // Smaller here because we will return that last value with a return\\n    try {\\n      const increment = yield index;\\n      index += increment ?? 1;\\n    } catch (e) {\\n      index = 0;\\n    }\\n  }\\n  return index;\\n}\\n\\nconst g = myGenerator();\\nconsole.log(g.next().value); // 0\\nconsole.log(g.next().value); // 1\\nconsole.log(g.next(2).value); // 3\\nconsole.log(g.next(3).value); // 6\\ng.throw(\\\"Error here\\\");\\nconsole.log(g.next().value); // 1\\nconsole.log(g.next().value); // 2\\n\\n\")), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"try\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"catch\"), \" block must surround the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" code inside the function generator. When the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"throw\"), \" function is called, the execution of the generator function goes into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"catch\"), \". In this example, we reset the index to zero. Full code in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codesandbox.io/p/sandbox/blog-typescript-generator-function-example-2-forked-tbf55u\"\n  }, \"CodeSandbox\"), \".\"), mdx(\"h1\", null, \"Completing a Generator Function\"), mdx(\"p\", null, \"In many scenarios, looping the iterable content will naturally end by having the generator function stop yielding and returning. However, in many other scenarios, there is no \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"official ending\"), \". It loops (literally loop) forever, waiting for events to happen. As the consumer of that continuous function, we may want to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"close\"), \" the data stream. The way to do it is to call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \" function. Calling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \" function sets the internal iterator to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"done: true\"), \", meaning that any potential access to the iterator would result in a terminated iterator. The only way to start again would be to create a new iterator.\"), mdx(\"p\", null, \"Note that if the generator function never returns and does not have a looping mechanism that one the last \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" the function will complete as the next time the consumer calls the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \", it would resolve into a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"done: true\"), \" with an undefined value.\"), mdx(\"h1\", null, \"Generator Function Usage\"), mdx(\"p\", null, \"Generator functions are rarely used. Use cases of streaming data require a use case where you have your own data structure or are building a streaming data mechanism. In both cases, most developers would consume a tool that acts rather than creating one. As a result, few frameworks leverage the mechanism like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://redux-saga.js.org/docs/basics/DeclarativeEffects\"\n  }, \"Redux Saga\"), \". However, because most people are unfamiliar, frameworks that leverage the mechanism start one step behind as the learning curve increases from the get-go. Another reason the adoption of generator functions is not mainstream is that it was officially supported only with ECMAScript 6.\"), mdx(\"p\", null, \"Using an iterable/iterator approach or the generator function is a matter of preference. The generator function offers a syntactic shortcut to achieve the same goal. With the generator function, you avoid having to worry about \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Symbol\"), \" and define up to three functions (next, throw, return) and work with the object that has the value and state of the iterator.\"), mdx(\"h1\", null, \"Performance\"), mdx(\"p\", null, \"A glance suggests that an infinite data stream may cause the system to fall into a stack overflow or take all the computer resources. However, generator functions are lazily evaluated. A lazily evaluated code means that the execution of the code only happens when the code is actively invoked. In the case of the generator function, the code is only executed when someone calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \". Indeed, if we are running inside a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for of\"), \" loop, it would result in some performance issues as the code will continually call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \". However, the following code is fine if the consumer calls it at a reasonable pace.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function* myGenerator() {\\n  let index = 0;\\n\\n  while (true) {\\n    yield index;\\n    index++;\\n  }\\n}\\n\")), mdx(\"p\", null, \"The reason is that the loop goes into an iteration only when the consumer call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"const g = myGenerator();\\nconsole.log(g.next().value); // 0\\nconsole.log(g.next().value); // 1\\n\")), mdx(\"p\", null, \"Thus, the code is looping twice and not infinitely. Using the same generator function, we can loop for ten milliseconds and see hundreds of iteration before the generator stop yielding and wait for a future call.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"const g = myGenerator();\\nconst t = Date.now();\\nwhile (Date.now() - t < 10) {\\n  console.log(g.next().value);\\n}\\n// We can also close the iteration\\nconsole.log(g.return()); //  {value:undefined, done:true}\\nconsole.log(g.next().value); // Undefined\\n\")), mdx(\"p\", null, \"Code in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codesandbox.io/p/sandbox/blog-typescript-generator-function-example-3-forked-9mvcc6\"\n  }, \"CodeSandbox\")), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"TypeScript has supported generator functions for many months, and as the standard goes up in stage are more widely available to use as they are integrated natively into browsers. Generator functions are a tool in the developer's toolbox to be aware of and can be helpful in case you are working with a stream of data or process-intensive tasks that can be broken down into sub-tasks, which the consumer can call at a wise pace. \"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"91383846-e8ae-5c7d-bdf2-e940de053edc","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}