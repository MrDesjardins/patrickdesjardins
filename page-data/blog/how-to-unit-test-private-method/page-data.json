{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-unit-test-private-method",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to unit test private method","date":"August 10, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to unit test private method\",\n  \"date\": \"2015-08-10\",\n  \"categories\": [\"test\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is something that I got asked from little start-up up to Microsoft. How to you test private method? I often see horrible things. For example, if your class as 1 public method that call 5 privates method and you want to unit test 1 of the 5 methods, calling the public method to do so is wrong. Something can change anywhere in the class and break that test. Also, creating test this way is painful because it takes time to setup all variables to value that make all others method not fail. Once you reach the method you want to test you can start really testing what you are there for. An other horrible thing is to start using advanced shimming stuff that rely on reflection. The solution is simple : create more cohesive classes.\"), mdx(\"p\", null, \"I think an example is better before continuing about how to divide code to help creating more efficient unit test. Here is a snippet that illustrate many problem. We have an Order class that has a list of item that can be bought. At some point, we want to pass a transaction so we have a method called Purchase which return the list of item that we can really purchase based on different business logic. For example, we allows only item that is between 0$ and 100$ to be bought, only item that is not discontinued, we can only buy 1 item of any kind per transaction, not more than 3 items at the same time can be in the basket and finally nothing above an order of 50$ is allowed (so we only add item to be purchase under 50$).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class ShoppingBasket { public List<Item> Items { get; set; }\\n\\npublic List<Item> Purchase() { var canBeBought = new List<Item>(); foreach (var item in Items) { bool canBuy = true; if (item.Money < 0 || item.Money > 100) { canBuy = false; }\\n\\nif (item.IsDiscontinued) { canBuy = false; }\\n\\nif (!this.IsUnique(item.Id)) { canBuy = false; }\\n\\nif (this.IsShoppingBasketFull()) { canBuy = false; }\\n\\nif (this.HasReachMaximumAmountPerOrder(canBeBought)) { canBuy = false;\\n\\n} if (canBuy) { canBeBought.Add(item); } } return canBeBought; }\\n\\nprivate bool IsUnique(int id) { return this.Items.Count(d => d.Id == id) > 1; }\\n\\nprivate bool IsShoppingBasketFull() { return this.Items.Count >= 5; }\\n\\nprivate bool HasReachMaximumAmountPerOrder(List<Item> canBeBought) { return canBeBought.Sum(d=>d.Money) > 50; } }\\n\\npublic class Item { public int Id { get; set; }\\n\\npublic double Money { get; set; }\\n\\npublic bool IsDiscontinued { get; set; } } \\n\")), mdx(\"p\", null, \"If you want to test if the Lambda expression is well formed for the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IsUnique\"), \" method, you will have to create a list of items and pass it to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ShoppingBasket\"), \" class. So far, this is fine. However, you cannot call the method IsUnique because this one is private. You have two choices. You break the encapsulation of the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ShoppingBasket\"), \" by changing the visibility from private to public or you refactor your class to something more testable, more cohesive and more object oriented. Changing the encapsulation is fine. In fact, in that case it does not really matter because it does not disrupt the system. Someone could call \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IsUnique\"), \" any time and it does not change any operational flow. However, is it really the responsability of the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ShoppingBasket\"), \" to handle the unique?\"), mdx(\"p\", null, \"Let's start trying to unit test this actual code to illustrate how it is not a good idea to test through the public method to reach a private method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" [TestMethod] public void TestIfIsUniqueMethodWorksWhenListHasNotUniqueItem() { // Arrange var shoppingBasket = new ShoppingBasket(); var item1 = new Item() {Id = 1, IsDiscontinued = false, Money = 5}; var item2 = new Item() {Id = 2, IsDiscontinued = false, Money = 10}; var item3 = new Item() {Id = 3, IsDiscontinued = false, Money = 50}; var item4 = new Item() {Id = 1, IsDiscontinued = false, Money = 5}; shoppingBasket.Items = new List<Item> {item1, item2, item3, item4};\\n\\n// Act var itemThatWeCanPurchase = shoppingBasket.Purchase();\\n\\n// Assert Assert.AreEqual(2, itemThatWeCanPurchase.Count); } \\n\")), mdx(\"p\", null, \"You will tell me that this is fine. In fact, it is. In that case the problem is not the amount of preparation. It is often the case, but not that time. The problem is that if tomorrow the threshold of 50$ go down to 10$ that this unit test will fail. Right now, the item id 2 and 3 are returned but if this limit goes from 50$ to 10$ than the id 2 is out which will return only one item. The unit test about unique fail because of the maximum amount per order. This is wrong.\"), mdx(\"p\", null, \"A unit test must test a unit. It has to test a single thing. It has to be atomic. This is why we need to refactor that code.\"), mdx(\"p\", null, \"The first thing to do is to ask who is the expert of the field for each logic. The first logic concern the logic about that we can only buy item with money between 0$ and 100$. This raise multiple questions.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Is it a shopping basket logic?\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Does that logic is universal on the software we are building or just for specific case? Does this range may change during the lifetime of this software?\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Do we have different kind of Item?\")), mdx(\"p\", null, \"The first question make sense. Maybe depending of the type of shopping basket that logic can change. For example you could have \\\"SmallShoppingBasket\\\" and a \\\"BigShoppingBasket\\\" and depending of the basket the threshold change. This is why we cannot build a software without knowing the specification: the code changes depending of what are the rules. Creating a generic system for all case increase the time to build this one by a huge magnitude of time. That said, for that first condition, we need to extract that code out of the loop in all case. The reason is that this condition is independent of all items -- it is a condition on a single item. Since we are not planning to have multiple basket and the amount belong to an item, for that use case, it makes sense to set the condition inside the Item class. This change result having one more method in Item and the unit test to call that method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class Item { public int Id { get; set; }\\n\\npublic double Money { get; set; }\\n\\npublic bool IsDiscontinued { get; set; }\\n\\npublic bool IsPriceLegitForPurchase() { return this.Money < 0 || this.Money > 100; } } \\n\")), mdx(\"p\", null, \"The second condition is checking if the item is discontinued. The call is already on the item which is great. However, already have a condition on the item done one line above since our last refactoring on the price.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" foreach (var item in Items) { bool canBuy = true; if (!item.IsPriceLegitForPurchase()) { canBuy = false; }\\n\\nif (item.IsDiscontinued) { canBuy = false; } // ... \\n\")), mdx(\"p\", null, \"Instead of calling twice the item we should think. These two operations has something in common: it validates the item for purchase. We should have a method in the item that does that for us. Not only it will self-document what it is going on but that logic could be reused later without having to duplicate both calls. We end up having a single validation method for purchase in item. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public bool IsValidForPurchase() { if (!this.IsPriceLegitForPurchase()) { return false; }\\n\\nif (this.IsDiscontinued) { return false; } return true; } \\n\")), mdx(\"p\", null, \"The test is also clearer. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" //... if(!item.IsValidForPurchase()) { canBuy = false; } //... \\n\")), mdx(\"p\", null, \"The third condition was to check if the shopping basket is full. The logic belong to the basket because this one is the one who know its size, which is 5. The problem is that when we will test that logic, we do not want to have to create items that necessary pass condition for \\\"IsValidForPurchase\\\" method. We just want to create a list of item and test the count. That said, this is a perfect case that this method should be public.\"), mdx(\"p\", null, \"The next condition is about if the list of item that is valid to purchase has still some place to add additional item. This is an interesting case. This logic does not belong to item, it belongs to the list. It means that this list is an entity which some properties, states, etc.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class ItemValidToPurchase : List<Item> { public bool HasReachMaximumAmountPerOrder() { return this.Sum(d => d.Money) > 50; } } \\n\")), mdx(\"p\", null, \"The condition in the Shopping Basket is just to call the method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" if (canBeBought.HasReachMaximumAmountPerOrder()) { canBuy = false; } \\n\")), mdx(\"p\", null, \"So the final code looks like this for the test \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"about unique\"), \". \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"private ShoppingBasket GetShoppingBasket() { var shoppingBasket = new ShoppingBasket(); var item1 = new Item() {Id = 1, IsDiscontinued = false, Money = 5}; var item2 = new Item() {Id = 2, IsDiscontinued = false, Money = 10}; var item3 = new Item() {Id = 3, IsDiscontinued = false, Money = 20}; var item4 = new Item() {Id = 1, IsDiscontinued = false, Money = 5}; shoppingBasket.Items = new List<Item> {item1, item2, item3, item4}; return shoppingBasket; }\\n\\n[TestMethod] public void TestIfIsUniqueMethodWorksWhenListHasNotUniqueItem() { // Arrange var shoppingBasket = this.GetShoppingBasket();\\n\\n// Act var isUnique = shoppingBasket.IsUnique(1);\\n\\n// Assert Assert.IsFalse(isUnique); }\\n\\n[TestMethod] public void TestIfIsUniqueMethodWorksWhenListHasUniqueItem() { // Arrange var shoppingBasket = this.GetShoppingBasket();\\n\\n// Act var isUnique = shoppingBasket.IsUnique(2);\\n\\n// Assert Assert.IsTrue(isUnique); } \\n\")), mdx(\"p\", null, \"And the classes code look. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class Item { public int Id { get; set; }\\n\\npublic double Money { get; set; }\\n\\npublic bool IsDiscontinued { get; set; }\\n\\npublic bool IsPriceLegitForPurchase() { return this.Money < 0 || this.Money > 100; }\\n\\npublic bool IsValidForPurchase() { if (!this.IsPriceLegitForPurchase()) { return false; }\\n\\nif (this.IsDiscontinued) { return false; } return true; } } public class ItemValidToPurchase : List<Item> { public bool HasReachMaximumAmountPerOrder() { return this.Sum(d => d.Money) > 50; } } public class ShoppingBasket { public List<Item> Items { get; set; }\\n\\npublic ItemValidToPurchase Purchase() { var canBeBought = new ItemValidToPurchase(); foreach (var item in Items) { bool canBuy = true; if(!item.IsValidForPurchase()) { canBuy = false; }\\n\\nif (!this.IsUnique(item.Id)) { canBuy = false; }\\n\\nif (this.IsShoppingBasketFull()) { canBuy = false; }\\n\\nif (canBeBought.HasReachMaximumAmountPerOrder()) { canBuy = false; }\\n\\nif (canBuy) { canBeBought.Add(item); } } return canBeBought; }\\n\\npublic bool IsUnique(int id) { return this.Items.Count(d => d.Id == id) == 1; }\\n\\npublic bool IsShoppingBasketFull() { return this.Items.Count >= 5; } } \\n\")), mdx(\"p\", null, \"As you can see, the condition has changed on the IsUnique method. Because and error was present and only could have been detected with a valid set of unit test on that method. We could go even further by refactoring even more this code. I'll write a second post about what we could have done with a more flexible code that allow to have dynamic validation using other design pattern.\"), mdx(\"p\", null, \"You can find the initial code and the final code in this \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/UnitTestPrivateMethods\"\n  }, \"Git Repository\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"00ed9d58-343d-5545-b6bf-373304da6191","totalPages":75}},
    "staticQueryHashes": ["3159585216"]}