{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/linq-to-entity-to-get-the-number-of-day-between-two-dates",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Linq to Entity to get the number of day between two dates","date":"May 8, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Linq to Entity to get the number of day between two dates\",\n  \"date\": \"2014-05-08\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you want to have the amount of day between two dates, you can get those dates back to C\", \"#\", \" and do the difference between them. However, it is possible to tell Sql Server to do it for you by Linq To Entity.\"), mdx(\"p\", null, \"It has change since \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Entity Framework (EF) 6\"), \". You have to use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://msdn.microsoft.com/en-us/library/system.data.entity.dbfunctions_methods(v=vs.113).aspx\"\n  }, \"DbFunctions class\"), \" now to execute complex operations to Sql Server.\"), mdx(\"p\", null, \"The operation that interest us is named \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DiffDays\"), \". It takes two parameters. The first one is the smallest date, the second one is the biggest date. If you invert these parameters, the count will be negative.\"), mdx(\"p\", null, \"Here is an example of use:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"var allActiveContest = GetAllActiveContestForUser(userId) .Select(d=>new ContestWithSmallStatistics(){ Id=d.Id, Name=d.Name, NumberOfDaysRemainingBeforeEndDate = DbFunctions.DiffDays(d.RegistrationRules.StartingTime,d.RegistrationRules.EndingTime).Value, NumberOfUsersRegistered = d.Contester.Count }); \\n\")), mdx(\"p\", null, \"The main advantage is that you can have from the database exactly what you want instead of having a class that would have two dates. You could also use it for having some logics that will not return everything. For example, we could return only Active Contest for contest that has more than 30 days.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"5db4388d-001b-5294-88ea-9d5d09472d2f","totalPages":75}},
    "staticQueryHashes": ["3159585216"]}