{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/javascript-linear-search",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Linear Search","date":"June 12, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Linear Search\",\n  \"date\": \"2017-06-12\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Linear search is a basic search that is slow. Slow in the magnitude of having an asymptotic analysis of a BigO of O(n). This is the worse case is that the item is at the last position which require to traverse the whole array. Linear search moves one to one and check the value. It has the advantage of not needing to have an input sorted.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var arrayToSearch = [7, 23, 4, 23, 87, 2, 6, 3, 213, 43, 34, 1, 76, 43];\\n\\nconsole.log(\\\"Found at position :\\\" + linearSearch(arrayToSearch, 34));\\n\\nfunction linearSearch(arrayToSearch, valueToSearch) {\\n  var length = arrayToSearch.length;\\n  for (var i = 0; i < length; i++) {\\n    if (arrayToSearch[i] === valueToSearch) {\\n      return i;\\n    }\\n  }\\n  return -1;\\n}\\n\")), mdx(\"p\", null, \"Here is a naive implementation where -1 is returned in the case of no element found. As you can see, the function is under the invocation of the function. This is possible because of JavaScript's hoisting mechanism that move function declaration at the beginning of the scope (not function expression).\"), mdx(\"p\", null, \"A recursive solution is also possible :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"console.log(\\\"Found at position :\\\" + linearSearch(arrayToSearch, 34, 0));\\nfunction linearSearch(arrayToSearch, valueToSearch, index) {\\n  if (arrayToSearch.length === 0) {\\n    return -1;\\n  }\\n  if (arrayToSearch[0] === valueToSearch) {\\n    return index;\\n  }\\n  return linearSearch(arrayToSearch.slice(1), valueToSearch, index + 1);\\n}\\n\")), mdx(\"p\", null, \"The idea is to recursively remove the first element of the array and pass it down to the method again and again until the array is empty or the value is found.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"86defcf4-25b8-545f-945c-3a8bc3327d47","totalPages":69}},
    "staticQueryHashes": ["3159585216"]}