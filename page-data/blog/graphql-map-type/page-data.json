{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/graphql-map-type",
    "result": {"data":{"mdx":{"frontmatter":{"title":"GraphQL Map Type","date":"May 20, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"GraphQL Map Type\",\n  \"date\": \"2022-05-20\",\n  \"categories\": [\"graphql\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The battle between science and art in software engineering is constantly appearing. On one end, softwares are based on scientific mathematical concepts. On the other end, it lies in opinions and personal preferences. However, regardless of your situation, you must decide and move on. This article will describe many solutions to handle maps with GraphQL. We will expose the pros and cons of each of them. Finally, we will identify a satisfactory solution for most cases, which I strongly recommend following.\"), mdx(\"h1\", null, \"Preface\"), mdx(\"p\", null, \"The topic of map is controversal in GraphQL because the GraphQL standard does \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/graphql/graphql-spec/issues/101\"\n  }, \"not support the idea of a key-value\"), \" structure. In some language it is called a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\"\n  }, \"Map\"), \", in some other it is called a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-6.0\"\n  }, \"Dictionary\"), \".\"), mdx(\"h1\", null, \"Example\"), mdx(\"p\", null, \"Before getting into a concrete solution, let's define a structure of the types that will help us determine what a request and a response would look like for each solution.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\"\n  }, \"type City {\\n  name: String!\\n  citizens: [Person!]\\n  # Need a map from PersonID -> House\\n}\\n\\ntype House {\\n  address: String!\\n  city: City!\\n  owners: [Person!]!\\n}\\n\\ntype Person {\\n  id: String!\\n  name: string!\\n  houseOwner: House\\n}\\n\")), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"431px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/f106053e75b205ffc4d8f5f2290224cf/9cb4e/graphql_map-example-entities.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"60.66666666666667%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABY0lEQVQoz22T666CQAyE9/1fTcMPYxQxalBRwCt4BdSar0nNHg5NmnVtd3ZmtrjtdiuPx0P2+71EUSTX61VOp5OkaSrUPp+P5vv91iQ2m42UZSmHw0H6/b7MZjMpikJ2u524yWQiq9VKWKfTqRyPR835fC55nuvB8/msl5DswzDU/jiOdV0ul3K/35WMG4/HMhqNJAgCBeYwgFmW/dj5LAmYDwYDVcRZGF4uF2Xu6rpW9CRJVPbz+dT96/WSrgAUJoACCGPOQIZ0fjNF0gJWtloS6/VaUIZndg4PCdduvt1uKtnkteuseIsyAouwx2rObyTstbnd/vODelVVP2ZI9y92/oZomkbZmclIYaxIXhP2sIOVgfmE/njoM4Ih5sOi1+vpqLCHIQ+4WCz08rbXru2TFXkxjB8Oh/obIOYQ1uy7Hu4fQ79gkgBAvoXNaRdYp2QfEHZ8CQwxnxkS8dRGxO83wC8MJpsXsh/qHAAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"graphql map example entities\",\n    \"title\": \"graphql map example entities\",\n    \"src\": \"/static/f106053e75b205ffc4d8f5f2290224cf/9cb4e/graphql_map-example-entities.png\",\n    \"srcSet\": [\"/static/f106053e75b205ffc4d8f5f2290224cf/5a46d/graphql_map-example-entities.png 300w\", \"/static/f106053e75b205ffc4d8f5f2290224cf/9cb4e/graphql_map-example-entities.png 431w\"],\n    \"sizes\": \"(max-width: 431px) 100vw, 431px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The model is simple -- three entities. There is a top entity that is a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"City\"), \". It has a primitive scalar type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" and requires a map with a key that will be the owner's unique identifier (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PersonId\"), \") to a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"House\"), \". It is also possible to get the complete list of people living in the city.\"), mdx(\"p\", null, \"The house references the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"City\"), \" and a list of owners.\"), mdx(\"p\", null, \"Finally, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" entity has few properties but can also have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"House\"), \" optionally.\"), mdx(\"h1\", null, \"Solution #1: Store the Map into a Single String\"), mdx(\"p\", null, \"A solution is to store the whole map in a single string. The concept is to mark the map as a string and serialize the entire map into a string.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\",\n    \"metastring\": \"{4}\",\n    \"{4}\": true\n  }, \"type City {\\n  name: String!\\n  citizens: [Person!]\\n  personToHouse: String!\\n}\\n\")), mdx(\"p\", null, \"From the GraphQL server-side point of view, it is simple: you serialize the whole map. For example, if you are using Java:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"ObjectMapper mapper = new ObjectMapper();\\nString jsonResult = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(map);\\n\")), mdx(\"p\", null, \"If you are building the GraphQL server is TypeScript, you take the whole map and call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JSON.stringify()\"), \" if you are using a JS Object or use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/29085197/how-do-you-json-stringify-an-es6-map\"\n  }, \"something more complex\"), \" if you are using the ES6 Map. In all cases, it is pretty straightforward.\"), mdx(\"p\", null, \"Also, from the server-side perspective, it is convenient because it does not require creating any additional GraphQL type. It's a one-solution shop where any map is transformed into a single type: a string.\"), mdx(\"h2\", null, \"Limitations\"), mdx(\"p\", null, \"From the GraphQL client-side, it gets tricky.\"), mdx(\"h3\", null, \"Limitation #1: Un-Document the Graph\"), mdx(\"p\", null, \"First of all, you need \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"to know\"), \" that the string is a structure that must be deserialized. Suddenly, the concept breaks one of the strengths of GraphQL. There is always the possibility to create a custom scalar to differentiate a JSON structure from a String. The problem is that their JSON can still be from any shape, and without performing the query and observing, it is impossible to know from the client-side. Also, if the structure changes depending on external factors, nasty surprises can occur on the consumption side.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\"\n  }, \"scalar JSON\\n\")), mdx(\"p\", null, \"Furthermore, the client-side must deserialize the content of the string properly. Beyond executing the deserialization, it implies handling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JSON\"), \" scalar with a custom CodeGen policy and using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"typePolicies\"), \" for Apollo \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InMemoryCache\"), \" if you want a clean solution does not make the client-side have custom management of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JSON\"), \" type at each server calls. In this previous article, you can read more about \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"typescript-codegen-graphql-custom-scalar\"\n  }, \"CodeGen and Apollo Custom Scalar\"), \". The one-liner is: that it is not simple for the consumer, and the solution varies depending on the consumer technologies to query the GraphQL server.\"), mdx(\"h3\", null, \"Limitation #2: Reduce Discovery and Remove Fields Picking\"), mdx(\"p\", null, \"Second, there is a typing issue. The generated type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"City\"), \" will have a property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"personToHouse\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \". It is impossible to specify which property you want to consume.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\",\n    \"metastring\": \"{3}\",\n    \"{3}\": true\n  }, \"query SolutionOne {\\n  city(name: \\\"SanJose\\\") {\\n    personToHouse { # \\uD83D\\uDED1 Error\\n      name # \\uD83D\\uDED1 Error\\n    } # \\uD83D\\uDED1 Error\\n  }\\n}\\n\")), mdx(\"p\", null, \"As you can see, writing the query failed at design time. You cannot specify the field you want to use: the value is a string. Hence, you are forced to return the whole object. Replacing the entire object is subjective to whom is writing the server-side that returns the object. For some engineers, it means returning only the primitive types. For others, only the primary key for the children is to avoid expanding the tree of objects too deep.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"281px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/7e951ea3b113fdb50ec4993db77db82c/6b1e2/graphql_map-tree-nodes.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"135.58718861209965%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEF0lEQVRIx5WV6XLbNhSF+f7vlEmXH/EknXSy2K418iKJEvcFJLERBL8WkK0mmaZNMXMI4OLi8C7ARbI5CIrOkLeaepipx4VTozjWiqzRHGuJWzyhret6wfdacmo0syeibgf2aYZ1RMwL5K1k8etXhN+OvyI8VPK82cOpqLl6+55JO/QMdoF91rI/pMzzfNn0b6TJoZQo6xHSIS0YD4NaEGph1J5aWMZJkh4O5Hl+2ei9/yoEL0hqoWkHQzMYsnrkfl9EkrLTNMIgJnshqaqKzWZD3/ffj+GzE/E7z4Yiz/hbtr74eHHNWMP2fsv9/RZjNH5d8P4Z60JSjTm9aiPqsSQt9/S6pZNNlAndsa7nLA+6p1cNg+14PG3Z7G5pZUUzlXSyRqiOJBMHtNNMdoow3qBmFcdBXo0ZbpmjhZ1qkFYi7YRyKurKWV4Q9iWZSM+EZuTd7+949dMrNg8b7GpRVlEMpwthsDgSzpLru2te//qaq9/eMCgRZYMWJOWYYdzZKiEH6q5GTCL+RDtD+WyhX30MQ5DpWTPpiW7s6Mc+7g36kTAXhxiDEMuAUmRfxKWhmYpIFl2WNfVYUA6nGIpjs4vjgHrM41riWVnwhF4axeGUxgQsq4/yL4/t+qzr1iXOd+meyUhCyl44EtO2mKZl7jrE6cTu5gbX95i2w/Y9TspIFJpTCtM06LLEVhVPnz7R7/eYokDleVxL5O6JRQhc14GcYJpYxwHXtVGu8wzvHKv3qDyL8rmpWYWAcWAdBHPbMDdN5EhUegBjmPuezcePPNzeUu52rNPIqhXqdMLP85kwy/DjEPXzpye2nz9zenxgCcRywk8jiTqmoDV+mtjd3bH5+IHi6YlVSgiEx5RlPh8bU5VxU9Bvj0f++PCB++tr3CCivh/Hs8shZsENBhGxip65rqN76ng8uxwIy/LZ5Sa6GsIT3HZtG+UBiW1bbIxBzXBMOdxcY+sKXRTYEJcQ0+d77OQUdU3Q7zuy+y1jkTN3LTb8SPQk87IgtUZbSycED087XIiXtShjWLz/4tiAW1acO8t2+5RJhgIBy7LGPrm9vaUqS45pyuFw4OnxkbqqKIqCsizZ7/c4dy6uoh5psp761NEXA/m+pDl1dLmgK0VcPxNWFVmWxQKapmkkCgjy8BPnHH7x9NXAbB1Wzwz9GDENMs5tqPKTIQmlXSmFDm5rjTHmgjBflvOtWNwSLTDSoifL3c2Gn1//wturd0xCRrka9UuB/e/2QhisMWrGmYVwA62az9DnPvmnd+FbvDxIUy8RzUhbCEQ18vn9LdmuoCsEbd7HtR+y8NuXzT8/q1dvrui68/uyPsuS/0PWti1lWcQTUNUV2+02JrJpGuq6jkn8YcKQnJBxa218o0M/juNlHta7v4rDn8U1IiUwYhfIAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"graphql map tree nodes\",\n    \"title\": \"graphql map tree nodes\",\n    \"src\": \"/static/7e951ea3b113fdb50ec4993db77db82c/6b1e2/graphql_map-tree-nodes.png\",\n    \"srcSet\": [\"/static/7e951ea3b113fdb50ec4993db77db82c/6b1e2/graphql_map-tree-nodes.png 281w\"],\n    \"sizes\": \"(max-width: 281px) 100vw, 281px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\nIn this image, the server-side engineer can cut in many places the tree. A decision must be made since the client-side cannot provide hints about how much is needed.\"), mdx(\"p\", null, \"As you can see, there are many ways not to return the whole graph, which in many cases is not practical. The consequence is an inconsistency for the consumers. Depending on the map, the returned payload will have a different granularity of information. Removing the power to pick which field desire in the response payload is against GraphQL mentality. It is also prone to error and forces the consumer to perform additional queries to get the assemble of information needed -- it brings us back to the REST API style of consumer patterns.\"), mdx(\"h3\", null, \"Limitation #3: No Generated Type\"), mdx(\"p\", null, \"Third, Suppose you are using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"how-to-automatically-generate-typescript-for-consumer-of-your-graphql\"\n  }, \"CodeGen\"), \" to generate your TypeScript from your GraphQL to have all your type generated for you. In that case, you will be out of luck. Of course, you can coarse the return value of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JSON.parse\"), \" to the generated type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" but that is wrong. The actual type of the map should be what the user picked. In GraphQL, it could be an explicit fragment or a subset of fields but rarely the complete list of properties.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const { data } = useQuery<MyQuery, MyQueryVariables>(GRAPHQL_DOC);\\nconst payload: string = data.city.personToHouse;\\nconst mapData = JSON.parse(payload) as { [key: string]: House }; // Coarse to House\\n\")), mdx(\"p\", null, \"Because of limitation #2, The query assumes the client request all the person's properties. The reality is that the server might not return the entire \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" but a shallow version of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \". For example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" has a reference to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"House\"), \". Because the consumer cannot specify the structure desired, the server must decide where to cut the graph. Otherwise, it can be very deep. In that example, the relationship can be infinite with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \"\\u2192\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"House\"), \"\\u2192\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \"\\u2192\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"House\"), \"\\u2192...\"), mdx(\"h3\", null, \"Limitation #4: Runtime Exception\"), mdx(\"p\", null, \"With the data in a string, it opens an issue if the schema evolves. If a field is removed on the server-side, the generated code will not indicate to the client that the type has changed until the code is executed. It opens the door to bugs at run time.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const { data } = useQuery<MyQuery, MyQueryVariables>(GRAPHQL_DOC);\\nconst payload: string = data.city.personToHouse;\\nconst mapData = JSON.parse(payload) as { [key: string]: House }; // Coarse to House\\nconsole.log(mapData[\\\"123\\\"].owners[0].name); // Work well\\n\")), mdx(\"p\", null, \"In the above code, everything works well until \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"owners\"), \" is removed from the response but kept in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"House\"), \" type. That is a limited issue if the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"House\"), \" is a type generated from an automatic process. However, because the server needs to make the decision about where to cut the relationship, it opens the door to the runtime issue. As we recall, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"House\"), \" type is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not\"), \" the type of the query since there is no way to define which field to receive from a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \". A GraphQL response type is defined by the user's request. The problem increases if the content of the value is not well defined by the server-side. On some occasions, the server-side might want to rely on a map because they have a loose schema, a value that can be anything, and using a string as a value is a way to circumspect the problem by pushing the responsibility to make sense of the data to the consumer. To some extent, mostly theoretically, a runtime exception can occur if the serialization/deserialization differs from the server-side and client-side.\"), mdx(\"h2\", null, \"Pros/Cons\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Pros\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Cons\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1. Server-side: Easy to implement\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1. Client-side: Hard to know what will be the structure of the value\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2. Server-side: No need to build custom mapping type\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2. Client-side: Cannot define field to fetch\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3. Client-side: No accurate type to coarse\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"4. Client-side: Possible runtime exception\")))), mdx(\"h1\", null, \"Solution #2: Strongly Typed Type per Map\"), mdx(\"p\", null, \"The second solution is to create a wrapper type with a key and a value. The key can be of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Int\"), \" and the value of the kind you want to map.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\"\n  }, \"type City {\\n  name: String!\\n  citizens: [Person!]\\n  personToHouse: [MapPersonHouse!]!\\n}\\n\\ntype MapPersonHouse {\\n  personId: String! # Key\\n  house: House! # Value\\n}\\n\")), mdx(\"p\", null, \"You see the main inconvenience in the code above: we need to create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MapPersonHouse\"), \". If you expect to have 100 maps to different key-value within your application, you will need to have 100 additional types. The concept is to transform the map from the server-side into a list of strongly typed key-value. The benefices are many. First of all, it is well defined: we know which fields are available.\"), mdx(\"p\", null, \"Secondly, the user can query the exact field desired. For example, the following snippet of code shows that in that case, we only want the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"address\"), \" of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"House\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\"\n  }, \"query SolutionTwo {\\n  city(name: \\\"SanJose\\\") {\\n    personToHouse {\\n      address\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"The third benefit is that we can continue to leverage GraphQL subtype selection and that the server-side does not have to decide how deep to send to the client.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\"\n  }, \"query SolutionTwo {\\n  city(name: \\\"SanJose\\\") {\\n    personToHouse {\\n      address\\n      owners {\\n        name\\n        hourseOwner {\\n          owners {\\n            name\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"In that query, we fetch for the city of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SanJose\"), \" a map of people that gives the address of each house and the list of owners and go deeper and deeper until the client decides to stop diving.\"), mdx(\"p\", null, \"The fourth benefit is that CodeGen can generate a proper type to consume.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const { data } = useQuery<MyQuery, MyQueryVariables>(GRAPHQL_DOC);\\nconst list: MapPersonHouse = data.city.personToHouse;\\nconst map = new Map();\\nfor (const element of list) {\\n  map.set(element.personId, element.house);\\n}\\nconst houseId123 = map.get(123); // Type here is not House, it is a subset of House but still strongly typed\\n\")), mdx(\"p\", null, \"From the list, it is possible to build back a map. The idea is to loop the list and take the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"key\"), \" of each \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MapPersonHouse\"), \" as the map's key and the value to be set as the value. The last line of the code above defines a variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"houseId123\"), \" that is typed from a dynamic type of the subset of fields selected.\"), mdx(\"h2\", null, \"Limitations\"), mdx(\"p\", null, \"Limitations are now divided more equally between the server and client.\"), mdx(\"h3\", null, \"Limitation 1: More GraphQL Type\"), mdx(\"p\", null, \"The principal argument against the solution is it requires adding an additional type for each map. GraphQL does not have a generic type, and to have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" strongly typed, we must define a new type. The limitation weight is balanced by keeping the schema discoverable, generating type possible, and the client can determine the desired field using all the common GraphQL capabilities.\"), mdx(\"h3\", null, \"Limitation 2: Construct the Map\"), mdx(\"p\", null, \"A minor inconvenience is constructing the map from the list on the client-side.\"), mdx(\"h2\", null, \"Pros/Cons\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Pros\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Cons\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1. Client-side: Schema continues to be documented\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1. Server-side: Must defined more GraphQL types\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2. Client-side: Strongly-Typed\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2. Client-side: must rebuild the map or use the list\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3. Client-side: Define which field to fetch\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"4. Server-side: No need to take decision to where to stop diving. Sub-types are handled by GraphQL\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })))), mdx(\"h1\", null, \"Solution #3: Primitive Map\"), mdx(\"p\", null, \"Another solution is to use a map for only primitive types. It entails defining a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KeyValues\"), \" type. The type has one property per different values. For example, if you expect a map from key to boolean, you will need a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BooleanKeyValue\"), \". If you desire a map to a type, you need to add another property.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\"\n  }, \"type KeyValues {\\n  booleanKeyValues: [BooleanKeyValue!]\\n  intKeyValues: [IntKeyValue!]\\n  stringKeyValues: [StringKeyValue!]\\n}\\n\\ntype BooleanKeyValue {\\n  key: String\\n  value: Boolean\\n}\\ntype IntKeyValue {\\n  key: String\\n  value: Int\\n}\\ntype StringKeyValue {\\n  key: String\\n  value: String\\n}\\n\")), mdx(\"p\", null, \"Unfortunatelly, this solution breaks many scenarios. First of all, it only works with primitive types. In fact, it is impossible to get our example using this structure without polluting the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KeyValues\"), \" and then getting into the rabbit hole of adjusting the schema in such a way that it is questionable. For example, we would need alter the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KeyValue\"), \" with an optional \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"houseKeyValues\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\",\n    \"metastring\": \"{5}\",\n    \"{5}\": true\n  }, \"type KeyValues {\\n  booleanKeyValues: [BooleanKeyValue!]\\n  intKeyValues: [IntKeyValue!]\\n  stringKeyValues: [StringKeyValue!]\\n  houseKeyValues: [HouseKeyValue!]\\n}\\ntype HouseKeyValue {\\n  key: String!\\n  value: House!\\n}\\ntype City {\\n  name: String!\\n  citizens: [Person!]\\n  personToHouse: [KeyValues!]!\\n}\\n\")), mdx(\"p\", null, \"You can see two issues right here: You need to create an additional type, hence not better than the previous solution. Second, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KeyValues\"), \" will grow quite a lot. If you have 100 maps in your system, this type will be hard to understand for the server and client. The problem is that the client will need to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"guess\"), \" which property of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KeyValues\"), \" to use. Having to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"guess\"), \" defeats the purpose of GraphQL, which is a protocol that steward the client toward writing a proper request.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\"\n  }, \"query SolutionThree {\\n  city(name: \\\"SanJose\\\") {\\n    personToHouse {\\n      houseKeyValues {\\n        key\\n        value {\\n          address\\n        }\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"The problem is the client could have written:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\"\n  }, \"query SolutionThree {\\n  city(name: \\\"SanJose\\\") {\\n    personToHouse {\\n      intKeyValues {\\n        key\\n        value\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"It would have been valid but not practical as it does not exist and would return null. Overall, trying to push a single \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"KeyValues\"), \" brings more complexity for little gain.\"), mdx(\"h2\", null, \"Pros/Cons\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Pros\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Cons\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1. Client-side: Strongly-Typed\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1. Client-side: must rebuild the map or use the list\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2. Client-side: Define which field to fetch\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2. Client-side: must guess which field to use\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3. Server-side: No need to take decision to where to stop diving. Sub-types are handled by GraphQL\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3. Server-side: Must defined more GraphQL types\")))), mdx(\"h1\", null, \"What to use?\"), mdx(\"p\", null, \"After building GraphQL on the server-side and consuming it with GraphQL, I strongly recommend using solution #2: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strongly Typed Type per Map\"), \". My main argument can be summarized to:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Stay as close to GraphQL standard as possible. The server should let the user decide how deep and which fields to select. The solution should continue to be self-documented and guide the client toward a scalable and robust solution.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The addition of a map type per type that requires to be in a type might look annoying but is a small price to pay to continue leveraging the GraphQL philosophy.\")), mdx(\"p\", null, \"Indeed, there are exceptions. For example, suppose you have a case of a field that needs to be loosely coupled, something that can key-value of anything. In that case, I believe that you should have the same principle: a type that wraps key-value that is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \", allowing to store \\\"anything\\\" in the value. But that should be very exceptional. In most cases, even in a system with hundreds of types, embracing a strongly typed schema that converts the server-side map into a list is the most convenient and closest solution to GraphQL.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"505fe32c-baaa-59b7-afc2-20f5e1e45a39","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}