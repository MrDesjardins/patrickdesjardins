{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-update-specific-field-of-your-entity-with-a-generic-method-and-entity-framework",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to update specific field of your entity with a generic method and Entity Framework","date":"April 16, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to update specific field of your entity with a generic method and Entity Framework\",\n  \"date\": \"2013-04-16\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you are using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Entity Framework\"), \" with a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-4-repository\",\n    \"title\": \"Enterprise Asp.Net MVC Part 4: Repository\"\n  }, \"repository layer\"), \" which has the basic method like Get, Update, Insert (or Add) and Delete you are already in a good position. But what if you want to update a single property without having to load the whole entity from the database? If you have only the primary key (id) of your entity and the value of the property you want to update, you may want to simply update the field with a where clause with the id. In SQL, we would create the following query. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" update [dbo].[WorkoutSessions] set [Name] = 'New Name', [Order] = 1 where ([Id] = 123) \\n\")), mdx(\"p\", null, \"With \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Entity Framework\"), \", you could create single method like \\\"UpdateNameAndOrder\\\" but this would end to having a lot of update method if you require to have partial update among many properties. A better approach would be to specify which properties we want to update.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public int Update(T entity, Expression<Func<T, object>>[] properties) { DatabaseContext.Entry(entity).State = EntityState.Unchanged; foreach (var property in properties) { var propertyName = ExpressionHelper.GetExpressionText(property); DatabaseContext.Entry(entity).Property(propertyName).IsModified = true; } return DatabaseContext.SaveChangesWithoutValidation(); } \\n\")), mdx(\"p\", null, \"The code above is in the BaseRepository class of the project described in the \\\"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-part-1-mvc-the-planification\",\n    \"title\": \"Enterprise Asp.Net MVC Part 1: The Planification\"\n  }, \"Enterprise project\"), \"\\\". As you can see, it takes as its second parameter an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"expression of a function\"), \". This will let use this method by specifying in a Lambda expression witch property to update.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" ...Update(Model, d=>d.Name); //or ...Update(Model, d=>d.Name, d=>d.SecondProperty, d=>d.AndSoOn); \\n\")), mdx(\"p\", null, \"As you can see, the Update method first line change the state to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Unchanged\"), \". We could have using Attach of the IDbSet but since in the Enterprise project we have special sets a way to simply go directly to the DbSet of the current database context is to go directly to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Entry\"), \". Next, we loop all properties chosen. Inside the loop, we are using a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"System.Web.Mvc\"), \" namespace. We could have using the code of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetExpressionText\"), \" without having to use this namespace. Here is the code if you do not want a reference to this dll.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" /// <summary> /// Gets the model name from a lambda expression. /// </summary> /// /// <returns> /// The model name. /// </returns> /// <param name=\\\"expression\\\">The expression.</param> public static string GetExpressionText(LambdaExpression expression) { Stack<string> stack = new Stack<string>(); Expression expression1 = expression.Body; while (expression1 != null) { if (expression1.NodeType == ExpressionType.Call) { MethodCallExpression methodCallExpression = (MethodCallExpression) expression1; if (ExpressionHelper.IsSingleArgumentIndexer((Expression) methodCallExpression)) { stack.Push(ExpressionHelper.GetIndexerInvocation(Enumerable.Single<Expression>((IEnumerable<Expression>) methodCallExpression.Arguments), Enumerable.ToArray<ParameterExpression>((IEnumerable<ParameterExpression>) expression.Parameters))); expression1 = methodCallExpression.Object; } else break; } else if (expression1.NodeType == ExpressionType.ArrayIndex) { BinaryExpression binaryExpression = (BinaryExpression) expression1; stack.Push(ExpressionHelper.GetIndexerInvocation(binaryExpression.Right, Enumerable.ToArray<ParameterExpression>((IEnumerable<ParameterExpression>) expression.Parameters))); expression1 = binaryExpression.Left; } else if (expression1.NodeType == ExpressionType.MemberAccess) { MemberExpression memberExpression = (MemberExpression) expression1; stack.Push(\\\".\\\" + memberExpression.Member.Name); expression1 = memberExpression.Expression; } else if (expression1.NodeType == ExpressionType.Parameter) { stack.Push(string.Empty); expression1 = (Expression) null; } else break; } if (stack.Count > 0 && string.Equals(stack.Peek(), \\\".model\\\", StringComparison.OrdinalIgnoreCase)) stack.Pop(); if (stack.Count <= 0) return string.Empty; return Enumerable.Aggregate<string>((IEnumerable<string>) stack, (Func<string, string, string>) ((left, right) => left + right)).TrimStart(new char[1] { '.' }); } \\n\")), mdx(\"p\", null, \"What it does is it takes from the lambda the name of the property selected.\"), mdx(\"p\", null, \"The last thing the update method is doing it's saving without executing the validation on the entity. This is required since not the whole entity is loaded. Some property required might not be loaded which would result into validation exception. To be honest, an improvement would be to execute the validation for the updated property, but for the sake of simplicity, we will stay this smaller.\"), mdx(\"p\", null, \"To conclude, it's possible to update an entity in a generic way without having to preload this object or to update all its properties.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"0dc04ad3-f6d8-56b2-b60f-ac8c4cc3f4f3","totalPages":70}},
    "staticQueryHashes": ["3159585216"]}