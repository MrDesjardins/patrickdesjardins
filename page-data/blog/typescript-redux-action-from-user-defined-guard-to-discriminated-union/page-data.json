{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-redux-action-from-user-defined-guard-to-discriminated-union",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript Redux Action from User Defined Guard to Discriminated Union","date":"February 20, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript Redux Action from User Defined Guard to Discriminated Union\",\n  \"date\": \"2018-02-20\",\n  \"categories\": [\"redux\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Using TypeScript with Redux bring many questions about what really is passing around. Enforcing a strongly typed model and keeping the flexibility while using Redux is a challenge that doesn't have a single solution. In this article, we will see the first approach using user-defined guard and see how to transform this one to use a discriminated union.\"), mdx(\"p\", null, \"Redux is all about sending a message from the React component to the Redux store. In the middle, you can manipulate the message sent to middleware. The message sent is called \\\"action\\\". The action contains the payload that can be analyzed in the Redux's flow and transformed to finally be persisted in the single store. A common pattern is to send the payload by using a function that creates that message which is then passed to Redux's dispatch which will send the message in its normal flow. For example, in your React component, connected with React-Redux, you can dispatch a function that returns your payload. The payload should contain a unique identifier and the payload at the minimum. The unique identifier allows middlewares and reducers to know if they should catch the message or just let it goes. The payload is to be manipulated by the middlewares or stored in the store by the reducers. The first approach is, with a user-defined guard, is to create a reusable generic action which will be the envelope for your message.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const MY_OBJECT_UNIQUE_ACTION_ID_HERE = \\\"MY_OBJECT_UNIQUE_ACTION_ID_HERE\\\";\\n\\n// Reusable generic action \\nexport interface Actions<T> extends Action { \\n  readonly type: string; \\n  payload: T; \\n}\\n\\n// Example of a function that creates an action which is used in the Redux's dispatch \\nexport function createActionToSaveMyObject(data:MyObject): Actions<MyObject> { \\n  return { \\n    type: MY_OBJECT_UNIQUE_ACTION_ID_HERE, \\n    payload: data }; \\n  }\\n\\n// The dispatch done through the React-Redux's API \\ndispatch(createActionToSaveMyObject({id:1, name:\\\"test\\\"})); \\n\")), mdx(\"p\", null, \"Inside the middleware, to consume the action, you need to do two things. Like any Redux code, you need to check the type and compare it against the unique constant for the action. However, since we are using a generic action, it needs to have all possible type as a union inside the generic. This cause the action to have a payload not very strongly typed. It is but could be any of the type specified in the union of the generic type of Actions. To narrow down, we need to use a user-defined guard. We could have a user-defined guard function for each type, or we could cheat and have one type that just cast it to the desired type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"// Middleware example \\nexport interface ExtendedMiddleware<StateType> extends Middleware { \\n  <S extends StateType>(api: MiddlewareAPI<S>): (next: Dispatch<S>) => Dispatch<S>; \\n}\\n\\nexport const yourMiddleware: ExtendedMiddleware<AppReduxState> = \\n  <S extends AppReduxState>(api: MiddlewareAPI<S>) => (next: Dispatch<S>) => <A extends Actions<MyObject | MyObject2 | MyObject3 >>(action: A): A => { \\n    if (action.type === MY_OBJECT_UNIQUE_ACTION_ID_HERE && isGenericAction<MyObject>(action)) { \\n      // Logic that can access action.payload that is strongly typed with MyObject \\n    } \\n  });\\n\\n// Reducer is using the same logic\\nexport function youReducer( state: AppState = initialState, action: Actions<MyObject | MyObject2 | MyObject3 >> ): AppState { \\n  if (action.type === MY_OBJECT_UNIQUE_ACTION_ID_HERE && isGenericAction<MyObject>(action)) { \\n    // Logic that can access action.payload that is strongly typed with MyObject } }\\n\\n// The cheat: \\nexport function isGenericAction<T>(obj: any): obj is Actions<T> { \\n  const castedObject = (obj as Actions<T>); \\n  return castedObject.payload !== undefined && castedObject.type !== undefined; \\n} \\n\")), mdx(\"p\", null, \"As you can see, the problem with this approach is that is that we must use everywhere the function that will return the narrowed type. It's convoluting and also bring some issues. For instance, if you use the function and pass the generic type to something else that really what is the object, the cast will allow it and indicate to TypeScript the wrong type. isGenericAction(objectType2) will indicate to TypeScript that the object passed is of type 1 because the condition to evaluate is weak and always true for any time that extends the generic actions interface created. This approach has the advantage to be succinct anytime you need to create a new action which is to create an action creator function, an unique constant and a check when needed.\"), mdx(\"p\", null, \"An alternative is to use a discriminated union. This approach has more boilerplate but will eliminate the need to use a function to coerce a narrowed type. TypeScript will take care of doing it. The main advantage of using a discriminated union is that it is strongly typed. The disadvantage is that we are losing some flexibility since we cannot have anymore the member \\\"type\\\" to be a string. It needs to use a discriminated field which will be of the type of a unique string and not a string. For instance, the type will be the name of the constant as well as its values instead of being of type string with the value of the constant.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const MY_OBJECT_UNIQUE_ACTION_ID_HERE = \\\"MY_OBJECT_UNIQUE_ACTION_ID_HERE\\\";\\n\\n// Reusable generic action \\nexport interface Actions<T> extends Action { payload: T; }\\n\\n// Every action must have an interface with its discriminator \\nexport interface ISaveMyObject extends Actions<MyObject> { \\n  type: typeof MY_OBJECT_UNIQUE_ACTION_ID_HERE; \\n}\\n\\n// Example of a function that creates an action which is used in the Redux's dispatch \\nexport function createActionToSaveMyObject(data:MyObject): ISaveMyObject { \\n  return { \\n    type: MY_OBJECT_UNIQUE_ACTION_ID_HERE, \\n    payload: data \\n  }; \\n}\\n\\n// The dispatch done through the React-Redux's API \\ndispatch(createActionToSaveMyObject({id:1, name:\\\"test\\\"})); \\n\")), mdx(\"p\", null, \"So far, little changed. However, we see that we need to create an interface and set the type to a unique name. A good practice is to use the constant and with typeOf extract the string of it and assign it as a type. In the action creator function, you can assign the value of the constant. This might not look like a big drawback from user-defined guard, but it can be involving on big system with hundreds and hundreds of action. Nevertheness, middlewares and reducers are simplified. Since every action is having a unique interface with a unique discriminator under the common member \\\"type\\\", it's possible to check against the discriminator and TypeScript will know which interface it is associated with. Since every interface extends the actions that contain a strongly typed payload, the type is accessible directly.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface ExtendedMiddleware<StateType> extends Middleware { \\n  <S extends StateType>(api: MiddlewareAPI<S>): (next: Dispatch<S>) => Dispatch<S>; \\n}\\n\\ntype AcceptedAction = MyObject | MyObject2 | MyObject3 ;\\n\\nexport const yourMiddleware: ExtendedMiddleware<AppReduxState> = \\n  <S extends AppReduxState>(api: MiddlewareAPI<S>) => \\n    (next: Dispatch<S>) => \\n      <A>(action: A): A => { \\n        const actionTyped = action as any as AcceptedAction; \\n        if (actionTyped.type === MY_OBJECT_UNIQUE_ACTION_ID_HERE) { \\n          // Logic that can access actionTyped.payload that is strongly typed with MyObject \\n        } \\n      });\\n\\n// Reducer is very similar \\nexport function yourReducer( state: AppState = initialState, action: Actions<A> ): AppState { \\n  const actionTyped = action as any as AcceptedAction; \\n  if (action.type === MY_OBJECT_UNIQUE_ACTION_ID_HERE) { \\n    // Logic that can access actionTyped.payload that is strongly typed with MyObject \\n  } \\n} \\n\")), mdx(\"p\", null, \"There is one dirty trick that you can see the action being cast to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any\"), \" and cast to the list of accepted type. Ideally, the action would be of type of the union. However, Redux definition files require having a type A. Extending the type create confusion to the compiler which doesn't know which of the type and thus have the payload of all the unionized type.\"), mdx(\"p\", null, \"In this article, we saw two function ways to handle action from React to Redux's state. The first one is using a user-defined guard which was quicker to write but loosely strongly typed. The second approach is more convoluted but is strongly typed and protect you from having a false sense of security that the code is typed with a specific type which may be deceptive. Neither of the design are peculiar but the latter is by experience worth the additional typing.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"64deb987-0938-5baf-832d-d724c061af9f","totalPages":70}},
    "staticQueryHashes": ["3159585216"]}