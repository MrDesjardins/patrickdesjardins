{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/sql-arithmetic-overflow-error-converting-numeric-to-data-type-numeric",
    "result": {"data":{"mdx":{"frontmatter":{"title":"SQL Arithmetic overflow error converting numeric to data type numeric","date":"March 18, 2016"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"SQL Arithmetic overflow error converting numeric to data type numeric\",\n  \"date\": \"2016-03-18\",\n  \"categories\": [\"sql\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When you are using straight ADO.Net with SQL you may come when using an operation that produce an overflow. This is often hard to debug if you are inside an update statement which update several fields. You may think than using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cast\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"convert\"), \" to the type of the destination field solve the problem, but it is not actually valid.\"), mdx(\"p\", null, \"Here is two examples that show that even if you \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"convert\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cast\"), \" it won't be enough.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" declare @dob1 as decimal(16,4) set @dob1 = cast(554656545465486786844864613 as decimal(16,4)) select @dob1\\n\\ndeclare @dob2 as decimal(16,4) set @dob2 = CONVERT(decimal(16,4),5455531234268.68423224224244864613 ) select @dob2 \\n\")), mdx(\"p\", null, \"In my case, the problem was that I was performing an update in a field by executing a multiplication. field = field * 1/2. The problem was that field was already, in some case, at 0 and sometime above the maximum which is 12 (16-4) digits. Even if the following code work fine.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" declare @dob3 as int set @dob3 = cast(0*1/2 as int) select @dob3 \\n\")), mdx(\"p\", null, \"This one was not:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" declare @fromValue as int declare @toValue as int\\n\\nset @fromValue = 1 set @toValue = 2\\n\\nSELECT cast(Quantity * @fromValue/@toValue as int) as newQuantity FROM [Trading].[Stock] \\n\")), mdx(\"p\", null, \"However, adding a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"where\"), \" clause eliminates edge cases to be proceeded. The trick is to handle result of 0 and result above the limit.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" declare @fromValue as int declare @toValue as int\\n\\nset @fromValue = 1 set @toValue = 2\\n\\nSELECT cast(Quantity * @fromValue/@toValue as int) as newQuantity FROM [Trading].[Stock] WHERE Quantity > 0 AND Quantity < 999999999999 \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"1a8c7ff9-d8d4-5097-84a3-e9006e3e9a81","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}