{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/flipping-a-div-part-2",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Flipping a div (part 2)","date":"July 15, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Flipping a div (part 2)\",\n  \"date\": \"2013-07-15\",\n  \"categories\": [\"css\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In a previous post, we have discussed about how to flip a division. However, Javascript was involved with CSS3 while only CSS3 could have been enough. For the curious, here is the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://jsfiddle.net/xRXYW/4/\"\n  }, \"code/JsFiddle\"), \" (most of the code is not from me, but I cannot find the source).\"), mdx(\"p\", null, \"First of all, the Html structure changes a little with two divisions with the same class (\\\"side\\\") within 2 divisions. One is the card container and the second is card. The card will be the one animated while the card container act as a placeholder.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-html\"\n  }, \"<div class=\\\"card-container\\\"> \\n  <div class=\\\"card\\\"> \\n    <div class=\\\"side\\\">\\n      <img src=\\\"thisisanimage.png\\\"/>\\n    </div> \\n    <div class=\\\"side back\\\">This is some text</div> \\n  </div> \\n</div> \\n\")), mdx(\"p\", null, \"As for the CSS, the perspective is also set to have a 3d look of depth. This is what the card-container is for.\"), mdx(\"p\", null, \"After, the card is assigned to have a transition of 1 second. Nothing is trigged until the card has a transformation applied, which is the case with the next CSS statement.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-css\"\n  }, \".card-container { \\n  -webkit-perspective: 600; \\n  margin-bottom: 20px; \\n  position: relative; \\n  width: 150px; \\n}\\n\\n.card { \\n  position: absolute; \\n  -webkit-transform-style: preserve-3d; \\n  -webkit-transition: all 1s ease-in-out; width: 100%;\\n} \\n\\n.card:hover { \\n  -webkit-transform: rotateY(180deg);\\n } \\n \\n.card .side { \\n  -webkit-backface-visibility: hidden; \\n  position: absolute; width: 100%;\\n} \\n\\n.card .back { \\n  color: #404853; \\n  font-size: 14px; \\n  font-weight: bold; \\n  line-height: 150px; \\n  text-align: center;\\n  -webkit-transform: rotateY(180deg); \\n  background-color:yellow; \\n} \\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":hover\"), \" statement raise the transition to be executed (with the 1 second time). As you may have notice, the use of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"backface-visibility\"), \" lets the rendering to not display the back of the div but instead display the other division which rotate at the same time. This create the illusion that we are seeing the back of the division, but in fact, we are showing the other division. This is possible because of the position set to absolute. This put both division over each others.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"d6ebd0a2-670b-5245-9f99-5b1015ca5904","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}