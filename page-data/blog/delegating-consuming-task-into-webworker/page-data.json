{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/delegating-consuming-task-into-webworker",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Delegating Consuming Task into WebWorker","date":"March 23, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Delegating Consuming Task into WebWorker\",\n  \"date\": \"2017-03-23\",\n  \"categories\": [\"javascript\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Heavy operation can hang the main thread in JavaScript. This is mainly because there is only a single thread and every operation needs to not be too much intensive. A way to handle an heavy operation is to delegate this one into a WebWorker.\"), mdx(\"p\", null, \"A WebWorker is a place in the browser that can be requested by a page to do some task without being executed into the main thread. It has some limitations, like not being able to manipulate the Dom and being more slow, but has the main advantage to not interfere the main thread. All is done by messages between the script from the page and the script that run the worker.\"), mdx(\"p\", null, \"To illustrate the benefit, we will use an intensive script that will be run in the main thread from one button and having a second button that execute the same script into the WebWorker. The main thread will have the time updating every 50ms as well as adding a dot. The first button will have the consequence of having the time and the dot to stop for few seconds, while the WebWorker will have always a smooth time and dot update. Here is the result of the code being executed in the main thread.\"), mdx(\"p\", null, mdx(\"undefined\", {\n    parentName: \"p\"\n  }, \"\\n      \", mdx(\"div\", {\n    \"className\": \"gatsby-video-aspect-ratio\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"paddingTop\": \"70.96774193548386%\"\n    }\n  }, \"\\n    \", mdx(\"video\", {\n    parentName: \"div\",\n    \"preload\": \"\",\n    \"autoPlay\": true,\n    \"muted\": true,\n    \"loop\": true,\n    \"playsInline\": true,\n    \"style\": {\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\",\n      \"width\": \"100%\",\n      \"height\": \"auto\"\n    }\n  }, \"\\n      \", mdx(\"source\", {\n    parentName: \"video\",\n    \"src\": \"/static/MainThreadBlocking-41531420f304ded765912033668c6993-01206.webm\",\n    \"type\": \"video/webm\"\n  }), mdx(\"source\", {\n    parentName: \"video\",\n    \"src\": \"/static/MainThreadBlocking-41531420f304ded765912033668c6993-50762.mp4\",\n    \"type\": \"video/mp4\"\n  }), \"\\n    \"), \"\\n    \"), \"\\n    \")), mdx(\"p\", null, \"As you can see, when the button is click, the heavy process is taking so much of the processor that it hangs the whole thread. The clock stops ticking, the dots stop moving. However, looks at the result with WebWorker.\"), mdx(\"p\", null, mdx(\"undefined\", {\n    parentName: \"p\"\n  }, \"\\n      \", mdx(\"div\", {\n    \"className\": \"gatsby-video-aspect-ratio\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"paddingTop\": \"70.96774193548386%\"\n    }\n  }, \"\\n    \", mdx(\"video\", {\n    parentName: \"div\",\n    \"preload\": \"\",\n    \"autoPlay\": true,\n    \"muted\": true,\n    \"loop\": true,\n    \"playsInline\": true,\n    \"style\": {\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\",\n      \"width\": \"100%\",\n      \"height\": \"auto\"\n    }\n  }, \"\\n      \", mdx(\"source\", {\n    parentName: \"video\",\n    \"src\": \"/static/MainThreadNonBlocking-c60f899953233f53f080efd860253b88-01206.webm\",\n    \"type\": \"video/webm\"\n  }), mdx(\"source\", {\n    parentName: \"video\",\n    \"src\": \"/static/MainThreadNonBlocking-c60f899953233f53f080efd860253b88-50762.mp4\",\n    \"type\": \"video/mp4\"\n  }), \"\\n    \"), \"\\n    \"), \"\\n    \")), mdx(\"p\", null, \"The animation keeps working with the dots and the clock is not interfered by calculation. At the end, it's more smooth because the main thread is not doing the heavy lifting -- the WebWorker is doing it.\"), mdx(\"p\", null, \"The whole project is built in TypeSript which compile everything into JavaScript. The whole code can be found in this GitHub repository: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/TypeScriptWebWorker\"\n  }, \"https://github.com/MrDesjardins/TypeScriptWebWorker\")), mdx(\"p\", null, \"The project contains 3 files. The main.ts which will create the two buttons and starts the timer for the clock and the dots. The algo.ts which contains an intensive, not efficient, way to calculate prime numbers. It has two parameters, the first is the number of iteration and the second a multiplier. The iteration is to find more than just one prime number, the multiplier is increasing with a random number a number to verify if it's a prime.\"), mdx(\"p\", null, \"The slow button is executing the following code that disable the button, instantiate the algorithm class and execute it with a huge number. When it returns, it says that the data is back and enable the button.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function slowFunction(): void { \\n  $(\\\"#btn1\\\").prop(\\\"disabled\\\", true); \\n  const algo = new Algorithm(); \\n  const result = algo.calculatePrimes(50, 99887766554); \\n  const $line = $(\\\"<p>\\\").append(\\\"Result is returned\\\"); \\n  $(\\\"#main\\\").append($line); $(\\\"#btn1\\\").prop(\\\"disabled\\\", false); } \\n\")), mdx(\"p\", null, \"The WebWorker button is doing something different and needs more code. To execute code in the WebWorker we need to load the WebWorker and pass a message. To Receive the value back to the page from the WebWorker, we need to subscribe to an event.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"let worker: Worker; \\nconst callBack = (message: MessageEvent) => { \\n  if (message.data.command === \\\"done\\\") { \\n    const result = message.data.prime; \\n    const $line = $(\\\"<p>\\\").append(\\\"Result is returned\\\"); \\n    $(\\\"#main\\\").append($line); }\\n     $(\\\"#btn2\\\").prop(\\\"disabled\\\", false); \\n    }; \\n    \\n    function slowFunctionWebWorker(): void { \\n      $(\\\"#btn2\\\").prop(\\\"disabled\\\", true); \\n      if (worker) { \\n        worker.removeEventListener(\\\"message\\\", callBack); \\n        worker.terminate(); \\n      } \\n      worker = new Worker(\\\"output/webworker.js\\\"); \\n      worker.addEventListener(\\\"message\\\", callBack, false);\\n\\n      setTimeout(() => { \\n        worker.postMessage({ multiplier: 50, iterations: 50000, }); \\n        }, 1000); \\n    }\\n  }\\n} \\n\")), mdx(\"p\", null, \"The call back, is looking for which message is sent back. The string could have been anything, the important is that the WebWorker needs to send the same. This is the way to handle multiple messages and response between the page and WebWorker. In our case, we have only one method and one response so a single string is the only thing required which is called \\\"done\\\".\"), mdx(\"p\", null, \"The button is disabled and make sure that if a previous worker existed to remove the response listener and termine this one. After, it creates the worker. This is done by using the Worker class and passing a relative path to the WebWorker JavaScript file. After, we need to subscribe to a worker which of type \\\"message\\\". This allows to pass messages between the page and the WebWorker. Finally, there is a timeout of 1 sec before passing the request command down. The reason is that we need some time to the WebWorker to instanciate and register to listen to command. As you can see the postMessage is the way to call the WebWorker with some arguments.\"), mdx(\"p\", null, \"The WebWorker is using the same algorithm that the one execute in the main script which was loading it from an other module. To do that with WebWorker, we need to get more barebone which mean we cannot use the import syntax, but directly use requirejs.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"importScripts(\\\"../vendors/requirejs/require.js\\\"); \\nconsole.log(\\\"loaded\\\"); \\nrequirejs.config({ baseUrl: \\\".\\\", }); \\nrequire([\\\"algo\\\"], \\nfunction (algo_1) { \\n  console.log(\\\"required\\\"); //debugger; \\n  self.addEventListener(\\\"message\\\", (message: MessageEvent) => { \\n    console.log(\\\"receive message begin\\\"); \\n    const origin = message.origin; \\n    const iterations = message.data.iterations; \\n    const multiplier = message.data.multiplier; \\n    const algo = new algo_1.Algorithm(); \\n    const result = algo.calculatePrimes(iterations, multiplier); \\n    console.log(\\\"receive message end\\\"); \\n    (self as any).postMessage({ command: \\\"done\\\", primes: result }); \\n  }); \\n}); \\n\")), mdx(\"p\", null, \"To load a script, we must use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"importScripts\"), \" which will let us having \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"requirejs\"), \" to load the module. Then, we need to configure RequireJs with a minimum configuration. Then, we call require to load the algo module. A good thing is that you can use console.log as well as the debugger keyword to debug the WebWorker. Next, you need to subscribe to the \\\"message\\\" event to be able to receive the postMessage from the webpage. Once we receive a message, we get the parameters, instantiate the algorithm class and wait the result. Once the result is out, we postMessage back to the page. I had to cast to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any\"), \" to have access to postMessage (there is probably a better way).\"), mdx(\"p\", null, \"The end result is way better and as you can see, the interface doesn't pay the price. However, if you have keen eyes, you also saw that I reduced the multiplier count from 99 887 766 554 to 50 000. That is a lot less! Why? Because keeping the same huge value was killing the WebWorker. By that, I mean that the algorithm was running forever. The whole process was running more slowly than the main thread for an unknown reason to me (at this time I am writing this post). I'll have a future post about why it's slower, but for the moment, if you need to have some telemetry task, or small task that block the UI just for more than few seconds (but not too much!), it may be worth it to move some logic down to a WebWorker. Also, as you can see, TypeScript is totally possible with WebWorker without a lot of hassle which is a big plus for anyone working with TypeScript project.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"68d5ce1c-fb17-52ff-bcdc-9dcc4f0f9b6d","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}