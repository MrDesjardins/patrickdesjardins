{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-unit-test-a-file-in-jest-that-use-webworker",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to unit test a file in Jest that use webworker?","date":"December 14, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to unit test a file in Jest that use webworker?\",\n  \"date\": \"2017-12-14\",\n  \"categories\": [\"jest\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This might be tricky. Why is it a problem? It is because it's a web concept and Jest doesn't use the browser and in fact, we do not want to use this feature, we want to use a module that may reference a web worker. If you are using create-react-app or the TypeScript equivalence you know that to use a web worker you must do something different to import this one. Your code may look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import * as workerPath from \\\"file-loader?name=[name].js!../../WebWorkers/yourWebWorker\\\"; \\n\")), mdx(\"p\", null, \"With a file-loader definition file that may look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"declare module \\\"file-loader?name=[name].js!*\\\" { const value: string; export = value; } \\n\")), mdx(\"p\", null, \"However, doing so will have an issue with Jest that won't understand the file-loader and will crash. To get around, Jest allows configuring a \\\"moduleNameMapper\\\" property to mock the call. Unfortunately, if you are using create-react-app, you won't have access to this property since only a merely portions of what available is supported. You'll have to be more imaginative and use what you can find. Jest is open source and it allows to get inside. One thing you can see in the source code is that it sets the ENV variable to test. So a working solution is to look if we are in test and to return something else than the web worker.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"async function getWorkerPath() { \\n  let workerPathAsync = \\\"\\\"; \\n  if (process.env.NODE_ENV !== \\\"test\\\") {\\n     workerPathAsync = require(\\\"file-loader?name=[name].js!../../WebWorkers/logWebWorker\\\"); \\n  } return workerPathAsync; \\n} \\nconst workerPath = getWorkerPath(); \\n\")), mdx(\"p\", null, \"The \\\"require\\\" syntax work, the \\\"await import\\\" async version doesn't work yet for me even if I was using TypesScript 2.5.3. It was compiling but during Jest execution, the syntax was not supported. Regardless, the \\\"require\\\" solution let you load it for your development and production environment.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"db6be01a-0919-50f5-a41f-a83da8005a8e","totalPages":71}},
    "staticQueryHashes": ["3159585216"]}