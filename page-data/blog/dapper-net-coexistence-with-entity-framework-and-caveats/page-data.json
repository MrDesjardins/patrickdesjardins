{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/dapper-net-coexistence-with-entity-framework-and-caveats",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Dapper.Net coexistence with Entity Framework and caveats","date":"December 15, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dapper.Net coexistence with Entity Framework and caveats\",\n  \"date\": \"2015-12-15\",\n  \"categories\": [\"ado-net\", \"dapper-net\", \"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/StackExchange/dapper-dot-net\"\n  }, \"Dapper.Net\"), \" is a micro ORM (objection relational mapping) that \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://stackoverflow.com\"\n  }, \"StackOverFlow\"), \" is using. It's open source and it still maintained by the team, mostly by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://stackoverflow.com/users/23354/marc-gravell\"\n  }, \"Marc Gravell\"), \" who is a top 5 users in StackOverflow too. The project I am working on is getting slowed down by Entity Framework (EF) since few months and the introduction to an alternative solution was required. This is why I introduced Dapper.Net in the solution. The goal is to slowly switch toward something more under my control and Dapper.Net offers this by letting you write queries in SQL directly. In theory, it looks good since it's used by a top website, still maintained and is less intrusive by having less magic behind the scene. That said, most problem that I was hitting with Entity Framework was with DbContext and Dapper.Net simply doesn't have central object that they to be intelligent. In this process of introducing Dapper.Net, I'll keep Entity Framework generating the database and keep this one to read the data. I will just not use it to save problematic entities.\"), mdx(\"p\", null, \"Using Dapper.Net is simple. You use a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.nuget.org/packages/Dapper\"\n  }, \"Nuget package\"), \", the DLL is downloaded and you can use it. Not a lot of knowledge is require to use the basic because you are using a basic \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DbConnection\"), \" which is enhanced with static method (by extension) to let you query and execute SQL code. However, this assumption that it does not require a lot of knowledge ends soon when you try to do something a little bit out of scope of a quick get and set. The first caveat is that the documentation is very slim. One can say that it doesn't need more, but this is only true with basic scenario. To help explaining some limitations, this article will use an example where we will use Dapper.Net to save an entity called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Contest\"), \". It's a class that has properties which are object. Some of them are saved directly in the \\\"Contest\\\" table -- this is called \\\"Complex Object\\\" in Entity Framework. And some others are saved in other tables with a foreign key that link them. It as 3 optional properties in a 0 to 1 relationship which go to other table, also it has two 0 to many (0-*) relationship to other classes. It also have a 1 to 1 relationship that is required. The number of columns in the \\\"Contest\\\" class is about 20. Here is a high level of the class diagram of the Contest class. I added some blue inside the aggregation to illustrate complex object and the white one are for classes that are from different tables than the contest ones.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1024px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/4d3aaed4e20d0d16e6daa4f31ed29b38/72e01/2015-11-23-09.08.57-1024x768.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"75%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAerYoA//xAAXEAADAQAAAAAAAAAAAAAAAAAAAREQ/9oACAEBAAEFAqsiyEP/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAADAQADAAAAAAAAAAAAAAAAAREhQVFx/9oACAEBAAE/IVqojOUh9CMkEnpB/9oADAMBAAIAAwAAABBg3//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABkQAQEBAQEBAAAAAAAAAAAAAAERACExwf/aAAgBAQABPxAaAJzpryGU1HywtAg+zWC1SVdB4b//2Q==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"2015 11 23 09 08 57 1024x768\",\n    \"title\": \"2015 11 23 09 08 57 1024x768\",\n    \"src\": \"/static/4d3aaed4e20d0d16e6daa4f31ed29b38/72e01/2015-11-23-09.08.57-1024x768.jpg\",\n    \"srcSet\": [\"/static/4d3aaed4e20d0d16e6daa4f31ed29b38/f93b5/2015-11-23-09.08.57-1024x768.jpg 300w\", \"/static/4d3aaed4e20d0d16e6daa4f31ed29b38/b4294/2015-11-23-09.08.57-1024x768.jpg 600w\", \"/static/4d3aaed4e20d0d16e6daa4f31ed29b38/72e01/2015-11-23-09.08.57-1024x768.jpg 1024w\"],\n    \"sizes\": \"(max-width: 1024px) 100vw, 1024px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The second Dapper.Net limitation you will get is about the concept of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"complex object\"), \". Dapper.Net doesn't know about it, which is fair since it's a EF concept, but the problem is how can you tell this ORM to map a specific syntax into an object instead of a field directly into the main object (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Contest\"), \"). This is no where in the documentation. Here is two examples that you can see in almost every system: name that is localized and money with currency.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"373px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/97daabe407d5cc481c9878ced1e05e17/67a5d/ComplexObjectDapper.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"33%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAABYlAAAWJQFJUiTwAAABI0lEQVQY002Q0U4CMRBF+f+vMxpZurvtTNuZTmdBFmypyhowoCSep/Nykpu7mudjKaW1VkqptdbTqbX20Vo91VrL6UZrrS3ncynv76Ve/7FyDoe+BwTmBOAAgJidHQHRWmt6A871w7jbqum7wHK9Xi+XyyMG7xFVNasSkRkMc/x1QIgUbgKwn+csZJ17hPc4JaUYKEbJ2XuPHlUlqzKziDDTNG0B3DRNzFGmaVm+l2X5iyWljbkBAMZsANGDfe3WSfLYb6xDRFx3a6LgnNsfji/PT5Hpd/wqZwUEBy7G6L0nIlUVkSScc+bEkjiEkERS4vkwM9N+/+ZjPJ+/Vqp5GIfx/tA4DPfnOMQQAhKztW7TdSHESDEEv91tiVk1d8Z8fn78APQOfRby629oAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"ComplexObjectDapper\",\n    \"title\": \"ComplexObjectDapper\",\n    \"src\": \"/static/97daabe407d5cc481c9878ced1e05e17/67a5d/ComplexObjectDapper.png\",\n    \"srcSet\": [\"/static/97daabe407d5cc481c9878ced1e05e17/5a46d/ComplexObjectDapper.png 300w\", \"/static/97daabe407d5cc481c9878ced1e05e17/67a5d/ComplexObjectDapper.png 373w\"],\n    \"sizes\": \"(max-width: 373px) 100vw, 373px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Dapper.Net is expecting to have properties named \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Name_French, Name_English, InitialCapital_Value, InitialCapital_CurrencyTypeId\"), \". But, the problem is that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Contest\"), \" has 1 property called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Name\"), \" of type \", mdx(\"em\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"em\",\n    \"href\": \"./how-to-have-localized-string-with-mvc-and-entity-framework\"\n  }, \"LocalizedString\")), \" which has 2 properties called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"French\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"English\"), \" and 1 property called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"InitialCapital\"), \" of type \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Money\"), \" which has 2 properties \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Value\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"CurrencyTypeId\"), \". This doesn't work at all. The way to work with Complex Type (and also relationship tables) with Dapper is to use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"multi mapping\"), \" feature. This multi mapping allows you to divide a single database rows into different objects by defining a key pattern which is by default \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"id\"), \". In our example, we could specify that the pattern is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Name_French\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"InitialCapital_Value\"), \" to be the cue to create a new object. The problem is not obvious first but is the limitation that Dapper.Net ORM decided to be built. You cannot have more than 7 mappings. The problem is even more huge when you learn that multi mapping is also the way to work with relationship (join). In our case, just the 1-1, the three 0-1 and the two 0-* take 6 of the multi mapping. This constraint is even worse when you think that some objects in relationship to the main one (contest) may also need to be loaded (multiple inner joins). For example, you are loading a Contest, that as a relationship to a list of User that participate which has a relation to a list of reputations which has a complex object for the type of reputation. Right there, we are using 3 mappings (contest->user, user->reputation, reputation->type). Very fast you hit the 7 multi mapping limitation of Dapper. The limitation of 7 multi-mappings is very arbitrary and could and should be unlimited. In SQL, you can create as much joins as you want and the ORM should follow that principle.\"), mdx(\"p\", null, \"So, a way to get around limitation, you can create multiple select queries at a performance price. What is surprising is that few years ago, this limitation was raised and even got a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/StackExchange/dapper-dot-net/pull/44\"\n  }, \"pull request\"), \" sent to the team to fix the 7 mappings. This one got rejected. Stackoverflow.com has a limited set of tables and not a rich business domain of classes as many enterprise software. This may justify that in their opinion that 7 multi-mappings is enough. That said, working with Dapper and Entity Framework can become more challenging than expected.\"), mdx(\"p\", null, \"A second approach to work with a lot of complex type and relationship is to use a different class which flatten every table fields and then, using a more conventional classes mapping like AutoMapper to map the flatten table class into your rich domain class. However, this come with the cost of having more classes, the cost of having more mapping and finally, more unit test to write to ensure that the data goes from one place to the other one correctly.\"), mdx(\"p\", null, \"A third approach is to use the basic dynamic query which return a row of object. You need to cast each fields but also you need to handle multiple rows from your joins. At that point, you are almost doing what you would do with ADO.Net.\"), mdx(\"p\", null, \"A third Dapper.Net limitation is that it is not possible to configure this one to be wiser. Without being bloated like Entity Framework and without having to have a DbContext, Dapper.Net could have been a little more wise for mapping. You know ORM end with a \\\"M\\\" for \\\"Mapping\\\".\"), mdx(\"p\", null, \"Overall, Dapper.Net can work in parallel of Entity Framework as long as you adapt some of your SQL habits. Reducing the number of join, doing multiple queries, etc. I found it easier to start including Dapper.Net for write scenario than read scenario. This is justify by the fact that most of my insert and update scenario where for 1 entity at a time which just require me to create a basic SQL insert or SQL update query, copy and paste it inside a String variable and bind the object into it and execute. Yet, my current experience with Dapper.Net is mitigated and I feel that the .Net environment still have some place for improvement in the ORM area.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"1f47eede-36ee-5e9f-bdb0-42494282d37c","totalPages":71}},
    "staticQueryHashes": ["3159585216"]}