{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-extend-or-add-conditionnal-clause-to-expression",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to extend (or add) conditionnal clause to Expression<T>","date":"September 27, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to extend (or add) conditionnal clause to Expression<T>\",\n  \"date\": \"2012-09-27\",\n  \"categories\": [\"c-sharp\", \"dynamic\", \"linq\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you need to concatenate two expressions (with OR or AND) this can be done easily with the help of the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.albahari.com/nutshell/linqkit.aspx\"\n  }, \"LinqKit library\"), \".\"), mdx(\"p\", null, \"The idea is to Invoke both expression with the same model object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" Expression<Func<Customer, bool>> filter1 = customer => customer.FirstName == \\\"Test\\\"; Expression<Func<Customer, bool>> filter2 = customer => customer.LastName == \\\"Test\\\"; Expression<Func<Customer, bool>> filter3 = customer => filter1 .Invoke(customer) || filter2.Invoke(customer); \\n\")), mdx(\"p\", null, \"The last step is to use AsExpendable() and to you Expand to the last filter (filter3). \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" IEnumerable<Customer> customers = CustomerRepository.GetAll().AsExpandable().Where(filter3.Expand()).OrderBy(c => c.Id); \\n\")), mdx(\"p\", null, \"The AsExpendable() method simple create a wrapper around the IQueryable to create a ExpendableQuery. From here, the provider will change with the concrete provider ExpendableQueryProvider which inherit from IQueryProvider. This one will call the .Expand() of the expression.\"), mdx(\"p\", null, \"If you go check the source code of the method ExpendableQuery we can see the wrapping.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public static IQueryable<T> AsExpandable<T>(this IQueryable<T> query) { \\n  if (query is ExpandableQuery<T>) \\n    return query; \\n  else \\n    return (IQueryable<T>) new ExpandableQuery<T>(query); \\n} \\n\")), mdx(\"p\", null, \"The expand look like this : \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public static Expression<TDelegate> Expand<TDelegate>(this Expression<TDelegate> expr) { \\n   return (Expression<TDelegate>) new ExpressionExpander().Visit((Expression) expr); \\n} \\n\")), mdx(\"p\", null, \"It call the Visit method of the ExpressionExpander from the Expression.\"), mdx(\"p\", null, \"In short, what you have to remember it the use of LinqKit.dll make you life really easier when you manipulate dynamic expression.\"), mdx(\"p\", null, \"So you have appended two Linq To Entity expression \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://stackoverflow.com/questions/1266742/append-to-an-expression-linq-c\"\n  }, \"http://stackoverflow.com/questions/1266742/append-to-an-expression-linq-c\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"d5c8c99f-fee7-5298-a6ed-3ce74661c94e","totalPages":70}},
    "staticQueryHashes": ["3159585216"]}