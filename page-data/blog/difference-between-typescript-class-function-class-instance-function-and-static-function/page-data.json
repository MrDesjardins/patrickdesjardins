{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/difference-between-typescript-class-function-class-instance-function-and-static-function",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Difference between TypeScript Class Function, Class Instance Function and Static Function","date":"May 1, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Difference between TypeScript Class Function, Class Instance Function and Static Function\",\n  \"date\": \"2017-05-01\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This look like a very basic question to ask. What is the difference between the three different kind of functions you can have in a class? First, some people may be surprise to know that there is more than two. Let's see some code and look at the difference between the three ways to have function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"class User {\\n  private name: string;\\n  constructor(initialName: string) {\\n    this.name = initialName;\\n  }\\n  public greet(): string {\\n    return \\\"Hello, \\\" + this.name;\\n  }\\n\\n  public assign = (s: string, x?: string): void => {\\n    this.name = s;\\n    if (x === undefined) {\\n      console.log(\\\"Undefined\\\");\\n    }\\n  };\\n\\n  private static count = 0;\\n  public static assignStatic() {\\n    User.count = User.count + 1;\\n  }\\n}\\n\\nlet greeter = new User(\\\"Patrick\\\");\\n\")), mdx(\"p\", null, \"This example has a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"class function\"), \" called \\\"greet\\\". This is the most common way to create function in TypeScript. It feels natural from people coming from C# because it's almost the same declaration. You start with the level of encapsulation you want, followed by the name of the function and the parameters and return type.\"), mdx(\"p\", null, \"Under the hood, if you compile with EcmaScript 5 and lower, you will see:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"User.prototype.greet = function () {\\n  return \\\"Hello, \\\" + this.name;\\n};\\n\")), mdx(\"p\", null, \"The default way to create function create a prototype function. A prototype JavaScript function is shared between all instance of your class, but the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \" point to the actual class. Hence, the value is not shared. Why TypeScript is using prototype by default is about performance. Prototype functions are faster and use less memory. So, now, you may have figure out that the next way to create function, the instance function will not use the prototype. And, that right. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Instance function\"), \" setup the method inside the instance. This means that if you have 1000 instances of your class that this method will be created 1000 times. Here is the output:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"this.assign = function (s, x) {\\n  _this.name = s;\\n  if (x === undefined) {\\n    console.log(\\\"Undefined\\\");\\n  }\\n};\\n\")), mdx(\"p\", null, \"You can see that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \" has been changed to use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"_\", \"this\"), \" which is defined by the closure of the instance of the class.\"), mdx(\"p\", null, \"You can see the whole JavaScript generated by the TypeScript code above under this paragraph.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var User = (function () {\\n  function User(initialName) {\\n    var_this = this;\\n    this.assign = function (s, x) {\\n      _this.name = s;\\n      if (x === undefined) {\\n        console.log(\\\"Undefined\\\");\\n      }\\n    };\\n    this.name = initialName;\\n  }\\n  User.prototype.greet = function () {\\n    return \\\"Hello, \\\" + this.name;\\n  };\\n  User.assignStatic = function () {\\n    User.count = User.count + 1;\\n  };\\n  return User;\\n})();\\nUser.count = 0;\\nvar greeter = new User(\\\"Patrick\\\");\\n\")), mdx(\"p\", null, \"The third way to create a function is by setting this one as static. A static function share the same information and function between every instance. The way it's translated is that it set the function at the root of the closure of the type. This is true for the function and for static variable.\"), mdx(\"p\", null, \"When to use which one really depend of what you want to do. The easiest one to understand is static. You need static only if you want to share between instance data. While static may be a performance improvement in C# for method, it's still true in TypeScript BUT you already have that gain with the default class function that generate prototype function. So the main question is when to use an instance function. The main scenario is that this method will be used in a callback mechanism where the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \" pointer may get lost. While there is many pattern around like creating a wrapper function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"class User {\\n  private name: string;\\n  constructor(initialName: string) {\\n    this.name = initialName;\\n  }\\n  public greet(): void {\\n    console.log(\\\"Hello, \\\" + this.name);\\n  }\\n  public greet2 = (): void => {\\n    console.log(\\\"Hello2, \\\" + this.name);\\n  };\\n  public assign = (s: string, x?: string): void => {\\n    this.name = s;\\n    if (x === undefined) {\\n      console.log(\\\"Undefined\\\");\\n    }\\n  };\\n  private static count = 0;\\n  public static assignStatic() {\\n    User.count = User.count + 1;\\n  }\\n}\\nlet greeter = new User(\\\"Patrick\\\");\\nwindow.setTimeout(greeter.greet, 10); // this won't be the user this\\nwindow.setTimeout(() => greeter.greet(), 1000); // this will be user this\\nwindow.setTimeout(greeter.greet2, 2000); // this will be user this\\n\")), mdx(\"p\", null, \"Be aware that I changed a little bit the method and added a greet2 that is an instance function. You can see that I use inside these methods to log out the string. The output is as expected that the first one won't be able to output the name. The reason is that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \" is in the context of the window and not the user. Here is the output: ```typescript\\nHello, Hello, Patrick Hello2, Patrick\"), mdx(\"p\", null, \"A rule of thumb is to use class function as much as possible since they are optimized to not waste too much resource. About callback, using the arrow anonymous function is a great way if you do not need to release the pointer to this event. You may have to release memory manually and the easiest way in would be to use instance function. As you can see, it's not always black or white, but your line of though should be always to think about memory first.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"385b13d8-84fb-5248-a31e-d76c41242498"}},
    "staticQueryHashes": ["3159585216"]}