{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/reducing-boilerplate-of-redux-with-typescript",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Reducing Boilerplate of Redux with TypeScript","date":"May 15, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Reducing Boilerplate of Redux with TypeScript\",\n  \"date\": \"2018-05-15\",\n  \"categories\": [\"redux\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"For quite a while, I found that working with TypeScript and Redux was slow in term of all the boilerplate required when adding a new Redux's action. The creation of a unique constant, a unique type to narrow down the type and then an action creator function to have a unique place to call the action. The last step was to create a union of all actions (type) allowed for the Redux's reducer which was passed in the reducer (similar when the action was used in a middleware). With the arrival of TypeScript 2.8, it's easy to reduce the boilerplate.\"), mdx(\"p\", null, \"First, some generic code must be in place.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export function createActionPayload<TypeAction, TypePayload>(actionType: TypeAction): (payload: TypePayload) => ActionsWithPayload<TypeAction, TypePayload> { \\n  return (p: TypePayload): ActionsWithPayload<TypeAction, TypePayload> => { return { payload: p, type: actionType }; }; \\n  } \\n  \\nexport function createAction<TypeAction>(actionType: TypeAction): () => ActionsWithoutPayload<TypeAction> { \\n  return (): ActionsWithoutPayload<TypeAction> => { \\n    return { payload: {}, type: actionType }; \\n  }; } \\n  \\nexport interface ActionsWithPayload<TypeAction, TypePayload> { \\n  type: TypeAction; \\n  payload: TypePayload; \\n}\\n\\nexport interface ActionsWithoutPayload<TypeAction> { \\n  type: TypeAction; \\n  payload: {}; \\n}\\n\\nexport type ActionsUnion<A extends ActionCreatorsMapObject> = ReturnType<A[keyof A]>; \\n\")), mdx(\"p\", null, \"It might look like a lot of code, but in reality, you won't touch that code at all, just call it. Special mention at the last type which uses a TypeScript 2.8 feature \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReturnType\"), \" which will get all return types of the function we will have in a type removing some manual entries.\"), mdx(\"p\", null, \"At that point, to create a new action consist of few steps but not too many keystrokes.\"), mdx(\"p\", null, \"First, you still need a constant. The constant is of a type of a string literal (not a string) and must be unique by action. This will be used later to narrow the type down to the payload of the action itself. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export const ACTION_1 = \\\"ACTION_1\\\"; \\n\")), mdx(\"p\", null, \"The second step is to create the action with one of the two methods above. One method creates an action with a payload while the second one creates an action without a payload. Something interesting is that it is more convenient to gather all your action into a constant. This way, later, we will leverage the \\\"ReturnType\\\" to get all action type from the action creator function. For example, the example we are building, the action returns a unique type that uses the string literal of the action's constant.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export const SharedActions = { \\n  action1: createActionPayload<typeof ACTION_1, string>(ACTION_1), \\n}; \\n\")), mdx(\"p\", null, \"The third step is to consume the action. We can use a reducer and type the action it receives to have the only action from one or many constant we build. You can still restrict which actions a reducer can receive by specifying which variable that holds many actions with \\\"ActionsUnion\\\". In the example below, I mention that any action from the SharedAction object, and the OtherGroupAction and a specific other one is tolerated in that reducer. The greatest feature of this approach is that once you use a conditional statement like an IF or a SWITCH against the action's type, the type of the payload is narrowed down to the action. This gives an excellent IntelliSense.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"type ReducerAcceptedActions = ActionsUnion<typeof SharedActions & typeof OtherGroupOfAction & GroupB.individualAction>;\\n\\nexport function oneReducerHere( state: State = initialState(), action: ReducerAcceptedActions): State {\\n  switch (action.type) { \\n    case ACTION_1: { // ... } \\n  } \\n} \\n\")), mdx(\"p\", null, \"This way to proceed with Redux and TypeScript removes many boilerplate codes that were initially needed in TypeScript. In the end, the code is easy to read even if you have hundreds or thousands of actions because you can separate them in a bundle. Also, the automatic type narrowing is a bless giving a huge edge when developing by bringing a natural boundary of what is available in each payload automatically.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"772e27d9-6780-5a6b-9974-b9aa52595607","totalPages":71}},
    "staticQueryHashes": ["3159585216"]}