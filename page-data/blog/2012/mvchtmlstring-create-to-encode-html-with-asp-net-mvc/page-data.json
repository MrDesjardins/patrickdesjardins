{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2012/mvchtmlstring-create-to-encode-html-with-asp-net-mvc/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"MvcHtmlString.Create to encode Html with Asp.net MVC","date":"June 4, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"MvcHtmlString.Create to encode Html with Asp.net MVC\",\n  \"date\": \"2012-06-04\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"You may want to use a string that contain Html and display this one not with the Html tag but to execute it. Of course, you would like to do it encoded with Html (to have secure rendering).\"), mdx(\"p\", null, \"This can be done by using MvcHtmlString.Create.\"), mdx(\"p\", null, \"This method takes a string as parameter and return a MvcHtmlString.\"), mdx(\"p\", null, \"So, instead of using directly @Model.YourStringProperty, you should use MvcHtmlString.Create(Model.YourStringProperty)\"), mdx(\"p\", null, \"This method will check if the input (parameter) inherit of IHtmlString, if it does, it won't do anything. The reason is that class that inherit from IHtmlString. If not, it will encode the html output.\"), mdx(\"p\", null, \"From here, you can create your own Html extension to extend\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static class HtmlHelpers { public static MvcHtmlString HtmlEncode(this string data) { return MvcHtmlString.Create(data); } } \\n\")), mdx(\"p\", null, \"This extension will let you encode any string so you could use it with you properties.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" This is my property : @Model.Name.HtmlEncode() \\n\")), mdx(\"p\", null, \"On the other side, if you do not want to have the Html encoded, you could use Html.Raw() method which return a IHtmlString which won't be encoded by MVC framework.\"), mdx(\"p\", null, \"If you go inside the source code of Asp.Net we will find that Html.Raw() use the string and generate a simple IHtmlString from the concrete class HtmlString.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public IHtmlString Raw(string value) { return new HtmlString(value); }\\n\\npublic IHtmlString Raw(object value) { return new HtmlString(value == null ? null : value.ToString()); } \\n\")), mdx(\"p\", null, \"This is different from MvcHtmlString.Create()\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public sealed class MvcHtmlString : HtmlString { public static readonly MvcHtmlString Empty = Create(String.Empty);\\n\\nprivate readonly string_value;\\n\\npublic MvcHtmlString(string value) : base(value ?? String.Empty) {_value = value ?? String.Empty; }\\n\\npublic static MvcHtmlString Create(string value) { return new MvcHtmlString(value); }\\n\\npublic static bool IsNullOrEmpty(MvcHtmlString value) { return (value == null || value._value.Length == 0); } } \\n\")), mdx(\"p\", null, \"Are you can see, this one return a MvcHtmlString. At the end, both return something similar and encoded html.\"), mdx(\"p\", null, \"In the scenario you want to display the html's string you simply need to use the variable: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"@{ var x= \\\"<b>Test</b>\\\"; }\\n@x \\n\")), mdx(\"p\", null, \"To conclude, if you need to display html rendered to the browser, you can use one of the two methods and it will work. The reason is that MvcHtmlString inherit from HtmlString which inherit from IHtmlString. If you need to display the content of the string which contain Html (which will print the Html's string and not the rendered content) simply use directly the variable like : @Model.MyStringWithHtml\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"08b0844f-3bd7-56c8-bc9d-bb98a6b4d17c","slug":"2012/mvchtmlstring-create-to-encode-html-with-asp-net-mvc","__params":{"slug":"2012"}}},
    "staticQueryHashes": ["3159585216"]}