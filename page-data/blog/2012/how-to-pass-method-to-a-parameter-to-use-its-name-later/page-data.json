{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2012/how-to-pass-method-to-a-parameter-to-use-its-name-later/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to pass method to a parameter to use its name later?","date":"March 2, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to pass method to a parameter to use its name later?\",\n  \"date\": \"2012-03-02\",\n  \"categories\": [\"c-sharp\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The interface \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"INotifyPropertyChanged\"), \" require to pass has an event called event \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"PropertyChanged\"), \" that take a String as parameter. This String represent the name of the property changed.\"), mdx(\"p\", null, \"This kind of behaviour exist in many other system. Recently, I had to use a small project called Peta Poco, which is a tiny-tiny-tiny ORM for .Net. This also require to mark properties as modified.\"), mdx(\"p\", null, \"In those both case, the problem is when setting the property, you need to add automatically the name of the property between quotes. When refactoring the name of the property, you have chance that you miss the name change of this String. Most refactoring tool, won't change String value, and that's a good thing.\"), mdx(\"p\", null, \"But, you can simply create a method that use the Lambda Tree Expression to be able to pass the method itself. This way, refactoring the name won't be a problem later.\"), mdx(\"p\", null, \"How to do it is pretty straight forward.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" protected void Modified(Expression<Func<string>> prop) { if (prop== null){ throw new ArgumentNullException(\\\"prop\\\", @\\\"You must have selected a method\\\"); } var body = prop.Body as MemberExpression; if (body == null) throw new ArgumentException(\\\"The body must be a member expression\\\"); //USE : body.Member.Name } } \\n\")), mdx(\"p\", null, \"I put a comment in the above code that indicate how to get the property name. This way, you can add it to your own list or call the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"PropertyChanged\"), \" of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"INotifyPropertyChanged\"), \" .\"), mdx(\"p\", null, \"The use of this method is pretty easy also:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" Modified(()=>this.MyProperty); \\n\")), mdx(\"p\", null, \"Another option is to use System.Reflection.MethodBase. This option let you get the current Method name. This is also a good option but with the disadvantage that you can only have the current Property/Method and not be able to notified others fields. Sometime, you may need to notified multiple Property of a change. This won't give you this flexibility.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" System.Reflection.MethodBase.GetCurrentMethod().Name.Replace(\\\"set_\\\", string.Empty) \\n\")), mdx(\"p\", null, \"The code above give the string of the Property/Method that this line is executed. If it's inside a Property you will need to remove \\\"set\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\" if you use it inside the setter, or \\\"get\"), \"\\\" if you use it inside the getter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public string CustomerEmail { get { return_customerEmail; } set{_customerEmail = value; Modified(System.Reflection.MethodBase.GetCurrentMethod().Name.Replace(\\\"set_\\\", string.Empty)); } } \\n\")), mdx(\"p\", null, \"Another method which is relatively similar to the previous one is to use the Stacktrace to get the method called. This give you the advantage to not have to set any name or property reference to the method/property and just having a method in the inherit class that handle the name of the previous stack method called. This has the disadvantage that you cannot have multiple fields to be notified. This is a good default approach but the one with Lambda Expression should also be implemented to give the developer the leverage to be able to call multiple properties changes.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" private string GetPropertyName() { var callStackTrace = new StackTrace(); var propertyFrame = callStackTrace.GetFrame(1); var properyAccessorName = propertyFrame.GetMethod().Name; return properyAccessorName.Replace(\\\"get_\\\",\\\"\\\").Replace(\\\"set_\\\",\\\"\\\"); } \\n\")), mdx(\"p\", null, \"The code above could be in the top model class that all your model class inherit. This way, You just need to call another method like for example \\\"Update()\\\" which will refer to this GetPropertyName(). Do not forget, that if you call GetPropertyName() from a class in the model class to change GetFrame(1) by GetFrame(2) because the Stack will have YouProperty>Update()>GetPropertyName.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"2802e928-be8c-5f6a-bfb8-198d4539fd07","slug":"2012/how-to-pass-method-to-a-parameter-to-use-its-name-later","__params":{"slug":"2012"}}},
    "staticQueryHashes": ["3159585216"]}