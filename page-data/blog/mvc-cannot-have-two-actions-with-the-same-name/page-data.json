{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/mvc-cannot-have-two-actions-with-the-same-name",
    "result": {"data":{"mdx":{"frontmatter":{"title":"MVC cannot have two actions with the same name","date":"April 11, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"MVC cannot have two actions with the same name\",\n  \"date\": \"2012-04-11\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"You can compile any controller to have the same method name if they have different parameter type or numbers. This is normal in .Net framework but what MVC developer must know is that you cannot have 2 actions (which are methods) with the same name even if they doesn't have the same parameter type. That mean you cannot have :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public ActionResult Edit(int id) { //... } \\n\")), mdx(\"p\", null, \"and in the same controller having:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public ActionResult Edit(MyObjectToEdit obj) { //... } \\n\")), mdx(\"p\", null, \"This will fail when you will call these because the MVC framework won't know which one to call. You have two solutions to make MVC routing know which action to use. First, you can change the name. I think it's obvious that if you have different name that the routing won't have any problem to know which one to choose.\"), mdx(\"p\", null, \"The second solution is to add the attribute POST, GET, PUT, DELETE. This will tell depending of the header. So you could have:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" [HttpGet] public ActionResult Edit(int id) { //... }\\n\\n[HttpPost] public ActionResult Edit(MyObjectToEdit obj) { //... } \\n\")), mdx(\"p\", null, \"From here, you could call them by specifying in the Http Request the type of request you sent (Get or Post) and the MVC's routing system will know which one to choose.\"), mdx(\"h3\", null, \"Wait a minute\"), mdx(\"p\", null, \"Alright, there's a catch and it's if you return from those methods Json cause you cannot return Json from a Get request by default. This is for security purpose. In fact, someone could do the attack \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://haacked.com/archive/2009/06/25/json-hijacking.aspx\"\n  }, \"Json HiJacking\"), \" and harm you only if:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You return data into an array. This can be solved by returning into an object that may contain array.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Return sensitive information. This can be solved by using SSL.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using Get with Json. This can be solved by using Post or having multiple name instead of having the same action with two types of Http call type.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The browser support \\\"\", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"defineSetter\"), \"\\\" which is where the vulnerability is executed. this one, you have no control.\")), mdx(\"p\", null, \"So, it's not a big deal if you know what you are doing. In most case, you can allow Json to return data from Get if you handle what your action return. This mean, you should know what object you return and not returning an array directly.\"), mdx(\"p\", null, \"To allow Json to use Get to return data, simply add as a second parameter \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"JsonRequestBehavior.AllowGet\"), \". This will remove all possible errors.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" return Json(new { MyData = 1, MyData2= \\\"ASD\\\" }, JsonRequestBehavior.AllowGet); \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"9f16577a-ced4-5eed-b3fb-b4fd1003988d"}},
    "staticQueryHashes": ["3159585216"]}