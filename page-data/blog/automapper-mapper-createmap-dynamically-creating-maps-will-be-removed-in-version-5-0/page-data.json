{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/automapper-mapper-createmap-dynamically-creating-maps-will-be-removed-in-version-5-0",
    "result": {"data":{"mdx":{"frontmatter":{"title":"AutoMapper.Mapper.CreateMap : Dynamically creating maps will be removed in version 5.0","date":"May 5, 2016"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"AutoMapper.Mapper.CreateMap : Dynamically creating maps will be removed in version 5.0\",\n  \"date\": \"2016-05-05\",\n  \"categories\": [\"automapper\"],\n  \"tags\": [\"automapper\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"AutoMapper from version 4.2 the static method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CreateMap\"), \" is obsolete and will be removed at version 5. It's been years that people are configuring their mapping with this static method. Most people have divided their mapping into multiple classes across their model (domain) classes. While this can be a big task for huge solution, in most case the migration is simple. This article shows how to migrate from the static \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CreateMap\"), \" method into a custom static variable that will handle all configurations. While the new patterns is great to be injected, it doesn't mean that you should change your whole solution now to go in that direction.\"), mdx(\"p\", null, \"First of all, if you had a custom interface or base class for the classes that define your mapping you should use instead \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AutoMapper.Profile\"), \". Having your class using this interface lets you override a method called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Configure\"), \". You can from that base class call \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"base.CreateMap\"), \". Since you access the CreateMap method, not statically, and with the same signature, the migration is easy. Here is an example.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class OverallMapping: Profile { protected override void Configure() { base.CreateMap<HealthOverall, HealthOverallViewModel>(); } } \\n\")), mdx(\"p\", null, \"The last step is to have all profiles loaded into your static variable. The easiest way is to use reflection to loops through all classes and to get all classes that inherit from \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Profile\"), \". The method that use the reflection is called once in your Global.asax.cs during the application start. Since it's called once, the reflection call is not problematic on performance of your web application.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static class MappingConfiguration { public static void CreateMapping() { var profiles = (from type in typeof(MappingConfiguration).Assembly.GetTypes() where typeof(Profile).IsAssignableFrom(type) && !type.IsAbstract && type.GetConstructor(Type.EmptyTypes) != null select type).Select(d => (Profile)Activator.CreateInstance(d)) .ToArray();\\n\\nvar config = new MapperConfiguration(cfg => { foreach (var profile in profiles) { cfg.AddProfile(profile); } }); MapperFacade.MapperConfiguration = config.CreateMapper(); } }\\n\\npublic static class Mapper{ public static IMapper MapperConfiguration; } \\n\")), mdx(\"p\", null, \"The static class and static property that hold all mapping is what you need to use in your application to map anything. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var viewModel = MapperFacade.MapperConfiguration.Map<HealthOverall, HealthOverallViewModel>(model); \\n\")), mdx(\"p\", null, \"That's it! Pretty straight forward. What is time consuming is to change mapping configuration but this is still limited if your application already had a good division about how to define the mapping.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"723e1c6a-9a36-5dd8-92cf-f57ae346c1c4","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}