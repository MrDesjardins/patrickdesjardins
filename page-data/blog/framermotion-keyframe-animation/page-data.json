{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/framermotion-keyframe-animation",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Using Framer Motion to animate keyframe event on a parent following up by a children transition","date":"October 20, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Using Framer Motion to animate keyframe event on a parent following up by a children transition\",\n  \"date\": \"2022-10-20\",\n  \"categories\": [\"typescript\", \"react\", \"framer\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this article, we will fade in a tiny box into the viewport by using animated steps. The animation uses \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.framer.com/motion/\"\n  }, \"Framer Motion\"), \", which is a React library that helps perform animation using CSS transitions. \"), mdx(\"p\", null, \"This article focus on using animation with steps, also known as key frames. The keyframes change the position and the size of the box at a specific time. On unmount, we will animate the box to leave the screen using a different set of keyframes. \"), mdx(\"p\", null, \"The exciting part of the article is how to keep the box's content hidden until the main animation is completed. Similarly, when it is time to move the box out of sight, the box's content needs to disappear first. The reason is to avoid having the content badly rendered on screen. For example, you can imagine having a form with many inputs inside the box. When it starts at a tiny size, it will look unattractive to see a portion of the form.\"), mdx(\"p\", null, \"Here is the animation with a bug on the unmount that we will fix in this article\"), mdx(\"h1\", null, \"Key Frames\"), mdx(\"p\", null, \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.framer.com/motion/\"\n  }, \"Framer Motion\"), \" has many ways to perform animation, and one of them is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.framer.com/docs/animation/##keyframes\"\n  }, \"keyframes\"), \". Keyframing is the idea of using an array that defines the values to be used. Each index of that array is a frame. Then, you specify a specific percentage of the total duration for each index.\"), mdx(\"p\", null, \" For example, you can set 3 values for a left coordinate using the property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" and an array of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[50, 75, 125]\"), \". It means that Framer now has three keyframes. The first one at index 0 mentions that the position of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" is 50. Then, later, the second keyframe indicate the position to be 75 and finally to be 125.\"), mdx(\"p\", null, \"To set these keyframes from a sequential order into a timeline, you need to set in the transition two properties.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"transition={{\\n  duration: 2\\n  times: [0, 0.25, 1]\\n}}\\n\")), mdx(\"p\", null, \"For example, if you set the transition to be 2 seconds and have a timeline of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[0, 0.25, 1]\"), \", it means that at 0 second, the position is 50 pixels. At 500ms (2 sec \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \" 0.25), the position is 75 pixels. And finally, at 2 seconds (2 seconds \"), \" 1.00) the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" position is at pixel 125.\"), mdx(\"iframe\", {\n    src: \"https://codesandbox.io/embed/framer-motion-keyframe-nxfdx3?fontsize=14&hidenavigation=1&theme=dark&view=preview\",\n    style: {\n      \"width\": \"100%\",\n      \"height\": \"500px\",\n      \"border\": \"0\",\n      \"borderRadius\": \"4px\",\n      \"overflow\": \"hidden\"\n    },\n    title: \"Framer Motion: Keyframe\",\n    allow: \"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\",\n    sandbox: \"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n  }), mdx(\"h1\", null, \"The Problem with Parent-Child\"), mdx(\"p\", null, \"In our scenario, having only the parent using keyframes allows moving the box from a tiny rectangle into a big one without issue. However, the content shows during the movement making the animation look odd.\"), mdx(\"p\", null, mdx(\"undefined\", {\n    parentName: \"p\"\n  }, \"\\n      \", mdx(\"div\", {\n    \"className\": \"gatsby-video-aspect-ratio\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"paddingTop\": \"62.3059866962306%\"\n    }\n  }, \"\\n    \", mdx(\"video\", {\n    parentName: \"div\",\n    \"preload\": \"\",\n    \"autoPlay\": true,\n    \"muted\": true,\n    \"loop\": true,\n    \"playsInline\": true,\n    \"style\": {\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\",\n      \"width\": \"100%\",\n      \"height\": \"auto\"\n    }\n  }, \"\\n      \", mdx(\"source\", {\n    parentName: \"video\",\n    \"src\": \"/static/FramerMotionAnimationKeyFrameBad2-b32cf4747324dba1c822f3ac2eadd038-01206.webm\",\n    \"type\": \"video/webm\"\n  }), mdx(\"source\", {\n    parentName: \"video\",\n    \"src\": \"/static/FramerMotionAnimationKeyFrameBad2-b32cf4747324dba1c822f3ac2eadd038-50762.mp4\",\n    \"type\": \"video/mp4\"\n  }), \"\\n    \"), \"\\n    \"), \"\\n    \")), mdx(\"p\", null, \"Thus, hiding the children's content until the animation is almost completed is a good start. Then, on exit, hiding as fast as possible and moving out is the next move. There are many potential solutions, like using keyframes on the child, but that was causing a different issue of timing. Even synchronous mechanisms like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"layout\"), \" were not performing well on unmounting.\"), mdx(\"p\", null, mdx(\"undefined\", {\n    parentName: \"p\"\n  }, \"\\n      \", mdx(\"div\", {\n    \"className\": \"gatsby-video-aspect-ratio\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"paddingTop\": \"68.62745098039215%\"\n    }\n  }, \"\\n    \", mdx(\"video\", {\n    parentName: \"div\",\n    \"preload\": \"\",\n    \"autoPlay\": true,\n    \"muted\": true,\n    \"loop\": true,\n    \"playsInline\": true,\n    \"style\": {\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\",\n      \"width\": \"100%\",\n      \"height\": \"auto\"\n    }\n  }, \"\\n      \", mdx(\"source\", {\n    parentName: \"video\",\n    \"src\": \"/static/FramerMotionAnimationKeyFrameBad-7ca147b848bbae7289db534ca3f9d0bc-01206.webm\",\n    \"type\": \"video/webm\"\n  }), mdx(\"source\", {\n    parentName: \"video\",\n    \"src\": \"/static/FramerMotionAnimationKeyFrameBad-7ca147b848bbae7289db534ca3f9d0bc-50762.mp4\",\n    \"type\": \"video/mp4\"\n  }), \"\\n    \"), \"\\n    \"), \"\\n    \")), mdx(\"h1\", null, \"Simplicity Triumph\"), mdx(\"p\", null, \"The solution is more straightforward than it seems. Instead of using keyframes on the child or using delay on the child, a more pragmatic solution is to set the timing of the child directly on the transition event (initial/exit). On the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"animate\"), \", we put a delay of 0.9 seconds which is 100ms faster than the parent animation, then set the opacity to 1 in 100ms. It makes the child's content appears right when the parent stops moving.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"<motion.div\\n  initial={{ opacity: 0 }}\\n  animate={{\\n    opacity: 1,\\n    transition: {\\n      delay: 0.9,\\n      duration: 0.1\\n    }\\n  }}\\n  exit={{\\n    opacity: 0,\\n    transition: {\\n      duration: 0.1\\n    }\\n  }}\\n>\\n  More content\\n</motion.div>\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"exit\"), \" needs to have the opposite: a quick fade out. Hence, we have no \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"delay\"), \" property and a brief \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"duration\"), \" of 100ms that is executed immediately as the parent starts moving out.\"), mdx(\"iframe\", {\n    src: \"https://codesandbox.io/embed/framer-motion-keyframe-part-2-e7ob6w?fontsize=14&hidenavigation=1&theme=dark\",\n    style: {\n      \"width\": \"100%\",\n      \"height\": \"500px\",\n      \"border\": \"0\",\n      \"borderRadius\": \"4px\",\n      \"overflow\": \"hidden\"\n    },\n    title: \"Framer Motion: Keyframe Part 2\",\n    allow: \"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\",\n    sandbox: \"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n  }), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"Working with Framer Motion simplifies the animation overall, but it is easy to fall into the trap of an overcomplicated solution. It is not obvious how to debug has everything inject CSS animation/transition into HTML styles. Still, by staying simple, you can find a solution like the one proposed in this article.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"18f2c64e-f542-5613-b8bc-39b60fed04af","totalPages":73}},
    "staticQueryHashes": ["3159585216"]}