{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/rust-struct-memory-function",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Rust: Structure Memory when Using a Function","date":"November 4, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Rust: Structure Memory when Using a Function\",\n  \"date\": \"2022-11-04\",\n  \"categories\": [\"rust\", \"memory\", \"function\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I recently learned about the tool called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"clippy\"), \" that is available if you use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo\"), \". It provides lint information on your Rust code to ensure you are using good practices but also helps to use Rust idiomatic and consistent code. For example, one recommendation was to not use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".clone()\"), \" on one of my structures. The suggestion made me think. I was passing the structure into a few functions, and I wanted to ensure no function was modifying the content. \"), mdx(\"p\", null, \"Coming from a JavaScript/TypeScript background, I am cloning and passing the clone to have immutability. However, in Rust, passing a structure in a function does not give a reference in memory to that structure. Nor that passing a structure into a function allows the function to mutate. Rust has two explicit keywords: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mut\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&\"), \" to allow mutation and to pass by reference.\"), mdx(\"p\", null, \"Here is a short code that illustrates how a structure is preserved. But, first, let's create a structure.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rs\"\n  }, \"#[derive(Copy, Clone)]\\nstruct Test {\\n    x: u32\\n}\\n\")), mdx(\"p\", null, \"Second, let's create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"main\"), \" function that will create a structure we do not want to modify.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rs\"\n  }, \"fn main() {\\n    // Create value and print its memory address\\n    let t = Test {x:1};\\n    println!(\\\"Original t: {:p}\\\", &t);\\n\\n    // Call the mutate function\\n    let new_t = mutate(t);\\n\\n    // Print the values\\n    println!(\\\"{}\\\",t.x);\\n    println!(\\\"{}\\\",new_t.x);\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"main\"), \" function calls the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mutate\"), \" and returns a new instance of the struct. The expectation is that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" remains with the value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \" and that the returned value will be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"100\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rs\"\n  }, \"fn mutate(t_param: Test) ->Test {\\n    // Create a variable that is `x` but marked that it can be mutated\\n    let mut new_test = t_param;\\n\\n    // Print memory address\\n    println!(\\\"t_param: {:p}\\\", &t_param);\\n    println!(\\\"new_test: {:p}\\\", &new_test);\\n\\n    // Mutate the value from 1 to 100\\n    new_test.x = 100;\\n    new_test\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mutate\"), \" function cannot change the value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t_param.x\"), \" without the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mut\"), \" keyword. Rust will throw a compilation error saying that the variable must be mutable. Adding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mut\"), \" to a new variable creates new variables. The memory prints below the assignment show two addresses, which means that the variable passed by the parameter (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t_param\"), \") is not using the same memory as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new_test\"), \".\"), mdx(\"p\", null, \"The program prints:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"Original t: 0x7ffcc6ba0e94\\nt_param:    0x7ffcc6ba0dc0\\nnew_test:   0x7ffcc6ba0dc4\\n1\\n100\\n\")), mdx(\"h1\", null, \"Moving Ownership\"), mdx(\"p\", null, \"In the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mutate\"), \" function, we moved ownership to another variable by assigning the parameter to a new variable.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rs\"\n  }, \"let mut new_test = t_param;\\n\")), mdx(\"p\", null, \"The ownership is not transferred because of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mut\")), mdx(\"p\", null, \"The same occurs when we assign a variable to a function by parameter. For example, moves ownership in the following code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rs\"\n  }, \"let new_test = t_param;\\n\")), mdx(\"p\", null, \"The reason is to avoid having two or more variables with a pointer to a space in memory. It avoids bugs.\"), mdx(\"p\", null, \"The consequence of moving the ownership is that the former variable cannot access anything from the object.\"), mdx(\"p\", null, \"Let's modify the former example and see:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rs\"\n  }, \"fn main() {\\n    let mut t = Test {x:1};\\n    let mut new_test = t;\\n    println!(\\\"t_param: {}\\\", t.x);\\n    println!(\\\"new_test: {}\\\", new_test.x);\\n    \\n    t.x = 2;\\n    new_test.x = 1000;\\n    println!(\\\"t_param: {}\\\", t.x);\\n    println!(\\\"new_test: {}\\\", new_test.x);\\n    \\n    println!(\\\"t_param: {:p}\\\", &t);\\n    println!(\\\"new_test: {:p}\\\", &new_test);\\n}\\n\")), mdx(\"p\", null, \"The output is:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"t_param: 1\\nnew_test: 1\\nt_param: 2\\nnew_test: 1000\\nt_param: 0x7ffd03e227f0\\nnew_test: 0x7ffd03e227f4\\n\")), mdx(\"p\", null, \"We can see that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t_param\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new_test\"), \" can adjust the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" without affecting each other.\"), mdx(\"h1\", null, \"Function Parameter\"), mdx(\"p\", null, \"What small detail that may have gone unnoticed is the trait above the struct \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[derive(Copy, Clone)]\"), \". This is required to pass the structure in a function otherwise would create a compilation error with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"borrow of moved value\"), \" message. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"copy\"), \" trait is required because, unlike primitive types, they are copied by default. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"clone\"), \" is required because of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"copy\"), \" trait. You can quickly see what I am saying by clicking in VSCode on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"copy\"), \", which will lead you to the source code of the trait, and you will see:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rs\"\n  }, \"#[rustc_unsafe_specialization_marker]\\n#[rustc_diagnostic_item = \\\"Copy\\\"]\\npub trait Copy: Clone {\\n    // Empty.\\n}\\n\")), mdx(\"p\", null, \"We can step back and have the code (without trait on the struct). Then, we realize the code does not comply with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"borrow of moved value\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rs\"\n  }, \"struct Test {\\n    x: u32\\n}\\n\\nfn main() {\\n    let t = Test {x:1};\\n    let new_test = t;\\n    println!(\\\"t_param: {:p}\\\", &t);\\n    println!(\\\"new_test: {:p}\\\", &new_test);\\n}\\n\")), mdx(\"p\", null, \"Adding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[derive(Copy, Clone)]\"), \" makes the compiler happy. Once again, the reason is that we are moving from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new_test\"), \", which does a copy.\"), mdx(\"p\", null, \"The output is with two different addresses:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"t_param: 0x7ffda950bdb0\\nnew_test: 0x7ffda950bdb4\\n\")), mdx(\"h1\", null, \"Reference a.k.a. borrowing\"), mdx(\"p\", null, \"Sometimes, you may want to pass more than one variable without making copies. For example, you are giving a reference, or in the Rust's lingo, is to borrow, which cause an alias to the source of truth. However, there are some additional rules. For example, borrowing into a mutable variable with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&mut\"), \" is only possible once per scope, a.k.a. lifetime. So, for example, you can \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&mut\"), \" in a function once and do it again in another function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rs\"\n  }, \"#[derive(Copy, Clone)]\\nstruct Test {\\n    x: u32\\n}\\n\\nfn main() {\\n    let mut t = Test {x:1};\\n    println!(\\\"t_param: {}\\\", t.x);\\n    println!(\\\"t_param: {:p}\\\", &t);\\n    display(&mut t);\\n    println!(\\\"t_param: {}\\\", t.x);\\n    println!(\\\"t_param: {:p}\\\", &t);\\n}\\n\\nfn display(new_test: &mut Test){\\n    new_test.x = 1000;\\n    println!(\\\"Function x value: {}\\\", new_test.x);\\n    println!(\\\"Function struct ref address: {:p}\\\", new_test);\\n}\\n\")), mdx(\"p\", null, \"In this example, the output of add the addresses is the same:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"t_param: 1\\nt_param: 0x7ffc5187bd64\\nFunction x value: 1000\\nFunction struct ref address: 0x7ffc5187bd64\\nt_param: 1000\\nt_param: 0x7ffc5187bd64\\n\")), mdx(\"p\", null, \"The function shows that the reference address is the same as the original struct with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x7ffc5187bd64\"), \". \"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"Clippy was right! There was no need to call explicitly \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".clone()\"), \" because the structure is getting cloned automatically.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"6a1ac22f-1435-5798-8cec-efa54004a159","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}