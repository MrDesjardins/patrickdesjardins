{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/how-to-simplify-comprehension-of-a-complex-entity-framework-query",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to simplify comprehension of a complex Entity Framework Query","date":"July 17, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to simplify comprehension of a complex Entity Framework Query\",\n  \"date\": \"2012-07-17\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"You may run into the case of where the Linq to Entity query is long and complex.\"), mdx(\"p\", null, \"If you are using a layer of abstraction to access your database (DAL \\\"Data Access Layer) that return IQueryable you may be surprise that you can divide your query into multiple IQueryable and to merge all Linq to Entity back into a single IQueryable.\"), mdx(\"p\", null, \"The first step is to create your method into your DAL. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public IQueryable<MyModel> GetMyModel() { //Linq to Entity is returned here } \\n\")), mdx(\"p\", null, \"The second step is to create query in logical group. Let say you desire to have all objects of your MyModel that is over 100$ and another condition is that you want also all those over 20$ if they have a discount.\"), mdx(\"p\", null, \"You can do it with a single Linq to Entity, but in some situation (more complex than the one exposed here) you may found easier to cut the problem in sub query.\"), mdx(\"p\", null, \"This can be done by using multiple IQueryable.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public IQueryable<MyModel> GetMyModel() { var query1 = //Linq to Entity with condition for > 100$ var query2 = //Linq to Entity with condition for > 20$ && Discount > 0$ //return query1 + query 2 } \\n\")), mdx(\"p\", null, \"The last step is to merge query 1 and query 2. You can do it in two differents way with Linq. The first one is to use the Union keyword and the second is with Concat.\"), mdx(\"p\", null, \"The difference between the two is that union will merge only when not already present when concat will merge everything. Here is a small snippet of code that illustrate this theory.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var set1 = new int[] { 1, 2, 3 }; var set2 = new int[] { 3, 4, 5 };\\n\\nvar result= set1.AsQueryable().Concat(set2.AsQueryable()); // count == 6 var result2 = set1.AsQueryable().Union(set2.AsQueryable()); // count == 5 \\n\")), mdx(\"p\", null, \"Our example could look with union like this: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public IQueryable<MyModel> GetMyModel() { var query1 = //Linq to Entity with condition for > 100$ var query2 = //Linq to Entity with condition for > 20$ && Discount > 0$ return query1.union(query2); //Both condition } \\n\")), mdx(\"p\", null, \"Since we are using IQueryable, none of the query are executed until their execution. That mean that that Sql Server will receive a single query (with multiple sub query).\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"98a892b0-05d4-565b-8e0a-0bbc4c2c6e25"}},
    "staticQueryHashes": ["3159585216"]}