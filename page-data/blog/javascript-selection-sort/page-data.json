{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/javascript-selection-sort",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Selection Sort","date":"June 28, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Selection Sort\",\n  \"date\": \"2017-06-28\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The selection sort is a very primitive sort that has two loops. They are both imbricated which cause an asymptotic analysis of the upper bound to be O(n^2). The selection sort loops a first time all elements except the last one of the array which allow to evaluate every data. The second loop, is there to find the smallest value after the first loop and swap any smallest value if one found.\"), mdx(\"p\", null, \"The idea is : find the smallest one, put it at the beginning.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function swap(array, left, right) {\\n  var temp = array[left];\\n  array[left] = array[right];\\n  array[right] = temp;\\n}\\nfunction selectionSort(arrayToSort) {\\n  var length = arrayToSort.length;\\n  var minIndex = -1;\\n  for (var i = 0; i < length - 1; i++) {\\n    minIndex = i;\\n    for (var j = i + 1; j < length; j++) {\\n      if (arrayToSort[j] < arrayToSort[minIndex]) {\\n        minIndex = j;\\n      }\\n    }\\n    if (minIndex !== i) {\\n      swap(arrayToSort, minIndex, i);\\n    }\\n  }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"257f59f5-e256-5856-aa26-eb5bb6e176c5","totalPages":68}},
    "staticQueryHashes": ["3159585216"]}