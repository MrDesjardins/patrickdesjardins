{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/enterprise-asp-net-mvc-part-6-the-three-layers-of-validation",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Enterprise Asp.Net MVC Part 6: The three layers of validation","date":"November 7, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Enterprise Asp.Net MVC Part 6: The three layers of validation\",\n  \"date\": \"2012-11-07\",\n  \"categories\": [\"asp\", \"asp-mvc\", \"c-sharp\", \"enterprise\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Validations is definitely a serious subject. If no validation is made, then the system is compromise. Whatever the architecture, whatever the hardware setup and whatever the idea of the product, you need to implement validations to protect your system. This is why it must be taken seriously.\"), mdx(\"p\", null, \"By default, Asp.Net MVC handles validation and also \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./model-validation-and-entity-framework-4-3\"\n  }, \"Entity Framework uses the same interface to handle validation\"), \" entities. So, why not use what is already in place and not try to reinvent the wheel. In fact, we follow the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://en.wikipedia.org/wiki/KISS_principle\"\n  }, \"KISS\"), \" principle.\"), mdx(\"p\", null, \"Here is an overview of the article in a single image.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"265px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/2558ab1d3593c9c3362f734a2dcb3ef3/78e79/Validation-265x400.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"150.9433962264151%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,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')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Validation 265x400\",\n    \"title\": \"Validation 265x400\",\n    \"src\": \"/static/2558ab1d3593c9c3362f734a2dcb3ef3/78e79/Validation-265x400.png\",\n    \"srcSet\": [\"/static/2558ab1d3593c9c3362f734a2dcb3ef3/78e79/Validation-265x400.png 265w\"],\n    \"sizes\": \"(max-width: 265px) 100vw, 265px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"We have 3 layers of validation. The first layer and third layer are built-in with .Net with the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./how-to-validate-model-object-with-asp-net-mvc-correctly\"\n  }, \"IValidatableObject interface\"), \". I have \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./how-to-validate-model-object-with-asp-net-mvc-correctly\"\n  }, \"already\"), \" discussed about this interface for validating entity but I'll show you how to use it in a more \\\"enterprise way\\\".\"), mdx(\"h1\", null, \"Using IValidatableObject\"), mdx(\"p\", null, \"This interface lets you have a single method called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Validate\"), \" which lets you return error message linked to a property method. If you want a general error, you can also specify an empty string for the property name. Simple? Yes. Powerful? Even more! The framework know this interface and it automatically uses the validation when the model is bound from a Http request to your view model by the Model Binder. The .Net framework automatically call this method when Entity Framework try to save entities to the database. This mean that you have nothing to do, but to add your business logic validation.\"), mdx(\"p\", null, \"From here, it's interesting to force every model to have this interface and this is why a good place to inherit from \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IValidatableObject\"), \" is in the BaseModel.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public abstract class BaseModel : IValidatableObject { public const int NOT_INITIALIZED = -1; public int Id { get; set; }\\n\\n#region Implementation of IValidatableObject\\n\\npublic abstract IEnumerable<ValidationResult> Validate(ValidationContext validationContext);\\n\\n#endregion\\n\\n}\\n\")), mdx(\"p\", null, \"Every model have to define the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Validate\"), \" method. If no validation is required, the method is simply empty. Let's go back with the Workout entity and add some validations.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Workout : BaseModel, IUserOwnable {\\n  public DateTime StartTime { get; set; }\\n  public DateTime? EndTime { get; set; }\\n  public string Name { get; set; }\\n  public string Goal { get; set; }\\n  public ICollection<WorkoutSession> Sessions { get; set; }\\n\\n  public override IEnumerable<ValidationResult> Validate(ValidationContext validationContext) {\\n    if (string.IsNullOrEmpty(Name)) {\\n      yield return new ValidationResult(\\\"Name is mandatory\\\", new[] {\\\"Name\\\"});\\n    }\\n    if (EndTime.HasValue) {\\n      if (StartTime > EndTime.Value) {\\n        yield return new ValidationResult(\\\"EndTime must be after the StartTime\\\", new[] {\\\"StartTime\\\", \\\"EndTime\\\"});\\n      }\\n    }\\n  }\\n\\n  #region Implementation of IUserOwnable\\n\\n  public int UserId { get; set; }\\n\\n  #endregion\\n}\\n\")), mdx(\"p\", null, \"Every time we have an error we return a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ValidationResult\"), \". We specify a message and an array of properties that are concerned by the error. In this example, the name is validated and the EndTime property too but only when this one is specified.\"), mdx(\"h1\", null, \"The first layer of validation : Model Binding inside the controller\"), mdx(\"p\", null, \"We have implemented the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IValidatableObject\"), \" and when a Http request is done to the server, the controller bind the data to the model. Since we are using the ViewModel approach, this validation is not triggered! But, since we have a BaseController and already have defined the new approach of having the model to be automapped automatically it hooks the validation and apply it when the ViewModel is mapped to the Model. (You have to go read previous post of \\\"Business\\\" category to understand why it's automatically mapped.)\"), mdx(\"p\", null, \"The first modification occurs in the override method \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"OnActionExecuting\"), \" that should be already overrided with the modification of the mapper. We simply need to check if the model bound is really a IValidatableObject and to trig the validation mechanism.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"protected override void OnActionExecuting(ActionExecutingContext filterContext) {\\n  base.OnActionExecuting(filterContext); if(filterContext.ActionParameters.Any()) {\\n    var possibleViewModel = filterContext.ActionParameters.FirstOrDefault(x => x.Value.GetType() == typeof(TViewModel));\\n    if (possibleViewModel.Value!=null) {\\n      var viewModel = (TViewModel) possibleViewModel.Value;\\n      var model = (TModel) Activator.CreateInstance(typeof (TModel));\\n      Model =_mapperFactory.Map(viewModel, model);\\n      ApplyOwnership();\\n      ApplyErrorsToModelState();\\n    }\\n  }\\n}\\n\\nprivate void ApplyErrorsToModelState() {\\n  if (Model is IValidatableObject) {\\n    var errors = (Model as IValidatableObject).Validate(new ValidationContext(this));\\n    foreach (var validationResult in errors) {\\n      foreach (var memberName in validationResult.MemberNames) {\\n        ModelState.AddModelError(memberName, validationResult.ErrorMessage);\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"What we are doing is a general method that works for any entities. We verify if the Model bound from the ViewModel is really inherited from a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IValidatableObject\"), \". From here, we do what the framework would do if we weren't using view model : calling the Validate method of the interface. We then loop all error and assign everything to the ModelState. This will give us the possibility to act like if no view model has been used.\"), mdx(\"p\", null, \"The code above about the method \\\"ApplyErrorsToModelState\\\" could be replaced with the code below to be able to validate the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data annotation\"), \" AND also the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IValidatableObject\"), \" interface.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" private void ApplyErrorsToModelState() { ModelMetadata metadata = ModelMetadataProviders.Current.GetMetadataForType(() => Model, Model.GetType());\\n\\nforeach (ModelValidationResult validationResult in ModelValidator.GetModelValidator(metadata, this.ControllerContext).Validate(null)) { var propertyName = validationResult.MemberName; ModelState.AddModelError(propertyName, validationResult.Message); } }\\n\")), mdx(\"p\", null, \"The code above validate the data annotation and the IValidatableObject. This can be used in a scenario where you need to have deeper validation process. For example here is the same code as above with enhanced validation on the mapping. This required to have split both validation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"private void ApplyErrorsToModelState(TModel model, TViewModel viewModel) {\\n  //Data Annotation validation\\n  ICollection<ValidationResult> result;\\n  ValidateDataAnnotation(model, out result);\\n  foreach (ValidationResult validationResult in result) {\\n    foreach (string memberName in validationResult.MemberNames) {\\n      ModelState.AddModelError(memberName, validationResult.ErrorMessage);\\n    }\\n    }\\n  //IValidatableObject validation\\n  if (Model is IValidatableObject) {\\n    IEnumerable<ValidationResult> errors = (Model as IValidatableObject).Validate(new ValidationContext(this));\\n    foreach (ValidationResult validationResult in errors) {\\n      if (validationResult is EnhancedMappedValidationResult<TModel>) {\\n          var enhanced = (EnhancedMappedValidationResult<TModel>)validationResult;\\n          var viewModelPropertyName =_mapperFactory.GetMapper(model, viewModel).GetErrorPropertyMappedFor(enhanced.Property); ModelState.AddModelError(viewModelPropertyName, validationResult.ErrorMessage);\\n      } else {\\n        if (validationResult.MemberNames.Any()) {\\n          foreach (string memberName in validationResult.MemberNames) {\\n            ModelState.AddModelError(memberName, validationResult.ErrorMessage);\\n          }\\n        } else {\\n          ModelState.AddModelError(string.Empty, validationResult.ErrorMessage);\\n        }\\n      }\\n    }\\n  }\\n  /* //This validate underlying entity which can be not fully loaded in the case of reference ModelMetadata metadata = ModelMetadataProviders.Current.GetMetadataForType(() => Model, Model.GetType());\\n\\n  foreach (ModelValidationResult validationResult in ModelValidator.GetModelValidator(metadata, this.ControllerContext).Validate(null)) { \\n    var propertyName = validationResult.MemberName; \\n    ModelState.AddModelViewModelToErrorsMap(propertyName, validationResult.Message); \\n  }\\n  */\\n}\\n\\n  private bool ValidateDataAnnotation(object entity, out ICollection<ValidationResult> results) {\\n    var context = new ValidationContext(entity);\\n    results = new List<ValidationResult>();\\n    return Validator.TryValidateObject(entity, context, results, true);\\n  }\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" [HttpPost] public ActionResult Create(WorkoutViewModel viewModel) { \\n  if (ModelState.IsValid) //This is the default Asp.Net MVC way to validate entity \\n  { \\n    //Save the entity\\n\")), mdx(\"p\", null, \"This is great because it's the default way to validate object that has been bound in MVC. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IsValid\"), \" doesn't only validate our business logic but also validate all data annotation that could have been set. It's even greater because people that are used to use the ModelState for validation won't have to learn a new way to act with controllers because it's the same.\"), mdx(\"h1\", null, \"The second layer of validation : Service layer\"), mdx(\"p\", null, \"So far, the validation works fine but it doesn't handle the case that you need to validate across many entities. You can have case that you need to validate an entity dependently of the value of others entities. It can also be a validation from some value that are inside the database. Since Model doesn't have access to the repository, at this moment, we couldn't validate. To solve this problem, the second layer of validation is required and the perfect place it's in the Service layer. The reason is that this layer does have access to all entities and also have access to all repositories. Contrary to the first layer of validation, this one will require some manual explicit call for validation. The concrete implementation of this second layer of validation will be done with the Workout entity. What we want to implement is a validation that the active user cannot create more than 3 workouts per month without a premium account. That mean that we need to go check in the database the amount of workout for a specific user for a specific month. This couldn't be validate in the Workout class because it doesn't have access to the database.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public int Create(Workout model) { \\n  int amountWorkout = Repository.Workout.GetAmountWorkoutForCurrentMonth(); \\n  if (amountWorkout>3)//More than 3 workouts done without premium account \\n  { \\n    throw new ValidationErrors(new GeneralError(\\\"You have reach the limit of 3 workouts per month, you need premium or wait the next month\\\")); \\n  } \\n  return Repository.Workout.Insert(model); \\n}\\n\")), mdx(\"p\", null, \"This get the amount of workout for the month and if it's over a certain threshold will raise the error.\"), mdx(\"p\", null, \"The error is handled by the controller that verify that the action executed has been completed without error. Here is the Create action of the Workout controller with the first layer validation and with the catch for the second layer.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"[HttpPost] \\npublic ActionResult Create(WorkoutViewModel viewModel) { \\n  if (ModelState.IsValid) { \\n    try {_service.Create(Model); } \\n    catch (ValidationErrors propertyErrors) { \\n      ModelState.AddValidationErrors(propertyErrors); \\n    } \\n  } \\n  return View(\\\"Create\\\"); \\n}\\n\")), mdx(\"p\", null, \"The exception type is ValidationErrors which is our custom error handler. The reason is that we do not want to use specific exception from other layers. This is why cross layers classes will be used to transport exception through all layers. This will be discussed after the third layer of validation.\"), mdx(\"h1\", null, \"The third layer of validation : Persistence layer\"), mdx(\"p\", null, \"The persistence layer is where the call to the database is done. This is an automatic validation with Entity Framework that call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IValidatableObject\"), \" interface of the entity before save it to the database.\"), mdx(\"p\", null, \"But, since we do not want to raise a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DbEntityValidationResult\"), \" up to the controller (because it's a class that belong to Entity Framework (System.Data.Entity.Validation), we will use our own exception classes.\"), mdx(\"p\", null, \"We will create an interface that will hold the property name in error and also the error message.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public interface IBaseError { \\n  string PropertyName { get; } \\n  string PropertyExceptionMessage { get; } \\n}\\n\")), mdx(\"p\", null, \"Two classes will inherit from this interface. One for a property error and one for a general error.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class PropertyError:IBaseError { \\n  public string PropertyName { get; set; } \\n  public string PropertyExceptionMessage { get; set; } \\n  public PropertyError(string propertyName, string errorMessage) { this.PropertyName = propertyName; this.PropertyExceptionMessage = errorMessage; } \\n}\\n\\npublic class GeneralError:IBaseError { \\n  #region Implementation of IBaseError\\n\\n  public string PropertyName { get {return string.Empty; }} \\n  public string PropertyExceptionMessage { get; set; }\\n  public GeneralError(string errorMessage) { this.PropertyExceptionMessage = errorMessage; }\\n\\n  #endregion \\n}\\n\")), mdx(\"p\", null, \"Then, we add the interface \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IValidationErrors\"), \" which holds all \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IBaseError\"), \" to be send back through all layers.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public interface IValidationErrors { List<IBaseError> Errors { get; set; } }\\n\")), mdx(\"p\", null, \"The first implementation can be used anywhere, like in the service layers.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class ValidationErrors : Exception, IValidationErrors { \\n  public List<IBaseError> Errors { get; set; } \\n  public ValidationErrors() { Errors = new List<IBaseError>(); }\\n\\n  public ValidationErrors(IBaseError error): this() { \\n    Errors.Add(error); \\n  }\\n\\n}\\n\")), mdx(\"p\", null, \"The second is more specific to database.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class DatabaseValidationErrors : ValidationErrors { \\n  public DatabaseValidationErrors(IEnumerable<DbEntityValidationResult> errors):base() { \\n    foreach (var err in errors.SelectMany(dbEntityValidationResult => dbEntityValidationResult.ValidationErrors)) { \\n      Errors.Add(new PropertyError(err.PropertyName,err.ErrorMessage)); \\n    } \\n  } \\n}\\n\")), mdx(\"p\", null, \"The last one is used by the repository. In fact, when we \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SaveChanges()\"), \" to the database, we need to validate before Entity Framework executes the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SaveChanges\"), \". Of course, we could let Entity Framework but we would have to catch the exception. Since they are a way without having to catch an exception, I prefer to use it.\"), mdx(\"p\", null, \"If you remember correctly, our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DatabaseContext\"), \" inherits from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IDatabaseContext\"), \" which have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SaveChanges()\"), \" method. We simply need to override this one instead of relying on the one from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DbContext\"), \" and call the DbContext one if everything is fine.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public override int SaveChanges() { var errors = this.GetValidationErrors(); if (!errors.Any()) { return base.SaveChanges(); } else { throw new DatabaseValidationErrors(errors); } }\\n\")), mdx(\"p\", null, \"The exception thrown will loop all errors and be trig to a higher level. In fact, this exception is raised to the service layer which doesn't handle the exception. So, the exception will be raised to the controller layer. This is the same patch of exception than having an exception thrown from the service in the layer 2 because of business logic validation! We are reusing the same mechanism and this is possible because of the exceptions classes we have created which are abstracted with interface.\"), mdx(\"h1\", null, \"Model State and custom exceptions classes\"), mdx(\"p\", null, \"If you remember, the controller does have a catch for ValidationErrors.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" //... \\ncatch (ValidationErrors propertyErrors) { \\n  ModelState.AddValidationErrors(propertyErrors); \\n}\\n\")), mdx(\"p\", null, \"By default, the model state doesn't have this method that accept our interface IValidationErrors. This is an extension method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public static class ControllersExtensions { \\n  public static void AddValidationErrors(this ModelStateDictionary modelState, IValidationErrors propertyErrors) { \\n    foreach (var databaseValidationError in propertyErrors.Errors) { \\n      modelState.AddModelError(databaseValidationError.PropertyName, databaseValidationError.PropertyExceptionMessage); \\n    } \\n  } \\n}\\n\")), mdx(\"p\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IValidationErrors\"), \" lets handle errors from the service layer or the database error. In fact, at this point, it doesn't really matter because we want to loop through all exceptions and to use the model state to attach doesn't exception to the correct property (or if general exception to the string.empty which will be a global error message).\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"Validation of the model could be more complex. It could have been used external classes for each validation. We could have create our own system for validation message and not using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IValidatableObject\"), \" interface. We could have completely not using the ModelState and create our own html helper with custom mechanism for validating across all layers. We could have add a layer of abstraction between Entity Framework and the service and to handle validation there. But at the end, having solution that are short and efficient seem to be better in my point of view. The current solution give a lot of flexibility concerning the validation and keep the code easy to maintain. In fact, add a validation are a two steps. First, where the validation should be coded? Second, adding the validation. I have seen patterns for validation that goes so beyond MVC and respect even more the single responsibility principle that adding a single validation take over 30 minutes. For me, this is not acceptable. Abstractions levels never should make the development of the code harder. In theory, adding levels of abstraction ain't cost a thing, but in real enterprise code, where people have to maintain the code base, this can lead to problem.\"), mdx(\"p\", null, \"The solution proposed here use layers previously defined without adding overhead to handle validation.\"), mdx(\"h1\", null, \"Series Articles\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./enterprise-asp-net-part-1-mvc-the-planification\"\n  }, \"Article #1: Asp.Net MVC Enterprise Quality Web Application\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./enterprise-asp-net-mvc-part-2-building-the-model\"\n  }, \"Article #2: Asp.Net MVC Enterprise Quality Web Application Model\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./enterprise-asp-net-mvc-part-3-controller\"\n  }, \"Article #3: Asp.Net MVC Enterprise Quality Web Application Controller\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./enterprise-asp-net-mvc-part-4-repository\"\n  }, \"Article #4: Asp.Net MVC Enterprise Quality Web Repository Layer\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./enterprise-asp-net-mvc-part-5-database-context-and-impersonate-data\"\n  }, \"Article #5: Asp.Net MVC Enterprise Quality Web with Entity Framework\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./enterprise-asp-net-mvc-part-6-the-three-layers-of-validation\"\n  }, \"Article #6: Asp.Net MVC Enterprise Quality Layers\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./enterprise-asp-net-mvc-part-7-securing-action-with-role-authorization\"\n  }, \"Article #7: Asp.Net MVC Enterprise Quality Web Security\"))), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/GymWorkout\"\n  }, \"Source code on GitHub\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"de562f23-9abb-5ca1-b42f-b77e42e9878a","totalPages":75}},
    "staticQueryHashes": ["3159585216"]}