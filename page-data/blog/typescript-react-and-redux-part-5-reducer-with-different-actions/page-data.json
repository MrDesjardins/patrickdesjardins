{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-react-and-redux-part-5-reducer-with-different-actions",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript, React and Redux Part 5 : Reducer with Different Actions","date":"October 11, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript, React and Redux Part 5 : Reducer with Different Actions\",\n  \"date\": \"2017-10-11\",\n  \"categories\": [\"react\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"TypeScript's type can be highlighting to what is going on if you have been doing Javascript for a while. This is shockingly true if you look at Redux's reducers. Usually, a reducer takes two parameter which is the state and the action. The state passed is the same type that the reducer's return type. It contains the actual data before the reducer come in play. The parameter named \\\"action\\\" is an object with at least a string that defines what type of action is being invoked as well as the information that needs to be saved in the state. The reducer's role is to take the payload (information) and set this one at the right position in the state before returning it.\"), mdx(\"p\", null, \"In JavaScript, the second parameter, the action, can change shape. For example, if your reducer is for your users (let's call it \\\"usersReducer\\\"), this one can let you update users information, as well as their relationship. You won't send back the whole user's state every time. You may just send a list of ids for the relation. Hence, in JavaScript, you could pass in the payload one that is the whole user object when the user gets created or updated, but only a list of integers when the relationship list is changed to one of these users. In JavaScript, it won't matter because depending on the string you pass to determine the type of action, you go to a different branch of code which you will access and work with the expected format of data you know you are passing. Here is a quick example with two actions. One to create, one to update a user's relationship.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function myReducer( state action) { \\n  if (action.type === ACTION_CREATE) { \\n    const immutableData = {...state}; \\n    immutableData[action.payload.userId] = action.payload.newUser; \\n    return immutableData; \\n  } else if (action.type === ACTION_UPDATE_LIST_RELATIONSHIPS) { \\n    const immutableData = {...state}; i\\n    mmutableData[action.payload.userId].relationShipIds = action.payload.ids; \\n    return immutableData; \\n  } \\n  return state; \\n} \\n\")), mdx(\"p\", null, \"We can see that the action argument shape change depending on the type. This is totally valid in JavaScript, but require more work in TypeScript.\"), mdx(\"p\", null, \"In TypeScript, types must be defined. That means that we need to pass a known type for the second argument. This is where it's convenient to have a generic action object that allows you to reuse some part like the one specify the type as well as the payload. Since the payload varies, the use of generic makes sense.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface Actions<T> { \\n  readonly type: string; \\n  payload: T; \\n} \\n\")), mdx(\"p\", null, \"You can extend this interface with other members if desired or simply enhance this one directly. From there, you can have your reducer to use a union of potential action:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function myReducer( state: UsersState, action: Actions<UsersState> | Actions<User> | Actions<{userId:number, ids:number[]}>): UsersState { \\n  if (action.type === ACTION_CREATE) {\\n     const immutableData = {...state}; \\n     immutableData[action.payload.userId] = action.payload.; \\n     return immutableData; \\n  } else if (action.type === ACTION_UPDATE_LIST_RELATIONSHIPS) { \\n    const immutableData = {...state}; \\n    immutableData[action.payload.userId].relationShipIds = action.payload.ids; \\n    return immutableData; \\n  } \\n  return state; \\n} \\n\")), mdx(\"p\", null, \"The problem with the code above is that it doesn't transpile. TypeScript will not know which type is the action and won't let you use the object. You need to user defined typed guard which will tell TypeScript which type is actually the argument. With the generic action, we can use also a generic typed guard.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export function isGenericAction<T>(obj: any): obj is Actions<T> { \\n  const castedObject = (obj as Actions<T>); \\n  return castedObject.payload !== undefined && castedObject.type !== undefined; \\n} \\n\")), mdx(\"p\", null, \"The next step is to use the check with the type in conditions.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function myReducer( state: UsersState, action: Actions<UsersState> | Actions<User> | Actions<UserRelationships>): UsersState { \\n  if (action.type === ACTION_CREATE && GenericAction<User>(action)) { \\n    const immutableData = {...state}; \\n    immutableData[action.payload.userId] = action.payload; \\n    return immutableData; \\n  } else if (action.type === ACTION_UPDATE_LIST_RELATIONSHIPS && GenericAction<UserRelationships>(action)) { \\n    const immutableData = {...state}; \\n    immutableData[action.payload.userId].relationShipIds = action.payload.ids; \\n    return immutableData; \\n  } \\n  return state; \\n} \\n\")), mdx(\"p\", null, \"The code above compiles and it allows you to use a single reducer with many different actions' payload. An alternative idea could be to have a single reducer per payload type, but this gets fast cumbersome the more your domain grows and require more consolidation once you get back to your React component. Your reducers should be designed to be flat, but also to support the idea of a specific domain. In the example above, a single reducer for user management makes sense.\"), mdx(\"p\", null, \"In this article, we saw that JavaScript allows us to have mixed kind of data in a single argument which we would act differently depending on the type (specified in a string). Then, we realized that when it's time to type, that it can be problematic since TypeSCript expects to have a clear idea of what type is needed before proceeding with the information. Finally, a solution that embraces strong type, union and type guard was proposed to accommodate Redux and being strongly typed.\"), mdx(\"h3\", null, \"Articles of the series:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-react-and-redux-part-1-the-big-picture\"\n  }, \"TypeScript, React and Redux\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-react-and-redux-part-2-creating-the-store-and-the-reducer\"\n  }, \"TypeScript and Redux Store\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-react-and-redux-part-3-binding-the-store-and-component\"\n  }, \"TypeScript Redux Store Binding\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-react-and-redux-part-4-multiple-returns-from-action-creator\"\n  }, \"TypeScript Redux Action Creators\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-react-and-redux-part-5-reducer-with-different-actions\"\n  }, \"TypeScript, React and Redux Part 5 : Reducer with Different Actions\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"affa8602-d7fc-5f33-8fbc-bcc2ea15ba23","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}