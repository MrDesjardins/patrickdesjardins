{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-webproject-environment-variables",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Typescript Web Project and Environment Variables","date":"January 26, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Typescript Web Project and Environment Variables\",\n  \"date\": \"2022-01-26\",\n  \"categories\": [\"typescript\", \"react\", \"solidjs\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Many projects require to have configurations. These configurations change depending on the environment. For example, you can have a different service DNS address and port to connect depending if you are developing locally or in a testing environment, or in production. A typical pattern is to set variables in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".env\"), \" file. Many systems like NodeJS or Docker can easily read the file. However, web projects created with a web framework struggle to read the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".env\"), \" file. ReactJS and SolidJS are two popular frameworks that have a workaround. They inject the value of specific prefixed variables from the .env file into the code. The constraint of the prefix allows having at build time values from the file into the generated JavaScript to bypass the limitation that the browser does not have access to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".env\"), \" file on the server. The issue with this workaround is that it forces the usage of variables prefixed (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://create-react-app.dev/docs/adding-custom-environment-variables/\"\n  }, \"React Doc\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/solidjs/solid/issues/292\"\n  }, \"SolidJS Doc\"), \"). What if we want to use a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".env\"), \" file in a mono repository that shares a variable between projects or do not wish to use a prefixed variable between projects?\"), mdx(\"p\", null, \"A small solution is to create your custom script that opens the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".env\"), \" file and generates a variable that can be referenced directly in your codebase. It means that Docker and other systems can rely on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".env\"), \" file, using all the variable names you desired and at the same time having the web project, React framework or else to also use the same variable names -- no duplication or name constraint.\"), mdx(\"h1\", null, \"Package.json\"), mdx(\"p\", null, \"The first modification is to ensure that the script is running when you start your application. You want to ensure the script generate the TypeScript (or JavaScript) file that contains all the value. With the generated file in place, you can import the variable and use the values in your web project.\"), mdx(\"p\", null, \"Here is an example of a SolidJS project that relies on Vite.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"  \\\"scripts\\\": {\\n    \\\"start:production\\\": \\\"npm run copy:env && vite --host 0.0.0.0\\\",\\n    \\\"start:development\\\": \\\"npm run copy:env && vite --host 0.0.0.0\\\",\\n    \\\"build\\\": \\\"npm run copy:env && vite build\\\",\\n    \\\"serve\\\": \\\"npm run copy:env && vite preview\\\",\\n    \\\"copy:env\\\": \\\"python ../scripts/envToConsts.py\\\"\\n  },\\n\")), mdx(\"p\", null, \"As you can see, all commands start with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm run copy:env\")), mdx(\"h1\", null, \"Python Script\"), mdx(\"p\", null, \"I decided to rely on Python for the script. It is a shortcode that relies on opening a file, reading the lines, and saving the created variable into a TypeScript file.\"), mdx(\"p\", null, \"Here is the complete script that works even if there are comments inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".env\"), \" file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"import os\\n\\n# Read the environment variables from the .env file\\n__location__ = os.path.realpath(os.path.join(\\n    os.getcwd(), os.path.dirname(__file__)))\\nf = open(os.path.join(__location__, '../.env'))\\nlines = f.read().splitlines()\\n\\n# Extract all the key-value of each line\\nkeyValues = []\\nfor line in lines:\\n    if line.find(\\\"=\\\") >= 0 and line.strip().find(\\\"#\\\") != 0:\\n        lineSplit = line.split(\\\"=\\\")\\n        left = lineSplit[0].strip()\\n        right = lineSplit[1].strip()\\n        if right.find(\\\"#\\\") > 0:\\n            right = right[:right.find(\\\"#\\\")-1]\\n        keyValues.append([left, right])\\n\\n# Create the TS file\\ntsFile = \\\"/**\\\\n ** This file is generated by scripts/envToConsts.py\\\\n **/\\\\n\\\"\\ntsFile += \\\"export const ENV_VARIABLES = {\\\\n\\\"\\n\\nfor pair in keyValues:\\n    if unicode(pair[1], \\\"utf-8\\\").isnumeric():\\n        tsFile += \\\"  \\\" + pair[0] + \\\": \\\" + pair[1] + \\\",\\\\n\\\"\\n    elif pair[1] == \\\"true\\\" or pair[1] == \\\"false\\\" or pair[1] == \\\"TRUE\\\" or pair[1] == \\\"FALSE\\\":\\n        tsFile += \\\"  \\\" + pair[0] + \\\": \\\" + pair[1].lower() + \\\",\\\\n\\\"\\n    else:\\n        tsFile += \\\"  \\\" + pair[0] + \\\": \\\\\\\"\\\" + pair[1].lower() + \\\"\\\\\\\",\\\\n\\\"\\ntsFile += \\\"}\\\"\\n\\n# Write the file on disk\\nf = open(os.path.join(__location__,\\n         '../app/src/generated/constants_env.ts'), \\\"w\\\")\\nf.write(tsFile)\\nf.close()\\n\")), mdx(\"p\", null, \"The input file can look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-env\"\n  }, \"# Which environment is running? It should be \\\"development\\\" or \\\"production\\\".\\nNODE_ENV=development\\n\\nCLIENT_IP=127.0.0.1\\nCLIENT_PORT=3000 # Need to be the same as the value set in vite.config.ts and nginx.conf\\nDOCKER_CLIENT_PORT_FORWARD=3501 # Port opened by the Docker to communicate to the client\\nDOCKER_CLIENT_HEALTHCHECK_TEST=/bin/true \\n\\nSERVER_IP=127.0.0.1\\nSERVER_PORT=80 # Internal port for the Node server\\nDOCKER_SERVER_PORT_FORWARD=3500 # Port opened by the Docker to communicate to the server\\n\\n# What health check test command do you want to run? In development, having it\\n# curl your web server will result in a lot of log spam, so setting it to\\n# /bin/true is an easy way to make the health check do basically nothing.\\n#export DOCKER_SERVER_HEALTHCHECK_TEST=curl localhost:8700/health\\nDOCKER_SERVER_HEALTHCHECK_TEST=/bin/true \\n\")), mdx(\"p\", null, \"and the produced TypeScript file looks like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"/**\\n ** This file is generated by scripts/envToConsts.py\\n **/\\nexport const ENV_VARIABLES = {\\n  NODE_ENV: \\\"development\\\",\\n  CLIENT_IP: \\\"127.0.0.1\\\",\\n  CLIENT_PORT: 3000,\\n  DOCKER_CLIENT_PORT_FORWARD: 3501,\\n  DOCKER_CLIENT_HEALTHCHECK_TEST: \\\"/bin/true\\\",\\n  SERVER_IP: \\\"127.0.0.1\\\",\\n  SERVER_PORT: 80,\\n  DOCKER_SERVER_PORT_FORWARD: 3500,\\n  DOCKER_SERVER_HEALTHCHECK_TEST: \\\"/bin/true\\\",\\n}\\n\")), mdx(\"p\", null, \"The script might require some modification for your need. For example, the source path and the output path. In my case, I had to work around Docker and adjust the paths for the Docker's folders structure.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"I found the scripting solution to be quite convenient. It allows a central configuration file with clean names. Furthermore, it provides for potential customization like marking configuration to be opt-out for the web project if needed (e.g., using a particular comment to opt-out). In the end, this simple script removed the need to duplicate variables. For example, Docker uses the IP and port for the server in this file and the web project to know where to connect. Without this solution, we would need to have duplicated data (prefixed and non-prefixed) or to have the Docker system uses the prefixed variables.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"22cc160a-f1fa-57a4-ad0a-4c86ff6dd894","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}