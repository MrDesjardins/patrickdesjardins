{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/visual-studio-code-with-npm-and-typescript-part-6-lazy-loading",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Visual Studio Code with NPM and TypeScript (Part 6 : Lazy-loading)","date":"March 20, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Visual Studio Code with NPM and TypeScript (Part 6 : Lazy-loading)\",\n  \"date\": \"2017-03-20\",\n  \"categories\": [\"gulp\", \"javascript\", \"nodejs-web\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"To have the fastest website possible you must be wise to not load unnecessary JavaScript. In some scenario, it is the good strategy to not have everything in a bundle. For example, if a kind of action require different JavaScript files but that this one is not in the main scenario then it's better to lazy-load this module. This article will explain how to lazy-load TypeScript module.\"), mdx(\"p\", null, \"Let's fake the scenario that we want to load a module 2 seconds after a method is called:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export class ClassB {\\n  public method1(): void {\\n    console.log(\\\"ClassB>method1\\\");\\n    setTimeout(() => {\\n      //Use code from fileToLazyLoad.ts\\n    }, 2000);\\n  }\\n}\\n\")), mdx(\"p\", null, \"The way to do it is to use directly the AMD loader instead of using the EcmaScript import. This might not be the case in the future, but this is how to do it at the time I am writing this post. From the previous article about TypeScript, we configured to use AMD (requirejs). To have the TypeScript lazy-loaded, we will need to use require directly in the file. The first step is to add at the top of the file a require to a reference to the type. This won't load the file at runtime, but let us in development time a reference to the type. The second step is to use requirejs() method at the time you need to module. The third step is to have the types aware in every modules. This last and third step is done by using :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" npm install @types/requirejs --save-dev\\n\")), mdx(\"p\", null, \"The first and second step can be seen in this transformed code form the initial snippet:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import foo = require(\\\"folder1/fileToLazyLoad\\\");\\nexport class ClassB {\\n  public method1(): void {\\n    console.log(\\\"ClassB>method1\\\");\\n    setTimeout(() => {\\n      requirejs([\\\"folder1/fileToLazyLoad\\\"], (c: typeof foo) => {\\n        const co = new c.ClassC();\\n        co.method1();\\n      });\\n    }, 2000);\\n  }\\n}\\n\")), mdx(\"p\", null, \"You can see that you can load multiple modules since the first parameter is an array. The second is a function that contains the same amount of argument that the length of the array. It's at this moment that the browser will do a HTTP request to get JavaScript file and execute the code. In that example, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"method1()\"), \" is called once the file is downloaded.\"), mdx(\"p\", null, \"Here is how the browser handles the HTTP request: \", mdx(\"undefined\", {\n    parentName: \"p\"\n  }, \"\\n      \", mdx(\"div\", {\n    \"className\": \"gatsby-video-aspect-ratio\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"paddingTop\": \"52.389078498293514%\"\n    }\n  }, \"\\n    \", mdx(\"video\", {\n    parentName: \"div\",\n    \"preload\": \"\",\n    \"autoPlay\": true,\n    \"muted\": true,\n    \"loop\": true,\n    \"playsInline\": true,\n    \"style\": {\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\",\n      \"width\": \"100%\",\n      \"height\": \"auto\"\n    }\n  }, \"\\n      \", mdx(\"source\", {\n    parentName: \"video\",\n    \"src\": \"/static/LazyLoadingNetwork-a5e215ecf8b016516451e7ad04479f47-01206.webm\",\n    \"type\": \"video/webm\"\n  }), mdx(\"source\", {\n    parentName: \"video\",\n    \"src\": \"/static/LazyLoadingNetwork-a5e215ecf8b016516451e7ad04479f47-50762.mp4\",\n    \"type\": \"video/mp4\"\n  }), \"\\n    \"), \"\\n    \"), \"\\n    \")), mdx(\"p\", null, \"Lazy loading should be in your tool belt and be used anytime you can delay unnecessary module on the critical path. Good case are for dialog window, or deep hidden menu options. However, be careful not to degrade the user experience by having the user to wait on every click. Nothing is more annoying than clicking a menu and having a white space for few milliseconds. While not everything needs to be loaded, once the user is having what needed to work, you should eagerly load alternate scenario. At the end, the best strategy is to use lazy-loading at the right moment to have a good balance of performance and user experience.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"08b43341-b29f-50ce-aced-508f5357a3c5","totalPages":73}},
    "staticQueryHashes": ["3159585216"]}