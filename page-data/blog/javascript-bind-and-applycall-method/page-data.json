{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/javascript-bind-and-applycall-method",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Bind and Apply/Call Method","date":"May 29, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Bind and Apply/Call Method\",\n  \"date\": \"2017-05-29\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"JavaScript has three methods that are useful to assign on what \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" refer to. These three methods are Bind, Apply and Call.\"), mdx(\"p\", null, \"Bind are from the prototype of Function. It takes as first parameter the reference to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \", and all the subsequent parameters to be the argument to the function. The Bind method return a copy of the function with this one having the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" to the one desired.\"), mdx(\"p\", null, \"Call is similar, but instead of returning a copy with the provided reference to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \", it provides the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" reference and invoke the method.\"), mdx(\"p\", null, \"Apply is like call but the second parameter is an array instead of being a signature with undermined amount of parameter.\"), mdx(\"p\", null, \"Here is an example to distinct the difference:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"f1.call(myThisRef, param1, param2, param3);\\n// or\\nf1.apply(myThisRef, [param1, param2, param3]);\\n\")), mdx(\"p\", null, \"How can this be useful? This can be useful to change the context of a piece of code to access different member without assigning the values. For example, in the following code we have the same function and by calling apply or bind we can assign \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" to a complete new object that has what is using by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \", in that case the_name.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var hero = {\\n  _name: \\\"John Doe\\\",\\n  getName: function () {\\n    return this._name;\\n  },\\n};\\n\\nconsole.log(hero.getName()); // John Do\\n// --- var\\nhero2 = { _name: \\\"Patrick\\\" };\\nvar getNameMethod = hero.getName;\\n\\nconsole.log(getNameMethod.apply(hero2)); // Patrick\\nconsole.log(getNameMethod.bind(hero2)()); // Patrick\\n\")), mdx(\"p\", null, \"This example illustrates that apply can be called to have momentary a call with a reference to the hero2 instead of the original hero. On the next line, the bind method is called and executed by using the parentheses right away. Normally, we would store the return value of the bind method to get an object that can get subsequent calls with the hero2 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" reference.\"), mdx(\"p\", null, \"When to use of of the other? apply and call should be used when it's only for one invocation. Bind should be used to store the new variable with that will have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" with the provided reference to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" when created with bind.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"6b6710ab-b135-5aee-b403-6eebe16858ac","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}