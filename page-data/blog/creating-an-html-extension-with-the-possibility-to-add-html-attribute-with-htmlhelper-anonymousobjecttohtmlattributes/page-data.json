{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/creating-an-html-extension-with-the-possibility-to-add-html-attribute-with-htmlhelper-anonymousobjecttohtmlattributes",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Creating an Html Extension with the possibility to add Html Attribute with HtmlHelper.AnonymousObjectToHtmlAttributes","date":"July 4, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Creating an Html Extension with the possibility to add Html Attribute with HtmlHelper.AnonymousObjectToHtmlAttributes\",\n  \"date\": \"2012-07-04\",\n  \"categories\": [\"general\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When you are building a Html Extension, it's always a good idea to provide an overloaded of your extension that can have additional html attribute. This lead to the possibility to insert class, style or any other html attribute to the control that you are rendering.\"), mdx(\"p\", null, \"First of all, you need to create the overload of your extension. You can also add at last parameter with default value with the default value to null because the type of this parameter should be object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static MvcHtmlString MyExtensionXZY<TModel, TProperty>(this HtmlHelper<TModel> htmlHelper, string anyThing) { //... } public static MvcHtmlString MyExtensionXZY<TModel, TProperty>(this HtmlHelper<TModel> htmlHelper, string anyThing, object htmlAttributes) { //... } \\n\")), mdx(\"p\", null, \"Or this can be with a default value: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static MvcHtmlString MyExtensionXZY<TModel, TProperty>(this HtmlHelper<TModel> htmlHelper, string anyThing, object htmlAttributes=null) { //... } \\n\")), mdx(\"p\", null, \"In both case, the next step is to transform the object into a Dictionary. Why do we accept an object if it's to transform it into a Dictionary few lines after? The reason is to let anonymous object to be used. This way, it's possible to call the html helper without having to declare the dictionary every time we want to use it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" @Html.MyExtensionXZY(\\\"Test\\\", new {class= \\\"MyClass\\\"}); \\n\")), mdx(\"p\", null, \"Last step is to assign the attributes values to the html control that we are building. This can be done with a single line of code if you use a HtmlHelper method that is available in its static class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" myControl.MergeAttributes(System.Web.Mvc.HtmlHelper.AnonymousObjectToHtmlAttributes(htmlAttributes), true); \\n\")), mdx(\"p\", null, \"So, what it does is that it takes the object html Attribute and convert it into a dictionnary. The method AnonymousObjectToHtmlAttributes is available in System.Web.Mvc.HtmlHelper: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static RouteValueDictionary AnonymousObjectToHtmlAttributes(object htmlAttributes) { RouteValueDictionary result = new RouteValueDictionary();\\n\\nif (htmlAttributes != null) { foreach (PropertyDescriptor property in TypeDescriptor.GetProperties(htmlAttributes)) { result.Add(property.Name.Replace('_', '-'), property.GetValue(htmlAttributes)); } }\\n\\nreturn result; } \\n\")), mdx(\"p\", null, \"Once this is converted, it will be used with the MergeAttributes method of your new control. This method is available if you are using the System.Web.Nvc.TagBuilder class which let you create html tag. Once done with the TagBuilder, you only need to call the .ToString() of the object and you will get the generated html. As you may have notice, the MergeAttributes has \\\"True\\\" at its second parameter. This let know the builder that if an attribute was already available to override it with the new one. This let you have the final control of the rendering of your control.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"8e73b1bf-f083-5a90-8e37-ebfddd7b892e","totalPages":71}},
    "staticQueryHashes": ["3159585216"]}