{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/gulp-watch-to-build-only-changed-typescript",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Gulp Watch to build only changed TypeScript","date":"April 20, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Gulp Watch to build only changed TypeScript\",\n  \"date\": \"2017-04-20\",\n  \"categories\": [\"gulp\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Performance when building TypeScript can be crutial if you are working on a big projects. If you are using watcher to compile when any TypeScript file change and use Gulp Watch to compile every TypeScript file, then you will have a huge performance hit. It means that if you change 1 file that you may have to build thousand of them. The following code is the lazy approach that build every TypeScript file if one changed:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"gulp.watch(paths.typescript_in + \\\"**/*.ts\\\", [\\\"build\\\", \\\"tsreload\\\"]);\\n\")), mdx(\"p\", null, \"This script watch for TypeScript files to be changed, if it does, run the build task and reload the browser. The problem is that the build task build all TypeScript. To remedy that situation, we want TypeScript to only build the changed file. For that, you will need a new Gulp package called \\\"gulp-cached\\\" that you install as a dev dependency.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"npm install gulp-cached --save-dev\\n\")), mdx(\"p\", null, \"Inside your gulpfile.js, you need to access the module: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const changed = require('gulp-cached');\\n\")), mdx(\"p\", null, \"And finally, you need to use the \\\"on change\\\" event after the watch, and remove the tasks's dependencies. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"gulp.watch(\\\"app/scripts/**/*.ts\\\").on(\\\"change\\\", function() { \\n  var compilationResults = gulp.src(\\\"app/scripts/**/*.ts\\\") .pipe(changed(\\\"./deploy/output\\\")) \\n    .pipe(sourcemaps.init()) \\n    .pipe(tsProject());\\n    compilationResults.dts\\n      .pipe(gulp.dest(\\\"./deploy/output\\\")); \\n    compilationResults.js \\n      .pipe(sourcemaps.write('.')) \\n      .pipe(gulp.dest(\\\"./deploy/output\\\")) \\n      .pipe(connect.reload()); });\\n\")), mdx(\"p\", null, \"The main change is that we pipe through the changed call the destination. This pipe, once ran once, will keep data about if the file change. If this one change, it will go down the pipeline. Otherwise, it will be filtered out. It means that the first time a TypeScript file change, the watch will build everything. After, it will only filter all the source down the changed file. The reload is by calling directly connect.reload() at the end. This is a huge performance boost for your as a developer because you will be able, what ever the size of the project you are working on, to build under 1 sec every change you do. Having a rapid window between you save your file and the time you can see your change in your browser is critical to ship fast code. With this library that act a cache, you can benefit of filtering out the noise that doesn't change and concentrate your computer to build only what is required.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"b3a2cf69-cba9-5da6-bcf9-16136ae52458","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}