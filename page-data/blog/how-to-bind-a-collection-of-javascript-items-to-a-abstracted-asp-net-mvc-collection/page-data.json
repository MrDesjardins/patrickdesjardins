{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-bind-a-collection-of-javascript-items-to-a-abstracted-asp-net-mvc-collection",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to bind a collection of Javascript items to a abstracted Asp.Net MVC collection","date":"February 13, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to bind a collection of Javascript items to a abstracted Asp.Net MVC collection\",\n  \"date\": \"2013-02-13\",\n  \"categories\": [\"asp-mvc\", \"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This scenario is plausible in multiple business domain. Let say that you have a collection that is built from an external service that your Javascript need to send back to the server or even simpler, let just say that you have a Javascript grid that when you save you take all rows of your table and send it back to the server but this one has a model which is a collection of Interface. How you can bind everything back together?\"), mdx(\"p\", null, \"First, let's take some minutes to understand the mecanism. The example of a the collection is simpler to understand. We have a Model that is bound to the View and the collection is ICollection. Having to create a table is a simple matter of looping the collection and display the properties needed of the interface to the UI.\"), mdx(\"p\", null, \"For example here is what could be the Model: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" UIHint(\\\"MyTableTemplate\\\")] public readonly ICollection<IMyInterface> MyCollection; \\n``` The MyTableTemplate simply loop the collection and display everything inside a TABLE, with multiple TR and TD. When it's the time to save back everything to the server, we need to send back the collection which could have changed via Javascript. Rows can have been deleted, and some added. How to send back this table to the Asp.Net server? Simply by using serialization. On the submit, we need to hook the click even and store the table serialized into an hidden field. The hidden field must have the same name of the Model bound. In our case, we will have an hidden field with the name \\\"MyCollection\\\". The code below show you how to do it generically, by having the Template using the information about the name of the property and use it for the hidden field.\\n\\n\\n```csharp\\n @{ var controlPropertyName = ViewData.TemplateInfo.HtmlFieldPrefix; } <input type=\\\"hidden\\\" value=\\\"\\\" name=\\\"@controlPropertyName\\\"/> \\n\")), mdx(\"p\", null, \"Having the same name for the hidden field and the model property let Asp.Net MVC know where to map the information.\"), mdx(\"p\", null, \"The Javascript invoked into the serialization is quite simple. It takes all rows and you create a Javascript object that contains the info. The code below display how to serialize with Javascript 2 cells per rows. As you can see, a \\\"data-key\\\" was set by the template to the row to have the unique identifier. This let us know that this row is not new because new row won't have any id. The deserialization will put the default value for your key at the deserialization time.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var obj = []; \\n$('#YouTable tbody tr').each(function () { \\n  var tempo = {}; \\n  tempo.PropertyKey = $(this).attr('data-key'); \\n  tempo.Property1 = $(this).find('td').eq(0).html(); \\n  tempo.Property2 = $(this).find('td').eq(1).html(); \\n  obj.push(tempo); \\n});\\n\\n$('#YourHiddenField').val(JSON.stringify(obj)); \\n\")), mdx(\"p\", null, \"Second, let's see what happen. Asp.Net MVC will try to bind. In fact, it should crash and it's logic because we try to bind to an interface. What we need to do is to create a ModelBinder and handle this specific case. Since you should know which concrete type is used for this case, when deserializing you simply need to specify to which concrete type the deserializer must instanciate.\"), mdx(\"p\", null, \"The first step is to create a class that inherit from IModelBinder. This will give you the BindModel method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class MyInterfaceTypeModelBinder:IModelBinder { \\n   public object BindModel(ControllerContext controllerContext, ModelBindingContext bindingContext) { \\n     var valueResult = bindingContext.ValueProvider.GetValue(bindingContext.ModelName); \\n     var modelState = new ModelState {Value = valueResult};\\n\\n    MyInterface actualValue = null; \\n    try { \\n      actualValue = JsonConvert.DeserializeObject<MyInterface>(valueResult.AttemptedValue); \\n    } catch (FormatException e) { \\n      modelState.Errors.Add(e); \\n    } \\n    bindingContext.ModelState.Add(bindingContext.ModelName, modelState); \\n    return actualValue;\\n  } \\n} \\n\")), mdx(\"p\", null, \"We also need to register the ModelBinder in the Global.asax.cs inside the ApplicationStart method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" ModelBinders.Binders.Add(typeof(IMyInterface), new MyInterfaceTypeModelBinder()); \\n\")), mdx(\"p\", null, \"In the case that the IMyInterface would have some property which were interface too, you may need to specify to the deserializer to what type to map them. Here is an example.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class MyInterfaceTypeModelBinder:IModelBinder { \\n  public object BindModel(ControllerContext controllerContext, ModelBindingContext bindingContext) { \\n    var valueResult = bindingContext.ValueProvider.GetValue(bindingContext.ModelName); \\n    var modelState = new ModelState {Value = valueResult};\\n\\n    MyInterface actualValue = null; \\n    var settings = new JsonSerializerSettings(); \\n    settings.Converters.Add(new MyOtherInterfaceTypeConverter()); \\n    try { \\n      actualValue = JsonConvert.DeserializeObject<MyInterface>(valueResult.AttemptedValue, settings); \\n    } catch (FormatException e) { \\n      modelState.Errors.Add(e); \\n    } \\n    bindingContext.ModelState.Add(bindingContext.ModelName, modelState); \\n    return actualValue; \\n    } \\n  } \\n\\n  public class MyOtherInterfaceTypeConverter : JsonConverter { \\n    public override bool CanConvert(Type objectType) { \\n      return (objectType == typeof(IMyOtherInterface)); \\n    }\\n\\n  public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) { \\n    return serializer.Deserialize<MyOtherInterfaceConcrete>(reader); \\n  }\\n\\n  public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) { \\n    //... to be done if we care about serialization... \\n  } \\n}\\n\")), mdx(\"p\", null, \"From here, the model binder of Asp.Net MVC will use your model binder for your type and sub type used in the process. This whole post has been used \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://james.newtonking.com/pages/json-net.aspx\"\n  }, \"Json Newton library\"), \" for deserializing the Javascript JSON object.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"06c72267-6f5e-59df-b47c-d84d4a26aec7","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}