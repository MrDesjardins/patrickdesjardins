{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/implementing-the-map-and-reduce-javascript-function-in-typescript",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Implementing the Map and Reduce JavaScript Functions in TypeScript","date":"December 8, 2023"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"JavaScript is a language with several built-in functions. In this article, we will implement some of them in TypeScript. The goal is to understand how they work and to have a better understanding of the language.\"), mdx(\"h1\", null, \"Map Function\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" function loops each element of an array. The function takes a callback function as a parameter. The callback function takes the current value, the current index, and the array as parameters. In this example, we will simplify the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" function by only taking the current value as a parameter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export function map<T, Z>(arr: T[], fn: (element: T) => Z): Z[] {\\n  const newArr: Z[] = [];\\n  for (let x of arr) {\\n    newArr.push(fn(x));\\n  }\\n  return newArr;\\n}\\n\")), mdx(\"p\", null, \"The function has two generic types: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Z\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" is the type of the array and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Z\"), \" is the type of the returned array. The reason for having two generic types is to allow the input array to be of a different type than the output array. For example, the input array can be an array of numbers and the output array can be an array of strings.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"console.log(map(arr, (x) => x.toString()));\\n\")), mdx(\"p\", null, \"If we remove the generic to tailor this particular example of receiving a list of numbers and returning a list of strings, the function would look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export function map(arr: number[], fn: (element: number) => string): string[] {\\n  const newArr: string[] = [];\\n  for (let x of arr) {\\n    newArr.push(fn(x));\\n  }\\n  return newArr;\\n}\\n\")), mdx(\"p\", null, \"The use of TypeScript generic allows the function to be more flexible. For example, you can transform numbers to return a list of numbers.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"console.log(map(arr, (x) => x * 10));\\n\")), mdx(\"h1\", null, \"Reduce Function\"), mdx(\"p\", null, \"The reduce function is a function that takes a list of elements and returns a single value. The function loops each value and calls a function. The function accumulates the single value, which is accessible in the subsequent calls. Thus, you can use the previous value to compute the next value. The function takes four parameters: the array, the callback function, the initial value, and the current index.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export function reduce<T>(\\n  arr: T[],\\n  callback: (accumulator: T, currentValue: T, currentIndex: number) => T,\\n  initialValue?: T\\n): T | undefined {\\n  if (arr.length === 0) {\\n    return undefined;\\n  }\\n  let result = initialValue ?? arr[0];\\n  const intialIndex = initialValue === undefined ? 1 : 0;\\n  for (let i = intialIndex; i < arr.length; i++) {\\n    const r = callback(result, arr[i], i);\\n    result = r;\\n  }\\n  return result;\\n}\\n\")), mdx(\"p\", null, \"The function is generic. The single generic value is the type of the array, which is also the type of the final value. The accumulation of the values is also the type of element of the initial collection. The default initial index is 0. However, the initial index is 1 if a call to the function has no initial value. The reason is that the function skips the first element, the base of the accumulation. The initial value becomes the first element of the index instead of a value provided by the user.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \" console.log(reduce([1, 2, 3, 4], (acc, x) => acc + x));\\n\")), mdx(\"p\", null, \"In the example above, the initial value is not provided . Thus, the initial value is the first element of the array. The callback function adds the current value to the accumulator. The accumulator results from the previous call going from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"3\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"6\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10\"), \". The result is the sum of all the array elements, which is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"\\n# Conclusion\\n\\nYou can play with the code in the following Code Sand Box: https://codesandbox.io/p/sandbox/common-functions-tnt76x?file=/src/index.ts:6,54\\n\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"Implementing the Map and Reduce JavaScript Functions in TypeScript\\\",\\\"date\\\":\\\"2023-12-08\\\",\\\"categories\\\":[\\\"typescript\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"e4d98f46-7a9a-5dbb-8c20-8b98c25ba085","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}