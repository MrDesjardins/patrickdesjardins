{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-consuming-producing-redpanda-message",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Typescript Consuming and Producing Redpanda Messages","date":"September 11, 2023"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Typescript Consuming and Producing Redpanda Messages\",\n  \"date\": \"2023-09-11\",\n  \"categories\": [\"typescript\", \"redpanda\", \"kafka\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Redpanda\"), mdx(\"p\", null, \"Redpanda is a C++ implementation of Kafka that is very performance and easy to install because it does not require Java or Apache Zookeeper. Redpanda, like Kafka, is a pub/sub system allowing messages to travel from a producer to one or many consumers.\"), mdx(\"h1\", null, \"Simple Goal\"), mdx(\"p\", null, \"The goal is to start an instance of Redpanda, create a script that will consume messages as they go in, and use a second script to push a message that the consumer script will see.\"), mdx(\"p\", null, \"1) Start Redpanda\\n2) Create a consumer\\n3) Create a producer\"), mdx(\"h1\", null, \"Redpanda Installation\"), mdx(\"h2\", null, \"Redpanda Command Line\"), mdx(\"p\", null, \"Redpanda offers a single command line to start a Redpanda node or cluster of nodes).\"), mdx(\"p\", null, \"Step #1: Open WSL2 on Windows\\nStep #2: Download and install\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"curl -LO https://github.com/redpanda-data/redpanda/releases/latest/download/rpk-linux-amd64.zip\\nmkdir -p ~/.local/bin\\nunzip rpk-linux-amd64.zip -d ~/.local/bin/\\nrpk container start\\n\")), mdx(\"p\", null, \"If you are using ZSH, edit the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".zshrc\"), \" by adding the path to the installation of Redpanda (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rpk\"), \").\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"path+=(\\\"~/.local/bin\\\")\\n\")), mdx(\"h2\", null, \"Docker Image\"), mdx(\"p\", null, \"The former way did not work for me. However, using the docker Redpanda image worked.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"docker run -d --pull=always --name=redpanda-1 --rm \\\\\\n-p 8081:8081 \\\\\\n-p 8082:8082 \\\\\\n-p 9092:9092 \\\\\\n-p 9644:9644 \\\\\\ndocker.redpanda.com/redpandadata/redpanda:latest \\\\\\nredpanda start \\\\\\n--overprovisioned \\\\\\n--smp 1  \\\\\\n--memory 1G \\\\\\n--reserve-memory 0M \\\\\\n--node-id 0 \\\\\\n--check=false\\n\")), mdx(\"p\", null, \"Then login into the container:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"docker exec -it redpanda-1 bash\\n\")), mdx(\"h1\", null, \"Redpanda Topic\"), mdx(\"p\", null, \"Messages need to travel into a topic. The producer will push the message into a topic. The consumer will pull the message from the topic.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"rpk topic create my-topic\\n\")), mdx(\"h1\", null, \"Node Configurations\"), mdx(\"p\", null, \"Redpanda is compatible with Kafka API. Thus, the TypeScript code will be using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kafkajs\"), \" library. We will use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uuid\"), \" library to have a unique identifier to consume the message. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"npm install --save uuid@latest kafkajs@latest    \\nnpm install --save-dev @types/node @types/uuid typescript@latest  \\n\")), mdx(\"h1\", null, \"Consumer TypeScript Code\"), mdx(\"p\", null, \"The first part is the consumer. The consumer will run first to receive the message from the producer. The consumer uses the Kafkajs library to connect to Redpanda. The main Kafka object connects to one or many brokers. They are instances of the Redpanda node.\"), mdx(\"h2\", null, \"Import and Kafka\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import { Kafka, logLevel } from \\\"kafkajs\\\";\\nimport { brokers, topicName } from \\\"./shared.js\\\";\\nimport { v4 as uuidv4 } from \\\"uuid\\\";\\n\\nconst redpanda = new Kafka({\\n  brokers: brokers,\\n  logLevel: logLevel.DEBUG,\\n});\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"./shared.js\"), \" is a file shared between the consumer and producer that contains the brokers and topic name. Thus, one place to edit if we change it and both parts of the system are updated. The content is two lines:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export const brokers = [\\\"localhost:9092\\\", \\\"localhost:9644\\\"];\\nexport const topicName = \\\"my-topic\\\";\\n\")), mdx(\"h2\", null, \"Consumer Code\"), mdx(\"p\", null, \"Using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uuid\"), \" library, the consumer is unique, allowing Redpanda to know if a particular consumer read the messages. Using the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"groupId\"), \" would mean that the system would not push previously pushed messages in the case of a reconnect. Thus, it's essential to have a unique id per user or process group that work together to consume messages on a topic.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const consumer = redpanda.consumer({ groupId: uuidv4() });\\n\\ntry {\\n  await consumer.connect();\\n  await consumer.subscribe({\\n    topic: topicName,\\n  });\\n  await consumer.run({\\n    eachMessage: async ({ topic, partition, message }) => {\\n      console.log(\\n        `Received message: ${message.value} at ${topic}:${partition}, offset ${message.offset} and time ${message.timestamp}`\\n      );\\n    },\\n  });\\n} catch (error) {\\n  console.error(\\\"Consumer send:\\\", error);\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"run\"), \" reads one message at a time. Using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"batch\"), \" function can consume more than one message at a time. In that case, we display the value, the offset (order in the topic), and the time it went into Redpanda.\"), mdx(\"h2\", null, \"Consumer Cleaning Code\"), mdx(\"p\", null, \"Finally, we need to disconnect in case of an error or in case the process is closed.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export async function disconnect() {\\n  try {\\n    await consumer.disconnect();\\n  } catch (error) {\\n    console.error(\\\"Consumer disconnect:\\\", error);\\n  }\\n}\\n\\nprocess.on(\\\"SIGINT\\\", async () => {\\n  try {\\n    await disconnect();\\n  } catch (error) {\\n    console.error(\\\"Consumer:\\\", error);\\n  } finally {\\n    process.exit(0);\\n  }\\n});\\n\")), mdx(\"h1\", null, \"Producer TypeScript Code\"), mdx(\"p\", null, \"The producer is very similar. The first part is identical.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import { Kafka, logLevel } from \\\"kafkajs\\\";\\nimport { brokers, topicName } from \\\"./shared.js\\\";\\n\\nconst redpanda = new Kafka({\\n  brokers: brokers,\\n  logLevel: logLevel.DEBUG,\\n});\\n\")), mdx(\"p\", null, \"The second part is to create a producer instead of a consumer. Then, connect, and instead of running, we are sending with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"send\"), \". \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const producer = redpanda.producer();\\n\\ntry {\\n  await producer.connect();\\n  await producer.send({\\n    topic: topicName,\\n    messages: [{ value: \\\"Hello World!\\\" }],\\n  });\\n} catch (error) {\\n  console.error(\\\"Producer send:\\\", error);\\n}\\n\")), mdx(\"p\", null, \"Finally, similarly, we are handling the disconnect.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export async function disconnect() {\\n  try {\\n    await producer.disconnect();\\n  } catch (error) {\\n    console.error(\\\"Producer disconnect:\\\", error);\\n  }\\n}\\n\\nprocess.on(\\\"SIGINT\\\", async () => {\\n  try {\\n    await disconnect();\\n  } catch (error) {\\n    console.error(\\\"Disconnect:\\\", error);\\n  } finally {\\n    process.exit(0);\\n  }\\n});\\n\")), mdx(\"h1\", null, \"Executing\"), mdx(\"p\", null, \"Running the system requires two consoles open: one for the consumer and one for the producer.\"), mdx(\"p\", null, \"Console #1:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"npm run start:consumer\\n\")), mdx(\"p\", null, \"Console #2:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"npm run start:producer\\n\")), mdx(\"p\", null, \"Once the second npm script starts, the first console will display the message.\"), mdx(\"h1\", null, \"Debugging\"), mdx(\"p\", null, \"If you have an issue, you can always use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rpk\"), \" command line to get more information. Here are some commands that can be useful:\"), mdx(\"h2\", null, \"Listening to a topic\"), mdx(\"p\", null, \"If you want to debug your producer, you can listen to the topic. The goal is to isolate the potential issue of not receiving from the consumer by removing from the equation that the consumption code is failing.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"rpk topic consume my-topic\\n\")), mdx(\"h2\", null, \"Check the offset of a consumer id\"), mdx(\"p\", null, \"We can use the private \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__consumer_offsets\"), \" topic to read information about the offset.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"rpk topic consume __consumer_offsets\\n\")), mdx(\"p\", null, \"The output is a list of consumer with they groupId and the value is their offset within a topic. It's encoded in Unicode. I hardcoded the groupid to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"patrickgroupid\"), \". I know the offset is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"4\"), \" in my example since the consumer script displays the offset and I ran the producer script four times. We can validate by fetching all the messages using:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"rpk topic consume my-topic -o \\\"start\\\"\\n\")), mdx(\"p\", null, \"Which returns:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n  \\\"topic\\\": \\\"my-topic\\\",\\n  \\\"value\\\": \\\"Hello World!\\\",\\n  \\\"timestamp\\\": 1694128832293,\\n  \\\"partition\\\": 0,\\n  \\\"offset\\\": 0\\n}\\n{\\n  \\\"topic\\\": \\\"my-topic\\\",\\n  \\\"value\\\": \\\"Hello World!\\\",\\n  \\\"timestamp\\\": 1694128870160,\\n  \\\"partition\\\": 0,\\n  \\\"offset\\\": 1\\n}\\n{\\n  \\\"topic\\\": \\\"my-topic\\\",\\n  \\\"value\\\": \\\"Hello World!\\\",\\n  \\\"timestamp\\\": 1694129115833,\\n  \\\"partition\\\": 0,\\n  \\\"offset\\\": 2\\n}\\n{\\n  \\\"topic\\\": \\\"my-topic\\\",\\n  \\\"value\\\": \\\"Hello World!\\\",\\n  \\\"timestamp\\\": 1694129182939,\\n  \\\"partition\\\": 0,\\n  \\\"offset\\\": 3\\n}\\n{\\n  \\\"topic\\\": \\\"my-topic\\\",\\n  \\\"value\\\": \\\"Hello World!\\\",\\n  \\\"timestamp\\\": 1694129515917,\\n  \\\"partition\\\": 0,\\n  \\\"offset\\\": 4\\n}\\n\")), mdx(\"p\", null, \"We can see the private topic \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__consumer_offsets\"), \" has these three entries for the group id \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"patrickgroupdid\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n  \\\"topic\\\": \\\"__consumer_offsets\\\",\\n  \\\"key\\\": \\\"\\x02\\x0Epatrickgroupid\\\",\\n  \\\"value\\\": \\\"\\x03\\bconsumer\\x01\\x12RoundRobinAssigner,kafkajs-a4eb9d4d-370c-4e98-a7df-4c08d94d9a33\\x01\\uFFFDq\\uFFFD\\uFFFD<\\x01\\x03,kafkajs-a4eb9d4d-370c-4e98-a7df-4c08d94d9a33\\uFFFD\\uFFFD\\x07kafkajs%n172.17.0.1\\uFFFD`u0\\x14\\x01\\bmy-topic\\x1C\\x01\\bmy-topic\\x01\\\",\\n  \\\"timestamp\\\": 1694129504832,\\n  \\\"partition\\\": 0,\\n  \\\"offset\\\": 0\\n}\\n{\\n  \\\"topic\\\": \\\"__consumer_offsets\\\",\\n  \\\"key\\\": \\\"\\x01\\x0Epatrickgroupid\\bmy-topic\\\",\\n  \\\"value\\\": \\\"\\x03\\x05\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\x01\\uFFFDq\\uFFFD\\uFFFD\\uFFFD\\\",\\n  \\\"timestamp\\\": 1694129515933,\\n  \\\"partition\\\": 0,\\n  \\\"offset\\\": 1\\n}\\n{\\n  \\\"topic\\\": \\\"__consumer_offsets\\\",\\n  \\\"key\\\": \\\"\\x02\\x0Epatrickgroupid\\\",\\n  \\\"value\\\": \\\"\\x03\\bconsumer\\x02\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\x01\\uFFFDq\\uFFFD(U\\\",\\n  \\\"timestamp\\\": 1694129530965,\\n  \\\"partition\\\": 0,\\n  \\\"offset\\\": 2\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"offset\"), \" is not the offset of the group id, but the offset of the message into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__consumer_offsets\"), \" topic. In that case, the value is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"value\\\": \\\"\\x03\\bconsumer\\x02\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\x01\\uFFFDq\\uFFFD(U\\\",\"), \" which is in a binary format.\\nThus, some code is needed:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const admin = redpanda.admin();\\ntry {\\n  await admin.connect();\\n  const groupPartitionOffset = await admin.fetchOffsets({\\n    groupId: \\\"patrickgroupid\\\",\\n    topics: [topicName],\\n  });\\n  for (const partitions of groupPartitionOffset) {\\n    console.log(`Topic ${partitions.topic}`);\\n    for (const p of partitions.partitions) {\\n      console.log(`Offset for ${p.offset} at partition ${p.partition}`);\\n    }\\n  }\\n} catch (error) {\\n  console.error(\\\"Admin offset:\\\", error);\\n}\\n\")), mdx(\"p\", null, \"In this particular case, we are targetting the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"patrickgroupid\"), \" which output:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"Topic my-topic\\nOffset for 5 at partition 0\\n\")), mdx(\"p\", null, \"The value is 5, meaning the following value to read would be the fifth offset.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"The road to this simple example was relatively easy to achieve. Redpanda has good but minimal documentation, and Kafkajs library is prevalent (but needs to be more supported; they are \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tulios/kafkajs/issues/1603\"\n  }, \"looking for a maintainer\"), \"). Nonetheless, we can produce and consume messages from Redpanda with minimal lines.\"), mdx(\"p\", null, \"The source code of this article is available in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/redpandasimpleconsumerproducer\"\n  }, \"Github\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"741cc383-1f8b-5971-a7bf-90aacf08fa2e","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}