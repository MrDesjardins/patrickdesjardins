{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-use-typeScript-satisfies-operator-keyword",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to use TypeScript Satisfies Operator Keyword?","date":"March 17, 2023"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to use TypeScript Satisfies Operator Keyword?\",\n  \"date\": \"2023-03-17\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"My first reaction when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"satisfies\"), \" operator launched with TypeScript 4.9 was that it was one more complex to understand in the language. I continued my way without spending much of my time understand the goal until one day I stumble into a scenario that was problematic for many years. TypeScript should do something about it! Then, I suddenly thought about \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"satisfies\"), \" and realized that it was the solution to my current and many years issue.\"), mdx(\"h1\", null, \"Preface: The Problematic Situation\"), mdx(\"p\", null, \"To understand \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"satisfies\"), \", you must feel the pain of not having the operator. \"), mdx(\"h2\", null, \"Example 1: Too Many Fields\"), mdx(\"p\", null, \"Imagine you have a type that defines a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" and a function to add people into something.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"interface Person {\\n    name: string;\\n    age: number;\\n}\\n\\ndeclare function addPerson(p:Person):void;\\n\")), mdx(\"p\", null, \"In this example, we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"declare\"), \" to avoid getting into the detail of the function, as it is irrelevant to the point we are illustrating. What is important is how to call this function. Calling the function with a variable is the safest way without \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"satisfies\"), \" as the variable has an explicit type. For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"interface Person {\\n    name: string;\\n    age: number;\\n}\\n\\ndeclare function addPerson(p:Person):void;\\n\\nconst p: Person = {name:\\\"Patrick\\\", age: 89}; // Variable\\naddPerson(p); // Using the variable\\n\")), mdx(\"p\", null, \"The problem is that you \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"must\"), \" define an explicit variable. While it is acceptable in many cases, it would be, in some cases, more straightforward to remove that line.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"interface Person {\\n    name: string;\\n    age: number;\\n}\\n\\ndeclare function addPerson(p:Person):void;\\n\\naddPerson({name:\\\"Patrick\\\", age: 89}); // Will be dangerous soon\\n\")), mdx(\"p\", null, \"The problem with the above code is that you may add fields later. As long as the minimum is there, TypeScript will allow passing the object because of its structural nature.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"addPerson({name:\\\"Patrick\\\", age: 89, lastName:\\\"Haha!\\\"}); // lastName added, still pass the compilation time\\n\")), mdx(\"p\", null, \"The problem is that maybe the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lastName\"), \" was there in the past and removed. Then, you have a piece of code that should not be there anymore, but you are not warned. It might sound like a small problem so let's get into a second example.\"), mdx(\"h2\", null, \"Example 2: Union\"), mdx(\"p\", null, \"Let's add more complexity. Let's have a function called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" that accepts a union of two interfaces with no field that overlaps.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"interface Person {\\n    name: string;\\n    age: number;\\n}\\n\\ninterface Animal {\\n    breathUnderWater: boolean;\\n}\\n\\ndeclare function add(p:Person|Animal):void;\\n\\nadd({name:\\\"Patrick\\\", breathUnderWater:true}); // dangerous\\n\")), mdx(\"p\", null, \"This example compiles without problem. The function takes a union of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Animal\"), \" and it is legit to pass a mix of both because it fulfills the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Animal\"), \" part of the contract and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" is superfluous. The auto-complete in Visual Studio Code (VsCode) is also mixed up by the suggestion a mix of both types.\"), mdx(\"p\", null, \"Before using TypeScript \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"satisfies\"), \" keyword, a trick was to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cast\"), \". For example, if we knew we wanted to pass a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" we could use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as Person\"), \" and the example above would be in error.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"add({name:\\\"Patrick\\\", breathUnderWater:true} as Person); // dangerous\\n\")), mdx(\"p\", null, \"However, it opens another issue: it coerces the type to be a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" while it is not. So it means that maybe we are getting an error because we forgot some fields, in that case \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"age\"), \", and adding the field fixes the compiler error.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"add({name:\\\"Patrick\\\", age:123, breathUnderWater:true} as Person);\\n\")), mdx(\"p\", null, \"But, it remains that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"breathUnderWater\"), \" field should not be acceptable.\"), mdx(\"h2\", null, \"Example 3: Nested Implicit Object\"), mdx(\"p\", null, \"Another example is if you have a list of nested objects that are not explicitly typed. For example, you may have an object with many constants or feature flags.\"), mdx(\"p\", null, \"Here is a small example.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const MY_APP_CONSTANTS = {\\n    SIZES: {\\n        MIN: 1024\\n    },\\n    THRESHOLDS: {\\n        LOWER_BOUND: 0,\\n        UPPER_BOUND: 100\\n    },\\n    FEATURE_FLAGS: {\\n        ENABLE_POST_FORM: true\\n    }\\n};\\n\")), mdx(\"p\", null, \"The problem is that each field are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"boolean\"), \" and it can be improved with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as const\"), \" so that each field has exactly only one possible value (the one defined in the object).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const MY_APP_CONSTANTS = {\\n    SIZES: {\\n        MIN: 1024\\n    },\\n    THRESHOLDS: {\\n        LOWER_BOUND: 0,\\n        UPPER_BOUND: 100\\n    },\\n    FEATURE_FLAGS: {\\n        ENABLE_POST_FORM: true\\n    }\\n} as const;\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as const\"), \" works well, and trying to access an additional field that does not exist does not compile.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"MY_APP_CONSTANTS.SIZES.MAX = 10000; // Compiler error, as expected.\\n\")), mdx(\"p\", null, \"So, there is no problem with example 3? There is. In that case, there is no type, and the implicit typing takes care of the issue. However, in a similar matter, we may have a type that will get into a similar problem of example 2, where we can access a non-existant field without compilation error.\"), mdx(\"p\", null, \"Let's simplify the constant to have only the feature flag and to be open for additional flags. Later, we will allow any feature flag name as a string if the value is a boolean.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"interface AppThresholds extends Record<string, boolean>{}\\n\\ninterface AppConfig {\\n    FEATURE_FLAGS: AppThresholds;\\n}\\n\\nconst MY_APP_CONSTANTS:AppConfig = {\\n    FEATURE_FLAGS: {\\n        ENABLE_POST_FORM: true\\n    }\\n};\\n\")), mdx(\"p\", null, \"So far, so good. However, a problem occurs when we use a type for the root of the object rather than the children.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"interface AppFlags extends Record<string, boolean>{}\\n\\ninterface AppConfig {\\n    FEATURE_FLAGS: AppFlags;\\n}\\n\\nconst MY_APP_CONSTANTS: AppConfig = {\\n    FEATURE_FLAGS: {\\n        ENABLE_POST_FORM: true\\n    }\\n};\\n\\nMY_APP_CONSTANTS.FEATURE_FLAGS.ENABLE_POST_FORM = true;\\nMY_APP_CONSTANTS.FEATURE_FLAGS.do_not_exist = true; // dangerous\\n\")), mdx(\"p\", null, \"The code compiles but \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"do_not_exist\"), \" does not exist. Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as const\"), \" does not help.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const MY_APP_CONSTANTS: AppConfig = {\\n    FEATURE_FLAGS: {\\n        ENABLE_POST_FORM: true\\n    } as const\\n} as const;\\n\")), mdx(\"p\", null, \"The only way is not to type, which will have the constant to infer the type and not use the feature flag as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Record<string>\"), \", which means can be anything like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"do_not_exist\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const MY_APP_CONSTANTS = {\\n    FEATURE_FLAGS: {\\n        ENABLE_POST_FORM: true\\n    } \\n}\\n\")), mdx(\"p\", null, \"However, the problem is that someone might add something else and change the goal of this object! \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const MY_APP_CONSTANTS = {\\n    FEATURE_FLAGS: {\\n        ENABLE_POST_FORM: true\\n    },\\n    DO_NOT_ADD: { // Oh no! It does not respect the intended AppConfig contract\\n        SHOULD_NOT: true\\n    }\\n} \\n\")), mdx(\"p\", null, \"Hence we are stuck between having a contract that forces the developer that block unintended additional fields in the interface at the expense of using fields that might not be there or having a strongly typed object that blocks the developer from adding fields outside the expected ones from the interface but allow them to access field not defined later.\"), mdx(\"h1\", null, \"Satisfies Role\"), mdx(\"p\", null, \"In all three examples, the TypeScript operator \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"satisfies\"), \" fixes the issues.\"), mdx(\"h2\", null, \"Example 1: Too Many Fields\"), mdx(\"p\", null, \"The first example showed that the function accepted too many fields.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"addPerson({name:\\\"Patrick\\\", age: 89, lastName:\\\"Haha!\\\"} satisfied Person); // Compiler error\\n\")), mdx(\"p\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"satisfies\"), \" tells the compiler that the object must \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"satisfies\"), \" the contract of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" interface, and it that case the field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lastName\"), \" is not part of the contract, thus causing a compilation error. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"satisfies\"), \" is better than an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as\"), \" because it does not try to coerce the type to be casted to something that it does not. In this example, it would be cast because it has the minimum structural field to match the expected \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \". Thus, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as\"), \" is not the solution.\"), mdx(\"h2\", null, \"Example 2: Union\"), mdx(\"p\", null, \"Similarly, with example two with the union where a mix of the two desired type was compiled without a problem.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"add({name:\\\"Patrick\\\", age:123, breathUnderWater:true} satisfies Person);\\n\")), mdx(\"p\", null, \"The code was working with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as\"), \" but we were adding a field that did not belong there. With \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"satisfies\"), \" the code does not compile as expected.\"), mdx(\"h2\", null, \"Example 3: Nested Implicit Object\"), mdx(\"p\", null, \"The final example works well with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"satisfies\"), \" if you do not type the object. The object will respect the contract or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"satisfy\"), \" the interface by only allowing the developer to add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FEATURE_FLAGS\"), \" to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MY_APP_CONSTANTS\"), \" object but will not allow the usage of the object to access fields that do not \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"satisfy\"), \" the feature flag object signature.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"interface AppFlags extends Record<string, boolean>{}\\n\\ninterface AppConfig {\\n    FEATURE_FLAGS: AppFlags;\\n}\\n\\nconst MY_APP_CONSTANTS = {\\n    FEATURE_FLAGS: {\\n        ENABLE_POST_FORM: true\\n    } satisfies AppFlags,\\n    DO_NOT_ADD: { // Do not compile because we typed `AppConfig` to the object\\n       SHOULD_NOT: true\\n    }\\n} satisfies AppConfig; \\n\\nMY_APP_CONSTANTS.FEATURE_FLAGS.ENABLE_POST_FORM = true;\\nMY_APP_CONSTANTS.FEATURE_FLAGS.do_not_exist = true; // Do not compile\\n\")), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"The TypeScript operator \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"satisfies\"), \" may not be needed in many prominent areas of your code base but should get into a reflect anytime you use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cast\"), \" or are into a situation where the code compiles by adding superfluous fields where it should not.\"), mdx(\"p\", null, \"I have been using TypeScript since version 1.3-ish, and TypeScript seems to get bloated every year with new keywords or how keywords are used (for example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"extends\"), \"). The TypeScript operator \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"satisfies\"), \" fulfill a role to fix an issue with structural language and is worth learning and, to some extent \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"worth\"), \" bloating TypeScript a little more. While it would be great that some of these pitfalls be automatically fixed without explicitly marking the code with a keyword, it is currently the best solution to ensure type safety in a few scenarios.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"433c20ee-44bd-5fd2-a1d1-84c30f91fc7b","totalPages":75}},
    "staticQueryHashes": ["3159585216"]}