{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-copy-attribute-from-one-property-to-another",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to copy attribute from one property to another","date":"November 3, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to copy attribute from one property to another\",\n  \"date\": \"2015-11-03\",\n  \"categories\": [\"automapper\", \"c-sharp\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Earlier, I showed \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./how-to-automap-asp-net-attribute-from-model-to-viewmodel\"\n  }, \"how to transfer attribute form model class to view model class with AutoMapper and Asp.Net MVC\"), \". This work fine but what if the view model class has a custom property that manipulate even further the data and that you would like to display on screen a display attribute from another property of the model class? The solution we had in the previous post transferred the display attribute from the model to the view model\\u2019s property by using AutoMapper to map the DisplayAttribute with the corresponding From and To property. But how can we extends this logic to be able to pass this attribute to another property of the view model class? This is what we will resolve in this article. The following image illustratre the desired result. We want the property B from the view model to use the p roperty A display attribute that come from the model property A. \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"675px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"25.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA5ElEQVQY0xXN65KDIAxAYd//Afcy62hbQZRwDUkQW8tO/59vzrBs3nqMudyNGxcLscjRqDbk2nuPyKsN1udZw6xg1s64VNszFHld17D7jCQkFWJRNlBt1/t9vq6Awu3pEmFh4mogrZCMy4mk9y7H+cEulsI1Is+rW/ZofI5UHUosn2iFPCmYNNw3r2xUNj32oCFBIq7nkD/bQ0OatPu6baMCj9zOJx9n7z1RnVf3fTN/ix0V/D72n/t+M27Ubgs0ZKpFji2gzxxQXCKfCeWg2nrvXFssAokCckD2mX2mWGSPpZ2vf2u3GPNW6ApcAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"ModelToViewModel\",\n    \"title\": \"ModelToViewModel\",\n    \"src\": \"/static/b051704a6219fe772e228c530048b101/23296/ModelToViewModel.png\",\n    \"srcSet\": [\"/static/b051704a6219fe772e228c530048b101/5a46d/ModelToViewModel.png 300w\", \"/static/b051704a6219fe772e228c530048b101/0a47e/ModelToViewModel.png 600w\", \"/static/b051704a6219fe772e228c530048b101/23296/ModelToViewModel.png 675w\"],\n    \"sizes\": \"(max-width: 675px) 100vw, 675px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \")), mdx(\"p\", null, \"The first part, is already been done in the AutoMap code from the previous article. This is the code that map the attribute from the model to view model. The next step is to specify in the view model that we need to transfer from one property\\u2019s attribute to the other property. This require to create a new attribute where we can specify from which property we want to get the attributes.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class CopyAttributesFrom : Attribute { public string PropertyName { get; set; } } \\n``` Then, we need to use it in the view model class. This class is limited to one property: the name of the property to take attributes. The mapping is than 1-1, nothing fancy. Let\\u2019s see an example. The following code is having two property. The first one get from the model some attributes and the second one want to get the attribute from the first property (which also has once mapped the ones from the model).\\n\\n\\n```csharp\\n public TimeSpan? MinimumHoldingTime { get; set; }\\n\\n[CopyAttributesFrom(PropertyName = \\\"MinimumHoldingTime\\\")] public int? MinimumHoldingTimeMinutes { get { return this.MinimumHoldingTime.HasValue ? Convert.ToInt32(this.MinimumHoldingTime.Value.TotalMinutes) : (int?)null; } } \\n``` Why don\\u2019t we map directly into AutoMapper the logic? Because the code we are using to transfer attributes from the model to viewmodel works with **DestinationProperty** and not an expression. Having logic in the **ForMember** method of AutoMapper uses an expression. This force us to map the value and in a second step to have the property desired with the data manipulated.\\n\\nIn the code to map with AutoMapper model attributes to view model, we had a custom **DataAnnotationsModelMetadataProvider**. This one need to be adjusted to add attributes from our custom a _CopyAttributesFrom_ attribute.\\n\\n\\n```csharp\\n public class MappedDataAnnotationsModelMetadataProvider : DataAnnotationsModelMetadataProvider { private readonly IConfigurationProvider mapper;\\n\\npublic MappedDataAnnotationsModelMetadataProvider(IConfigurationProvider mapper) { this.mapper = mapper; }\\n\\nprotected override ModelMetadata CreateMetadata(IEnumerable<Attribute> attributes, Type containerType, Func<object> modelAccessor, Type modelType, string propertyName) { //Copy attributes from the model and to the view model var mappedAttributes = containerType == null ? attributes.ToList() : mapper.GetMappedAttributes(containerType, propertyName, attributes).ToList();\\n\\n//Map CopyAttributes attributes foreach (var attributeCopy in attributes.Where(d => d.GetType() == typeof (CopyAttributesFrom)).Cast<CopyAttributesFrom>()) { var propertyFromTheMappedModelOfTheCopiedProperty = mapper.GetMappedAttributes(containerType, attributeCopy.PropertyName, attributes).ToList(); mappedAttributes.AddRange(propertyFromTheMappedModelOfTheCopiedProperty); } var modelMetadata = base.CreateMetadata(mappedAttributes, containerType, modelAccessor, modelType, propertyName); return modelMetadata; } } \\n\")), mdx(\"p\", null, \"The foreach is where everything happen. We verify that the property we map is marked with our copy attribute; if yes, we go in AutoMapper to get from the model the attributes. We must go back to the model and not directly copy the attributes from the specified viewmodel\\u2019s attribute because this one may not already been transferred from the model \\u2014 we do not control the order that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CreateMetaData\"), \" is invoked. Nevertheless, this is not a problem, we take the view model property name, and instead of binding the attribute to the property specified we bind them to the property we are creating the metadata.\"), mdx(\"p\", null, \"If you are not using this whole AutoMapper model/view model mapping, you can get a similar result by using the .Net framework. Here is how.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var sourceProperty = containerType.GetProperty(attributeCopy.PropertyName); var allAttributeFromSpecifiedProperty = sourceProperty.GetCustomAttributes(true); foreach (object attr in allAttributeFromSpecifiedProperty) { mappedAttributes.Add(attr as Attribute); } \\n\")), mdx(\"p\", null, \"Nonetheless, this solution has a pitfall which is the way we specify the property to copy the attributes \\u2014 this one is hardcoded. Refactoring of this class is harder and the string may be unsynchronize with a property rename. However, since we localize the copy to the class itself and not beyond this boundary, the instability is restrained. This is a limitation of the actual .Net framework which does not allow to use expression inside an attribute.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"71f2eab1-add6-55f8-b0eb-326cb506ce55","totalPages":71}},
    "staticQueryHashes": ["3159585216"]}