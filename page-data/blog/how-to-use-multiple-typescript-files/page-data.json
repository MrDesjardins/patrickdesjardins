{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-use-multiple-typescript-files",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to use multiple TypeScript files","date":"February 7, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to use multiple TypeScript files\",\n  \"date\": \"2017-02-07\",\n  \"categories\": [\"asp-mvc\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"TypeScript allows you to use EcmaScript import syntax to bring code from another file, or multiple files. This is very useful if you do not want to have all your code into a single file, or if you want to reuse code in different files.\"), mdx(\"p\", null, \"For example, let's have 2 files. app.ts and fileToInclude.ts which will contain a class that we want to use in App.ts.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"//app.ts content: \\nimport { ClassA } from \\\"fileToInclude\\\"\\n\\nconst a = new ClassA(); a.method1();\\n\\n//fileToInclude.ts content: \\nexport class ClassA { \\n  public method1(): void { \\n    console.log(\\\"ClassA>method1\\\"); \\n  } \\n} \\n\")), mdx(\"p\", null, \"As you can see, the way to import a class is to specify the class name and from which file to import it. On the other side, the class that you want to import must be marked as export to be imported. The export and import are not TypeScript specific, but something EcmaScript version 6 allows you to use instead of using a custom AMD loader library like Require.js.\"), mdx(\"p\", null, \"So while this is supported since EcmaScript 6, some browser doesn't support this feature. However, with TypeScript, you can style use EcmaScript, except for module loading. So, if you compile using EcmaScript and go to Chrome you will end up with an unexpected error if you do not.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Uncaught SyntaxError: Unexpected token import\")), mdx(\"p\", null, \"By changing the target of the tsconfig.json to use a module loader the generated code will be using the module loader syntax instead of the EcmaScript syntax. A popular one is Require.js. to do so, the tsconfig.json file needs to have a module entry.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"{ \\n  \\\"compilerOptions\\\": { \\n    \\\"sourceMap\\\": true, \\n    \\\"target\\\": \\\"es6\\\", \\n    \\\"module\\\": \\\"amd\\\", \\n    \\\"outDir\\\": \\\"./Scripts/App\\\" \\n    }, \\n    \\\"include\\\": [ \\\"src/**/*\\\" ] } \\n\")), mdx(\"p\", null, \"Without specifyin the module, the code generated was: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import { ClassA } from \\\"./fileToInclude\\\"; \\nconst a = new ClassA(); \\na.method1(); \\n\")), mdx(\"p\", null, \"With the module to AMD, this will output a JavaScript that will wrap the module with require. For example: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"define([\\\"require\\\", \\\"exports\\\", \\\"./fileToInclude\\\"], function (require, exports, fileToInclude_1) { \\n  \\\"use strict\\\"; \\n  var a = new fileToInclude_1.ClassA(); \\n  a.method1(); \\n}); \\n\")), mdx(\"p\", null, \"Finally, you cannot call directly the .js file in the .cshtml. Instead, we need to use the script tag with a src to requirejs and call a specific method to indicate which module to load (which file).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"<script src=\\\"~/Scripts/require.js\\\"></script> \\n<script> requirejs.config({ baseUrl: '/Scripts/App/' }); \\nrequirejs(['app']); </script> \\n\")), mdx(\"p\", null, \"In our case, we want to execute app.js, so we write \\\"app\\\" without the extension \\\".js\\\". However, before doing so, we need to setup require requirejs to know that the root of all JavaScript file are located into the Script folder.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"33e02ac0-80e9-53a1-a797-49facdab4499","totalPages":68}},
    "staticQueryHashes": ["3159585216"]}