{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/communicating-between-sibling-react-hook-components",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Communicating Between Sibling React Hook Components","date":"November 1, 2021"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Communicating Between Sibling React Hook Components\",\n  \"date\": \"2021-11-01\",\n  \"categories\": [\"react\", \"react-hooks\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Communication between React's components is natural using the properties of each component. However, if a child wants to send information back the tree of components, some additional work is required. In this article, I'll clarify how to communicate top-down, bottom-up, and side-to-side.\"), mdx(\"p\", null, \"Let's start with a basic React application that has three components.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export default function App() {\\n  return (\\n    <div className=\\\"App\\\">\\n      <Parent>\\n        <Sibling1 name=\\\"Patrick\\\" />\\n        <Sibling2 age={100} />\\n      </Parent>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"The parent:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface ParentProps {\\n  children: React.ReactNode | React.ReactNode[];\\n}\\n\\nexport const Parent = (props: ParentProps) => {\\n  return <div id=\\\"parent\\\">{props.children}</div>;\\n};\\n\")), mdx(\"p\", null, \"And the two children components:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface Sibling1Props {\\n  name: string;\\n}\\n\\nexport const Sibling1 = (props: Sibling1Props) => {\\n  return <div id=\\\"sibling1\\\">Sibling1 name is: {props.name}</div>;\\n};\\n\\nexport interface Sibling2Props {\\n  age: number;\\n}\\n\\nexport const Sibling2 = (props: Sibling2Props) => {\\n  return <div id=\\\"sibling2\\\">Sibling2 age is {props.age}</div>;\\n};\\n\\n\")), mdx(\"h1\", null, \"Top-Bottom Communication\"), mdx(\"p\", null, \"The scaffolding already contains one communication principle: passing the information by property. In that case, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" hands down the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"age\"), \". Important to note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Parent\"), \" does not pass the information down. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Parent\"), \" component contains only an instruction to render what the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \" property.\"), mdx(\"p\", null, \"How can we have one of the siblings having an action to send information from the bottom-up? If we want to remain on track with React, we are limited by the property mechanism. However, instead of passing the information directly, we give the value inside a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"function\"), \".\"), mdx(\"p\", null, \"First, let's modify one of the siblings to have a property that takes a function without a parameter and that returns no value.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface Sibling2Props {\\n  age: number;\\n  notifyParent: () => void;\\n}\\n\\nexport const Sibling2 = (props: Sibling2Props) => {\\n  return (\\n    <div id=\\\"sibling2\\\">\\n      <div>Sibling2 age is {props.age}</div>\\n      <div>\\n        <button\\n          onClick={() => {\\n            props.notifyParent();\\n          }}\\n        >\\n          Click me\\n        </button>\\n      </div>\\n    </div>\\n  );\\n};\\n\")), mdx(\"p\", null, \"You can play with the code in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codesandbox.io/s/react-sibling-communication-part1-ssdge\"\n  }, \"CodeSandbox.io\"), \".\"), mdx(\"h1\", null, \"Bottom-Up Communication\"), mdx(\"p\", null, \"If we modify the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.tsx\"), \" to have a title and that each time the application gets notified that the title adds a smiley face, we get:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export default function App() {\\n  const [title, setTitle] = useState(\\\"App Title\\\");\\n  return (\\n    <div className=\\\"App\\\">\\n      <div>{title}</div>\\n      <Parent>\\n        <Sibling1 name=\\\"Patrick\\\" />\\n        <Sibling2\\n          age={100}\\n          notifyParent={() => {\\n            setTitle((title) => title + \\\"\\uD83D\\uDE00\\\");\\n          }}\\n        />\\n      </Parent>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"You can play with the code in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codesandbox.io/s/react-sibling-communication-part2-tlzzw\"\n  }, \"CodeSandbox.io\"), \".\"), mdx(\"p\", null, \"Hence, the child that has a property that is function can send the information above.\"), mdx(\"h1\", null, \"Slibling Communication by the parent\"), mdx(\"p\", null, \"The reflex is to communicate to a sibling is to look at the common point. In our case, the parent or the application component at the root of the application. For example, if we want to have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Sibling2.tsx\"), \" communicate with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Sibling1.tsx\"), \" we would visit \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Parent.tsx\"), \". In terms of code, it is a slight change compared to the previous iteration. First, we need to remove the title from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.tsx\"), \" into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Sibling1.tsx\"), \". We keep the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.tsx\"), \". The reason is that the function continues to be invoked in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.tsx\"), \". Then, to send the information from the function to the sibling, we need to use the state. The reason is that we want to send top to bottom the information. Thus, we need to pass the new title to the other child. The code looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export default function App() {\\n  const [title, setTitle] = useState(\\\"App Title\\\");\\n  return (\\n    <div className=\\\"App\\\">\\n      <Parent>\\n        <Sibling1 name=\\\"Patrick\\\" title={title} />\\n        <Sibling2\\n          age={100}\\n          notifyParent={() => {\\n            setTitle((title) => title + \\\"\\uD83D\\uDE00\\\");\\n          }}\\n        />\\n      </Parent>\\n    </div>\\n  );\\n}\\n\\nexport interface Sibling1Props {\\n  name: string;\\n  title: string;\\n}\\n\\nexport const Sibling1 = (props: Sibling1Props) => {\\n  return (\\n    <div id=\\\"sibling1\\\">\\n      <div>Title is: {props.title}</div>\\n      <div>Sibling1 name is: {props.name}</div>\\n    </div>\\n  );\\n};\\n\")), mdx(\"p\", null, \"A keen eye realizes one conceptual issue here. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" does not have any business with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"title\"), \". The state is the responsibility of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Sibling1.tsx\"), \" only. So the logic to increment is a logic that belongs to the owner of the title, not the app, neither the sibling triggering the notification that something happened. An idea that is impossible to do is to have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"notifyParent\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"call\"), \" a function in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Sibling1\"), \". Something like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{10}\",\n    \"{10}\": true\n  }, \"export default function App() {\\n\\n  return (\\n    <div className=\\\"App\\\">\\n      <Parent>\\n        <Sibling1 name=\\\"Patrick\\\" title={title} />\\n        <Sibling2\\n          age={100}\\n          notifyParent={() => {\\n            sibling1.notify();\\n          }}\\n        />\\n      </Parent>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"Unfortunately, that does not exist. One pattern is to rely on React'S context.\"), mdx(\"h1\", null, \"Communication sibling to sibling using Context\"), mdx(\"p\", null, \"To communicate with a sibling without polluting a component with a state is to store that state elsewhere -- a shared place. That place is a custom context.\"), mdx(\"p\", null, \"Define the contract in an interface. In that particular example, we will share a way to consume using a property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"title\"), \" and a way to send information \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setTitle\"), \". With the interface, we create a context. The values don't matter at that step. Actually, an alternative is to provide fake data is to mark the field as optional.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface Communication {\\n  title: string;\\n  setTitle: (newTitle: string) => void;\\n}\\n\\nexport const CommunicationContext = createContext<Communication>({\\n  title: \\\"\\\",\\n  setTitle: () => {}\\n});\\n\")), mdx(\"p\", null, \"Then, you create a React component that will handle the values:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface CommunicationContextProviderProps {\\n  children: ReactElement | ReactElement[];\\n}\\n\\nexport const CommunicationContextProvider = (\\n  props: CommunicationContextProviderProps\\n) => {\\n  const [title, setTitle] = useState(\\\"App Title\\\");\\n  return (\\n    <CommunicationContext.Provider\\n      value={{\\n        title: title,\\n        setTitle: (newTitle: string) => {\\n          setTitle(newTitle);\\n        }\\n      }}\\n    >\\n      {props.children}\\n    </CommunicationContext.Provider>\\n  );\\n};\\n\\n\")), mdx(\"p\", null, \"The idea is the state is stored in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Provider\"), \" function. It does not pollute the application or the parent component. Instead, it keeps the data inside the provider. By providing a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setTitle\"), \", the sibling2 will be able to set the title. By providing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"title\"), \", because we use a state, once the value change, anyone under the provider will have its component re-render and receive the new value using the context.\"), mdx(\"p\", null, \"Looks how uncluttered is the application now:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"\\nexport default function App() {\\n  return (\\n    <div className=\\\"App\\\">\\n      <CommunicationContextProvider>\\n        <Parent>\\n          <Sibling1 name=\\\"Patrick\\\" />\\n          <Sibling2 age={100} />\\n        </Parent>\\n      </CommunicationContextProvider>\\n    </div>\\n  );\\n}\\n\")), mdx(\"p\", null, \"The sibling2, which invokes the function looks the following. No more function in its properties for communication to a sibling but a call to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useContext\"), \" to have access to the function to trigger a call that the other sibling will receive.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{6,13}\",\n    \"{6,13}\": true\n  }, \"export interface Sibling2Props {\\n  age: number;\\n}\\n\\nexport const Sibling2 = (props: Sibling2Props) => {\\n  const context = useContext(CommunicationContext);\\n  return (\\n    <div id=\\\"sibling2\\\">\\n      <div>Sibling2 age is {props.age}</div>\\n      <div>\\n        <button\\n          onClick={() => {\\n            context.setTitle(\\\"From sibling 2\\\");\\n          }}\\n        >\\n          Click me\\n        </button>\\n      </div>\\n    </div>\\n  );\\n};\\n\")), mdx(\"p\", null, \"The other sibling is also uncluttered. No more properties that receive the title. Instead, it relies on the context and consumes the value.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface Sibling1Props {\\n  name: string;\\n}\\n\\nexport const Sibling1 = (props: Sibling1Props) => {\\n  const context = useContext(CommunicationContext);\\n  return (\\n    <div id=\\\"sibling1\\\">\\n      <div>Title is: {context.title}</div>\\n      <div>Sibling1 name is: {props.name}</div>\\n    </div>\\n  );\\n};\\n\")), mdx(\"p\", null, \"You can play with the code in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codesandbox.io/s/react-sibling-communication-part3-pmrtj\"\n  }, \"CodeSandbox.io\"), \".\"), mdx(\"p\", null, \"I'll conclude by teasing the topic of the following article: how can you notice that something is pressed? So far, we are passing a string (the title). Because the value of the string is changing, the state is changing in the React's context. Insofar, we rely on the change to trigger the property to be passed down and have the title changing. But, in a situation where we have no value to pass down, only when something happens, how can we do it? For example, imagine sibling2 having a button \\\"reset\\\" and that each time we press, sibling1 reset its values. \"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"b89f77d1-acc9-5aaf-bda6-72c0a77bf367","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}