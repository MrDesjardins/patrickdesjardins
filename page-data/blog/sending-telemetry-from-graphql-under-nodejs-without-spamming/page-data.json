{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/sending-telemetry-from-graphql-under-nodejs-without-spamming",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Sending Telemetry from GraphQL under NodeJS without Spamming","date":"June 11, 2019"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Sending Telemetry from GraphQL under NodeJS without Spamming\",\n  \"date\": \"2019-06-11\",\n  \"categories\": [\"graphql\", \"nodejs-web\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I am running a GraphQL server hosted with NodeJS. Under the hood, it is an Express server with Apollo Middleware. I am collecting different information along with errors. The way it works is that I have an Elastic Search server fronted by a simple REST API facade. The endpoint on the REST accepts a single telemetry payload or a collection of them. The latter is recommended. When I use the REST facade for the web, I am collecting all call to the telemetry and batch the request every 5 seconds or when the browser send a beacon (when leaving the page). It reduces the load on the server by limiting the number of HTTP requests. For example, if there is 24 different telemetry within a few seconds, it performs a single HTTP request with 24 entries.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"541px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/d297ee3ba9e05e7ee261d30d644bbc4c/9d576/Blog.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"26%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAzElEQVQY011Q2QqEMAzs/3+VP+CziIjgXVvxvo9ZJtCF3UBpk85MMlFaa4zjCGstmqZBXddgbRgGMO77xnmemOcZRVEgDEMEQYA0TaX2vu/PUdM0CZliVVUhz3OUZSlNGMuyYNs2yYnjXxzHII9//6EowCmu65J7XVfpRJHjOCTnzcPavu9Se55HBB2Ped/3UHxQwAU7k9i2rdQ5EScjkWLE0yrfXdcJjs7owPd9KIo4/wxHJIh7jaIIWZbBGPO1yJ06TJIkguF+Pc/DB7s4f31hjpF6AAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Telemetry Information flow\",\n    \"title\": \"Telemetry Information flow\",\n    \"src\": \"/static/d297ee3ba9e05e7ee261d30d644bbc4c/9d576/Blog.png\",\n    \"srcSet\": [\"/static/d297ee3ba9e05e7ee261d30d644bbc4c/5a46d/Blog.png 300w\", \"/static/d297ee3ba9e05e7ee261d30d644bbc4c/9d576/Blog.png 541w\"],\n    \"sizes\": \"(max-width: 541px) 100vw, 541px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Under NodeJS, I could do something similar with a timer, but while reading how the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/graphql/dataloader\"\n  }, \"DataLoader\"), \" library handles batching I thought I could code a similar pattern. Instead of leveraging on time, I could batch every telemetry on a single NodeJS event loop. In the NodeJS world, this is called a \\\"tick\\\". There are two ways to accomplish the batching, and I leaned on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setImmediate\"), \".\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"771px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/b60a35d31ba83ffdab5fa234d1c77bcb/5d030/Blog-Page-2.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"24.666666666666664%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAv0lEQVQY002QSQqFYAyD//sfyhu41J0KKuKsOI/08RUqbxHS0qQpdUmSyHmechyH8vM8ct+39td1fbX1/7X18Pu+Ms+zOAzTNMmyLFLXtVRVpWjbVgVd1+nMNFYzgwG+YRjE931xaZoKWNf1E5t53/ePuZ5LYHrDtm26HD+HuDzPpSgKveTfiMiEMKFxHEuWZRo4jqOCGT48ZVmKQ8QfAWm8gD8S0DSN9H2viKJIPM+TIAh0IUewgKWE8sswDOUHwbB9Irj8mx4AAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"NodeJS Event Loop\",\n    \"title\": \"NodeJS Event Loop\",\n    \"src\": \"/static/b60a35d31ba83ffdab5fa234d1c77bcb/5d030/Blog-Page-2.png\",\n    \"srcSet\": [\"/static/b60a35d31ba83ffdab5fa234d1c77bcb/5a46d/Blog-Page-2.png 300w\", \"/static/b60a35d31ba83ffdab5fa234d1c77bcb/0a47e/Blog-Page-2.png 600w\", \"/static/b60a35d31ba83ffdab5fa234d1c77bcb/5d030/Blog-Page-2.png 771w\"],\n    \"sizes\": \"(max-width: 771px) 100vw, 771px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The idea is that NodeJS runs in an infinite loop. It is possible to mention to the system to prepare the execution later, on the next loop with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setImmediate\"), \" which execute when the \\\"poll phase\\\" is completed. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setImmediate\"), \" is different from the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setTimeout\"), \" because it does not rely on a time threshold. Often, libraries use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"process.nextTick\"), \". it processes the task after the event loop. I avoided using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"process.nextTime\"), \" because in some situation it can cause an infinite loop with recursivity. setImmediate is enough to delay the execution. In fact, after using it for more than two weeks, every telemetry collected within a single GraphQL request are batched together which is perfect in my case.\"), mdx(\"p\", null, \"The code in the NodeJS server is short. There is a class that consists of a boolean field that indicates if we have batched information. By default, the value is false until we invoke the first time the function to send the telemetry. When the flag is true, we keep calling the code that will add into an array all the telemetry but we do not call the function performing the HTTP request to the API; we wait that the setImmediate function callback is executed. When this one is executed and returned with a successful HTTP code, we copy the content of the array, flush the data from the list of telemetry, send the information and turn back the flag to false. Ready for the next round of batching. While the code is sending the telemetries, other telemetries can be collected. The data is added to the array to be sent. In case of failure, the data is added back to the next batch.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"public send(data: TelemetryPayload): void {\\n    const dateToSend = { ...data };\\n    this.listDataToSend.push(dateToSend);\\n    if (!this.isTransmittingQueuedPayload) {\\n        this.isTransmittingQueuedPayload = true;\\n        setImmediate(() => {\\n            this.send(); // Perform HTTP requests with all the this.listDataToSend\\n        });\\n    }\\n}\\n\")), mdx(\"p\", null, \"Overall, the code is pretty clean and under one hundred lines of code. It reduces drastically the number of HTTP requests while being easy to read once we get the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setImmediate\"), \" detail clarified.\"), mdx(\"h2\", null, \"My Other GraphQL Blog Posts\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"getting-started-with-graphql-for-netflix-open-connect\"\n  }, \"Getting Started with GraphQL for Netflix Open Connect\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"install-apollo-server-to-host-a-graphql-service\"\n  }, \"Install Apollo Server to host a GraphQL service\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"apollo-server-and-secured-playground\"\n  }, \"Apollo Server and Secured Playground\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"graphql-context\"\n  }, \"GraphQL Context\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"graphql-query-with-argument\"\n  }, \"GraphQL Query with Argument\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"apollo-graphql-resolvers-and-data-source-separation\"\n  }, \"Apollo GraphQL Resolvers and Data Source separation\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"how-to-setup-a-typescript-nodejs-express-apollo-server-to-easy-debugging-with-vscode\"\n  }, \"How to setup a TypeScript, NodeJS, Express Apollo Server to easy debugging with VsCode\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"graphql-resolvers-with-apollo\"\n  }, \"GraphQL Resolvers with Apollo\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"configuring-apollo-playground-and-api-on-two-different-url\"\n  }, \"Configuring Apollo Playground and API on two different URL\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"how-to-automatically-generate-typescript-for-consumer-of-your-graphql\"\n  }, \"How to automatically generate TypeScript for consumers of your GraphQL\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"graphql-extension-to-collect-http-and-resolvers-telemetry\"\n  }, \"GraphQL and HTTP Telemetry\"), \"  \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"how-to-consume-graphql-in-typescript-and-react\"\n  }, \"GraphQL and TypeScript/React\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"6df25526-bcad-5f25-9eab-ba8df8f2890e","totalPages":75}},
    "staticQueryHashes": ["3159585216"]}