{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2013/how-can-i-run-an-update-on-specific-properties-for-detached-objects/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How can I run an update on specific properties for detached objects?","date":"June 19, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How can I run an update on specific properties for detached objects?\",\n  \"date\": \"2013-06-19\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In some scenario you will want to update a specific property but not others. This can be for security reason or for performance reason. In either case, the goal is to update only specific property of your entity. In Entity Framework, this can be done by specifying to the database context (dbcontext) the property status. Each property does have a IsModified property that can be set to true or false.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" context.Entry(yourObject).Property(u => u.YourProperty).IsModified = true; \\n\")), mdx(\"p\", null, \"Of course, if your object is from view, this one is not known by Entity Framework's database context and will require to attach it first.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" using (var entities = new MyDbContext()) { var entity = new YourEntity {Id = id, Name=\\\"Test\\\"}; entities.YourEntities.Attach(entity); entities.Entry(entity).Property(e => e.Name).IsModified = true; entities.SaveChanges(); } \\n\")), mdx(\"p\", null, \"This will save YourEntity entity but only change the Name property. This is quite useful in scenario where you do not want the user to hack a web form to add properties that you doesn't want to be read by Entity Framework.\"), mdx(\"p\", null, \"By specifying which property that is modified, you tell Entity Framework to generate the SQL with only the \\\"Set\\\" for them. For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" UPDATE YourEntity SET Name = \\\"Test\\\" WHERE Id = 123; \\n\")), mdx(\"p\", null, \"Finally, you may want to close the automatic validation if you are using the validation mechanism. This can be done by setting the ValidateOnSaveEnabled to false.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" entities.Configuration.ValidateOnSaveEnabled = false; \\n\")), mdx(\"p\", null, \"The reason is that since not all the object is loaded, you may have some validation on field that should be required that isn't at this time. To temporary disable the validation, use ValidateOnSaveEnabled. Of course, set it back to true once the save changes is done. You can find an example on my blog concerning the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./how-to-save-multiple-entities-in-inheritance-in-the-same-time-with-entity-framework-5-0\"\n  }, \"ValidateOnSaveEnabled\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"5da4b250-0e48-55f4-b877-29f0b764a6f7","slug":"2013/how-can-i-run-an-update-on-specific-properties-for-detached-objects","__params":{"slug":"2013"}}},
    "staticQueryHashes": ["3159585216"]}