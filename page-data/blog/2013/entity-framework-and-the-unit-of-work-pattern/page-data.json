{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2013/entity-framework-and-the-unit-of-work-pattern/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Entity Framework and the Unit of Work pattern","date":"December 16, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Entity Framework and the Unit of Work pattern\",\n  \"date\": \"2013-12-16\",\n  \"categories\": [\"asp-mvc\", \"enterprise\", \"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Abstract\"), mdx(\"p\", null, \"This article is a summary of how to make the use of a unit of work with Entity Framework. First of all, Entity Framework is a unit of work by itself. You can do multiple insert, update and delete and it's not until a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SaveChanges\"), \" that everything is committed to the Sql Server. The problem is that you may want to have multiple repositories. This mean that if you want to be under the same transaction that you want to share the save DbContext. Here comes the unit of work, a pattern that share the DbContext. The reference of DbContext is shared across repositories, which is interesting because if we want to be domain driven we can share the DbContext between repositories of the same domain. It's also interesting for unit testing. The reason is that the unit of work has interface which can be easily mocked.\"), mdx(\"p\", null, \"I have seen an article on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.asp.net/mvc/tutorials/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application\"\n  }, \"Asp.Net website\"), \" concerning Entity Framework and the unit of work pattern but I believe it's wrong. I prefer the one of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/julielerman\"\n  }, \"Julie Lerman\"), \" in her \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://pluralsight.com/training/courses/TableOfContents?courseName=efarchitecture&highlight=julie-lerman_efarchitecture-m4-testing*13#efarchitecture-m4-testing\"\n  }, \"Pluralsight\"), \" video. The main reason is the one of Asp.Net includes the repository inside the unit of work and the DbContext. The one of Julie Lerman only contain the DbContext and the unit of work is passed through every repositories of the domain.\"), mdx(\"p\", null, \"Here is the representation of every layers that we would like with the unit of work.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"251px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/patrickdesjardins/static/2ac181bd9270e42c4816016618a8160a/26abe/Layers.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"113.14741035856572%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAIAAACEf/j0AAAACXBIWXMAAA7DAAAOwwHHb6hkAAADr0lEQVQ4y43T6U/bZhwHcP+b06ZOXTmbDBG6qe0olJE7tpOQOCe5D19xEidxTA7skMR2nDthBEopsEl0a1+1fbGjY4jJoGnrCxiPPvrqJ/2+Lx490gMkGTHNjVKVHlnu3hFR6qS3B0GyCkDRbYSUvJluiN0Ls5O7CBX3YpVDe7IOLBhRlS62YMIMiY4+3r4LXUw2of2nCAtMGXIPbdvzcHnWsnVXZnYert5bQZVrO0nRgTedhOAkRCXx/+HAmu6UrPflgVC+R9SO0OoE3T7Aqvs49wLnD2+HcS9SjWMvJQIaY3zJGH9kTmqM8flV7/f+ipXsw1gHxrs3gbCOPTVc85YANcxqEH7RyS06FBqktuTauZ0GqX3jFWaNGWBGh6uhvMpCq8GcGsypLLTKnFVZcuqbqcz0Alz8aiUKUPzeVvsnpnXCSCeMdMy0ToryaV44ukWu+ZKVT2P5FrDmyoIx3hSuQok6GK9ZYrwpUnVlBx56dBN3duhn9syRbUCtTyyC1CJIaaD0Iyv9tQFT69H1sKiNtq5I/wz/Wo9IhkT3saMITJmKD+31OZibs3KzUHUO5uZt/DRYnrYoZsDK9fAJc2kW5r5YwQHTZgHBGwjesCc4Fym4SMGJ7bjIpiclInjDgfIeSnKTgpsUXUoqXETTl5ZN/jxgDWRBf8oRZZxx1hFjNiIFV2LLhVa0TsxN7IDBvC3CwoGsLUSHc2JBPqWFI1o4KrZ/jBZkACHEQGHspweBwthH9xW5YYCWqXKXru3StV2q0gtkZe9VIcjsBpndQGEcKe1b4zxgSQjOzHiDGmxQA0d66MwMIWKQ4UaX579fnP95cXF+/sev2FbPmho6qMFGqr+R6tvJHpIZazcrwKqf18Xk9YiojUrrEVEXlZ4FhGSxe3gwGY1/OHp1crA/CdDy85CkvHxEuq7p4/K39jxgC+dDtBTMiv5UPZAVwrTkIetVcfftL6+Pj4/Pzl5/eP8uXRJdGB/OtYIZYZNqBDJCnO07EyVgzYE/t6NaN6VzU3pvBgwVbckdvvvyzc9nw9FoMpl8eP+OKIrLcHLdSRi8tN6b0bnTm9kOgtcBU6wJEV0QbSvfBe/ARMeQaJOV/uVfHy+vzvnH3xJsz4R2IawN4R0I74BY20r2Vz0ssOQoPd0UnvgaCr+Sj/3NZR9njPBrHkYfrBrD/Hde/omveb1VCr76crC1AOaAL7X0tKU6ZS7/1wNz+b65+tlK6p6ueN9UefDpdspUmoG4z5/hfwOT6IrgaPePcQAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Layers\",\n    \"title\": \"Layers\",\n    \"src\": \"/patrickdesjardins/static/2ac181bd9270e42c4816016618a8160a/26abe/Layers.png\",\n    \"srcSet\": [\"/patrickdesjardins/static/2ac181bd9270e42c4816016618a8160a/26abe/Layers.png 251w\"],\n    \"sizes\": \"(max-width: 251px) 100vw, 251px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"As you can see, the controller should contact the service layer where all queries are from databases, access to caching services and web services are executed. For the database part, we contact the data access layer accessor which is an abstraction for the unit of work and repositories. This allow every developers that use repositories to abstract the need to create the unit of work and to pass it through constructors. The accessor does have a reference to repositories and to the unit of work.\"), mdx(\"p\", null, \"This article explains how to create a layered approach that has a controller, a service layer, a data access layer accessor with repositories and unit of work with a simple set of entities. I already have wrote an article for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-4-repository\"\n  }, \"repository and entity framework\"), \". This was an other simpler way to design the repository. Previously, a facade was passing the DbContext to all repository, which was created the same behavior as the unit of work pattern. However, the unit of work is more elaborate and allows to unit test easily and allow you to reuse repository in several DbContext if required. Having the possibility to create several DbContext and to share it by domain (for domain driven design) is important for big software. It increase the performance of the database context by having a limited amount of entity to handle. So, the previous way to handle repository is perfect if you have under 50 entities. This is a rule of thumb and it depends of many factors. If you have a lot of entities and that you can draw specific domains, the approach of unit of work in this post is preferable. As you will see, a lot of more classes will be needed and this is not a small detail to consider before going into this way.\"), mdx(\"h2\", null, \"Creating the entities, the database context and the tables\"), mdx(\"p\", null, \"First of all, let's create entities and a simple context that we will call directly from the controller. This should never been done in enterprise but it will allow us to migrate the code from a simple basic code to a more heavy layered application.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class Animal { public int Id { get; set; } public string Name { get; set; }\\n\\npublic virtual ICollection<Animal> Enemies { get; set; } public virtual ICollection<Animal> EnemyOf { get; set; } }\\n\\npublic class Cat : Animal { public int NumberOfMustache { get; set; } public int RemainingLife{get;set;} }\\n\\npublic class Dog : Animal { public string Type { get; set; } } \\n\")), mdx(\"p\", null, \"We have two classes, one is for Cat and one is for Dog. Both inherit from Animal class. These are very simple classes because we want to focus on the unit of work and not on complex classes. The next step is to create the database context.\"), mdx(\"p\", null, \"The first step is to get Entity Framework. This can be done by using Nuget with the interface (\\\"Manage Nuget Package\\\") or with a command line : ```\\nPM> install-package entityframework \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\nThen, we need to inherit from DbContext and setup web.config to have a connection string for the database. The web.config looks like this: \\n```xml\\n <configuration> <configSections> <section name=\\\"entityFramework\\\" type=\\\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\\\" requirePermission=\\\"false\\\" /> </configSections> <connectionStrings> <add name=\\\"EntityConnectionString\\\" connectionString=\\\"Data Source=PATRICK-I7\\\\\\\\SQLEXPRESS;Initial Catalog=UnitOfWork;Integrated Security=SSPI;\\\" providerName=\\\"System.Data.SqlClient\\\" /> </connectionStrings> \\n\")), mdx(\"p\", null, \"The first is that we have a new configSection for Entity Framework. This has been added automatically. The line that is required to be added manually is the connection string.\"), mdx(\"p\", null, \"The last step is to configure the entity. Since we are simplify the whole application for the purpose of the unit of work, the model class will be directly the entity. Some may want in enterprise application have an additional layer to not share entity classes with the model.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class AllDomainContext:DbContext { public AllDomainContext():base(\\\"EntityConnectionString\\\") { }\\n\\nprotected override void OnModelCreating(DbModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder);\\n\\n//Table per type configuration modelBuilder.Entity<Dog>().ToTable(\\\"Animals\\\"); modelBuilder.Entity<Dog>().ToTable(\\\"Dogs\\\"); modelBuilder.Entity<Cat>().ToTable(\\\"Cats\\\");\\n\\n//Primary keys configuration modelBuilder.Entity<Animal>().HasKey(k => k.Id);\\n\\nmodelBuilder.Entity<Animal>() .HasMany(entity => entity.Enemies) .WithMany(d => d.EnemyOf) .Map(d => d.ToTable(\\\"Animals_Enemies_Association\\\").MapLeftKey(\\\"AnimalId\\\").MapRightKey(\\\"EnemyId\\\")); } } \\n``` The configuration has something special for the Enemies list because I did not wanted to handle the the association table by myself. Entity Framework can handle it for us by configure a many to many relationship with the animal class. It requires to have a table name for the many-many table with a foreign keys.\\n\\n## Setup the controllers, service layer and data access layer\\n\\nBefore even having the service layer, let's use the context directly into the controller and see the database creation. Then, we will change to code every layers but not the unit of work yet. We can use scaffolding to leverage Visual Studio power to get code generation for us. First step, right click the controller and select add new controller. ![](images/MvcControllerWithEntityFramework-400x278.png)\\n\\nThe second step is to select to model class, you can select the one of Animal and select the DbContext class. If you do not see your DbContext class (DatabaseContext), close the window and compile your application. The wizard bases its choice on the compiled resource of the project. Once generated, you can execute the code, IIS Express start by default and you just need to go to http://localhost:15635/Animal and the DbContext will start the creation of the database. If you open SQL Server Manager, the unit of work database should have 3 tables.\\n\\n![](images/TabletsTPTForAnimal.png)\\n\\n## Transforming to have service layers\\n\\nAt this stage, the architecture of the web application is not enterprise grade. The controller has a strong reference to the database context. The next step is to have everything related to the database inside a service layer which abstract entity framework. This allow us to test easily the controller without having to care about the database.\\n\\nThis is the current controller code at this moment. \\n```csharp\\n public class AnimalController : Controller { private DatabaseContext db = new DatabaseContext();\\n\\npublic ActionResult Index() { return View(db.Animals.ToList()); }\\n\\npublic ActionResult Details(int? id) { if (id == null) { return new HttpStatusCodeResult(HttpStatusCode.BadRequest); } Animal animal = db.Animals.Find(id); if (animal == null) { return HttpNotFound(); } return View(animal); }\\n\\npublic ActionResult Create() { return View(); }\\n\\n[HttpPost] [ValidateAntiForgeryToken] public ActionResult Create([Bind(Include=\\\"Id,Name\\\")] Animal animal) { if (ModelState.IsValid) { db.Animals.Add(animal); db.SaveChanges(); return RedirectToAction(\\\"Index\\\"); }\\n\\nreturn View(animal); }\\n\\npublic ActionResult Edit(int? id) { if (id == null) { return new HttpStatusCodeResult(HttpStatusCode.BadRequest); } Animal animal = db.Animals.Find(id); if (animal == null) { return HttpNotFound(); } return View(animal); }\\n\\n[HttpPost] [ValidateAntiForgeryToken] public ActionResult Edit([Bind(Include=\\\"Id,Name\\\")] Animal animal) { if (ModelState.IsValid) { db.Entry(animal).State = EntityState.Modified; db.SaveChanges(); return RedirectToAction(\\\"Index\\\"); } return View(animal); }\\n\\npublic ActionResult Delete(int? id) { if (id == null) { return new HttpStatusCodeResult(HttpStatusCode.BadRequest); } Animal animal = db.Animals.Find(id); if (animal == null) { return HttpNotFound(); } return View(animal); }\\n\\n[HttpPost, ActionName(\\\"Delete\\\")] [ValidateAntiForgeryToken] public ActionResult DeleteConfirmed(int id) { Animal animal = db.Animals.Find(id); db.Animals.Remove(animal); db.SaveChanges(); return RedirectToAction(\\\"Index\\\"); }\\n\\nprotected override void Dispose(bool disposing) { if (disposing) { db.Dispose(); } base.Dispose(disposing); } } \\n\")), mdx(\"p\", null, \"If you want to test rapidly the database, just add the code in the index. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public ActionResult Index() { var animal1 = new Animal { Name = \\\"Boss\\\" }; var cat1 = new Cat { Name = \\\"Mi\\\" }; var cat2 = new Cat { Name = \\\"Do\\\" }; animal1.Enemies = new List<Animal> { cat1,cat2}; db.Animals.Add(animal1); db.Animals.Add(cat1); db.Animals.Add(cat2); db.SaveChanges(); return View(db.Animals.AsNoTracking().ToList()); } \\n\")), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"400px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/patrickdesjardins/static/e4835a3b2cba74ff7b4e127fbbe83d31/e17e5/tablesDataForAssociation-400x309.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"77.33333333333333%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABrElEQVQ4y6WS3Y7aMBBG/f5P1FatelOpF7tSaSk/gYQQEiCQBEISxw4xORXeXYoqVl2xIx2NPZI/e8af8LxH8mzLYAh1bdhlHaOJYbZa0vc8JkGAF4Y4cx8/WvLTdVnGMes4ZrvdkiYJ282GOI6ppER4vsvJtOQ5tK1BVh15YSgbxU5KCqUsB6Uotba1+nik67qbiG/ff5AkKUWZkx8OSFlS1xWyqtB1jVYKrWpqKW3tnKuqoizLm4iHnsNiETKbzXl47PHxwyc+f/lqa8vlivk8IFiEbJOENMtI02ey2whn6pNmO1zPJ4qWljCM2O9z1uuYRRgRRSu0bjidTv9F/BpMOBQF63hDawyX6DqklFfbjreEmLjB5cD1TecPatv2L8Zg3oBw3ICyKHCcKatzi4vQtl3XCqU1Sl2jrvK/6yfE75FLkmaMJj5BtLbekrK2r4TuVXu8apuzoLFtPbVoTPsyNe4J4c5Ce1hrbQWbpkE3jc33IIbjmTX2YDim3x/Y2TXN8X7B/nBqbRNGK7Is470hev0xTaPZ7/cUZXmx0L0Ibx5ZkfOvvkfoRfAPFJeHQQMoenYAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"tablesDataForAssociation 400x309\",\n    \"title\": \"tablesDataForAssociation 400x309\",\n    \"src\": \"/patrickdesjardins/static/e4835a3b2cba74ff7b4e127fbbe83d31/e17e5/tablesDataForAssociation-400x309.png\",\n    \"srcSet\": [\"/patrickdesjardins/static/e4835a3b2cba74ff7b4e127fbbe83d31/5a46d/tablesDataForAssociation-400x309.png 300w\", \"/patrickdesjardins/static/e4835a3b2cba74ff7b4e127fbbe83d31/e17e5/tablesDataForAssociation-400x309.png 400w\"],\n    \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The first step is to create a repository class for animal inside the DataAccessLayer folder. Normally, I create a folder called Repository to have all repositories.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class AnimalRepository : IAnimalRepository { private DatabaseContext db = new DatabaseContext();\\n\\npublic Models.Animal Find(int? id) { return db.Animals.Find(id); }\\n\\npublic void Insert(Models.Animal animal) { db.Animals.Add(animal); db.SaveChanges(); }\\n\\npublic void Update(Models.Animal animal) { db.Entry(animal).State = EntityState.Modified; db.SaveChanges(); }\\n\\npublic void Delete(Models.Animal animal) { db.Animals.Remove(animal); db.SaveChanges(); }\\n\\npublic void Dispose() { db.Dispose(); }\\n\\npublic IList<Animal> GetAll() { return db.Animals.AsNoTracking().ToList(); } } \\n\")), mdx(\"p\", null, \"This class as also an interface with the public method in it.\"), mdx(\"p\", null, \"The second step is to create a service layer. Normally, we would create a new project, but to keep everything simple, let's just add a new folder (namespace). Then, we move the DatabaseContext class from the controller to the service.\"), mdx(\"p\", null, \"The animal service class looks like the following code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class AnimalService: IAnimalService { private IAnimalRepository animalRepository;\\n\\npublic AnimalService(IAnimalRepository animalRepository) { this.animalRepository = animalRepository; }\\n\\npublic Models.Animal Find(int? id) { return this.animalRepository.Find(id); }\\n\\npublic void Insert(Models.Animal animal) { this.animalRepository.Insert(animal); }\\n\\npublic void Update(Models.Animal animal) { this.animalRepository.Update(animal); }\\n\\npublic void Delete(Models.Animal animal) { this.animalRepository.Delete(animal); } public IList<Animal> GetAll() { return this.animalRepository.GetAll(); } } \\n\")), mdx(\"p\", null, \"It's all the code from the controller. Later, some improvement should be done. One of this change is to move the SaveChanges because it's not interesting to save every time we add, modify or update an entity. This cause performance problem when several entities are required to be posted to the database. However, let's focus on the transformation first, later these details will be gone. The role of the service layer is to resemble every repository. In this situation we have only one repository. In fact, in more complex problem like in enterprise, a service has several repository and caching classes.\"), mdx(\"p\", null, \"The next class that require changes is the animal controller class. This one now has a constructor that need an IAnimalService.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class AnimalController : Controller { private IAnimalService_service;\\n\\npublic AnimalController() {_service = new AnimalService(new AnimalRepository()); }\\n\\npublic AnimalController(IAnimalService animalService) {_service = animalService; }\\n\\npublic ActionResult Index() { return View(_service.GetAll()); }\\n\\npublic ActionResult Details(int? id) { if (id == null) { return new HttpStatusCodeResult(HttpStatusCode.BadRequest); } Animal animal =_service.Find(id); if (animal == null) { return HttpNotFound(); } return View(animal); }\\n\\npublic ActionResult Create() { return View(); }\\n\\n[HttpPost] [ValidateAntiForgeryToken] public ActionResult Create([Bind(Include=\\\"Id,Name\\\")] Animal animal) { if (ModelState.IsValid) {_service.Insert(animal); return RedirectToAction(\\\"Index\\\"); }\\n\\nreturn View(animal); }\\n\\npublic ActionResult Edit(int? id) { if (id == null) { return new HttpStatusCodeResult(HttpStatusCode.BadRequest); } Animal animal =_service.Find(id); if (animal == null) { return HttpNotFound(); } return View(animal); }\\n\\n[HttpPost] [ValidateAntiForgeryToken] public ActionResult Edit([Bind(Include=\\\"Id,Name\\\")] Animal animal) { if (ModelState.IsValid) {_service.Update(animal); return RedirectToAction(\\\"Index\\\"); } return View(animal); }\\n\\npublic ActionResult Delete(int? id) { if (id == null) { return new HttpStatusCodeResult(HttpStatusCode.BadRequest); } Animal animal =_service.Find(id); if (animal == null) { return HttpNotFound(); } return View(animal); }\\n\\n[HttpPost, ActionName(\\\"Delete\\\")] [ValidateAntiForgeryToken] public ActionResult DeleteConfirmed(int id) { Animal animal =_service.Find(id);_service.Delete(animal); return RedirectToAction(\\\"Index\\\"); } } \\n\")), mdx(\"p\", null, \"At this stage, the controller is separated from the database by the service and the repository. Still, it's better to not having a strong reference to AnimalService inside the controller. This is why we will extract an interface from AnimalService and we will inject the concrete class by inversion of control. This allow us to have when doing test entry point to inject a fake AnimalService that won't goes to the database. You can use the refactoring tool to extract the interface easily.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"400px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/patrickdesjardins/static/b8c36cd7347efec83fb8e214bdd42eb5/e17e5/ExtractInterface-400x281.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"70.33333333333334%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACQUlEQVQ4y4WSaY+bMBRF+f8/bdpOZzJbQth3MLZZAtmAU+FJR21VKZaOjPhwfd+9zxL9iVKnxMkjXvREJbf0ncNl9Dgd3C+Ohz1KFVRyQKiBbphoDxdUe6IUHUXd0/ZHrPZ4ZjgOZFmM7TrESURVV5S1QGqFbBSq0dS6xo8FH17Pj/fPO60hKGY2tmazbwnzAUtJTV4qtl7D95eMb5uUF1viJiOFhri8EhaXz++0IAo3vL09YO9+0DYRsvbY2z/xvWeESLDadkS3A1E+8OHWBidq2XoKL+mpmoVSz4gW0qwiCF32rsNuvyMvU4QscTyHIPIpRYU1z9B0J2xf8vAc8vyR46cDdtAQZCOpuJgHnLjDizVeJLE9wc4tCbOOXBxxQokbapOvpdSJNFd4ccOHK3HjjqrBIJp15CNbT7ILWmo9ADOwGJZlYp6vn/+WmWWZseI4wPVTbF/x8BSw2RYUajason56wA4bCrVQ65H1LMtygxvLF9blMqObE0F64G0veLErouL05TLMR+PQz0akEVz+EvgXq22vSLXmoHl6z3CijkRcKPViXK4Z+mmPmxyoZP+Pw/8IxlFAUSrT8rsjzIh5fSUTlz8EDyTiahb6ruD5PCHq3pTiJ71ZzqgYTRm5nEjKE0E+ktbTrZQ7gl03kWbajJzWV7NvpcaMLG4Zrs1ncr6VcifDwHcpSo0btaaUVeh3fuudiStJdTYOK3m473CaJrr+jO0LHl8jXnc5b/uCl22GHUjiYjC4cUu52r8j+AuORSW7qVr4rwAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"ExtractInterface 400x281\",\n    \"title\": \"ExtractInterface 400x281\",\n    \"src\": \"/patrickdesjardins/static/b8c36cd7347efec83fb8e214bdd42eb5/e17e5/ExtractInterface-400x281.png\",\n    \"srcSet\": [\"/patrickdesjardins/static/b8c36cd7347efec83fb8e214bdd42eb5/5a46d/ExtractInterface-400x281.png 300w\", \"/patrickdesjardins/static/b8c36cd7347efec83fb8e214bdd42eb5/e17e5/ExtractInterface-400x281.png 400w\"],\n    \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public interface IAnimalService { void Delete(Animal animal); Animal Find(int? id); IList<Animal> GetAll(); void Insert(Animal animal); void Update(Animal animal); } \\n\")), mdx(\"p\", null, \"Inside the controller, we have two constructors. One to help us for this example which instantiate the service layer and the real one that takes a single parameter. This is the one that you should have in your enterprise grade software because it can inject any thing of IAnimalService into the controller.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class AnimalController : Controller { private IAnimalService_service;\\n\\npublic AnimalController(IAnimalService animalService) {_service = animalService; } //... \\n\")), mdx(\"p\", null, \"Before implementing the unit of work, we will create a new repository to illustrate why the unit of work is required. We will also do a little re-factoring by changing the repository to stop having automatically a call to SaveChanges. This allow us to insert several entities in a single transaction.\"), mdx(\"p\", null, \"This is now the animal service class and interface.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public interface IAnimalService { void Delete(Animal animal); void Delete(IList<Animal> animals); Animal Find(int? id); IList<Animal> GetAll(); void Save(Animal animal); void Save(IList<Animal> animal); } public class AnimalService: IAnimalService { private IAnimalRepository animalRepository;\\n\\npublic AnimalService(IAnimalRepository animalRepository) { this.animalRepository = animalRepository; }\\n\\npublic Models.Animal Find(int? id) { return this.animalRepository.Find(id); }\\n\\npublic void Delete(IList<Animal> animals) { foreach (var animal in animals) { this.animalRepository.Delete(animal); } this.animalRepository.Save(); }\\n\\npublic void Delete(Models.Animal animal) { this.Delete(new List<Animal> { animal }); }\\n\\npublic IList<Animal> GetAll() { return this.animalRepository.GetAll(); }\\n\\npublic void Save(Animal animal) { Save(new List<Animal> { animal }); }\\n\\npublic void Save(IList<Animal> animals) { foreach (var animal in animals) { if (animal.Id == default(int)) { this.animalRepository.Insert(animal); } else { this.animalRepository.Update(animal); } }\\n\\nthis.animalRepository.Save(); } }\\n\\n\\n\")), mdx(\"p\", null, \"As you can see, it's better. It also hide the complexity for update and insert by having a single method \\\"save\\\". Next, we will create a new repository. We won't code its detail but we will use it inside the AnimalService to simulate a case where we need to interact on several entities.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class HumanRepository : IHumanRepository { } public interface IHumanRepository { void Insert(Models.Human humain); } \\n\")), mdx(\"p\", null, \"We also need to modify the service to have in its constructor the IHumanRepository.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class AnimalService: IAnimalService { private IAnimalRepository animalRepository; private IHumanRepository humanRepository;\\n\\npublic AnimalService(IAnimalRepository animalRepository, IHumanRepository humanRepository) { this.animalRepository = animalRepository; this.humanRepository = humanRepository; } //... } \\n\")), mdx(\"p\", null, \"Then we can simulate the need to have something in the same transaction between animal and human repository. This can be in the Save method of the AnimalService. Let's create a new save method in the service which take an Animal and also an Human. In IAnimalService we add.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" void SaveAll(Animal animal, Human humain); \\n\")), mdx(\"p\", null, \"And in the concrete implementation we have :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public void SaveAll(Animal animal, Human humain) { this.animalRepository.Insert(animal); this.humanRepository.Insert(humain); } \\n\")), mdx(\"p\", null, \"This is where the unit of work is required. The animal repository has its own DbContext and the human repository has its one two. Since both have not the same repository, they are in two different transaction. We could wrap these both lines with a TransactionScope but since Entity Framework is already a transaction scope and since in more complex scenario where we would want to use the DbContext furthermore, having to use the same DbContext is something viable.\"), mdx(\"h2\", null, \"Implementing Unit of Work pattern\"), mdx(\"p\", null, \"As we have seen, we need to share the DbContext. This is where the unit of work shines. The first move is to create the unit of work which hold the DbContext.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public interface IUnitOfWork { IDbSet<T> Set<T>() where T:class;\\n\\nDbEntityEntry<T> Entry<T>(T entity) where T:class;\\n\\nvoid SaveChanges(); } \\n\")), mdx(\"p\", null, \"The interface could be richer but this should be the minimal number of methods. The implementation is only having a central point for every database sets. In a more domain driven design application we could restrain entities by having a DbContext that is less general than the one created. \\\"AllDomainContext\\\" contains all entities set. This is perfect to create the whole database or when your application has a limited number of entities (under 50). But if you are domain driven design or with a big application, to have Entity Framework perform well and restrict the domains, having several DbContext is a good solution. With unit of work and its generic T class, you can pass any domain you want to have.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class UnitOfWork<T>:IUnitOfWork where T : DbContext, new() { public UnitOfWork() { DatabaseContext = new T(); }\\n\\nprivate T DatabaseContext { get; set; }\\n\\npublic void SaveChanges() { DatabaseContext.SaveChanges(); }\\n\\npublic System.Data.Entity.IDbSet<T> Set<T>() where T : class { return DatabaseContext.Set<T>(); }\\n\\npublic DbEntityEntry<T> Entry<T>(T entity) where T : class { return DatabaseContext.Entry<T>(entity); } } \\n\")), mdx(\"p\", null, \"This unit of work is very general since it can takes T as set. This mean that any entity defined can be used. In our example, with this modified unit of work, the controller needs to be changed too.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class AnimalController : Controller { private IAnimalService_service;\\n\\npublic AnimalController() { var uow = new UnitOfWork<AllDomainContext>();_service = new AnimalService(uow, new AnimalRepository(uow), new HumanRepository(uow)); } public AnimalController(IAnimalService animalService) {_service = animalService; } //... } \\n\")), mdx(\"p\", null, \"So, the unit of work is instantiated with the domain we want. Here, it's everything. We still have the \\\"real\\\" constructor that takes only the IAnimalService which is the one that should be used in the real application with inversion of control to inject the controller. Since it's an article, to keep it simple, I show you what the IoC should do in the background.\"), mdx(\"p\", null, \"The animal service is changed too to work with the unit of work. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class AnimalService: IAnimalService { private IAnimalRepository animalRepository; private IHumanRepository humanRepository; private IUnitOfWork unitOfWork; public AnimalService(IUnitOfWork unitOfWork, IAnimalRepository animalRepository, IHumanRepository humanRepository) { this.unitOfWork = unitOfWork; this.animalRepository = animalRepository; this.humanRepository = humanRepository; }\\n\\npublic Animal Find(int? id) { return this.animalRepository.Find(id); }\\n\\npublic void Delete(IList<Animal> animals) { foreach (var animal in animals) { this.animalRepository.Delete(animal); }\\n\\nthis.unitOfWork.SaveChanges(); }\\n\\npublic void Delete(Models.Animal animal) { this.Delete(new List<Animal> { animal }); }\\n\\npublic IList<Animal> GetAll() { return this.animalRepository.GetAll(); }\\n\\npublic void Save(Animal animal) { Save(new List<Animal> { animal }); }\\n\\npublic void Save(IList<Animal> animals) { foreach (var animal in animals) { if (animal.Id == default(int)) { this.animalRepository.Insert(animal); } else { this.animalRepository.Update(animal); } }\\n\\nthis.unitOfWork.SaveChanges(); }\\n\\npublic void SaveAll(Animal animal, Human humain) { this.animalRepository.Insert(animal); this.humanRepository.Insert(humain); this.unitOfWork.SaveChanges(); } } \\n\")), mdx(\"p\", null, \"The repository now accepts the unit of work. It can works with set defined in the domain without problem.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class AnimalRepository : WebsiteForUnitOfWork.DataAccessLayer.Repositories.IAnimalRepository { private IUnitOfWork UnitOfWork { get; set; }\\n\\npublic AnimalRepository(IUnitOfWork unitOfWork) { this.UnitOfWork = unitOfWork; }\\n\\npublic Models.Animal Find(int? id) { return UnitOfWork.Set<Animal>().Find(id); }\\n\\npublic void Insert(Models.Animal animal) { UnitOfWork.Set<Animal>().Add(animal); }\\n\\npublic void Update(Models.Animal animal) { UnitOfWork.Entry(animal).State = EntityState.Modified; }\\n\\npublic void Delete(Models.Animal animal) { UnitOfWork.Set<Animal>().Remove(animal); }\\n\\npublic IList<Animal> GetAll() { return UnitOfWork.Set<Animal>().AsNoTracking().ToList(); } } \\n\")), mdx(\"p\", null, \"It's possible to continue to improve the unit of work and Entity Framework by going further in the use of the repository. But, what have been shown here is enterprise graded repository design. It allows you to divide the domain and improve the performance of Entity Framework by the same time. It allows to have an abstraction between the Asp.Net MVC front and the Entity Framework. It easily testable because we use interface which can be mocked easily. Benefits are clear but the price to pay is the overwhelm required to support this infrastructure. More classes need to be in place. Still, the version presented is light and once the setup is done, adding new entity is only a matter of editing the context in which it belongs and create into the repository what action is needed.\"), mdx(\"h2\", null, \"Source code\"), mdx(\"p\", null, \"You can find the source code on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/WebsiteForUnitOfWork\"\n  }, \"GitHub for this Unit of work example\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"b36f9db6-fdac-5528-a5fb-618a34e15e29","slug":"2013/entity-framework-and-the-unit-of-work-pattern","__params":{"slug":"2013"}}},
    "staticQueryHashes": ["3159585216"]}