{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2013/how-to-register-area-without-having-to-specify-them-all-in-the-global-asax-cs/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to register Area without having to specify them all in the global.asax.cs","date":"August 12, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to register Area without having to specify them all in the global.asax.cs\",\n  \"date\": \"2013-08-12\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When you go into an existing project you have two possibilities. The first possibility is that every area are registered into the global asax, or with Mvc4 in the routing class that the global.asax call. The second possibility is to use AreaRegistration class and have 1 class inherit this class per area.\"), mdx(\"p\", null, \"The first solution is simple, fast and it's suitable for a small project (rule of thumb: less than 5 areas). What you need is to add a new entry into routes.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" protected void Application_Start() { RegisterRoutes(RouteTable.Routes); }\\n\\npublic static void RegisterRoutes(RouteCollection routes) { routes.MapRootArea(\\\"{area}/{controller}/{action}/{id}\\\", \\\"RouteNameHere\\\", new { area=\\\"area1\\\", controller = \\\"controller1\\\", action = \\\"action1\\\", id = \\\"\\\" }); } \\n\")), mdx(\"p\", null, \"The second solution require two steps. The first step is to tell the framework to auto register a specific type of class for routing, and the second step is to define one class per area for configuration purpose.\"), mdx(\"p\", null, \"Step1: Inside Global.asax.cs \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" protected void Application_Start() { AreaRegistration.RegisterAllAreas(); } \\n\")), mdx(\"p\", null, \"Step2: Inside every folders of every area you have create a class that inherit from AreaRegistration \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class MyArea_AreaRegistration : AreaRegistration { public override string AreaName { get { return \\\"MyArea\\\"; } }\\n\\npublic override void RegisterArea(AreaRegistrationContext context) { const string nameSpace = \\\"MyNameSpaceForThisArea\\\"; const string areaName = \\\"MyAreaName\\\"; const string defautlRouteUrl = areaName + \\\"/{controller}/{action}/{id}\\\";\\n\\nvar defaultRouteValueDictionary = new RouteValueDictionary(new { action = \\\"Index\\\", id = UrlParameter.Optional });\\n\\nvar dataTokensDictionary = new RouteValueDictionary(new { Namespaces = nameSpace, area = areaName, UseNamespaceFallback = false });\\n\\ncontext.Routes.Add(string.Format(\\\"{0}_Default\\\", areaName), new Route(defautlRouteUrl, defaultRouteValueDictionary, dataTokensDictionary, new MvcRouteHandler())); } } \\n\")), mdx(\"p\", null, \"Few things are important. First, you shouldn't copy and paste that code in all your classes. The namespace and area will change but every other lines remain the same across all areas. Be wise and encapsulate the logic in a reusable place. Second, the new MvcRouteHandler() will be most of the time something that you will inherit from because you could set over there some specification over localization. For example, you may want to have /fr/ which if available change the current thread to the language specified in the url.\"), mdx(\"p\", null, \"The override in the example above is more complex that it should be if you do not have a custom RouteHandler. In fact, you could use this simple 1 liner:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" context.Routes.MapRoute(\\\"DefaultRouteForAreaXYZ\\\" , \\\"AreaXYZ/{controller}/{action}/{id}\\\" , new { controller=\\\"Home\\\" , action=\\\"index\\\" , id= UrlParameter.Optional } ); \\n\")), mdx(\"p\", null, \"Perhaps it's simpler, but you won't have the leverage of controlling every aspect of the routing, which is viable for project where you do not need to parse the routing for additional features.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"d272cdd2-20dc-5ffc-8a10-91ed35b4bebf","slug":"2013/how-to-register-area-without-having-to-specify-them-all-in-the-global-asax-cs","__params":{"slug":"2013"}}},
    "staticQueryHashes": ["3159585216"]}