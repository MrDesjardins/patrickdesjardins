{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/javascript-fibonnaci-recursive-with-memoizer-and-iterative",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Fibonnaci Recursive, with Memoizer and Iterative","date":"September 18, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Fibonnaci Recursive, with Memoizer and Iterative\",\n  \"date\": \"2017-09-18\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Fibonnaci numbers are a sequence of number that keep adding from previous result. It's a common problem that can be resolve with few lines of code by using recursivity. The formula is F(x) = F(n-1) + F(n-1). The following code is a basic Fibonnaci implemented with a recursive loop.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function fib(x) {\\n  if (x <= 0) {\\n    return 0;\\n  }\\n  if (x == 1 || x == 2) {\\n    return 1;\\n  } else {\\n    return fib(x - 1) + fib(x - 2);\\n  }\\n}\\n\\nconsole.log(\\\"10:\\\" + fib(10));\\n\")), mdx(\"p\", null, \"We can use a closure to keep in memory previous value. This increase the speed since you do not have to compute many time the same function. However, this solution will grow your memory consumption.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var fibMemoize = (function () {\\n  var memoize = [0, 1, 1];\\n  var innerFib = function (x) {\\n    var resultFromMemoize = memoize[x];\\n    if (resultFromMemoize === undefined) {\\n      memoize[x] = innerFib(x - 1) + innerFib(x - 2);\\n      return memoize[x];\\n    } else {\\n      return resultFromMemoize;\\n    }\\n  };\\n  return innerFib;\\n})();\\n\\nconsole.log(\\\"10:\\\" + fibMemoize(10));\\n\")), mdx(\"p\", null, \"It's also possible to implement an iterative version of Fibonnaci. We do not need to keep an array since we won't compute more than once every possibility (we do not have a branch of n-1 and n-2). In that case, what we do is always keeping the n-2 and n-1 result in a variable and keep swapping the value while iterating to the number desired.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function fibIterative(x) {\\n  if (x <= 0) {\\n    return 0;\\n  }\\n  var n2 = 1;\\n  var n1 = 1;\\n  for (var i = 2; i < x - 1; i++) {\\n    var newValue = n2 + n1;\\n    n2 = n1;\\n    n1 = newValue;\\n  }\\n  return n2 + n1;\\n}\\n\\nconsole.log(\\\"10 iterative:\\\" + fibIterative(10));\\n\")), mdx(\"p\", null, \"There is plenty of other solutions, but these three are the basic ones.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"1cf200d3-3499-52de-b816-46b79ca54e7b"}},
    "staticQueryHashes": ["3159585216"]}