{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/access-to-modified-closure-when-having-a-linq-inside-a-loop",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Access to modified closure when having a Linq inside a loop","date":"December 20, 2011"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Access to modified closure when having a Linq inside a loop\",\n  \"date\": \"2011-12-20\",\n  \"categories\": [\"linq\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you have Resharper, you can see sometime a warning saying that you \\\"Access to modified closure\\\". If you do not have it, you can still have odd behavior something with the values. In both case, this mean that Linq is accessing a value that might (or not) be modified.\"), mdx(\"p\", null, \"Linq execute delegate functions. If you try :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var listInteger = new List<int>() { 1, 2, 3, 4, 5 }; //Values\\n\\nvar funcs = new List<Func<int>>(); //Delegate function that take a Integer as parameter\\n\\nforeach(var v in listInteger) // Add in the list of delegate's functions a function that return the integer value { funcs.Add( ()=>v ); } foreach(var f in funcs) //Execute functions which should just return the value. { Console.WriteLine(f()); // We expect here to have 1,2,3,4,5 } \\n\")), mdx(\"p\", null, \"You wull not see 1,2,3,4,5 but 5,5,5,5,5. The reason is that is access a modified variable. The function is not adding the value of v but the pointer to it. This is why it remains on the last value of the loop. But, by using a variable inside the loop, the pointer is to this variable and directly to the good value.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"var listInteger = new List<int>() { 1, 2, 3, 4, 5 }; //Values\\n\\nvar funcs = new List<Func<int>>(); //Delegate function that take a Integer as parameter\\n\\nforeach(var v in listInteger) // Add in the list of delegate's functions a function that return the integer value \\n{ \\n  var vv = v; funcs.Add( ()=>vv ); \\n} \\nforeach(var f in funcs) //Execute functions which should just return the value. \\n{ \\n  Console.WriteLine(f()); // We expect here to have 1,2,3,4,5 \\n} \\n\")), mdx(\"p\", null, \"Most of the time, no body will feel this problem because most of the time the Linq won't execute delegate function defined somewhere else but an anonymous function that call directly the value of the variable. But, as a good practice, it's always better when accessing variable that may be changed to create a temporary variable to remove the undesired effect.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"3d676207-89e3-5216-aac1-abae90408236","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}