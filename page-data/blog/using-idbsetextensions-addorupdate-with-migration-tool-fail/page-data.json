{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/using-idbsetextensions-addorupdate-with-migration-tool-fail",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Using IDbSetExtensions.AddOrUpdate with Migration Tool fail","date":"February 25, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Using IDbSetExtensions.AddOrUpdate with Migration Tool fail\",\n  \"date\": \"2013-02-25\",\n  \"categories\": [\"asp-mvc\", \"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IDbSetExtensions.AddOrUpdate\"), \" with Migration Tool fail if you are using a custom \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IDbSet\"), \".\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Unable to call public, instance method AddOrUpdate on derived IDbSet type 'DataAccessLayer.Database.FilteredDbSet`1\", \"[Model.Workout]\", \"'. Method not found.\")), mdx(\"p\", null, \"The exception above is raised when using : \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"PM> update-database -verbose -force\"), \". The class \", mdx(\"em\", {\n    parentName: \"p\"\n  }, mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"FilteredDbSet\")), \", inherit \", mdx(\"em\", {\n    parentName: \"p\"\n  }, mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"IDbSet\")), \" and should be able to use the method AddOrUpdate which is pretty useful when seeding data. But, the exception raise and the reason is that it try to get the method definition with a parameter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static void AddOrUpdate<TEntity>(this IDbSet<TEntity> set, params TEntity[] entities) where TEntity : class { RuntimeFailureMethods.Requires(set != null, (string) null, \\\"set != null\\\"); RuntimeFailureMethods.Requires(entities != null, (string) null, \\\"entities != null\\\"); DbSet<TEntity> set1 = set as DbSet<TEntity>; if (set1 != null) { InternalSet<TEntity> internalSet = (InternalSet<TEntity>) set1.InternalSet; IDbSetExtensions.AddOrUpdate<TEntity>(set1, IDbSetExtensions.GetKeyProperties<TEntity>(typeof (TEntity), internalSet), entities); } else { Type type = set.GetType(); MethodInfo method = type.GetMethod(\\\"AddOrUpdate\\\", new Type[1] { typeof (TEntity[]) }); if (method == (MethodInfo) null) throw System.Data.Entity.Resources.Error.UnableToDispatchAddOrUpdate((object) type); method.Invoke((object) set, (object[]) new TEntity[1][] { entities }); } } \\n\")), mdx(\"p\", null, \"Instead, we will call the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"GetMethod\")), \" without the second parameter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static void AddOrUpdate<TEntity>(this IDbSet<TEntity> set, params TEntity[] entities) where TEntity : class { var set1 = set as DbSet<TEntity>; if (set1 != null) { System.Data.Entity.Migrations.IDbSetExtensions.AddOrUpdate(set,entities); } else { Type type = set.GetType(); MethodInfo method = type.GetMethod(\\\"AddOrUpdate\\\");\\n\\nif (method == null) throw new Exception(\\\"\\\"); var data = new object[entities.Length]; for (int i = 0; i < entities.Length; i++) { data[i] = entities[i]; } method.Invoke(set, data); } } \\n\")), mdx(\"p\", null, \"Also, you can see that we call Invoke by passing a single array of object. This is required to be able to call the method correctly.\"), mdx(\"p\", null, \"The trick is to create the extension and to use it instead of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"IDbSetExtension\")), \" and you will be able to\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"8a2c9a14-3613-55d8-ab4f-29f60a5c4392","totalPages":69}},
    "staticQueryHashes": ["3159585216"]}