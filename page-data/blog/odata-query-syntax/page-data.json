{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/odata-query-syntax",
    "result": {"data":{"mdx":{"frontmatter":{"title":"OData Query syntax","date":"July 25, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"OData Query syntax\",\n  \"date\": \"2013-07-25\",\n  \"categories\": [\"odata\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you have setup WCF Data Service, you can now query your service with the OData syntax. If you are using Entity Framework, you will see a lot of similarity between Entity Framework and this string syntax. OData works with http request which is based on URI. Every queries statements need to be passed by this url. Here is a list of all possibles statement that can be used together as Entity Framework or a SQL statement.\"), mdx(\"h2\", null, \"OData ordering keyword : orderby\"), mdx(\"p\", null, \"If you request one of your entity set, you may want to order the result. To be able to order, you will have to user \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"orderby\"), \" with = and the property of the entity. If you need multiply properties in your ordering, simply seperate them with a comma \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \",\"), \". Here is two examples.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"http://yourwebsite/YourService.svc/YourEntitiesSet?$orderby=OneOfYourProperty\\n\\nhttp://yourwebsite/YourService.svc/YourEntitiesSet?$orderby=OneOfYourProperty,ASecondProperty \\n\")), mdx(\"h2\", null, \"OData getting a limited amount of data keyword : top\"), mdx(\"p\", null, \"This is the same keyword as Sql Server or Entity Framework. This let the consumer to ask to the WCF Data Service how many result maximum the consumer receive. It can be the specific number or less, or none. Here is an example.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" http://yourwebsite/YourService.svc/YourEntitiesSet?$top=10 \\n\")), mdx(\"h2\", null, \"OData paging result keyword : skip\"), mdx(\"p\", null, \"You can do paging with OData. For example, if you want to have a list that display 10 elements per page, you could request the WCF Data Service to get the first 10 entities and then ask the next 10 entities when the user request the next page. This can be done with the previous keyword \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"top\"), \" to get the 10 entities but to get which group of 10, we need to new keyword \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"skip\"), \". If you want to have the third page of 10 elements, we will need to use skip with the value 20 and the top at 10. This can be translated by : \\\"I want the third page of 10 elements\\\". The value of skip is 20 because we have 10 elements by page. One page mean we display 10, two pages mean we display 20. The third page requires to skip those 20 pages and to display the next 10. This is specify with the top keyword.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" http://yourwebsite/YourService.svc/YourEntitiesSet?$skip=20&$top=10 \\n\")), mdx(\"h2\", null, \"Condition with OData by the filter keyword\"), mdx(\"p\", null, \"In SQL, we would use the keyword \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"where\"), \" and the keyword \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"and\"), \" if we have multiple conditions. It's the samething with Entity Framework. But, with OData, the keyword is not where. The keyword is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"filter\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" http://yourwebsite/YourService.svc/YourEntitiesSet?$filter=YourProperty equal('Test') \\n\")), mdx(\"p\", null, \"OData contains several keyword to compare : \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://go.microsoft.com/fwlink/?LinkId=186972\"\n  }, \"http://go.microsoft.com/fwlink/?LinkId=186972\")), mdx(\"h2\", null, \"Joining entity with the keyword expand\"), mdx(\"p\", null, \"Entity Framework gives the keyword \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"include\"), \" which add a reference to an other entity or a list of entities. You need to specify the name of the property and this one will be loaded in the foreign key that define the relationship in the database. With OData, the keyword is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"expand\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" http://yourwebsite/YourService.svc/YourEntitiesSet?$expand=YourPropertyThatLinkToAnOtherEntity \\n\")), mdx(\"h2\", null, \"Selecting specify properties of an entity with the OData keyword select\"), mdx(\"p\", null, \"This is exactly the same as SQL and Entity. As you can see since the beginning of this article, a lot of keyword in OData are the same with Entity and SQL. This is a strong positive point that give a low learning curl. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"select\"), \" keyword give you the posibility to not returning the whole entity information but only specific property of this one.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" http://yourwebsite/YourService.svc/YourEntitiesSet?$select=Property1,Property2 \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"766db8b5-490c-5e17-9023-74e6541a91a6","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}