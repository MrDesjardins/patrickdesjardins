{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/linq-to-sql-cache",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Linq to Sql and Entity Framework cache","date":"September 25, 2011"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Linq to Sql and Entity Framework cache\",\n  \"date\": \"2011-09-25\",\n  \"categories\": [\"entity-framework\", \"linq-to-sql\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Linq to Sql has a caching system that rely on the primary key of each object. Inside the data context, an identity map keep the value of the retrieved data. Every thing is handled by the data context and you have to worry about nothing. Keep in mind that if someone else change the value that the cache won't be refreshed.\"), mdx(\"p\", null, \"If you change the data on your side, the cache won't also be updated. This can be problematic in some situation. If this behavior is not what you want, you can disable the caching feature of Linq to Sql with a property of the data context.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"myDataContext.ObjectTrackingEnabled = false; \\n\")), mdx(\"p\", null, \"Or, you can refresh specific object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" myDataContext.Refresh(RefreshMode.OverwriteCurrentValues, myObjectToRefresh); \\n\")), mdx(\"p\", null, \"The reason behind this technical choice is that initially it has been developed for performance on consecutive call of the same object. The goal is not the have a real caching system.\"), mdx(\"p\", null, \"To conclude, the title mentions Entity Framework and I haven't say anything about it yet. The reason is that Entity Framework react the same way as Linq to Sql for the cache.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"4563ee81-187c-5ba4-85fc-3cd922f363a8","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}