{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/localized-url-with-asp-net-mvc",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Localized URL with Asp.Net MVC with Traversal Feature","date":"May 16, 2016"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Localized URL with Asp.Net MVC with Traversal Feature\",\n  \"date\": \"2016-05-16\",\n  \"categories\": [\"asp-mvc\", \"asp-net\"],\n  \"tags\": [\"route\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I already wrote \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./how-to-localized-mvc-routing-with-area-without-specifying-local-in-the-url-with-a-fluent-api\"\n  }, \"how to have URL in multiple languages in Asp.Net MVC\"), \" without having to specify the language in the URL. I then, shown \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./improve-the-custom-localized-mvc-routing-with-fluent-api\"\n  }, \"how to configure the routing with a Fluent Api\"), \" to help creating routing. In this article, I have an improved version of the previous code.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Routing Traversal with the Visitor Pattern\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mirror Url Support\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Add Routing for Default Domain Url\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Associate Controller to a Specific NameSpace\")), mdx(\"h3\", null, \"Routing Traversal with the Visitor Pattern\"), mdx(\"p\", null, \"The biggest improvement from the last article is the possibility to traversal the whole routing tree to search a specific route. While the solution works with Asp.Net MVC by hooking easily with the AreaRegistrationContext and RouteCollection, you may want to traverse to get the translated Url in project outside the web project. In any case, the new solution let you traverse easily with different logic without the need to change anything. The secret resides in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Visitor Pattern\"), \". Route classes accept a visitor where logic can be executed. Here is an example of a concrete visitor that get the localized url from an area, controller and action.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" // Arrange var visitor = new RouteLocalizedVisitor(LocalizedSection.EN, Constants.Areas.MODERATOR, \\\"Symbol\\\", \\\"SymbolChangeList\\\", null, null);\\n\\n// Act RoutesArea.AcceptRouteVisitor(visitor);\\n\\n// Assert var result = visitor.Result().FinalUrl(); Assert.AreEqual(\\\"Moderation/Symbol-en/Symbol-Change-List\\\",result); \\n\")), mdx(\"p\", null, \"How is this possible? By having 2 interfaces. One is for every element (Area, controller, action, list of area, list of controller, list of action) and one interface for the visitor.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" /// <summary> /// A route element is an Area, a Controller, an Action or a list of all these threes. /// </summary> public interface IRouteElement { /// <summary> /// Entry point for the visitor into the element /// </summary> /// <param name=\\\"visitor\\\"></param> void AcceptRouteVisitor(IRouteVisitor visitor); }\\n\\n/// <summary> /// A visitor is the code that will traverse the configuration (tree) of routes. /// </summary> public interface IRouteVisitor { /// <summary> /// Logic to be done by the visitor when this one visit an Area /// </summary> /// <param name=\\\"element\\\"></param> /// <returns>True if has found a route that match the area criteria</returns> bool Visit(AreaSectionLocalized element);\\n\\n/// <summary> /// Logic to be done by the visitor when this one visit a Controller /// </summary> /// <param name=\\\"element\\\"></param> /// <returns>True if has found a route that match the controller criteria</returns> bool Visit(ControllerSectionLocalized element);\\n\\n/// <summary> /// Logic to be done by the visitor when this one visit an Action /// </summary> /// <param name=\\\"element\\\"></param> /// <returns>True if has found a route that match the actopm criteria</returns> bool Visit(ActionSectionLocalized element);\\n\\n/// <summary> /// Flag to indicate that a route has been found and that subsequent visits call be cancelled. /// This is to improve performance. /// </summary> bool HasFoundRoute { get; } } \\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IRouteElement\"), \" interface is the entry point to start traversing the route's tree. It's also this interface used to move from one node to another one. This interface is implemented by every nodes (Area, controller, action, list of area, list of controller, list of action). The consumer of the fluent Api shouldn't care else than knowing that this is where he will pass its visitor. For the curious, here is the implementation on the Controller.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public void AcceptRouteVisitor(IRouteVisitor visitor) { if (visitor.Visit(this)) { foreach (var action in this.ActionTranslations) { action.AcceptRouteVisitor(visitor); if (visitor.HasFoundRoute) { break; } } } } \\n\")), mdx(\"p\", null, \"The implementation is very similar for Area. What is does is that it allow the visitor to visit the controller node, if this one is matching (controller name), then it visits every children (actions) of the controller. To improve the performance, the loop is stopped if an action is found has a good one. The most interesting part is how to create a visitor. The visitor is the one that get called by the tree on every \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AcceptRouteVisitor\"), \". The visitor is the one having the logic of what you want to do. Here is the full code to get a localized route.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" /// <summary> /// Visitor to find from generic information a localized route from an three of routes /// </summary> public class RouteLocalizedVisitor: IRouteVisitor { private readonly CultureInfo culture; private readonly string area; private readonly string controller; private readonly string action; private readonly string[] urlInput; private readonly string[] tokens; private readonly RouteReturn result;\\n\\n/// <summary> /// /// </summary> /// <param name=\\\"culture\\\">Culture used for the route to Url convertion</param> /// <param name=\\\"area\\\">Area requested. Can be null.</param> /// <param name=\\\"controller\\\">Controller requested. This cannot be null.</param> /// <param name=\\\"action\\\">Action requested. This cannot be null</param> /// <param name=\\\"urlInput\\\">Specific input. Can be null.</param> /// <param name=\\\"tokens\\\">Custom localized token. Can be null.</param> public RouteLocalizedVisitor(CultureInfo culture, string area, string controller, string action, string[] urlInput, string[] tokens) { if (controller == null) { throw new ArgumentNullException(nameof(controller)); } if (action == null) { throw new ArgumentNullException(nameof(action)); } this.culture = culture; this.area = area; this.controller = controller; this.action = action; this.urlInput = urlInput; this.tokens = tokens; this.result = new RouteReturn(); }\\n\\n/// <summary> /// Visitor action for area. If the area match, the result is updated with the localized area name /// </summary> /// <param name=\\\"element\\\">Area visited</param> /// <returns>True if found; False if not found</returns> public bool Visit(AreaSectionLocalized element) { if (element.AreaName == this.area) { this.result.UrlParts[Constants.AREA] = element.Translation.First(d => d.CultureInfo.Name == this.Culture.Name).TranslatedValue; return true; } else { return false; } }\\n\\n/// <summary> /// Visitor action for controller. If the controller match, the result is updated with the localized controller name /// </summary> /// <param name=\\\"element\\\">Controller visited</param> /// <returns>True if found; False if not found</returns> public bool Visit(ControllerSectionLocalized element) { if (element.ControllerName == this.controller) { this.result.UrlParts[Constants.CONTROLLER] = element.Translation.First(d => d.CultureInfo.Name == this.Culture.Name).TranslatedValue; return true; } else { return false; } }\\n\\n/// <summary> /// Visitor action for action. If the action match, the result is updated with the localized action name /// </summary> /// <param name=\\\"element\\\">Action visited</param> /// <returns>True if found; False if not found</returns> public bool Visit(ActionSectionLocalized element) { var urlPartToAddIfGoodPart = new Dictionary<string, string>(); if (element.ActionName == this.action) { if (!this.ExtractTokens(element, urlPartToAddIfGoodPart)) { return false; }\\n\\nif (!this.ExtractUrlPartValues(element, urlPartToAddIfGoodPart)) { return false; }\\n\\nthis.result.UrlParts[Constants.ACTION] = element.Translation.First(d => d.CultureInfo.Name == this.Culture.Name).TranslatedValue; } else { return false; } this.RemoveOptionalWithDefaultEmpty(element, urlPartToAddIfGoodPart); urlPartToAddIfGoodPart.ToList().ForEach(x => this.result.UrlParts.Add(x.Key, x.Value)); //Merge the result this.result.UrlTemplate = element.Url; this.result.HasFoundRoute = true; return true;\\n\\n}\\n\\n/// <summary> /// Remove optional value by adding this one in the UrlPart with Empty string which make the GetFinalUrl to replace the {xxx} with nothing /// </summary> /// <param name=\\\"element\\\"></param> /// <param name=\\\"urlPartToAddIfGoodPart\\\"></param> private void RemoveOptionalWithDefaultEmpty(ActionSectionLocalized element, Dictionary<string, string> urlPartToAddIfGoodPart) { if (element.Values != null) { var dict = (RouteValueDictionary) element.Values; foreach (var keyValues in dict) { var remove = this.urlInput == null || (this.urlInput != null && this.urlInput.All(f => f != keyValues.Key)); if (remove) { urlPartToAddIfGoodPart[keyValues.Key] = string.Empty; } } } }\\n\\n/// <summary> /// If the user request a url than we let it through (to let the user replace with his value). If not defined in UrlPart, then use default value. /// </summary> /// <param name=\\\"element\\\"></param> /// <param name=\\\"urlPartToAddIfGoodPart\\\"></param> /// <returns></returns> private bool ExtractUrlPartValues(ActionSectionLocalized element, Dictionary<string, string> urlPartToAddIfGoodPart) { //Default Values : check if there, nothing to replace if (this.urlInput != null) { foreach (string input in this.urlInput) { if (element.Url.IndexOf(input, StringComparison.CurrentCultureIgnoreCase) >= 0) { var routeValues = (RouteValueDictionary) element.Values; var isDefinedValue = (routeValues != null) && routeValues.Keys.Contains(input); if (isDefinedValue) { var defaultValue = routeValues[input].ToString(); if (defaultValue == string.Empty) { urlPartToAddIfGoodPart[input] = \\\"{\\\" + input + \\\"}\\\"; } else { urlPartToAddIfGoodPart[input] = defaultValue; } } else { //Default if not empty urlPartToAddIfGoodPart[input] = \\\"{\\\" + input + \\\"}\\\"; } } else { return false; } } } return true; }\\n\\n/// <summary> /// Get localized value for every tokens /// </summary> /// <param name=\\\"element\\\"></param> /// <param name=\\\"urlPartToAddIfGoodPart\\\"></param> /// <returns></returns> private bool ExtractTokens(ActionSectionLocalized element, Dictionary<string, string> urlPartToAddIfGoodPart) { if (this.tokens != null) { if (element.Tokens == null) { return false; } for (int i = 0; i < this.tokens.Length; i++) { if (element.Tokens.ContainsKey(this.tokens[i])) { var tokenFound = element.Tokens[this.tokens[i]]; var tokenTranslation = tokenFound.First(d => d.CultureInfo.Name == this.Culture.Name); urlPartToAddIfGoodPart[this.tokens[i]] = tokenTranslation.TranslatedValue; } else { return false; } } } return true; }\\n\\n/// <summary> /// Indicate if a route has been found. This mean that every condition was met /// </summary> public bool HasFoundRoute { get { return this.result.HasFoundRoute; } }\\n\\npublic CultureInfo Culture { get { return this.culture; } }\\n\\npublic RouteReturn Result() { return this.result; } } \\n``` This code let you specify an area (or not), a controller, an action, expected values to be passed and tokens. If the values has a default value, this one will be used. If the default value is empty, this one is avoided in the url. The token is simply translated. Here is two examples:\\n\\n\\n```csharp\\n public static ControllerSectionLocalizedList RoutesController = FluentLocalizedRoute .BuildRoute() .ForBilingualController(\\\"Account\\\", \\\"Account-en\\\", \\\"Compte\\\") .WithBilingualAction(\\\"Profile\\\", \\\"Profile-en\\\", \\\"Afficher-Profile\\\") .WithDefaultValues(new { username = UrlParameter.Optional }) .WithUrl(\\\"{action}/{username}\\\") .ToList(); [TestMethod] public void GivenARouteToVisit_WhenNoAreaWithDefaultValue_ThenReturnRouteWithoutAreaWithDefaultValue() { // Arrange var visitor = new RouteLocalizedVisitor(LocalizedSection.EN, null, \\\"Account\\\", \\\"Profile\\\", null, null);\\n\\n// Act RoutesController.AcceptRouteVisitor(visitor);\\n\\n// Assert var result = visitor.Result().FinalUrl(); Assert.AreEqual(\\\"Profile-en\\\",result); }\\n\\n[TestMethod] public void GivenARouteToVisit_WhenNoAreaWithDefaultValueSet_ThenReturnRouteWithoutAreaWithDefaultValue() { // Arrange var visitor = new RouteLocalizedVisitor(LocalizedSection.EN, null, \\\"Account\\\", \\\"Profile\\\", new [] {\\\"username\\\"}, null);\\n\\n// Act RoutesController.AcceptRouteVisitor(visitor);\\n\\n// Assert var result = visitor.Result().FinalUrl(); Assert.AreEqual(\\\"Profile-en/{username}\\\", result); } \\n\")), mdx(\"h3\", null, \"Mirror Url Support\"), mdx(\"p\", null, \"Mirror Url is the capability to have more than one Url for a specific route. This is good when you want to have more than a single URL to be associated to a specific action. It's a mirror Url because the real Url won't get affected. It also mean that trying to generate this Url from the route values won't get into that mirror Url but the main one. The change is inside the Fluent Url and it adds in the list of action the mirror Url.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public IRouteBuilderAction_ToListOnlyWithAnd WithMirrorUrl(string url) { this.AddInActionList(); var mirrorAction = new ActionSectionLocalized(this.currentAction.ActionName , this.currentAction.Translation , this.currentAction.Values , this.currentAction.Constraints , url); var s = new RouteBuilderAction(this.currentControllerSection, mirrorAction, this.routeBuilder,this.routeBuilderController); this.currentControllerSection.ActionTranslations.Add(mirrorAction); this.currentAction = mirrorAction; return s; } \\n\")), mdx(\"h3\", null, \"Add Routing for Default Domain Url\"), mdx(\"p\", null, \"This new feature lets having an action related to the root url, the domain one. In short, it set the controller and action as a default value, so, it's not required to be in the Url.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public IRouteBuilderAction_ToListWithoutUrl AddDomainDefaultRoute(string controller, string action) { var controller1 = ForBilingualController(\\\"{controller}\\\", \\\"{controller}\\\", \\\"{controller}\\\"); var action1 = controller1.WithBilingualAction(\\\"{action}\\\", \\\"{action}\\\", \\\"{action}\\\"); var action2 = action1.WithDefaultValues(Constants.CONTROLLER, controller); var action3 = action2.WithDefaultValues(Constants.ACTION, action); var action4 = action3.WithUrl(\\\"{controller}/{action}\\\"); return action4; } \\n\")), mdx(\"h3\", null, \"Associate Controller to a Specific NameSpace\"), mdx(\"p\", null, \"The last modification is to have the possibility to associate a namespace for the controller. This is required if your controller name is used in different namespace to avoid collision. This is also inside the Fluent Api. In short, it add to the controller section a namespace if this one doesn't have one. However, if this one already have a namespace, this one is added.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public IRouteBuilderControllerAndControllerConfiguration AssociateToNamespace(string @namespace) { if (currentControllerSection.NameSpaces == null) { currentControllerSection.NameSpaces = new[] { @namespace }; } else { var currentNamespaces = currentControllerSection.NameSpaces; var len = currentControllerSection.NameSpaces.Length; Array.Resize(ref currentNamespaces, len + 1); currentNamespaces[len-1] = @namespace; currentControllerSection.NameSpaces = currentNamespaces; } return this; } \\n``` A change is also required inside the **LocalizedRoute** class. \\n```csharp\\n private void AdjustForNamespaces() { var namespaces = this.ControllerTranslation.NameSpaces; bool useNamespaceFallback = (namespaces == null || namespaces.Length == 0); base.DataTokens[\\\"UseNamespaceFallback\\\"] = useNamespaceFallback; if ((namespaces != null) && (namespaces.Length > 0)) { base.DataTokens[\\\"Namespaces\\\"] = namespaces; } } \\n\")), mdx(\"p\", null, \"These changes are nice addition to the previous post. You can find the the whole source code in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/AspNetMvcEasyRouting\"\n  }, \"GitHub\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"fe969087-dcfb-575c-9359-ee6a594007e1","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}