{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/nodejs-and-mongodb-on-windows-connecting-and-inserting",
    "result": {"data":{"mdx":{"frontmatter":{"title":"NodeJs and MongoDb on Windows : Connecting and Inserting","date":"August 7, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"NodeJs and MongoDb on Windows : Connecting and Inserting\",\n  \"date\": \"2017-08-07\",\n  \"categories\": [\"mongodb\", \"nodejs-web\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"MongoDb is an interesting choice of permanent persistence when using NodeJs since it stores document which is ideal of JSON document to get stored.\"), mdx(\"p\", null, \"You can download a free version directly on MongoD : \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.mongodb.com/download-center#community\"\n  }, \"https://www.mongodb.com/download-center#community\"), \" Once it's downloaded, it's best to be sure that the system environment variable is set to have an entry in the path to point to the bin folder of the installation path of MongoDb.\"), mdx(\"p\", null, \"Before working out MongoDb with NodeJs, I recommend to download RoboMongo for free: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://robomongo.org/download\"\n  }, \"https://robomongo.org/download\"), \". This tool allows to query MongoDb and explore the data. Before using RoboMongo or to use the MongoDb library, we need to run the MongoDb server. To do so, go in the development folder you are working and execute the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"mongod\"), \" command with the dbpath. For example, the following command will store the MongoDb in the \\\"data\\\" folder in the development folder.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" mongod --dbpath=.\\\\\\\\data\\n\")), mdx(\"p\", null, \"Inside your NodeJs project, you needs sto have the mongodb library. If you are using TypeScript, you can get the type definition too.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"npm install mongodb --save npm install @types/mongodb --save-dev\\n\")), mdx(\"p\", null, \"At this point, you can start using the library to access the information. First step, connecting to the server. Second step, connecting to the collection. The first step is the same as any other database, the second one is just that every documents are stored into a collection. Think about it as a table.\"), mdx(\"p\", null, \"From here, we need to import some classes.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import { MongoClient, MongoError, Db, InsertOneWriteOpResult } from \\\"mongodb\\\";\\n\")), mdx(\"p\", null, \"MongoClient is the main class to connect to Mongo. MongoError is the class that wrap the error which we will use to get information about the connection's error. Db is the class that hold information about MongoDb once connected. We need it to properly close the connection, but also to select the collection in which we want to invoke the action (find, insert, delete). The InsertOneWriteOpResult is the result on an insert.\"), mdx(\"p\", null, \"Here is the connection code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"MongoClient.connect(url, (errMongo: MongoError, db: Db) => {\\n  if (errMongo) {\\n    console.log(errMongo);\\n  } else {\\n    console.log(\\\"Connected successfully to server\\\");\\n  }\\n});\\n\")), mdx(\"p\", null, \"To insert something in you need to get the collection name and use the insert method. Something I haven't yet figure out perfectly is how to handle Date from a .json file. In my case, I was opening file (.json) and inserting them into MongoDb. The Json parse method was returning the date as string, hence I needed to assign the value back with an instance of date\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"// To have a real date format in MongoDb\\nobjToInsert.fullDate = new Date(objToInsert.fullDate);\\n\\n// Access the collection we want to insert\\nconst collection = db.collection(\\\"documents\\\"); // \\\"documents\\\" can be anything you want your collection to be named\\n\\n// Insert with a callback that has an error or the result data\\ncollection.insert(\\n  objToInsert,\\n  (err: MongoError, result: InsertOneWriteOpResult) => {}\\n);\\n\")), mdx(\"p\", null, \"The code above will add a new entry and alter the object to add an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_id\"), \" with a GUID for the object. This way, every entry has a unique identifier automatically.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"33f14384-044f-5f5d-8763-fb2e2213a990","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}