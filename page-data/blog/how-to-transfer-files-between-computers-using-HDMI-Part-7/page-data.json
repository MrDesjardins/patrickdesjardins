{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-transfer-files-between-computers-using-HDMI-Part-7",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to Transfer Files Between Computers Using HDMI (Part 7: Instruction and Black and White)","date":"June 4, 2023"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to Transfer Files Between Computers Using HDMI (Part 7: Instruction and Black and White)\",\n  \"date\": \"2023-06-04\",\n  \"categories\": [\"rust\", \"hdmi\", \"video\", \"encoding\", \"steganography\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Transfering data using the HDMI cable and the capture card continues to demonstrate how easy corruption can cause the file to be unusable.\"), mdx(\"p\", null, \"Let's review few points that seem to demonstrate taht we have some inconsistancy around frames.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"ffmpeg -f dshow -list_options true -i video=\\\"USB Video\\\"\\n\")), mdx(\"p\", null, \"Shows \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"vcodec=mjpeg\"), \". The codec is a compressend one and we have tackle the issue using a less space efficienct way using black and white with more than a single pixel to hold the information.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"ffmpeg  -r 15 -f dshow -s 1920x1080 -vcodec mjpeg -rtbufsize 200M -i video=\\\"USB Video\\\" -r 15 out_fps15_size10px.mp4\\n\")), mdx(\"p\", null, \"The command above uses a lower speed of 15 frames per second (fps) to ensure we give some pace to the whole process. It required to encode the file in 15 fps as well but it is still problematic. During the command, additional information like the following gives a hint that the fps is inconsistant on reading.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"Input #0, dshow, from 'video=USB Video':\\n  Duration: N/A, start: 613320.254228, bitrate: N/A\\n  Stream #0:0: Video: mjpeg (Baseline) (MJPG / 0x47504A4D), yuvj422p(pc, bt470bg/bt709/unknown), 1920x1080, 15 fps, 15 tbr, 10000k tbn\\nStream mapping:\\n  Stream #0:0 -> #0:0 (mjpeg (native) -> h264 (libx264))\\n\\n\\n[libx264 @ 000001cd3023be80] using cpu capabilities: MMX2 SSE2Fast SSSE3 SSE4.2 AVX FMA3 BMI2 AVX2 AVX512\\n[libx264 @ 000001cd3023be80] profile High 4:2:2, level 4.0, 4:2:2, 8-bit\\n[libx264 @ 000001cd3023be80] 264 - core 164 r3106 eaa68fa - H.264/MPEG-4 AVC codec - Copyleft 2003-2023 - http://www.videolan.org/x264.html - options: cabac=1 ref=3 deblock=1:0:0 analyse=0x3:0x113 me=hex subme=7 psy=1 psy_rd=1.00:0.00 mixed_ref=1 me_range=16 chroma_me=1 trellis=1 8x8dct=1 cqm=0 deadzone=21,11 fast_pskip=1 chroma_qp_offset=-2 threads=24 lookahead_threads=4 sliced_threads=0 nr=0 decimate=1 interlaced=0 bluray_compat=0 constrained_intra=0 bframes=3 b_pyramid=2 b_adapt=1 b_bias=0 direct=1 weightb=1 open_gop=0 weightp=2 keyint=250 keyint_min=15 scenecut=40 intra_refresh=0 rc_lookahead=40 rc=crf mbtree=1 crf=23.0 qcomp=0.60 qpmin=0 qpmax=69 qpstep=4 ip_ratio=1.40 aq=1:1.00\\nOutput #0, mp4, to 'out_fps15_size10px.mp4':\\n  Metadata:\\n    encoder         : Lavf60.3.100\\n  Stream #0:0: Video: h264 (avc1 / 0x31637661), yuvj422p(pc, bt470bg/bt709/unknown, progressive), 1920x1080, q=2-31, 15 fps, 15360 tbn\\n    Metadata:\\n      encoder         : Lavc60.3.100 libx264\\n    Side data:\\n      cpb: bitrate max/min/avg: 0/0/0 buffer size: 0 vbv_delay: N/A\\nframe=  674 fps= 15 q=27.0 size=  221952kB time=00:00:44.80 bitrate=40585.5kbits/s speed=0.978x\\n\")), mdx(\"p\", null, \"If we zoom toward the encoding portion we see that there is a mix of mjpeg and h264. At the moment, I only suspect there is more compression than anticipated but we should be cover.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"Stream #0:0: Video: mjpeg (Baseline) (MJPG / 0x47504A4D), yuvj422p(pc, bt470bg/bt709/unknown), 1920x1080, 15 fps, 15 tbr, 10000k tbn\\nStream #0:0 -> #0:0 (mjpeg (native) -> h264 (libx264))\\nStream #0:0: Video: h264 (avc1 / 0x31637661), yuvj422p(pc, bt470bg/bt709/unknown, progressive), 1920x1080, q=2-31, 15 fps, 15360 tbn\\n\")), mdx(\"p\", null, \"To this point, the issue seems that sometimes we are missing some frames. For example, even missing a single frame will cause the whole file to not be readable. For now, we rely on a single red frame to indicate the starting point. After the red frame we assume the following frame starts with the instruction frame that gives the number of bytes for the actual content. However, what happen if the transfer of the frame after the red one fail to be transmitted or read? Also, there is actually no way to ensure we are reading all the frames.\"), mdx(\"h1\", null, \"Adaptation: Pagination\"), mdx(\"p\", null, \"The next idea is to add to every frame a reserved 64 bits space, similar to the instruction, to every frame. Also, modifying the instruction to be the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"last\"), \" 64 bits of the red frame. The reason is that one we figure out the frame to be the starting one (the red one) we do not need to rely on the next frame to be the instruction -- the red frame has always the instruction. Thus, we are still able to know the total amount of byte to recupperate. With the addition of the pagination, we can read all the whole video several times and with the use of a dictionary accumulate on each pass the missing frames.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"897px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/eee939536fac03afd2bf38b3433dd81c/3a737/hdmi_article7_pagination.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"41.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJ0lEQVQoz31Sy5KDIBD0/38vp5xjIggKCBgUTG/1xOyeslR1jcP0vBq7eZ6Rc0atFfu+o9WKg3bf8Xw+UUrBtm2CN6f+ceqOdV2Fw1zajgUJay0GpeC1xuFmJK0wTRPGccQwDBLnt7EWizGo1mBRSnzGHo8HLpcLOnbgJJxyiRFlXXGwa4wIIWAJAcYYfDbJ64oUgnC2nBFjlCkJcjp8ObW1d5NlgVJK8Enket9Ox3FJOo5DNDpaw4s4/dbaL8hpZ+x1ciXn5LKRFKRW1Km/3xHGEcVaJGuhx1Em01qLTn3fi5/nGcUaeK1Ed27hnMP1ekXnvZcLWl4m71DcjOy9FGGMoFbk2GmS2OYdknPiM5ZSwu12+0fDWkUKkjk9H4a/Dh9qr/Wrhj/nuWlELevJMgAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"hdmi article7 pagination\",\n    \"title\": \"hdmi article7 pagination\",\n    \"src\": \"/static/eee939536fac03afd2bf38b3433dd81c/3a737/hdmi_article7_pagination.png\",\n    \"srcSet\": [\"/static/eee939536fac03afd2bf38b3433dd81c/5a46d/hdmi_article7_pagination.png 300w\", \"/static/eee939536fac03afd2bf38b3433dd81c/0a47e/hdmi_article7_pagination.png 600w\", \"/static/eee939536fac03afd2bf38b3433dd81c/3a737/hdmi_article7_pagination.png 897w\"],\n    \"sizes\": \"(max-width: 897px) 100vw, 897px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"e5f48a5e-7142-55eb-85c8-1c4c4c007fc5","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}