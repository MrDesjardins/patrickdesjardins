{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-static-methods",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript Static Unnamed Method with version 4.4","date":"January 20, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript Static Unnamed Method with version 4.4\",\n  \"date\": \"2022-01-20\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"TypeScript version 4.4 gives the possibility to have a static block inside a class. The addition follows the EcmaScript standard to allow an unnamed function to be called when the static class is accessed for the first time. Like initializing a static variable in a class, the static block is called when the class is accessed first. The block is called right after the static variables.\\n\\xDF\\nThe following example shows that depending of static constants, the static variables are initialized by calling a function or not.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{11}\",\n    \"{11}\": true\n  }, \"function fetchGlobalCount(): number {\\n  return 1;\\n}\\nclass Constants {\\n  static isDistributed = true;\\n}\\nclass Telemetry {\\n  static globalInstanceCount = 0;\\n  static localIntanceCount = 0;\\n\\n  static {\\n    if (Constants.isDistributed) {\\n      Telemetry.globalInstanceCount = fetchGlobalCount();\\n      Telemetry.localIntanceCount = Telemetry.globalInstanceCount + 1;\\n    } else {\\n      Telemetry.localIntanceCount = 0;\\n    }\\n  }\\n  public static log(): void {\\n    console.log(Telemetry.localIntanceCount);\\n  }\\n}\\n\\nTelemetry.log();\\n\")), mdx(\"p\", null, \"The main benefit is the initialization of static private variables. Before the unnamed static block, additional code would be needed to access the static class variable and set the value needed. However, for private variables, it would be problematic. Also, having the possibility to rely on try/catch block is possible inside the static block giving a clean, central place to initialize safely static values for your class.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"cdf38a7a-f760-57a5-89d9-2c233e05f453","totalPages":73}},
    "staticQueryHashes": ["3159585216"]}