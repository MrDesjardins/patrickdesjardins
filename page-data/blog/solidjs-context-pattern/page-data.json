{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/solidjs-context-pattern",
    "result": {"data":{"mdx":{"frontmatter":{"title":"SolidJS: Context Simple Pattern","date":"March 22, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"SolidJS: Context Simple Pattern\",\n  \"date\": \"2022-03-22\",\n  \"categories\": [\"solidjs\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I have discussed in the past two patterns that can be used with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://patrickdesjardins.com/blog/two-patterns-with-react-context\"\n  }, \"React and Context\"), \". In this article, we will see in action the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"second pattern\"), \" described in the previous article with SolidJS. The pattern is the one described in the official documentation and the one I have been using recently.\"), mdx(\"p\", null, \"Why use this pattern? \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It defines a clear contract with a TypeScript interface.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You can have initialization value on the context creation\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It forces the context to be used only as a context.\")), mdx(\"h1\", null, \"TypeScript Interfaces\"), mdx(\"p\", null, \"There is a couple of valuable interfaces (or types) to define. The first one is the context property. The interface defines what can be done on the initialization of the context. It happens once, at the root of your application. Here is an example extracted from my latest SolidJS project. It has two \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface SensorsContextProps {\\n  useFakeSensors: boolean;\\n  children: JSX.Element;\\n}\\n\")), mdx(\"p\", null, \"In this example, there is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useFakeSensors\"), \" which is determined at the beginning of the application. You can swap that property for the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"theme\"), \" of your website or any other initial value. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \" allows wrapping the rest of your application. The following code shows how the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useFakeSensors\"), \" is used.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{3, 12}\",\n    \"{3,\": true,\n    \"12}\": true\n  }, \"const App: Component = () => {\\n  return (\\n    <SensorsProvider useFakeSensors={true}>\\n      <div class={styles.App}>\\n        <div class={styles.Container}>\\n          <Routes>\\n            <Route path={ROUTES.HOME} element={<Choose />} />\\n            <Route path=\\\"/*all\\\" element={<NotFound />} />\\n          </Routes>\\n        </div>\\n      </div>\\n    </SensorsProvider>\\n  );\\n};\\n\")), mdx(\"p\", null, \"In the example, you can see the provider. Before creating the provider, we need to define what content it will offer to wrap the underlying component.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface SensorsContextModel {\\n  state: SensorsContextState;\\n  sensors: SensorsContextSensors;\\n  actions: SensorsContextActions;\\n}\\n\")), mdx(\"p\", null, \"In my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/gym-water-app\"\n  }, \"current project\"), \", I have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SensorsContextModel\"), \" interface that has three properties. One has some shared state, access to sensors information, and some actions that can be invoked by children component that will affect the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state\"), \".\"), mdx(\"h1\", null, \"Provider\"), mdx(\"p\", null, \"The core of the pattern is creating a component that returns a provider. That way, we force the context code to be used only under a context situation. The example is once again extract from my project and simplified. You can see it has its store for the state and returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SensorsContext\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SensorsContext\"), \" is coming from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createContext\"), \". Here, React has a subtle difference where you do not have to define an empty implementation of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SensorsContextModel\"), \", which is convenient. Instead, we create the context and return the provider.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export const SensorsContext = createContext<SensorsContextModel>();\\n\\nexport function SensorsProvider(props: SensorsContextProps) {\\n  const [state, setState] = createStore<SensorsContextState>({});\\n  const distanceSensor = new UltraSonicSensor(props.useFakeSensors);\\n  const magneticSensor = new MagneticContactSensor(props.useFakeSensors);\\n\\n  const value: SensorsContextModel = {\\n    state: state,\\n    sensors: {\\n      ultraSonicSensor: distanceSensor,\\n      magneticContactSensor: magneticSensor,\\n    },\\n    actions: {\\n      listenDistanceSensor() {\\n        distanceSensor.startListening();\\n      },\\n    },\\n  };\\n\\n  return <SensorsContext.Provider value={value}>{props.children}</SensorsContext.Provider>;\\n}\\n\")), mdx(\"h1\", null, \"Using the Context\"), mdx(\"p\", null, \"At this point, the last step is to consume the context. Exactly like React, the call to a function (or hook) is needed in the child. I have a small function to simulate a hook with the context file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export function useSensors(): SensorsContextModel | undefined {\\n  return useContext(SensorsContext);\\n}\\n\")), mdx(\"p\", null, \"That step is not mandatory. However, encapsulating the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useContext\"), \" makes the code unaware of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SensorContext\"), \" instance. Hence, we can use the created function inside any of the children by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const c = useSensors()\"), \" and have access to everything inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SensorsContextModel\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"8747be07-de95-547a-95ae-b5232cb3a8d6","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}