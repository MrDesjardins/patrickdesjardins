{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-nodejs-sibling-project",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to Import Files from a Sibling Folder when Using TypeScript and NodeJS","date":"May 2, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to Import Files from a Sibling Folder when Using TypeScript and NodeJS\",\n  \"date\": \"2022-05-02\",\n  \"categories\": [\"typescript\", \"nodejs\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Imagine you have two kinds of services inside your project: frontend and backend. You may want to share some interfaces or other TypeScript files. The idea is to have a sibling folder to the frontend and backend folders called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shared\"), \".\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"138px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/d9bdfa5b03c233650690bb7606466181/948cf/typescript-nodejs-sibling-folders.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACZklEQVQ4y3WTW08TURDHG0US0Yjc2m67u223e2mXlpZSWnoRKuVS7gVsQimkxiIqGKKGV998Vj8BJsb45IMxPvvip/Bb+A1+Zk+hgRQfJnNmNud/5jcz6/IFI8iajRK2hR+aP2C41MAbLyIHLfyaTcCIo4RHCdsplHBMnJ28c9cfina8Yy4nUPUYmdw0WrLI4NIx7nKT/rkWpfIyu4evqdZbLFZ32Ww8pdY8Ynv/OfPrO3hVs1vwIiGHokjBCJ50Be9kBa+VRtdtouN5QpEkISuJFhnHimewxrIYsTSSanZV6bqcEGj+IO50hZHSLm47h3z+fcQfFqiOiFsO45Z1AuaYyHVV6JhHMUlkZ4iaUXre/sL1G26e/mAqN0Pj2RsqW3sCeefJS1ZrTXHeqLewxjJ4FaNb0HklZCVQAwaDi4fcOflC/9ordCtOtrTERL5MKjfLRGGOVL5MMlsS5vT/2h52hFUTKZpFMlPIstbG9WkMuFWGpCCDngADHlXETht8lwq6iqyaJDLTArn39Duun9Bz/JnCgzLr9QPKqzVmVx4J1OXtfZa29lipNcWQrkWWApaYXChkcK/+jlsf/tDXfE/ETgrk6YUq6eI8M4ubFOfWRVworxI0E+LulT28KNfZK7Fbmo3fH0SRZNyywf0RpWP9w35hg5428oVYF7IjFJ8oYOoRbh994sbZX+4+/ohhxlioNsg9XCY/uyK8U6Xjpf8tdlvQIpqcQtdM+l6c4foGvSdfSSQnWdtpsbBRZ2vvsPPHOG3wKHpH6NopS4HIOYKNTxttvx6wxBJ7FEN4cZb1K6iXK/wHbzSUqfbJ7YEAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"typescript nodejs sibling folders\",\n    \"title\": \"typescript nodejs sibling folders\",\n    \"src\": \"/static/d9bdfa5b03c233650690bb7606466181/948cf/typescript-nodejs-sibling-folders.png\",\n    \"srcSet\": [\"/static/d9bdfa5b03c233650690bb7606466181/948cf/typescript-nodejs-sibling-folders.png 138w\"],\n    \"sizes\": \"(max-width: 138px) 100vw, 138px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The idea is far from being exotic and workout naturally without doing anything if within the frontend folder you are using TypeScript and SolidJS. However, if the backend folder contains a NodeJS project, issues arise. The problem is that the TypeScript configuration inside the NodeJS will not allow accessing any file parent to the project's root (the backend folder).\"), mdx(\"h1\", null, \"Solution\"), mdx(\"p\", null, \"The solution is to rely on TypeScript \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"paths\"), \" ability to create an alias. The alias allows start importing from the alias instead of the root of the project (in that case, the backend folder).\"), mdx(\"p\", null, \"For example, in the tsconfig.json of the backend project, you have:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\",\n    \"metastring\": \"{7-9}\",\n    \"{7-9}\": true\n  }, \"{\\n  \\\"compilerOptions\\\": {\\n    \\\"module\\\": \\\"commonjs\\\"\\n    \\\"lib\\\": [\\\"ESNext\\\"],\\n    \\\"outDir\\\": \\\"build\\\",\\n    \\\"strict\\\": true,\\n    \\\"paths\\\": {\\n      \\\"@shared/*\\\": [\\\"../shared/*\\\"]\\n    },\\n    \\\"esModuleInterop\\\": true,\\n    \\\"skipLibCheck\\\": true,\\n  },\\n  \\\"include\\\": [\\\"src/**/*\\\"],\\n  \\\"exclude\\\": [\\\"node_modules\\\"]\\n}\\n\")), mdx(\"p\", null, \"Then, inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"backend\"), \" folder, it is possible to use the created alias, which is the left-end-side of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"paths\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import { LoginRequest, LoginResponse } from \\\"@shared/models/login\\\";\\n\")), mdx(\"p\", null, \"The result is appealing as well in terms of import statement. It does not have many \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"../../..\"), \". However, I found a drawback with VsCode: it cannot automatically resolve the import statement. Nonetheless, the advantage is that the sibling folder can be used across folders without requiring copying between folders or to relies on symbolic links.\"), mdx(\"h1\", null, \"Docker\"), mdx(\"p\", null, \"If you build your mono repository with Docker using Docker compose of two Docker images (frontend and backend), you will also need to adjust the configuration to access the volumes.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"volumes:\\n  - \\\"./services/backend:/node/app:delegated\\\"\\n  - \\\"./services/shared:/node/shared:delegated\\\"\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"566cb01d-2d28-54e5-a638-62cf1d5a058b","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}