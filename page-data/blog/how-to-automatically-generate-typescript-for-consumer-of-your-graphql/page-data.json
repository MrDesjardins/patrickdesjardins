{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-automatically-generate-typescript-for-consumer-of-your-graphql",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to automatically generate TypeScript for consumer of your GraphQL","date":"April 2, 2019"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to automatically generate TypeScript for consumer of your GraphQL\",\n  \"date\": \"2019-04-02\",\n  \"categories\": [\"graphql\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"One strength of GraphQL is that it has types. In an ideal world, the consumer of the GraphQL would receive the payload strongly typed. The reason that it is not the case is natural. The data that is moving from the server to the client who invoked the query receives a JSON format that does not have any notion of type. However, the client who call the GraphQL know exactly which fields he wants to consume and GraphQL maps each queried fields to a type.\"), mdx(\"h2\", null, \"Objectives\"), mdx(\"p\", null, \"The idea of this article is to let the user who call the GraphQL server to get a tailored object that is only for the field requested but also strongly typed for the field needed. It means that if the user request field A, B, and C of an object that has A, B,C, D, E, that the type that will be automatically generated will be only with A, B, C. While it might look that the generated type is not representing the real object, it reflects exactly the data that can be used. There is no need to have a generated object that you could not use.\"), mdx(\"h2\", null, \"Constraints\"), mdx(\"p\", null, \"Many articles discuss about introspection and how types can be generated by having the consumer connect directly to GraphQL server to fetch the schema. I had the constraint that I could not do it for security reason, hence I had to expose the schema by the server into another way and have the consumer uses the generated merged schemas.\"), mdx(\"h2\", null, \"Server Steps\"), mdx(\"p\", null, \"On the server side, one step is required: exposing the schemas into a unified schema (file) that can be shared. By generating the type every time the server is compiled, the schema remains in synchronization. Hence, we do not lose the freshness of being connected directly to GraphQL.\"), mdx(\"p\", null, \"I created a script in the package.json that execute a TypeScript script.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"\\\"generateunifiedschema\\\": \\\"ts-node src/scripts/mergeAllGraphqlSchemas.ts\\\",\\n\\n\")), mdx(\"p\", null, \"The code in the TypeScript file is simple -- really simple. Here is the whole code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import fs from \\\"fs\\\";\\nimport { fileLoader, mergeTypes } from \\\"merge-graphql-schemas\\\";\\nimport path from \\\"path\\\";\\nconst documentTypeDefs = fileLoader(\\\"src/**/*.graphql\\\");\\nconst mergedSchema = mergeTypes(documentTypeDefs);\\nconst typesPath = \\\"output_types\\\";\\nconst schemaPath = path.join(typesPath, \\\"allSchema.graphql\\\");\\nfs.writeFileSync(schemaPath, mergedSchema);\\n\")), mdx(\"p\", null, \"It uses the library \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"merge-graphql-schemas\"), \" and search for all individual schema that is spread inside the project. The result goes outside in a folder. That's it. In my case, that generated file is available internal at Netflix but not exposed outside. It means that every developers that consume the GraphQL service can download the schema, create query in their TypeScript code and use the unified schema to generate their code.\"), mdx(\"h2\", null, \"Client Steps\"), mdx(\"p\", null, \"Each consumer will have to do few steps. First, they need to download the unified schemas. Second, they need to write their GraphQL query and use gql. The gql allows to have a library that will scan the TypeScript file for gql (GraphQL Query) and will generate the appropriate TypeScript definition for the response data.\"), mdx(\"h4\", null, \"Download Unified Schema\"), mdx(\"p\", null, \"The download step is a matter of using curl. I create a simple bash file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"curl -X GET \\\\\\\\\\n  http://retracted/allSchema.graphql \\\\\\\\\\n  -H 'accept: text/plain, */*' \\\\\\\\\\n  --silent \\\\\\\\\\n  --output allSchema.graphql\\n\")), mdx(\"h4\", null, \"Query the GraphQL\"), mdx(\"p\", null, \"The next step is to write the client code to query the data. There is many ways to do it, I'll demonstrate one but will not go in detail in this article.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"async () => {\\n            try {\\n                const result: ApolloQueryResult<Proto.Query> = await this.client.query<Proto.Query>({\\n                    query: gql`\\n                        query Proto {\\n                            org(orgId: 0) {\\n                                name\\n                            }\\n                        }\\n                    `\\n                });\\n                if (result.data.org && result.data.org.name) {\\n                    this.setState({\\n                        longName: result.data.org.name\\n                    });\\n                }\\n            } catch (error) {\\n                console.error(error.networkError.bodyText);\\n            }\\n        }\\n\")), mdx(\"p\", null, \"At that point, your may wonder what is \\\"Proto.Query\\\" type and how come the result is strongly typed. The \\\"Proto.Query\\\" is the type that will be generated from the query specified in the client.query. The gql contains a query name which is translated into a TypeScript's namespace. It is important to name each query differently because of potential collisions. In my case, the org entity has only a single field, but later I might request more which will generate another org. A good way is to not call it \\\"Proto\\\" but something more relevant. For example, \\\"Financial\\\" or \\\"Inventory\\\" depending on the usage of the entity. Still, how do we generate the object.\"), mdx(\"h4\", null, \"Generate the TypeScript type\"), mdx(\"p\", null, \"The generation is done by using a library named \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"graphql**\"), \"-code-generator** which scan the TypeScript file for gql and uses the unified schema (or could work by directly connecting to the GraphQL) and output in a specified folder the type. It means that the first time you are writing the gql, you should not strongly type the ApolloQueryResult, then will have access to the type. Then, every change in the type will mend the existing type which is a great experience. For example, removing in the gql a field that is being used in TypeScript will make the code not compile. The \\\"graphql-code-generator\\\" library has a bin that you can use in your package.json to read the codegen.yml file with your custom configuration. I added two scripts. One that analyzes the TypeScript files and generates and another one that I use while developing who constantly check in the background to generate types.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"\\\"generatetypes\\\": \\\"gql-gen --config graphql/codegen.yml\\\",\\n\\\"generatetypes:watch\\\": \\\"gql-gen --config graphql/codegen.yml --watch\\\"\\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"codegen.yml\"), \" has the schema and document configuration. At first, I was confusing about these two terms. The documentation is dry on the differentiation. The schema configuration is about where to get the GraphQL schema, this is the downloaded unified GraphQL schema from the server. The document is which TypeScript file to analyze (could be JavaScript file as well).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema: \\\"./graphql/**/*.graphql\\\"\\ndocuments: \\\"./src/**/*.+(tsx|ts)\\\"\\noverwrite: true\\ngenerates:\\n  ./src/autogenerated/octoolstypes.ts:\\n    config: {}\\n    plugins:\\n      - \\\"typescript-common\\\"\\n      - \\\"typescript-client\\\"\\nrequire: ['ts-node/register']\\n\")), mdx(\"p\", null, \"It uses few plugins, hence you need to get the NPM packages accordingly.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\"graphql-code-generator\\\": \\\"0.16.0\\\",\\n\\\"graphql-codegen-add\\\": \\\"0.16.0\\\",\\n\\\"graphql-codegen-typescript-client\\\": \\\"0.16.0\\\",\\n\\\"graphql-codegen-typescript-common\\\": \\\"0.16.0\\\",\\n\\\"graphql-codegen-typescript-server\\\": \\\"0.16.0\\\"\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphqlcodegen\"), \" will check and generate the code. Unfortunately, it is slow. Even on a small code base, the process can take 10-15 seconds. Nonetheless, you have your TypeScript type generated for you and it will adapt with the backend (GraphQL server) changes.\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"Having the type generating automatically from the backend is fascinating and is efficient. If your business domain is rich in quantity of entities (interfaces) and if many of them have several fields and complex interconnection than having the type generated instead of typing it manually is a relief.\"), mdx(\"h2\", null, \"Related GraphQL Articles\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"getting-started-with-graphql-for-netflix-open-connect\"\n  }, \"Getting Started with GraphQL for Netflix Open Connect\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"install-apollo-server-to-host-a-graphql-service\"\n  }, \"Install Apollo Server to host a GraphQL service\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"apollo-server-and-secured-playground\"\n  }, \"Apollo Server and Secured Playground\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"graphql-context\"\n  }, \"GraphQL Context\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"graphql-query-with-argument\"\n  }, \"GraphQL Query with Argument\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"apollo-graphql-resolvers-and-data-source-separation\"\n  }, \"Apollo GraphQL Resolvers and Data Source separation\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"how-to-setup-a-typescript-nodejs-express-apollo-server-to-easy-debugging-with-vscode\"\n  }, \"How to setup a TypeScript, NodeJS, Express Apollo Server to easy debugging with VsCode\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"graphql-resolvers-with-apollo\"\n  }, \"GraphQL Resolvers with Apollo\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"configuring-apollo-playground-and-api-on-two-different-url\"\n  }, \"Configuring Apollo Playground and API on two different URL\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"how-to-automatically-generate-typescript-for-consumer-of-your-graphql\"\n  }, \"How to automatically generate TypeScript for consumers of your GraphQL\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"graphql-extension-to-collect-http-and-resolvers-telemetry\"\n  }, \"GraphQL and HTTP Telemetry\"), \"  \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"how-to-consume-graphql-in-typescript-and-react\"\n  }, \"GraphQL and TypeScript/React\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"66a76cc9-d11d-55b7-adfc-42c70bde6960","totalPages":73}},
    "staticQueryHashes": ["3159585216"]}