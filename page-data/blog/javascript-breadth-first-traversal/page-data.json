{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/javascript-breadth-first-traversal",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Breadth First Traversal","date":"July 18, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Breadth First Traversal\",\n  \"date\": \"2017-07-18\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Traversing a tree is not a task you have to do often, but it's still a good exercise to practice moving around a tree. Breadth first traversal consist of navigating one level at a time, visiting each siblings before moving to children.\"), mdx(\"p\", null, \"Breadth first requires the use of a queue for it's iterative and recursive approach. This is a big different from is opposite depth first traversal approach who use only a stack for the iterative and doesn't need to hold any values for its recursive algorithm.\"), mdx(\"p\", null, \"Let's start with defining a structure that represent a node.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var node = function (v, c) {\\n  return { value: v, children: c };\\n};\\n\")), mdx(\"p\", null, \"As you can see, each node has a value and a children collection. The name could be more significant, but let's put that aside and create a tree.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var node5 = node(\\\"node5\\\");\\nvar node4 = node(\\\"node4\\\");\\nvar node3 = node(\\\"node3\\\");\\nvar node2 = node(\\\"node2\\\", [node5]);\\nvar node1 = node(\\\"node1\\\", [node3, node4]);\\nvar graph = node(\\\"root\\\", [node1, node2]);\\n\")), mdx(\"p\", null, \"The tree is simple. It has a single root element that has 2 childrens : node 1 and node 2. Node a has two children : node 3 and 4. If we move back to the root, the second children, node 2, has only a single child : node 5.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function breadthFirstRecursive(queue, callback) {\\n  if (queue.length === 0) {\\n    return;\\n  }\\n  var node = queue.shift();\\n  callback(node);\\n  if (node.children) {\\n    for (var i = 0; i < node.children.length; i++) {\\n      var child = node.children[i];\\n      if (!child.hasBeenVisited) {\\n        child.hasBeenVisited = true;\\n        queue.push(child);\\n      }\\n    }\\n  }\\n  breadthFirstRecursive(queue, callback);\\n}\\n\")), mdx(\"p\", null, \"The algorithm starts by looking at the queue to be sure that we still have something to proceed. If that's the case, we take the first element from the left. This is important because children will be pushed in the queue and that we do not want to visit them until we are done with all siblings of the level. The last piece of code is the invocation where we put the root in the queue to be proceeded.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var queue = [];\\nqueue.push(graph);\\nbreadthFirstRecursive(queue, function (node) {\\n  console.log(node.value);\\n});\\n\")), mdx(\"p\", null, \"This output : Root, Node1, Node2, Node3, Node4, Node5\"), mdx(\"p\", null, \"The iterative approach is similar with the same output if we provide the same input.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function breadthFirstIterative(root, callback) {\\n  var queue = [];\\n  queue.push(root);\\n  while (queue.length > 0) {\\n    var node = queue.shift();\\n    callback(node);\\n    if (node.children) {\\n      for (var i = 0; i < node.children.length; i++) {\\n        var child = node.children[i];\\n        if (!child.discovered) {\\n          child.discovered = true;\\n          queue.push(child);\\n        }\\n      }\\n    }\\n  }\\n}\\n\\nbreadthFirstIterative(graph, function (node) {\\n  console.log(node.value);\\n});\\n\")), mdx(\"p\", null, \"The recursive call is replaced by a loop that will proceed the queue until that this one is empty.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"622cf978-63aa-53a7-ab9d-ee49d5bac08d","totalPages":69}},
    "staticQueryHashes": ["3159585216"]}