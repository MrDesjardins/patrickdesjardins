{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/javascript-object-create-vs-new",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Object.create vs new","date":"May 5, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Object.create vs new\",\n  \"date\": \"2017-05-05\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"It's possible to create instance in JavaScript by using Object.create or using new called constructor function.\"), mdx(\"p\", null, \"The Object.create creates an instance of an object with the prototype passed has first parameter. If a second parameter is provided, it will be used for this object only. This second parameter must be of type \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\"\n  }, \"DefinedProperty\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var MyClass1 = function () {\\n  this.member1 = \\\"m1\\\";\\n};\\n\\nMyClass1.prototype.function1 = function () {\\n  return \\\"return from function1\\\";\\n};\\n\\nvar instance1 = new MyClass1();\\nvar instance2 = Object.create(MyClass1.prototype, {\\n  member2: { value: \\\"m2\\\", writable: true },\\n});\\n\\nconsole.log(\\\"instance1.member1: \\\" + instance1.member1); //m1\\nconsole.log(\\\"instance1.function1: \\\" + instance1.function1()); //return from function1\\nconsole.log(\\\"instance2.member1: \\\" + instance2.member1); //undefined\\nconsole.log(\\\"instance2.member2: \\\" + instance2.member2); //m2\\nconsole.log(\\\"instance2.function1: \\\" + instance2.function1()); //return from function1\\nconsole.log(\\\"instance1.member2: \\\" + instance1.member2); //undefined\\n\")), mdx(\"p\", null, \"This example show that the member \\\"member1\\\" is only present on the first instance because the second instance is created with just the prototype of MyClass1. It also shows that the instance 1 doesn't have the member2 added by the second parameter of Object.create since it is a member added to the instance 2.\"), mdx(\"p\", null, \"Object.create and constructor function both create a new object and bot set the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"proto\"), \" but in a different way. Object.create sets the\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"proto\"), \" to be the one passed as the first parameter. The constructor function set the\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"proto\"), \" to the type specified prototype (in the previous example MyClass1.prototype). The major difference is that Object.Create returns the new object while the constructor function return the constructor of the object or the object.\"), mdx(\"p\", null, \"If we modified the preview code to have a console.log() in the constructor of the object, we can see that this one is executed only when using \\\"new\\\" and not when using Object.create.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var MyClass1 = function () {\\n  this.member1 = \\\"m1\\\";\\n  console.log(\\\"MyClass function\\\");\\n};\\n\\nMyClass1.prototype.function1 = function () {\\n  return \\\"return from function1\\\";\\n};\\n\\n//var instance1 = new MyClass1();\\n\\nvar instance2 = Object.create(MyClass1.prototype);\\n\")), mdx(\"p\", null, \"The code above doesn't execute the console.log. However, if we uncomment instance1 and comment instance2 (Object.create). We can see that it's called.\"), mdx(\"p\", null, \"In a future article, we will see that with Object.create that it's possible to create inheritance.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"7d3648cb-09e0-5d79-bb1a-1e48c56de855","totalPages":71}},
    "staticQueryHashes": ["3159585216"]}