{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/react-css-variable-component-css-files",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to use CSS variables in React components and CSS files","date":"October 27, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to use CSS variables in React components and CSS files\",\n  \"date\": \"2022-10-27\",\n  \"categories\": [\"typescript\", \"react\", \"css\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar CodeSandbox = makeShortcode(\"CodeSandbox\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you want to define at a single place values to use inside your React components and inside CSS files, you need a central location. I enjoy keeping colors and styles all in CSS files (or CSS modules).\"), mdx(\"h1\", null, \"CSS\"), mdx(\"p\", null, \"Settling into a solution of defining all values in CSS as the source of truth is technically possible.\"), mdx(\"p\", null, \"The first step is to define your variables. For example, you can specify a background color at the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":root\"), \". Of course, it could be at another level, but I prefer setting global variables at the highest level possible.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-css\"\n  }, \":root {\\n  --button-background-color: #c0c0c0;\\n}\\n\")), mdx(\"h1\", null, \"TypeScript\"), mdx(\"p\", null, \"The second step is to extract the value in TypeScript (or JavaScript), which React can use.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"const buttonBackgroundColor: string = getComputedStyle(\\n  document.documentElement\\n).getPropertyValue(\\\"--button-background-color\\\");\\n\")), mdx(\"h1\", null, \"Caveats\"), mdx(\"p\", null, \"Like most solution, there is some details that must be considered. First, the value extracted is a string. In the case of the color, it is fine, but if you pull a position or dimension, you will need to parse the string into a number.\"), mdx(\"p\", null, \"The second caveat is that you may miss type the name of the variable name. Is it \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--button-background-color\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--button-bg-color\"), \"? Providing the wrong name results to an empty string.\"), mdx(\"h1\", null, \"Code Sandbox: Extracting Values\"), mdx(\"p\", null, \"The code example provides an easy but not practical example of reading a variable and using it in a style. Indeed, in the real world, we would not rely on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"style\"), \" and only on CSS for that purpose. Nonetheless, it shows that we are using the variable value to set the color to the button background.\"), mdx(CodeSandbox, {\n    codeSandboxId: \"late-rain-z80cgd\",\n    mdxType: \"CodeSandbox\"\n  }), mdx(\"h1\", null, \"Theme with Conditional CSS Variables Value\"), mdx(\"p\", null, \"A pattern that I like is to define a variable depending on a theme. The theme is selected by assigning a value to an attribute, and the CSS check if the attribute is a specific value.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-css\"\n  }, \"html {\\n  --button-background-color: #c0c0c0;\\n}\\n\\nhtml[data-theme=\\\"dark\\\"] {\\n  --button-background-color: #7fffd4;\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"// Get current theme value (light or dark)\\nconst currentTheme = document.documentElement.getAttribute(\\\"data-theme\\\");\\n\\n// Alternate the theme (swap)\\nconst newTheme = currentTheme === \\\"dark\\\" ? \\\"light\\\" : \\\"dark\\\";\\n\\n// Set the new theme\\ndocument.documentElement.setAttribute(\\\"data-theme\\\", newTheme);\\n\\n// Force rerender which will make the TS code to read the CSS variable get the newest value\\nsetCurrentTheme(newTheme);\\n\")), mdx(\"h1\", null, \"Code Sandbox #2: Theme\"), mdx(CodeSandbox, {\n    codeSandboxId: \"react-reading-css-variables-theme-poc3tg\",\n    mdxType: \"CodeSandbox\"\n  }), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"It is reasonable to challenge the solution of using CSS as the source of truth for colors and styles. The argumentation of the lack of solid type and the possibility to miss typing the name is considerable. However, the opportunity to define the style in an agnostic way is valuable. CSS variables are usable in any old and new mechanism and are, in a way, future-proof. Also, it is framework agnostic allowing React or SolidJS, or Angular to consume the values. With the capability to change the value dynamically with CSS conditions, like with an attribute value change, the pattern works well for theming.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"9031faff-441a-5cba-9d7f-d22b36771754","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}