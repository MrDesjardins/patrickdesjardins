{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/react-autobinding-and-how-to-force-component-to-re-attach-its-events",
    "result": {"data":{"mdx":{"frontmatter":{"title":"React Autobinding and how to force component to re-attach its events","date":"September 26, 2016"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"React Autobinding and how to force component to re-attach its events\",\n  \"date\": \"2016-09-26\",\n  \"categories\": [\"react\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is not a usual scenario but imagine that you have a component that must reattach its events. How would you do it? The use case is that when a user click a link from the menu that we create the top level component which attach event to a store, etc. We want to attach everytime to a new store, thus not having any listener to the old one. The reason is that it's a cheap way to reset the JavaScript store and be sure to have no old events listening to the new view. However, if you just use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.createElement()\"), \" you will endup that any subsequent creation will not trigger \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"componentDidMount\"), \". That cause the component not listening to the store.\"), mdx(\"p\", null, \"Under the hood, React knows to handle binding events, even if it doesn't hit again the mounting method. It's called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Event Delegation\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AutoBinding\"), \". The event delegation is that every event attached are attached at the top level component instead of sub-component. React dispatches the event to the proper component when an action occurs. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AutoBinding\"), \" part is if you create a new object and this one is the same type and the same hiearchy level, this one doesn't need to re-attach events -- React already knows about it and it will handle the delegation properly to the new component. That is the reason that if you create a component and create it again that this one will not call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"componentDidMount\"), \" but it will still have the listener to the store.\"), mdx(\"p\", null, \"The problem is that if you want to reset those listeners, how do you do? How can you force the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AutoBinding\"), \" to reset all listeners? The solution is with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"key\"), \". The binding is associated to a component by this identifier. If you do not provide one, React is smart enough to figure out that you are creating again the same component and do some optimization like AutoBinding. If you want to skip this optimization and create from scratch, you need to setup a unique key. If you are clicking on different view, you can use the view id as the component key. If you want to have always a new creation, you can use a GUID.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" React.createElement(MyComponent, { props1: \\\"value1\\\", key: newGuid() } ); \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"e489e2a7-907f-5cd0-b058-5fd2295fea73","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}