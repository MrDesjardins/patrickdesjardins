{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/tempdata-why-you-should-use-bracket-instead-of-add",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TempData why you should use bracket instead of .Add","date":"August 13, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TempData why you should use bracket instead of .Add\",\n  \"date\": \"2012-08-13\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"TempDataDictionary (TempData is of type of TempDataDictionary) is useful if you need to keep you data between redirection. I have see some case of error with programmer who use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TempData\"), \" with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Add\"), \" method.\"), mdx(\"p\", null, \"First the Add method won't let you add more than 1 same key. This mean that it will crash if you write: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" TempData.Add(\\\"key1\\\",\\\"value1\\\"); \\n TempData.Add(\\\"key1\\\",\\\"value2\\\"); \\n\\n\")), mdx(\"p\", null, \"You will tell me why someone will do this, well, in the scenario of redirection, which should occur if you are using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TempData\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewBag\"), \" you may comeback in the same path of code that the user set the data. In this case, the value are set twice cause the TempData in a redirection keep its values.\"), mdx(\"p\", null, \"So, you can add some validation with the ContainsKey method. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"if(!TempData.ContainsKey(\\\"key1\\\")) { \\n  TempData.Add(\\\"key1\\\",\\\"value1\\\"); \\n} \\n\")), mdx(\"p\", null, \"Second, this solve the problem but create overwhelming code for a simple task. The solution in my opinion is to simply use the bracket overload of the TempDataDictionary.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" TempData[\\\"key1\\\"] = \\\"value1\\\"; \\n\")), mdx(\"p\", null, \"The code is shorter, cleaner and do what we want. It set the value and if it's a redirection to the same code who has set the value this one will just reset the same value. That's it! Simple and clean.\"), mdx(\"p\", null, \"If you are curious about the bracket code, here is the source code of the TempData for the property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[]\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"private Dictionary<string, object>_data; \\nprivate HashSet<string>_initialKeys = new HashSet<string>(StringComparer.OrdinalIgnoreCase); \\n//... \\npublic object this[string key] { \\n  get { object value; \\n    if (TryGetValue(key, out value)) {\\n      _initialKeys.Remove(key); \\n      return value; \\n    } \\n    return null; \\n  } \\n\\n  set {\\n    _data[key] = value;_initialKeys.Add(key); \\n  } \\n} \\n\")), mdx(\"p\", null, \"Of course, the real question now is why does this code has redirection that double set this value, but this is another story.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"be77e45b-f1cf-559e-8c2f-be82976b8009","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}