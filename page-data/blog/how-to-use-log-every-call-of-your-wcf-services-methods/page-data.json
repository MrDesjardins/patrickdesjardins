{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-use-log-every-call-of-your-wcf-services-methods",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to use log every call of your WCF service's methods","date":"April 9, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to use log every call of your WCF service's methods\",\n  \"date\": \"2013-04-09\",\n  \"categories\": [\"c-sharp\", \"wcf\", \"webservices\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you want to log information like which method has been called with which parameters on every methods of your WCF service, you shouldn't set the log every time on each method. Two approaches is possible to create something clean.\"), mdx(\"p\", null, \"The first option is to create an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attribute\"), \" and when this one is present will log. The second is to automatically log every call. I'll show you the second approach since it's seem more logic to log every methods. If you are curious about how to do it with an attribute, I'll post in few times the code to apply security with WCF with attribute which will show you how to do it.\"), mdx(\"p\", null, \"This article shows you how to log every calls of WCF's methods. It will use Unity as IOC. So, this article show you how to use an IOC (Unity) with WCF also.\"), mdx(\"p\", null, \"The first step is to modify your service definition. This can be done by editing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".scv\"), \" (not the .svc.cs).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"<%@ ServiceHost Language=\\\"C#\\\" Debug=\\\"true\\\" Service=\\\"MyNameSpace.MyServices.MyService\\\" CodeBehind=\\\"MyService.svc.cs\\\" Factory=\\\"MyNameSpace.MyServices.Common.MyServiceHostFactory \\\" %> \\n\")), mdx(\"p\", null, \"The important modification is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Factory\"), \" attribute. This one is required to be able to use Unity. This act as the global.asax.cs. By this, I mean, it's called when the service is initialized and not at every calls. Behind this factory, you own class is instanced and you are able to return your own ServiceHost class. This is a door to initialize Unity (IoC), AutoMapper and many others utilities class that need to be instanced once.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class MyServiceHostFactory : ServiceHostFactory { \\n  protected override ServiceHost CreateServiceHost(Type serviceType, Uri[] baseAddresses) {\\n    var serviceHost = new MyServiceHost(serviceType, baseAddresses); \\n    //ConfigureUnity(serviceHost.Container); \\n    //ConfigureAutoMapper();\\n    return serviceHost; \\n  } \\n} \\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MyServiceHostFactory\"), \" creates a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MyServiceHost\"), \" and configure the inversion of control container. It also initialize the Automapper configuration. The MyServiceHost inherit from ServiceHost, which let you add the implementation of the IoC container and handle behaviors. To be able to log on every service's method, a new behavior need to be defined.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class MyServiceHost : ServiceHost { \\n  public UnityContainer Container { get; set; } \\n  public MyServiceHost() { Container = new UnityContainer(); }\\n\\n  public MyServiceHost(Type serviceType, params Uri[] baseAddresses): base(serviceType, baseAddresses) { \\n    Container = new UnityContainer();\\n  }\\n\\n  protected override void OnOpening() { \\n    base.OnOpening();\\n\\n    if (this.Description.Behaviors.Find<MyServiceBehavior>() == null) { \\n      this.Description.Behaviors.Add(new MyServiceBehavior(Container)); \\n    } \\n  } \\n} \\n\")), mdx(\"p\", null, \"The MyServiceHost initializes the container and add a single behavior which handle the logging feature.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class MyServiceBehavior : IServiceBehavior { \\n  public UnityInstanceProvider InstanceProvider { get; set; }\\n\\n  public MyServiceBehavior() { InstanceProvider = new UnityInstanceProvider(); }\\n\\n  public MyServiceBehavior(UnityContainer unity) { InstanceProvider = new UnityInstanceProvider {Container = unity}; }\\n\\n  public void AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters) { }\\n\\n  public void ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase) { \\n    InstanceProvider.ServiceType = serviceDescription.ServiceType; \\n    foreach (ChannelDispatcherBase cdb in serviceHostBase.ChannelDispatchers) { \\n      var cd = cdb as ChannelDispatcher; if (cd != null) { \\n        foreach (EndpointDispatcher ed in cd.Endpoints) { \\n          ed.DispatchRuntime.InstanceProvider = InstanceProvider; \\n        } \\n      } \\n    }\\n\\n    var log = InstanceProvider.Container.Resolve<ILog>(); \\n    IOperationBehavior behavior = new LoggingOperationBehavior(log); \\n    foreach (ServiceEndpoint endpoint in serviceDescription.Endpoints) { \\n      foreach (OperationDescription operation in endpoint.Contract.Operations) { \\n        if (!operation.Behaviors.Any(d => d is LoggingOperationBehavior)) { \\n          operation.Behaviors.Add(behavior); \\n        } \\n      } \\n    } \\n  }\\n\\n  public void Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase) { } \\n} \\n\")), mdx(\"p\", null, \"This is where we attach for all endpoints, all operations (methods) the behavior to be executed. This is where we add the logging behavior. The first foreach is required for Unity to be the provider while the second foreach is there to add the logging behavior.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class UnityInstanceProvider : IInstanceProvider { \\n  public IUnityContainer Container { set; get; } \\n  public Type ServiceType { set; get; }\\n\\n  public UnityInstanceProvider() : this(null) { }\\n\\n  public UnityInstanceProvider(Type type) { ServiceType = type; Container = new UnityContainer(); }\\n\\n  public object GetInstance(InstanceContext instanceContext, Message message) { return Container.Resolve(ServiceType); }\\n\\n  public object GetInstance(System.ServiceModel.InstanceContext instanceContext) { return GetInstance(instanceContext, null); }\\n\\n  public void ReleaseInstance(InstanceContext instanceContext, object instance) {\\n\\n    var myInstance = instance as IDisposable;\\n\\n    if (myInstance != null) { \\n      myInstance.Dispose(); \\n    } \\n  } \\n} \\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class LoggingOperationBehavior : IOperationBehavior { \\n  private readonly ILog_myLog;\\n\\n  public LoggingOperationBehavior(ILog myLog) {_myLog = myLog; }\\n\\n  public void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation) { \\n    dispatchOperation.Invoker = new LoggingOperationInvoker(_myLog, dispatchOperation.Invoker, dispatchOperation); \\n  } \\n  \\n  public void Validate(OperationDescription operationDescription) { } \\n  \\n  public void ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation) { }\\n\\n  public void AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters) { }\\n} \\n\")), mdx(\"p\", null, \"At this point, we need to invoke the log. We need to specify an invoker that will be executed. This is why, we need to create a logging invoker which take the log that come from Unity.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class LoggingOperationInvoker : IOperationInvoker { \\n  private readonly IOperationInvoker_baseInvoker; \\n  private readonly string_operationName; \\n  private readonly string_controllerName; \\n  private readonly ILog_myLog;\\n\\n  public LoggingOperationInvoker(ILog myLog, IOperationInvoker baseInvoker, DispatchOperation operation) {\\n    _myLog = myLog;_baseInvoker = baseInvoker;\\n    _operationName = operation.Name;\\n    _controllerName = operation.Parent.Type==null?\\\"[None]\\\":operation.Parent.Type.FullName; \\n  } \\n  \\n  public object Invoke(object instance, object[] inputs, out object[] outputs) {\\n    _myLog.Log(\\\"Method \\\" +_operationName + \\\" of class \\\" +_controllerName + \\\" called\\\"); \\n    try { return_baseInvoker.Invoke(instance, inputs, out outputs); } \\n    catch (Exception ex) {_myLog.Log(ex); throw; } \\n  }\\n\\n  public object[] AllocateInputs() {return_baseInvoker.AllocateInputs(); }\\n\\n  public IAsyncResult InvokeBegin(object instance, object[] inputs, AsyncCallback callback, object state) {\\n    _myLog.Log(\\\"Method \\\" +_operationName + \\\" of class \\\" +_controllerName + \\\" called\\\"); \\n    return_baseInvoker.InvokeBegin(instance, inputs, callback, state); \\n  }\\n\\n  public object InvokeEnd(object instance, out object[] outputs, IAsyncResult result) {\\n    return_baseInvoker.InvokeEnd(instance, out outputs, result);\\n  }\\n\\n  public bool IsSynchronous { \\n    get {return_baseInvoker.IsSynchronous; } \\n  } \\n} \\n\")), mdx(\"p\", null, \"This is where the log is really written. It uses the interface to log which came from Unity from the Factory. The log is written when the method is invoked.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"a253d31a-61a9-567e-85a5-05a8f94b7525","totalPages":75}},
    "staticQueryHashes": ["3159585216"]}