{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/model-validation-and-entity-framework-4-3",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Model validation and Entity Framework 4.3","date":"April 16, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Model validation and Entity Framework 4.3\",\n  \"date\": \"2012-04-16\",\n  \"categories\": [\"entity-framework\", \"general\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In a previous post concerning the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./how-to-validate-model-object-with-asp-net-mvc-correctly\",\n    \"title\": \"How to validate model object with Asp.Net MVC correctly?\"\n  }, \"IValidatableObject with Asp.Net MV3\"), \" we have discussed the powerful of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IValidatableObject\"), \" interface with MVC framework which is a fast solution to handle error in the model, error in the model binding and error in the controller.\"), mdx(\"p\", null, \"What is great by using Microsoft ecosystem is that most of the framework work well together. If you are using the ORM Entity Framework and you are validating your business logic with the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IValidatableObject\"), \" interface you can benefit that before executing SaveChanges() on you database context that Entity Framework will call all model validation. This mean that you cannot forget to call it or it means that you do not need to explicitly check for the validation. If something is wrong with the model validation, when the SaveChanges() is called, Entity Framework will throw an exception.\"), mdx(\"p\", null, \"Here is an example that we try to save an entity which fail because a business logic added into the Validate method of the inherited class IValidateObject fail. Without having to check if the ModelState.IsValid, Entity Framework call the Validate method of all changed entity and raise an exception of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DbEntityValidationException\"), \". This is an awesome protection that ensure that nothing goes beyond the controller if something is wrong with the model; the database is clean.\"), mdx(\"p\", null, \"I am pretty sure that at this point, someone will say that the exception defeat the purpose in many scenario where you would like to handle particularly all errors from all models objects and display something to the user (or to log them). Well, you can skip the exception and go directly to the model error.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"var fromDatabase = dContext.Cars.Single(p => p.Id == car.Id); \\ndContext.Entry(fromDatabase).CurrentValues.SetValues(car); \\nif (!dContext.GetValidationErrors().Any()) { \\n  dContext.SaveChanges(); \\n} \\nelse { \\n  //Display the error in the list dContext.GetValidationErrors() \\n} \\n\")), mdx(\"p\", null, \"As you can see, this way, you check if they are any problem and then you save if none. On the other side, if errors occur you can display them. This is very powerful because you have the entity which is problematic, all its properties that is in error and all its errors messages. This is possible because the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetValidationErrors\"), \" function return a DbEntityValidationResult which contain the Entry itself, the state if it's valid or not and a collection of error in the DbValidationError format which mean that you know what property is in error with the message.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"400px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/fc342ec7542b2c87d596ceee49c5da13/e17e5/allerror-400x84.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"21%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAArklEQVQY042OS0rEQAAFc//7iFeYvSDMxklijGba9L87bf9KHHSpWFDwqNUb5uVgXQ2v6840vbG+LDjniSHhnMNaizGGEAKlFL7ovf/qUEom58wRI95ZvHNct3e2TXCkD1JKtFaptdJao/e/HZRWWG/xwVN7uz04XGI8n8nRwHf7L4O0mt3uSCvRXhGTQ0rL3enC/YPicVxQ+xNCjAhxQesFpZ6RckapGSmn2/7xE2ELNLeAv6ljAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"allerror 400x84\",\n    \"title\": \"allerror 400x84\",\n    \"src\": \"/static/fc342ec7542b2c87d596ceee49c5da13/e17e5/allerror-400x84.png\",\n    \"srcSet\": [\"/static/fc342ec7542b2c87d596ceee49c5da13/5a46d/allerror-400x84.png 300w\", \"/static/fc342ec7542b2c87d596ceee49c5da13/e17e5/allerror-400x84.png 400w\"],\n    \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"That's it. At this point, you know that Entity Framework work in a team with MVC's ModelState. You do not need to add custom code in a generic model class that will contain validation method. It's already built in. Also, if you are using Entity Framework as ORM, you can benefit of extra security that your database won't be altered by wrong data because Entity Framework takes care to call the Validate method of all your object before using them.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"ef8fb1f3-8596-5334-8891-f3b043aead29","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}