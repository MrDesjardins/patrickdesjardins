{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typeScript-performance-tests-github-workflow",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript Performance Tests with Github Workflow","date":"December 13, 2021"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript Performance Tests with Github Workflow\",\n  \"date\": \"2021-12-13\",\n  \"categories\": [\"github\", \"ci\", \"continuous integration\", \"performance\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Automation is vital for delivering a product of consistent quality. In that domain, automated assertive unit tests are the epitome. Unit tests are a well-accepted cog in a software engineer arsenal and rarely contested. While avoiding injecting new errors in the code is critical, ensuring another non-functional regression is equally valuable. However, we rarely see these other non-functional characteristics automated. In this article, I'll describe how to have your TypeScript code automatically tested for performance regression on Github.\"), mdx(\"p\", null, \"Before getting into the detail, here is a screenshot of the generated image for my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/hilbert-curve-ts\"\n  }, \"TypeScript Hilbert Curve library\"), \". The Github workflow generates a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://mrdesjardins.github.io/hilbert-curve-ts/dev/bench/\"\n  }, \"dynamic HTML page\"), \" with one chart per performance test. The x-axis contains the commits (in time) with a y-axis with the number of operations conducted.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1176px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/a78a6df0c9bc7aff014d6235df3a2c3a/e9d87/benchmark-hilbert-ts.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"64.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABvElEQVQ4y5VSa2/bMAz0//9La9bmhSxFlgYBsgfybDAUKVYnsiy7IiX5BtFO6gbthxE4HEWTR1JWgpZVVSW83+8xGo2wXC6xXq8xn8/FX61WwovFAiGEdzVnS2KgjWiHwwGdTgfD4RAPDzNMp1PMZjOMx2OJTSYTOOcugm0k1xNed/zcWkNITY0kjk5ECKFqiXo5O3oCF9+h9V9oncMYA++9rHvdVnTjysyE9KhQmj0CP0tyaJpGDsHLes4xnKM6HnN8CUfP0tS7E0JwqKqAhMjieMxQ5BuQvgGZe3D5A1z+Bpe/4OgPqsCXCYIvJIf0LazgDlZ/BZkxqkC1YJywyHfgvAeru7DZlzfoDigfgMuf4NeN+CKQD0B5v+FeI8hIlFI4KY1Cb8F5F1afk9roibDNbmpfhPpNbh+ku2+ChTHNym3BjzC4TGV173NBJsJLenonaD8QtC2Ba6bYwNwjxDuMf0/rAq8m3uFtfR959z9xBzbfgMrVDzu+ufTlCVptoY5rZKfNBeoYeQutdnLOs53k1LyReKzL1COKwpwFA6wlMMdH7kGR2Td+zWmqkOkCzkO+s6skHmvOdcyMf/t027CMsc3sAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"benchmark hilbert ts\",\n    \"title\": \"benchmark hilbert ts\",\n    \"src\": \"/static/a78a6df0c9bc7aff014d6235df3a2c3a/e9d87/benchmark-hilbert-ts.png\",\n    \"srcSet\": [\"/static/a78a6df0c9bc7aff014d6235df3a2c3a/5a46d/benchmark-hilbert-ts.png 300w\", \"/static/a78a6df0c9bc7aff014d6235df3a2c3a/0a47e/benchmark-hilbert-ts.png 600w\", \"/static/a78a6df0c9bc7aff014d6235df3a2c3a/e9d87/benchmark-hilbert-ts.png 1176w\"],\n    \"sizes\": \"(max-width: 1176px) 100vw, 1176px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"h1\", null, \"TypeScript Benchmark Code\"), mdx(\"p\", null, \"The first step is to create a benchmark. You can see a benchmark as a unit test suite that contains many unit tests. Github uses a workflow action that supports many benchmark libraries. For example, the currently supported one for JavaScript relies on the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://benchmarkjs.com/\"\n  }, \"Benchmarkjs library\"), \".\"), mdx(\"p\", null, \"I am using TypeScript, hence use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@types/benchmark\"), \" library as well. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"npm install --save-dev benchmarke@latest\\nnpm install --save-dev @types/benchmark@latest\\n\")), mdx(\"p\", null, \"Then, creating a benchmark test is a matter of defining what you want the library to perform several times. In my case, I wanted to benchmark the algorithm of a function with a specific parameter. Hence, I am creating one function (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".add\"), \") per scenario for this function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const Benchmark = require(\\\"benchmark\\\");\\nconst suite = new Benchmark.Suite();\\nconst { HilbertAlgorithm } = require(\\\"../dist/lib/es5/hilbertAlgorithm\\\");\\n\\nsuite\\n  .add(\\\"Hilbert Order 2\\\", function () {\\n    const h = new HilbertAlgorithm(2);\\n    h.indexToPoint(0);\\n  })\\n  .on(\\\"cycle\\\", function (event: any) {\\n    console.log(String(event.target));\\n  })\\n  .run();\\n\")), mdx(\"p\", null, \"You can see the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/hilbert-curve-ts/blob/master/benchmarks/benchmarks.ts\"\n  }, \"full benchmark TypeScript file here\"), \".\"), mdx(\"h1\", null, \"TypeScript Benchmark Script\"), mdx(\"p\", null, \"Once the benchmark functions are created, we need to have an entry point in the package.json. I added one command.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\"benchmarks\\\": \\\"ts-node benchmarks/benchmarks.ts --project tsconfig.benchmarks.json\\\",\\n\")), mdx(\"p\", null, \"As you can see, the command relies on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ts-node\"), \" because the benchmark is in a TypeScript file. Hence, you need to add the dependency in your package.json.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"npm install --save-dev ts-node@latest\\n\")), mdx(\"h1\", null, \"Github Workflow\"), mdx(\"p\", null, \"I'll assume you already have a workflow action that builds and run some unit tests (or not). Hence, we will need to add a step to your current workflow. Here is the full code of the two steps:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"- name: Run benchmarks\\n    run: npm run benchmarks | tee output.txt\\n    if: matrix.os == 'ubuntu-latest' && matrix.node-version == '16.x'\\n\\n- name: Store benchmark result\\n  uses: benchmark-action/github-action-benchmark@v1\\n  with:\\n    tool: \\\"benchmarkjs\\\"\\n    output-file-path: output.txt\\n    github-token: ${{ secrets.GITHUB_TOKEN }}\\n    auto-push: true\\n    comment-on-alert: true\\n    alert-comment-cc-users: \\\"@mrdesjardins\\\"\\n  if: matrix.os == 'ubuntu-latest' && matrix.node-version == '16.x'\\n\")), mdx(\"p\", null, \"The first step, named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Run benchmarks\"), \", which calls the NPM command created earlier. It uses a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"|\"), \" to send the output into a file using the Unix \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tee\"), \" command. The command redirects the output to a file. The file name is important and will be used later in the second step. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"if\"), \" is optional. In my workflow, I have a matrix of different compilations under different NodeJS versions and operating systems (OS). I want to run the performance test only in 1 particular combination, which is under Ubuntu and NodeJS 16. The reason is that it increases the process and also that I do not mind about performance between NodeJS version and OS.\"), mdx(\"p\", null, \"The second step, named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Store benchmark result\"), \", which uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"benchmark-action/github-action-benchmark@v1\"), \". The action takes the generated benchmark output from the file specified in the previous step and knows how to interpret the result. Then, it uses the Github token provided and pushes the result into another branch called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gh-pages\"), \". The branch contains one folder with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data.js\"), \". The folder contains the historical data of each time the benchmark was executed. Also, a file named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.html\"), \" is the entry point to read the result. \"), mdx(\"p\", null, \"To create the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gh-pages\"), \" branch, you need to execute:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"git switch --orphan gh-pages\\ngit commit --allow-empty -m \\\"initial commit\\\"\\ngit push -u origin gh-pages\\n\")), mdx(\"p\", null, \"You can find further information for the action at the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/benchmark-action/github-action-benchmark\"\n  }, \"Benchmark-action\"), \" repository.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/hilbert-curve-ts/blob/master/.github/workflows/action.yml\"\n  }, \"workflow\"), \" for the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/hilbert-curve-ts\"\n  }, \"TypeScript Hilbert Curve library\"), \" library builds, tests for logic, and now performance test. I am confident when I am modifying the code that the output of the functions is stable in terms of data and performance. The additional automation steps were a little investment, thanks for the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"action\"), \"  that is already integrated into Github.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"da1a1602-4aad-56da-b4df-dcb8e2f5c178","totalPages":73}},
    "staticQueryHashes": ["3159585216"]}