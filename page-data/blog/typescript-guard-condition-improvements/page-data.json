{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-guard-condition-improvements",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript Guard Condition Improvements with version 4.4","date":"January 10, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript Guard Condition Improvements with version 4.4\",\n  \"date\": \"2022-01-10\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"TypeScript allows variables to be of several types. For example, a function's parameter can be a number or a string. Or another example can be a variable within a function can be a union of several types.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function transform(arg: number | string) {\\n  let result = \\\"\\\";\\n  if (typeof arg === \\\"string\\\") {\\n    result = arg.toLowerCase();\\n  } else {\\n    result = arg.toString();\\n  }\\n  return result;\\n}\\n\")), mdx(\"p\", null, \"However, if you wanted to have the condition inside a variable before version 4.4, the following code would not compile. This is because the transpiler would have given an error saying that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"arg\"), \" variable is of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number | string\"), \" inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"if\"), \" statement.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{3}\",\n    \"{3}\": true\n  }, \"function transform(arg: number | string) {\\n  let result = \\\"\\\";\\n  const isString = typeof arg === \\\"string\\\";\\n  if (isString) {\\n    result = arg.toLowerCase();\\n  } else {\\n    result = arg.toString();\\n  }\\n  return result;\\n}\\n\")), mdx(\"p\", null, \"However, there is a catch, the variable that is holding the boolean value must be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \". It means that the following code does not transpile:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{3}\",\n    \"{3}\": true\n  }, \"function transform(arg: number | string) {\\n  let result = \\\"\\\";\\n  let isString = typeof arg === \\\"string\\\";\\n  if (isString) {\\n    result = arg.toLowerCase();\\n  } else {\\n    result = arg.toString();\\n  }\\n  return result;\\n}\\n\")), mdx(\"p\", null, \"Neither the following one:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{2}\",\n    \"{2}\": true\n  }, \"const isString = true;\\nfunction transform(arg: number | string, isString: boolean) {\\n  // ...\\n}\\n\")), mdx(\"p\", null, \"Or that one: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{2}\",\n    \"{2}\": true\n  }, \"const isString = true;\\nfunction transform(arg: number | string, isString: Readonly<boolean>) {\\n  // ...\\n}\\n\")), mdx(\"p\", null, \"Overall, this is useful, but you still will not have a function that handles the condition for you to be reusable across your system.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{3, 12-14}\",\n    \"{3,\": true,\n    \"12-14}\": true\n  }, \"function transform(arg: number | string) {\\n  let result = \\\"\\\";\\n  const isString = isItAString(arg);\\n  if (isString) {\\n    result = arg.toLowerCase();\\n  } else {\\n    result = arg.toString();\\n  }\\n  return result;\\n}\\n\\nfunction isItAString(arg: number | string): boolean {\\n  return typeof arg === \\\"string\\\";\\n}\\n\")), mdx(\"p\", null, \"The concept of having the type outside the direction condition also extends to discriminant type. In the following example, we have two interfaces with a common type name with a different value: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \". We can check the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \", and TypeScript will know depending on the value of the check is true for a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Human\"), \" or an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Animal\"), \". Before TypeScript 4.4, it was impossible to store the value inside a variable. Now, it is possible. It means that TypeScript carries the information about the check and the information about the interface. In the example, when the condition is true, the autocomplete will specify only the property of the interface belonging to the right interface. In the first \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"if\"), \" the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"livingSpecie\"), \" will have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"legs\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"networth\"), \" available only.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{14-15}\",\n    \"{14-15}\": true\n  }, \"interface Human {\\n  type: \\\"human\\\";\\n  legs: number;\\n  networth: number;\\n}\\n\\ninterface Animal {\\n  type: \\\"Animal\\\";\\n  legs: number;\\n  sound: string;\\n}\\n\\nfunction showUniqueInformation(livingSpecie: Human | Animal): void{\\n  const isHuman = livingSpecie.type === \\\"human\\\";\\n  if(isHuman){\\n    console.log(livingSpecie.networth);\\n  } else {\\n    console.log(livingSpecie.sound);\\n  }\\n}\\n\")), mdx(\"p\", null, \"The new version of TypeScript also allows more complex cases. For example, imagine that we want to set a value of number or string depending of the type. We need to check both types. We can continue to use the variable to hold the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isHuman\"), \", which help to reduce the repetition. Hence, we see the usefulness of the new feature.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{15-17}\",\n    \"{15-17}\": true\n  }, \"interface Human {\\n  type: \\\"human\\\";\\n  legs: number;\\n  networth: number;\\n}\\n\\ninterface Animal {\\n  type: \\\"Animal\\\";\\n  legs: number;\\n  sound: string;\\n}\\n\\nfunction saveUniqueValue(livingSpecie: Human | Animal, value: string | number): void {\\n  const isHuman = livingSpecie.type === \\\"human\\\";\\n  if (isHuman && typeof value === \\\"number\\\") {\\n    livingSpecie.networth = value;\\n  } else if (!isHuman && typeof value === \\\"string\\\") {\\n    livingSpecie.sound = value;\\n  }\\n}\\n\")), mdx(\"p\", null, \"But we can go a step further and also have the second check-in a variable, and TypeScript will combine the two.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function saveUniqueValue(livingSpecie: Human | Animal, value: string | number): void {\\n  const isHuman = livingSpecie.type === \\\"human\\\";\\n  const isValueHuman = typeof value === \\\"number\\\";\\n  if (isHuman && isValueHuman) {\\n    livingSpecie.networth = value;\\n  } else if (!isHuman && !isValueHuman) {\\n    livingSpecie.sound = value;\\n  }\\n}\\n\")), mdx(\"p\", null, \"It is still important to note that we cannot use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"else\"), \" in the previous code because there is a potential case that we have an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Animal\"), \" with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \" which would not be legit.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"fe5de447-f7b8-57af-a8f4-2f2e691212d5","totalPages":70}},
    "staticQueryHashes": ["3159585216"]}