{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/automapper-and-constructor-with-parameters",
    "result": {"data":{"mdx":{"frontmatter":{"title":"AutoMapper and constructor with parameters","date":"May 6, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"AutoMapper and constructor with parameters\",\n  \"date\": \"2014-05-06\",\n  \"categories\": [\"automapper\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In some use case you are forced to have classes that has \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"constructor with parameters\"), \". This is more rare if you are using Entity Framework (EF) because it requires to have parameterless constructor. However, if the scenario occurs, remember that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AutoMapper\"), \" does not have this constrain. In fact, you can have a private parameterless constructor for Entity Framework (EF) and force the use of a public constructor with parameters when using in your code.\"), mdx(\"p\", null, \"First of all, during the mapping configuration, you must use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConstructUsingServiceLocator\"), \" method. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" Mapper.CreateMap<ContestEditableViewModel, Model.Entities.Contest.Contest>() .ConstructUsingServiceLocator(); \\n\")), mdx(\"p\", null, \"This instruct AutoMapper to check for the option \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConstructServicesUsing\"), \" method that can be provided during the mapping instruction.\"), mdx(\"p\", null, \"Second, when you are using AutoMapper to map between classes, you must specify every parameters.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var model = AutoMapper.Mapper.Map<ContestEditableViewModel, Model.Entities.Contest.Contest>(viewModel , options=>options.ConstructServicesUsing( t=>new Model.Entities.Contest.Contest(yourFirstParameter, yourSecondParameter, \\n /*and so on*/) \\n ) ); \\n\")), mdx(\"p\", null, \"This way, you can have classes that have parameters and control how to provided them values.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"71c910fa-d913-5958-8d9f-c0fb991810f4","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}