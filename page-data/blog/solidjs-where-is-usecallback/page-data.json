{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/solidjs-where-is-usecallback",
    "result": {"data":{"mdx":{"frontmatter":{"title":"SolidJS: Where is useCallback?","date":"April 2, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"SolidJS: Where is useCallback?\",\n  \"date\": \"2022-04-02\",\n  \"categories\": [\"solidjs\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you are coming from React, you may wonder where the hook useCallback is? SolidJS does not have an equivalency because it does not need one!\"), mdx(\"h1\", null, \"React useCallback\"), mdx(\"p\", null, \"React relies on reference to know if something is changing or not. Similarly, SolidJS does the same thing. However, React executes the component code at every render while SolidJS does not. That slight difference is enormous in many ways, and it impacts events, like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onClick\"), \" defined to any HTML element. Using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useCallback\"), \" creates a single \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"instance\"), \" of a function, keeping across all render the same memory reference. Thus, it does not invalidate React's cache at every render.\"), mdx(\"h1\", null, \"SolidJS\"), mdx(\"p\", null, \"SolidJS executes the code of your component once. Hence, you can have a function, an event callback, directly in the component without relying on any external concept, like the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useCallback\"), \". The simplicity of SolidJS shines again, this time with a callback that does not need to be memoized.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"SolidJS departs of React with its simplicity like with its \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./solidjs-first-try-review\"\n  }, \"state that does not re-render components\"), \". The simplicity is a common theme when we think about how easy it is to work with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setTimout\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setInterval\"), \" compared to React, that require using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useRef\"), \" to persist value between re-render. Similarly, the lack of default \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./solidjs-react-on-props-change\"\n  }, \"dependency for \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"createEffect\")), \" to have SolidJS automatically figure out dependency avoid naturally stale data. In this short article, we saw (again) that the non-re-render also provides simplicity with function callback.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"77e4e7c0-1946-5b4b-8223-57d3fa7bde00","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}