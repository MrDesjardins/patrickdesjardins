{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/circular-reference-with-entity-framework-and-json-when-developing-with-asp-net-mvc",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Circular reference with Entity Framework and Json when developing with Asp.Net MVC","date":"October 29, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Circular reference with Entity Framework and Json when developing with Asp.Net MVC\",\n  \"date\": \"2012-10-29\",\n  \"categories\": [\"asp-mvc\", \"entity-framework\", \"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A circular reference was detected while serializing an object of type.\"), mdx(\"p\", null, \"Here come the problem of serializing. First of all, this occur because a parent object reference a child object and this one reference back to its parents. Sound familiar? Well, if you are working with Entity Framework and Code First, it should. Why? Because most of the Entity are cross referencing each others. This way, it's convenient for many operations. For example, if you are a Team entity that has a list of Player, won't it be convenient to have the User having a Team property to access his team name. It's also interesting to do myPlayer.Team.Id = 1 and save the myPlayer. This way you do not have to instantiate the Team 1 object and add the player and save the team. Anyways, that's how Entity Framework work and when it's time to serialize to Json, it can cause this behavior.\"), mdx(\"p\", null, \"The second problem is concerning the object itself. When trying to serialize, you are in fact serializing the Proxy also which is not what you want. In fact, you will get this error.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The RelationshipManager object could not be serialized. This type of object cannot be serialized when the RelationshipManager belongs to an entity object that does not implement IEntityWithRelationships.\")), mdx(\"p\", null, \"This is why you should disable the proxy creation and handle the state of your poco with the DbContext instead of relying on proxy. Disabling the proxy is a matter of setting to false your DbContext's property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ProxyCreationEnabled\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"_dbContext.Configuration.ProxyCreationEnabled = false; \\n\")), mdx(\"p\", null, \"Let's come back to the main purpose of this article. The problem with circular reference can be fixed by two solutions.\"), mdx(\"p\", null, \"The first one, is to broke those references when we send the information to Json. That mean that in your controller, before sending back the ActionResult, you loop problematic property to remove the reference. If we take back the example with Player and Team, we could simply loop the Team array of Player and set to Null all Player\", \"[i]\", \".Team.\"), mdx(\"p\", null, \"The second solution can be to use the attribute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ScriptIgnore\"), \" over the property of Team for example. So, it will serialize only from one side. I haven't try this solution that I have found at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://stackoverflow.com/questions/2002940/json-and-circular-reference-exception\"\n  }, \"StackOverflow.com\"), \" because I do not think that I should alter the Model for the View this way. The serialization process shouldn't impact the model and for sure not to make something work only in half. At the end, we loss the reference on one side which will require to us to rebind it later on.\"), mdx(\"p\", null, \"A better solution is to use a different library of Json which can handle reference, by that I mean the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://james.newtonking.com/projects/json-net.aspx\"\n  }, \"Newton King Library\"), \". This library support circular reference by add ID to object serialized.\"), mdx(\"p\", null, \"First, you need to remove the serialization from the default Json serializer and use the Json Newton King Library. This can be done in the Global.asax.cs file. with the following code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"GlobalConfiguration.Configuration.Formatters.Clear(); \\nGlobalConfiguration.Configuration.Formatters.Add(new JsonNetFormatter(new JsonSerializerSettings()));\\n\\nvar jsonSerializerSettings = new JsonSerializerSettings { \\n  PreserveReferencesHandling = PreserveReferencesHandling.Objects \\n}; \\n\")), mdx(\"p\", null, \"As you can see, we are setting up the PreserceReferencesHandling.Ojects. This will add the reference to object when circular dependencies are found.\"), mdx(\"p\", null, \"This setting add values into the Json structure that in the format \\\"$id\\\": \\\"1\\\" and instead of copying the object over and over (and creating a stack over flow), will use the syntax \\\"$ref\\\": \\\"1\\\" to refer to the object. For example, if we have an object Player that contain the Team and the Team contains the players, than we could have circular reference. The serialization with the library and the PreserceReferencesHandling will produce something similar to the code below if we serialize a single player.\"), mdx(\"p\", null, \"The C\", \"#\", \" code: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"class Program { \\n  static void Main(string[] args) { \\n    var p = new Program(); \\n  }\\n\\n  public Program() { \\n    var t1 = new Team() { \\n      TeamName = \\\"MyTeam\\\" \\n    }; \\n    var p1 = new Player { \\n      PlayerName = \\\"Patrick\\\" ,PlayerTeam = t1 \\n    }; \\n    var p2 = new Player() { \\n      PlayerName = \\\"Melodie\\\" , PlayerTeam = t1 \\n    }; t1.Players.Add(p1); \\n\\n    t1.Players.Add(p2);\\n\\n    var settings = new JsonSerializerSettings() { \\n      PreserveReferencesHandling = PreserveReferencesHandling.Objects \\n    }; \\n    string json = JsonConvert.SerializeObject(p1, settings); \\n    Console.WriteLine(json); \\n    Console.ReadLine(); \\n    //Product deserializedProduct = JsonConvert.DeserializeObject<Player>(json);\\n\\n  } \\n}\\n\\npublic class Player { \\n  public string PlayerName { get; set; } \\n  public Team PlayerTeam { get; set; } \\n}\\n\\npublic class Team { \\n  public string TeamName { get; set; } \\n  public List<Player> Players { get; set; } \\n  public Team() { \\n    this.Players = new List<Player>(); } \\n  } \\n\\nThe result: \\n\\n```javascript\\n{ \\n  \\\"$id\\\":\\\"1\\\", \\n  \\\"PlayerName\\\":\\\"Patrick\\\", \\n  \\\"PlayerTeam\\\": { \\n    \\\"$id\\\":\\\"2\\\", \\n    \\\"TeamName\\\":\\\"MyTeam\\\", \\n    \\\"Players\\\": [ \\n      { \\\"$ref\\\":\\\"1\\\" }, \\n      { \\\"$id\\\":\\\"3\\\", \\n      \\\"PlayerName\\\":\\\"Melodie\\\", \\n      \\\"PlayerTeam\\\": { \\\"$ref\\\":\\\"2\\\" } } \\n      ] \\n    } \\n} \\n\")), mdx(\"p\", null, \"If instead your serialize the team you will get: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"{ \\n  \\\"$id\\\":\\\"1\\\", \\n  \\\"TeamName\\\":\\\"MyTeam\\\", \\n  \\\"Players\\\": [ \\n    {\\\"$id\\\":\\\"2\\\",\\\"PlayerName\\\":\\\"Patrick\\\",\\\"PlayerTeam\\\":{\\\"$ref\\\":\\\"1\\\"}}, \\n    {\\\"$id\\\":\\\"3\\\",\\\"PlayerName\\\":\\\"Melodie\\\",\\\"PlayerTeam\\\":{\\\"$ref\\\":\\\"1\\\"}} \\n  ] \\n} \\n\")), mdx(\"p\", null, \"To conclude, you have to remember two things with Asp.Net MVC and Entity Framework. First, if you have not disabled proxy, than you will have this object serialized and it will cause problem when serializing. Second, you need to break those circular reference to stop the possibility of stack overflow. Using Json Newton library is simple and powerful when it came to handling references.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"82f977b8-7d09-53fb-8afc-be4fa853aeb2","totalPages":75}},
    "staticQueryHashes": ["3159585216"]}