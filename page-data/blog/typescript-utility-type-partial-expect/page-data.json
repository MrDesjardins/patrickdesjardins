{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-utility-type-partial-expect",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Typescript Utility Type Partial Expect","date":"September 5, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Typescript Utility Type Partial Expect\",\n  \"date\": \"2022-09-05\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"How to Transform your Type to Have All Fields Optional Expected Selected Fields to be Required?\"), mdx(\"p\", null, \"The situation is that you want to transform an existing type into all optional fields except a subset of the fields to be required. A use case is that you wish to have all fields except the primary key and many other keys you know must always be present.\"), mdx(\"h1\", null, \"Example Type\"), mdx(\"p\", null, \"We need to create a custom TypeScript utility type to have this new type. But first, let's make a testing type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface MyType {\\n  a: string;\\n  b: string;\\n  c: string;\\n}\\n\")), mdx(\"h1\", null, \"Breaking Down the Utility Types\"), mdx(\"p\", null, \"The result is more straightforward if we break the work into smaller chunks. In other words, we break down the utility types into several utility types. Then, combining the utility types allows us to get the sum of the transformation.\"), mdx(\"p\", null, \"The result is the combination of two operations: picking required fields and picking optional fields.\"), mdx(\"h2\", null, \"Picking Required Fields\"), mdx(\"p\", null, \"To pick the required field, we can take a subset of the fields depending of what the developer specifies as required properties of a type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"type RequiredFielsd<T, K extends keyof T> = Required<Pick<T, K>>;\\n\")), mdx(\"p\", null, \"The first utility type uses two native TypeScript's utility types: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Pick\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Required\"), \".\\nThe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Pick\"), \" extracts from an existing type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" fields specified.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"type MyOtherType1 = RequiredFielsd<MyType, \\\"a\\\">;\\ntype MyOtherType2 = RequiredFielsd<MyType, \\\"a\\\" | \\\"b\\\">;\\n\")), mdx(\"p\", null, \"These two examples create one type that has only a property name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" from the original type that has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" and make it required. The second example creates another type with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" fields required. No \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"c\"), \" field.\"), mdx(\"h2\", null, \"Picking Optional Fields\"), mdx(\"p\", null, \"The second step is to extract the optional field. Similar to the first part, we will leverage the existing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Pick\"), \". In this type, we will not take the field the user specify but the rest of the field (opposite).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"type PartialFields<T, K extends keyof T> = Partial<Pick<T, Exclude<keyof T, K>>>;\\n\")), mdx(\"p\", null, \"The utility type picks all fields that are not specified in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"k\"), \". Then, marks them as optional ( \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"| undefined\"), \"). \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"type MyOtherType3 = PartialFields<MyType, \\\"a\\\">;\\n\")), mdx(\"p\", null, \"The result of this new type is a type with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"c\"), \" that will be both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string | undefined\"), \". No \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \".\"), mdx(\"h1\", null, \"Combining the Utility Functions\"), mdx(\"p\", null, \"Now, we need to combine both.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"type PartialExcept<T, K extends keyof T> = RequiredFielsd<T, K> & PartialFields<T, K>;\\n\")), mdx(\"p\", null, \"Using the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" with the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"K\"), \" means that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RequiredFielsd\"), \" will take the fields specified and mark them as required while all the other fields will be set as optional.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{3}\",\n    \"{3}\": true\n  }, \"type MyFinalType = PartialExcept<MyType, \\\"a\\\">;\\nconst test: MyFinalType = {\\n    a: \\\"Required Value\\\"\\n};\\n\")), mdx(\"p\", null, \"The result is a new type with only \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" required with two optional fields.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"The best tip when working with TypeScript is to break them down into small transformers. Breaking the utility functions makes it easier to understand while creating and later when maintaining. Furthermore, you can reuse a subset of the transformers in another part of your system.\"), mdx(\"p\", null, \"You can find the code in this post in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgLIE8Aq6AOKDeAUMsnAFzIDOYUoA5gNzHIBGF1tIjzC7N9TAL6FCYXCgBKEAI4BXYFAgATAGLAIAG0pKAPJgA0yANLIIAD0ggllZAGsI6APYxkmAHzIAvMilyFynQAFYARbPUMjNzcmMTw0dAB5MAALaGw8AEYvHxl5RVV1LV0MdIhDACI4cujRcXik1KhSgCZs3zzlNU1tHRLxCqrkAB9kcpZqplq4wLgoMGA4DS6Na3DjUwsIKxt7Jxd3bJm5hY0gkLCDZABRMwQNWSUIHV3nVwiomtiUDAa08QBmQ6zeaLZarPp4AYTERfZBHEEaG5IHBgNYmcyWax2ByvA7edr+ArdXSXSLIABkcOBJzBlDRNSm33QahAi1KQOOiyREBRvSw-VGVRqCEcIGoyEg1AoGBZbLq3iIJBI5FGBPy5UIggYQA\"\n  }, \"TypeScript Playground\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"45ae03c6-1674-57db-af6d-95953b2b8721","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}