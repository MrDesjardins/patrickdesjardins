{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/entity-framework-4-3-an-object-with-the-same-key-already-exists-in-the-objectstatemanager",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Entity Framework 4.3:  An object with the same key already exists in the ObjectStateManager","date":"April 16, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Entity Framework 4.3:  An object with the same key already exists in the ObjectStateManager\",\n  \"date\": \"2012-04-16\",\n  \"categories\": [\"entity-framework\", \"general\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This situation occur if you have already the object inside the DbContext and you try to Attach your instance. Most of the time you can manage it but just remove the Attach method but in some case that you might not know if the instance is inside the DbContext you may would like to check it before attaching.\"), mdx(\"p\", null, \"This can be done with the help of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DbSet\"), \" and its \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Local\"), \" property which is a collection of Locally attached entity.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"if (!Database.Set<MyObject>().Local.Any(e => e.ID == myObject.ID)) \\n  Database.MyObjects.Attach(myObject); \\nelse myObject = Database.Set<MyObject>().Local.Single(e => e.ID == myObject.ID); \\n\")), mdx(\"p\", null, \"The first line verify if the Local repositor contains or not your object. This line use the primary has identifier (ID). If it doesn't contain anything, the object is attached. Otherwise, your object will takes the reference of the one of the Local repository. This way, it won't create a new instance of your object. Without the fourth line, you could end up with a new entry into the database even if the primary key is the same as an existing one (Entity Framework will do an Insert and the ID will auto-increment).\"), mdx(\"p\", null, \"I am still curious to know why in some simple project, I can simply attach and never having the possibility to have twice the same object in the Local property.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"7701c02f-dd56-5219-91e3-6a18c6a92878","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}