{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-moq-a-portion-of-a-class-and-test-the-other-part-of-it",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to Moq a Portion of a Class and Test the Other Part of it","date":"February 20, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to Moq a Portion of a Class and Test the Other Part of it\",\n  \"date\": \"2015-02-20\",\n  \"categories\": [\"test\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Unit testing against an interface is something that we do often with the help of Mock's framework. This allow to not execute code that we are not testing - to concentrate on the real code to test. However, what happen if you want to test a concrete class and only test a portion of it - you want to mock the other inherited method of that interface. Let's say that that we have a simple class that inherit an interface with two methods. If one method call the other and that we do not want to test this other method than we want to mock. For example, if you have one method that does some logic, call the second method that is slow because it goes into the file system, the web or has other logic that you do not want to tests, than you are in this scenario. Here is some code that we will use to demonstrate how to test only a portion of a class whilst having the rest Moq.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public interface IMyInterface { void TransformationA(); void TransformationB(); }\\n\\npublic class MyConcreteImplementation : IMyInterface { public MyConcreteImplementation(int counter) { Counter = counter; }\\n\\npublic int Counter { get; set; } public void TransformationA() { Counter++; TransformationB(); Counter++; }\\n\\npublic void TransformationB() { Thread.Sleep(25000); } } \\n\")), mdx(\"p\", null, \"We have a class named \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"MyConcreteImplementation\"), \" that implements the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IMyInterface\"), \". The purpose of the test would me to test the method \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TransformationA\"), \". This mean that we want to Mock TransformationB. This is problematic because we cannot mock the whole concrete instance of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"MyConcreteImplementation\"), \" because the test will be against the mock and not the instance. However, we can mock the method we want to test to execute the real concrete implementation and keep the mock on the other method. The unit test should looks like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" [TestClass] public class TransformationATest { [TestMethod] public void MyTest() { //Arrange var whatWeWantToTest = new MyConcreteImplementation(100); var mock = new Mock<IMyInterface>(); mock.Setup(d => d.TransformationA()).Callback(whatWeWantToTest.TransformationA); // -- We do nothing for B --\\n\\n// Act mock.Object.TransformationA();\\n\\n//Assert Assert.AreEqual(102, whatWeWantToTest.Counter);\\n\\n} } \\n\")), mdx(\"p\", null, \"The code is creating a mock and use the mocking's framework to do a callback on the real implementation that we want to test. The test occurs on the mock which act as a proxy for the concrete implementation. This way, the mocking framework is acting as it should for all methods excepted the one we want to test.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"288px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/e2b393c04e139dcf0b36b5aad9e83c2a/477c9/MyTestGreen.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"25.694444444444443%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABSElEQVQY0yXOTUsbQQDG8XzPWhT8Cj0sQo9SKgi25949NNbqoQqKlUJBKii22ezLjDOzL5nNGje7m2oEY+Yvxufy8Fx+PB07LLkc9/jZ+8PJxRW5MfR9n+tY4P/tIYRECknYj9BKEQYB1g6pqmqxb6tbdK1QY42pUzoOR1NPOC8uSNqEyo4QQpAlBv9fQBDG6GuNMSlhJDFKEwtFVddEkWRQWNI2Q49Tkian45zDzecMmxFylNAvBYXJyVRMJgIGKqY0EYWOyaVPmcS0Nzljq3hoRsCUYiKxE4Gd6FdwkRnkTYG9L7jSIZ8PJRs/BqzvJ3hfDd5Oxvu9Am8n5cNxi9dNWD9q2fp1x+ZpzsfTki9nls6LtXjJK/wwm3J24/Pp9xNrxw7vyLH63bG861j+Nmdl1/G2+7jope6MN9v/8Q4eeXfg2DiZ8gzmtGClvP+xqQAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"MyTestGreen\",\n    \"title\": \"MyTestGreen\",\n    \"src\": \"/static/e2b393c04e139dcf0b36b5aad9e83c2a/477c9/MyTestGreen.png\",\n    \"srcSet\": [\"/static/e2b393c04e139dcf0b36b5aad9e83c2a/477c9/MyTestGreen.png 288w\"],\n    \"sizes\": \"(max-width: 288px) 100vw, 288px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"You can find this example on GitHub : \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/MockingPortionOfCode\"\n  }, \"https://github.com/MrDesjardins/MockingPortionOfCode\"), \". It uses Moq as Mocking's framework but any others would do the same.\"), mdx(\"p\", null, \"If you want to do the samething with a method that return a result, instead of using the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Callback\"), \" method, use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Returns\"), \" method of your mocking framework.\"), mdx(\"p\", null, \"Edit (2016-08-09): It's also possible to do it pretty easily if the method tested is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"virtual\"), \". Here is a real example where we mock a concrete class by supplying all parameters like we would do normally. The setup take out the method you do not want to execute of the tested class. This is the one the need to be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"virtual\"), \". The assertion can check that method to see if it's been touched. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" // Arrange var mock = new Mock<PortefolioAccessor>(this.runningContest.Object, this.unitOfWork.Object, this.UnitOfWorkDapper.Object, this.portefolioRepository.Object, this.cache.Object); mock.Setup(d => d.SetPortefolioInCache(It.IsAny<Portefolio>(), false));\\n\\n// Act mock.Object.SaveInterDayStatistics(contest);\\n\\n// Assert mock.Verify(d=>d.SetPortefolioInCache(It.IsAny<Portefolio>(), false), Times.Exactly(1)); \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"1aa5feee-4664-555f-ae83-58b4f7e62077","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}