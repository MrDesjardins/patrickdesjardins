{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/enterprise-asp-net-mvc-part-5-database-context-and-impersonate-data",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Enterprise Asp.Net MVC Part 5: Database Context and Impersonate data","date":"November 5, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Enterprise Asp.Net MVC Part 5: Database Context and Impersonate data\",\n  \"date\": \"2012-11-05\",\n  \"categories\": [\"ado-net\", \"asp\", \"asp-mvc\", \"c-sharp\", \"enterprise\", \"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The database context is abstracting the connection between entity and Entity Framework.\\nWe won't abstract all method of the Entity Framework and Linq to Entity like \\\"Where\\\", \\\"Select\\\", \\\"Find\\\", \\\"First\\\", etc but we will abstract the entry point : DbSet.\\nIn fact, the reason is to be able to add ability to impersonate later and to be able to configure your entity that you need to have this DatabaseContext.\\nThe role of the factory is not to configure Entity Framework, neither to impersonate. The database context role is to do those task.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public interface IDatabaseContext { \\n   int SaveChanges(); IDbSet<TEntity> SetOwnable<TEntity>() where TEntity : class, IUserOwnable; DbSet<TEntity> Set<TEntity>() where TEntity : class; \\n   DbEntityEntry<TEntity> Entry<TEntity>(TEntity entity) where TEntity : class; \\n   void InitializeDatabase(); \\n   UserProfileImpersonate Impersonate(ICurrentUser userProfile); \\n} \\n\")), mdx(\"p\", null, \"For the moment, the interface of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IDatabaseContext\"), \" looks like this. We have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SaveChanges\"), \" because we might want to do operation over several repository and want to manually commit changes in a specific time.\\nThis will be the role of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SaveChanges\"), \" method. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SetOwnable<>\"), \" method will act like the default Set method but will automatically assign the user to the entity.\\nThis will be good for the loading and for the saving. When in the loading, we won't have to specify every time that we want the workout for the userA, etc. It will be automatically.\\nThis save us time, possibility of error and also improve the security because by default, everything will be bound the the current user.\\nThe InitializeDatabase method will be a method to configure extra database stuff. For example, in this project, I am using this method to setup the WebSecurity (membership layout for WebMatrix).\\nThe last method is the method that will give us some impersonation for the time of a query depending of another user profile.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class DatabaseContext : DbContext, IDatabaseContext { \\n  public const string DEFAULTCONNECTION = \\\"DefaultConnection\\\";\\n\\n  public DatabaseContext(IUserProvider userProvider) { \\n    UserProvider = userProvider;\\n    base.Database.Connection.ConnectionString = ConfigurationManager.ConnectionStrings[DEFAULTCONNECTION].ConnectionString; \\n    Configuration.ProxyCreationEnabled = false; \\n  }\\n\\n  public IUserProvider UserProvider { get; set; }\\n\\n  public ICurrentUser CurrentUser { get { return UserProvider.Account; } }\\n\\n  public new DbSet<TEntity> Set<TEntity>() where TEntity : class { \\n    if (typeof(IUserOwnable) is TEntity) { \\n      throw new SecurityException(\\\"You cannot by pass the ownable security\\\"); \\n    }\\n    return base.Set<TEntity>(); \\n  } \\n  \\n  public IDbSet<TEntity> SetOwnable<TEntity>() where TEntity : class, IUserOwnable { \\n    return new FilteredDbSet<TEntity>(this, entity => entity.UserId == CurrentUser.UserId, entity => entity.UserId = CurrentUser.UserId); \\n  }\\n\\n  public void InitializeDatabase() { \\n    WebSecurity.InitializeDatabaseConnection(DEFAULTCONNECTION, \\\"UserProfile\\\", \\\"UserId\\\", \\\"UserName\\\", autoCreateTables: true); \\n  }\\n\\n  protected override void OnModelCreating(DbModelBuilder modelBuilder) { \\n    base.OnModelCreating(modelBuilder); \\n    //Call here some other classes to build the configuration of Entity Framework \\n  }\\n\\n  public UserProfileImpersonate Impersonate(ICurrentUser userProfile) { \\n    return new UserProfileImpersonate(this, userProfile); \\n  } \\n} \\n\")), mdx(\"p\", null, \"This is a small example. That talk for itself. The two interesting part is the SetOwnable that use a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilteredDbSet\"), \" which the code has been trimmed from a version that you can find over the web and that we will discuss later.\\nThe other part is the Impersonate method that we will talk now.\"), mdx(\"p\", null, \"Lets start with the end result. For now, if you want to insert into the database a new Workout entity you need in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WorkoutRepository\"), \" to do : \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" DatabaseContext.SetOwnable<Workout>().Add(entity); \\n\")), mdx(\"p\", null, \"This will automatically insert a new workout to the current logged user. If you want to change the user, you could use the Set but because we override the Set method and check if the it inherit from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IUserOwnable\"), \" interface.\\nThis is the required interface to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SetOwnable\"), \" method. This way, we can get the user id. But, to protect developer to by pass this mechanism, an exception is thrown if we use Set method with entity that are ownable.\\nThat doesn't mean that you cannot save to an other user, but will require more work with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"impersonating\"), \". Why adding some over head and not letting the developer directly use the Set when he want to save an entity to someone else authority? Simply because all entity will inherit from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IUserOwnable\"), \" because it will be a lot easier to work with without having to always specify the user inside the repository.\\nAlso, repository doesn't have access directly to the user id. That's say, it's a painful process. Not letting access directly to the Set avoid the mistake to simply user \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Set\"), \" method for an entity. An exception will be thrown and the developer will automatically remember to user the SetOwnable method instead. If he really mean to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Set\"), \" method, than the impersonate method will be appropriate.\"), mdx(\"p\", null, \"For general entity, let say that we have a list of status that are shared across all entities or shared across all users, the entity won't inherit of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IUserOwnable\"), \" because it's not a user ownable entity. So in theory it works, let check in practice! \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"using (var db = DatabaseContext.Impersonate(new UserProfile { UserId = 1 })) { \\n   db.SetOwnable<Workout>().Add(entity);\\n} \\n\")), mdx(\"p\", null, \"This would be in the repository instead of the last piece of code. As you can see, we impersonate with a UserProfile with the Id 1. The code is around curly bracket and give us the scope of when the impersonation start and end.\"), mdx(\"p\", null, \"The DatabaseContext class implementation of Impersonate simply call a new DbContext. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public UserProfileImpersonate Impersonate(ICurrentUser userProfile) { return new UserProfileImpersonate(this, userProfile); } \\n\")), mdx(\"p\", null, \"A new class is used because we want to have a scope which is done by inherit from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IDisposable\"), \" interface. We will create a new instance of Impersonate and dispose it to come back with the real \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Current User\"), \" and not the impersonate one.\\nThe class is mostly the same as the DbContext but has a reference to the user profile before the impersonate because we want to set it back once it's done.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class UserProfileImpersonate : IDatabaseContext, IDisposable { \\n  private readonly DatabaseContext_databaseContext;\\n\\n  private readonly IUserProvider_oldUserProvider;\\n\\n  #region Implementation of IDisposable\\n\\n  public UserProfileImpersonate(DatabaseContext dbContext, ICurrentUser userProfile) {\\n    _databaseContext = dbContext;\\n    _oldUserProvider = dbContext.UserProvider;\\n    _databaseContext.UserProvider = new ImpersonateUserProvider(userProfile); \\n  }\\n\\n  public void Dispose() {\\n    _databaseContext.UserProvider =_oldUserProvider; \\n  }\\n\\n  #endregion\\n\\n  #region Implementation of IDatabaseContext\\n\\n  public int SaveChanges() { return_databaseContext.SaveChanges(); }\\n\\n  public IDbSet<TEntity> SetOwnable<TEntity>() where TEntity : class, IUserOwnable { return_databaseContext.SetOwnable<TEntity>(); }\\n\\n  public DbSet<TEntity> Set<TEntity>() where TEntity : class { return_databaseContext.Set<TEntity>(); }\\n\\n  public DbEntityEntry<TEntity> Entry<TEntity>(TEntity entity) where TEntity : class { return_databaseContext.Entry(entity); }\\n\\n  public void InitializeDatabase() {_databaseContext.InitializeDatabase(); }\\n\\n  public UserProfileImpersonate Impersonate(ICurrentUser userProfile) { return_databaseContext.Impersonate(userProfile); }\\n\\n#endregion } \\n\")), mdx(\"p\", null, \"Simple isn't? We simply call the same database context method but only change the current logged user profile. Single task to do which respect the single responsibility principle.\"), mdx(\"h3\", null, \"Series Articles\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-part-1-mvc-the-planification\"\n  }, \"Article #1: Asp.Net MVC Enterprise Quality Web Application\"), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-2-building-the-model\"\n  }, \"Article #2: Asp.Net MVC Enterprise Quality Web Application Model\"), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-3-controller\"\n  }, \"Article #3: Asp.Net MVC Enterprise Quality Web Application Controller\"), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-4-repository\"\n  }, \"Article #4: Asp.Net MVC Enterprise Quality Web Repository Layer\"), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-5-database-context-and-impersonate-data\"\n  }, \"Article #5: Asp.Net MVC Enterprise Quality Web with Entity Framework\"), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-6-the-three-layers-of-validation\"\n  }, \"Article #6: Asp.Net MVC Enterprise Quality Layers\"), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-7-securing-action-with-role-authorization\"\n  }, \"Article #7: Asp.Net MVC Enterprise Quality Web Security\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/GymWorkout\"\n  }, \"Source code on GitHub\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"ce7ccfd9-7684-59a7-ad76-293bba18a4b1","totalPages":69}},
    "staticQueryHashes": ["3159585216"]}