{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/how-to-get-react-router-route-segment",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to get React Router Route Segment","date":"January 4, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to get React Router Route Segment\",\n  \"date\": \"2018-01-04\",\n  \"categories\": [\"react\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Using React-Router library is almost the defacto in the industry right now. It handles many scenarios around how to route and handle URL on the client side. One specific case is that you may have some custom parameter that you want to extract to show specific information. For example, if you have a user and desire to have an url with the user id to load the user's profile when the user visits the URL, the routing system must load the user profile component and let you know which user has been requested.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"class Page extends React.Component<PageProps, PageState> { constructor() { super(); }\\n\\n  public render(): JSX.Element { \\n    return <div> \\n      <Switch> \\n        <Route path={\\\"UserProfile/:userId\\\"} \\n          component={UserProfile} /> \\n          <Route path=\\\"/\\\" component={MainPage} /> \\n      </Switch> </div>; \\n    } \\n} \\nconst c = connect(mapStateToProps, mapDispatchToProps)(Page); \\nexport default withRouter(c as any); \\n\")), mdx(\"p\", null, \"The code above illustrates two routes. The first route is the user profile which takes a user id as part of the url. The second is the default page which doesn't need anything. The challenge is how to get from the UserProfile component the userId. It's easy once you know what will happen. What happens is that the routing library will push a property to the component specified under \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"match\"), \". It means that if you are using Typescript that you must specify that member in the property of the component. Let's create a simple user profile component that displays the user id.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"class UserProfile extends React.Component<UserProfileProps, {}> {\\n\\n  public render(): JSX.Element { \\n    return <div> <p> User Id # {this.props.match.params.userId} </p> </div>; \\n  } \\n}\\n\\nexport default connect(mapStateToProps, mapDispatchToProps)(UserProfile); \\n\")), mdx(\"p\", null, \"The heart of the problem is to have the match member in your property and to do so you need to add manually a match entry and use the \\\"match\\\" class from the definition file of react-router. This one is generic and let you specify which token in the route you want. In our example, it is the user id.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import { match } from \\\"react-router\\\"; \\nexport interface UserProfileRouteTokens { \\n  userId: number; \\n} \\nexport interface UserProfileProps { \\n  match: match<UserProfileRouteTokens>; \\n} \\n\")), mdx(\"p\", null, \"This doesn't restrain additional properties, but force you to have one called \\\"match\\\". Back to the component, you can access the segment of the url with auto-complete. From there, you can load the user data by calling a dispatch action or whatever you want to do in that page.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"4768a040-9a1d-5b63-b0cf-140869ab4b38"}},
    "staticQueryHashes": ["3159585216"]}