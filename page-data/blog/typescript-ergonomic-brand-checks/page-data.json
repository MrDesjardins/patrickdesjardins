{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-ergonomic-brand-checks",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript Ergonomic Brand Checks","date":"February 4, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript Ergonomic Brand Checks\",\n  \"date\": \"2022-02-04\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In short, the term \\\"Ergonomic Brand Checks\\\" is linked to branding. Branding is a way to dynamically check for a type. It comes with JavaScript being schemaless. In JavaScript, you need to check for a field/property that exist on an object to ensure you are manipulating an object desired. For example, if you have an array of different objects, you might want to check if you are modifying a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" or an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Animal\"), \" before accessing (read or write) the object.\"), mdx(\"p\", null, \"With \\\"Ergonomic Brand Checks\\\" we are especially properties of an object. What is worth talking about is that TypeScript 4.5 allows checking private fields using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"in\"), \" operator.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{10}\",\n    \"{10}\": true\n  }, \"class Person {\\n    #shortname: string;\\n    public constructor(name: string) {\\n        this.#shortname = name;\\n    }\\n\\n    public static isPerson(obj: unknown): unknown {\\n        return obj &&\\n            typeof obj === \\\"object\\\" &&\\n            #shortname in obj;\\n    }\\n}\\n\\nclass Animal {\\n    #shortname: string;\\n    public constructor(name: string) {\\n        this.#shortname = name;\\n    }\\n}\\n\\nconst x1 = { shortname: \\\"Test\\\" };\\nconst x2 = new Person(\\\"Test2\\\");\\nconst x3 = new Animal(\\\"Test3\\\");\\nconsole.log(Person.isPerson(x1)); // False\\nconsole.log(Person.isPerson(x2)); // True\\nconsole.log(Person.isPerson(x3)); // False\\n\")), mdx(\"p\", null, \"Line 10 highlights and presents the newest addition for ergonomic brand check-in TypeScript. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"in\"), \" operator within the static function of a class is used to check if a private field exists. Oddly, the function does not return a boolean but \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"unknown\"), \". Changing the parameter type to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any\"), \" gives an output of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any\"), \". However, the output is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" when executing the code.\"), mdx(\"p\", null, \"An interesting observation is that the last line returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" when we pass an instance of the class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Animal\"), \" even though the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Animal\"), \" classes share the same field name. Actually, the value is also not relevant. The previous example modified to have the static function relying on a field that is not used but defined.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{2, 11, 16}\",\n    \"{2,\": true,\n    \"11,\": true,\n    \"16}\": true\n  }, \"class Person {\\n    #brand: unknown;\\n    #shortname: string;\\n    public constructor(name: string) {\\n        this.#shortname = name;\\n    }\\n\\n    public static isPerson(obj: unknown): unknown {\\n        return obj &&\\n            typeof obj === \\\"object\\\" &&\\n            #brand in obj;\\n    }\\n}\\n\\nclass Animal {\\n    #brand: unknown;\\n    #shortname: string;\\n    public constructor(name: string) {\\n        this.#shortname = name;\\n    }\\n}\\n\\nconst x1 = { shortname: \\\"Test\\\" };\\nconst x2 = new Person(\\\"Test2\\\");\\nconst x3 = new Animal(\\\"Test3\\\");\\nconsole.log(Person.isPerson(x1)); // False\\nconsole.log(Person.isPerson(x2)); // True\\nconsole.log(Person.isPerson(x3)); // False\\n\")), mdx(\"p\", null, \"The trick of using unsused private property has been there for a while. What is new is the possibility to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"in\"), \". I'll conclude by referring to a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://michalzalecki.com/nominal-typing-in-typescript/\"\n  }, \"great article by Michal Zalecki\"), \" about four ways to nominal typing techniques in TypeScript.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"4e509ac4-314d-5bf7-a9ee-50d3de9e86d0","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}