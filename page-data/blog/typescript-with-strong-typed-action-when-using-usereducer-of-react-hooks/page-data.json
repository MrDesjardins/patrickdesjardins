{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-with-strong-typed-action-when-using-usereducer-of-react-hooks",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript with Strong Typed Action when using useReducer of React Hooks","date":"March 5, 2019"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript with Strong Typed Action when using useReducer of React Hooks\",\n  \"date\": \"2019-03-05\",\n  \"categories\": [\"react-hooks\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The technic I will demonstrate in this article comes from what I was using with the traditional React and Redux. Now, with React Hooks we do not need to use Redux anymore but the same principles exist with the hook \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \". I have witnessed many people struggling using TypeScript and Redux because they are passing strings around instead of a string literal. Often, the struggle I hear is around the boilerplate required as well as it is not strongly typed. Let's try to make it as simple as possible and strongly typed in term of action name and action payload\"), mdx(\"h2\", null, \"Code\"), mdx(\"p\", null, \"If you want to play around with what I will present, you can jump into the code sandbox available under this paragraph. However, keep in mind that you will not see the benefit of having Intellisense showing available actions and the security of working in VsCode where it will warn you if you are passing something of the wrong type -- this is a limitation of the online sandbox tool. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"The demonstration has many files, I suggest you click \\\"Open in Editor\\\" and click the hamburger menu to navigate between files.\")), mdx(\"iframe\", {\n    src: \"https://codesandbox.io/embed/ll6n2p8omq?fontsize=14view=editor\",\n    style: {\n      \"width\": \"100%\",\n      \"height\": \"500px\",\n      \"border\": \"0\",\n      \"borderRadius\": \"4px\",\n      \"overflow\": \"hidden\"\n    },\n    sandbox: \"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"\n  }), mdx(\"h2\", null, \"Configuring the Actions\"), mdx(\"p\", null, \"The first step is to get some types. Once you have that code in your project, you will be good to go without touching it. I am posting the code and will explain what it does.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"/**\\n * Create an action that has a strongly typed string literal name with a strongly typed payload\\n */\\nexport function createActionPayload<TypeAction, TypePayload>(\\n  actionType: TypeAction\\n): (payload: TypePayload) => ActionsWithPayload<TypeAction, TypePayload> {\\n  return (p: TypePayload): ActionsWithPayload<TypeAction, TypePayload> => {\\n    return {\\n      payload: p,\\n      type: actionType,\\n    };\\n  };\\n}\\n\\n/**\\n * Create an action with no payload\\n */\\nexport function createAction<TypeAction>(\\n  actionType: TypeAction\\n): () => ActionsWithoutPayload<TypeAction> {\\n  return (): ActionsWithoutPayload<TypeAction> => {\\n    return {\\n      type: actionType,\\n    };\\n  };\\n}\\n/**\\n * Create an action with a payload\\n */\\nexport interface ActionsWithPayload<TypeAction, TypePayload> {\\n  type: TypeAction;\\n  payload: TypePayload;\\n}\\n\\n/**\\n * Create an action that does not have a payload\\n */\\nexport interface ActionsWithoutPayload<TypeAction> {\\n  type: TypeAction;\\n}\\n\\n/**\\n * A very general type that means to be \\\"an object with a many field created with createActionPayload and createAction\\n */\\ninterface ActionCreatorsMapObject {\\n  [key: string]: (\\n    ...args: any[]\\n  ) => ActionsWithPayload<any, any> | ActionsWithoutPayload<any>;\\n}\\n\\n/**\\n * Use this Type to merge several action object that has field created with createActionPayload or createAction\\n * E.g. type ReducerWithActionFromTwoObjects = ActionsUnion<typeof ActionsObject1 & typeof ActionsObject2>;\\n */\\nexport type ActionsUnion<A extends ActionCreatorsMapObject> = ReturnType<\\n  A[keyof A]\\n>;\\n\")), mdx(\"p\", null, \"The first function uses a type named \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ActionsWithPayload\"), \". The function must be used when you create a new action that carry a payload. It will take two generics type. The former is the string literal of your type: a unique identifier for your action. The latter is the type of the payload. For example, you can set a field of an entity, like the name of a person, by using the following code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"setName: createActionPayload<typeof ACTION_SET_NAME, string>(ACTION_SET_NAME);\\n\")), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setName\"), \" is the strongly typed function of the action that you use to dispatch later on. It is linked to the specific string literal ACTION_SET_NAME (unique identifier) and the payload that can be passed to the action is only a string. You invoke the action by calling that function with the payload that you desire:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"dispatch(setName(\\\"MyNewNameHere\\\"));\\n\")), mdx(\"p\", null, \"The return of the function \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"createActionPayload\"), \" is an object with the payload and the type -- both strongly typed. It allows to have in your reducer a comparison on the type which is unique because it is not a string -- but a string literal type. To accomplish this feat, you must define one type per action. That is why, in your reducer file (or the file you want to store all your actions) you must defined a one line per action\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export const ACTION_INCREASE_COUNT = \\\"ACTION_INCREASE_COUNT\\\";\\nexport const ACTION_SET_NAME = \\\"ACTION_SET_NAME\\\";\\n\")), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"createActionPayload\"), \" has also a sibling function \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"createAction\"), \" that does not take any payload. It works in a similar fashion which is that the type of the action is a unique string literal, but that time without a payload.\"), mdx(\"p\", null, \"To recap what we need to far: first, we need to create a constant that is a string literal that will be used as a unique identifier of the action. Second, we need to create a function that has a payload strongly typed by the action's type. To tidy up everything, I usually group all common action in a single object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export const AppActions = {\\n  increaseCount: createAction<typeof ACTION_INCREASE_COUNT>(\\n    ACTION_INCREASE_COUNT\\n  ),\\n  setName: createActionPayload<typeof ACTION_SET_NAME, string>(ACTION_SET_NAME),\\n};\\n\")), mdx(\"p\", null, \"It changes slightly how to invoke the action which is clearer. It \\\"namespaces\\\" the action.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"dispatch(setName(\\\"MyNewNameHere\\\")); // Before\\ndispatch(AppActions.setName(\\\"MyNewNameHere\\\")); // After\\n\")), mdx(\"h2\", null, \"Reducer\"), mdx(\"p\", null, \"The reducer is exactly like with Redux, it is a function that takes a state and an action. However, our actions will be constrained to the group of action we allow for the reducer.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export function appReducer(\\n  state: AppReducerState,\\n  action: AcceptedActions\\n): AppReducerState {\\n  // ...\\n}\\n\")), mdx(\"p\", null, \"Because we have a strongly typed function per action, we can now define a collection of allowed actions. It helps when you have several reducers in an application to limit the scope of what is expected. If you are tidying the action in an object as proposed, you can do:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export type AcceptedActions = ActionsUnion<typeof AppActions>;\\n\")), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"AcceptedActions\"), \" type is from the type you add in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ActionsUnion\"), \". It means you can add several group of action if you desire with the following syntax.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"ActionsUnion<typeof ActionsObject1 & typeof ActionsObject2>;\\n\\n\")), mdx(\"p\", null, \"Here is the complete reducer, like any reducer that you are used to code. However, the switch case only accept cases with the name that are from the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"AcceptedState\"), \" which clarify what is possible or not to reduce.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export function appReducer(\\n  state: AppReducerState,\\n  action: AcceptedActions\\n): AppReducerState {\\n  switch (action.type) {\\n    case ACTION_INCREASE_COUNT:\\n      return {\\n        ...state,\\n        clickCount: state.clickCount + 1,\\n      };\\n    case ACTION_SET_NAME:\\n      return {\\n        ...state,\\n        activeEntity: { ...state.activeEntity, ...{ name: action.payload } },\\n      };\\n  }\\n  return state;\\n}\\n\")), mdx(\"h2\", null, \"React Hooks useReducer\"), mdx(\"p\", null, \"The last piece of the puzzle is how to consume the data from the reducer's state and how to mutate the value. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" function is a React Hooks that take the reducer function and the initial state as parameter. It returns the state and the dispatcher funciton.\"), mdx(\"p\", null, \"const \", \"[state, dispatch]\", \" = useReducer(appReducer, appState);\"), mdx(\"p\", null, \"To read the value of the state, it is a matter to use the variable state. Because the state is strongly typed, you will get your IDE support as well as static validation from TypeScript. Same for the invocation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"<button\\n  onClick={() => {\\n    dispatch(AppActions.increaseCount());\\n  }}\\n>{`Increase State Count ${state.clickCount}`}</button>\\n\")), mdx(\"p\", null, \"The dispatch requires a function. We reuse the tidy object to select the action. The object is strongly typed, hence when typing you get a nice autocompletion of what action can be dispatched. You avoid any potential mistake of using a variable that is not supported by the reducer. In that example, there is no payload, but the following example shows a strongly typed action with a strongly typed argument.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"<button\\n  onClick={() => {\\n    dispatch(AppActions.setName(\\\"test\\\"));\\n  }}\\n>\\n\")), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"With about 50 lines of TypeScript, you get few utility functions and types to handle React Hooks's reducer with TypeScript in a pleasant way. As a developer, a new action is a matter of adding a line to uniquely identifier the action, and to define a one-line function to associate the action to a payload type. The reducer is strongly typed, the dispatch of action is also strongly typed. The solution scales well with multiple reducers, it works well with clarifying what can be dispatched and ensure consistency within the application by having a design that group actions of a similar domain together.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"3f586e27-7e08-5de2-b1d9-cca20911f05e","totalPages":69}},
    "staticQueryHashes": ["3159585216"]}