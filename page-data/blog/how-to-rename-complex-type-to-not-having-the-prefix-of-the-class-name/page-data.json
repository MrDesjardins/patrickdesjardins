{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-rename-complex-type-to-not-having-the-prefix-of-the-class-name",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to rename complex type to not having the prefix of the class name","date":"June 13, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to rename complex type to not having the prefix of the class name\",\n  \"date\": \"2013-06-13\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Entity Framework has a standard with the naming of column. This is also the case with complex type which will be added to every tables where complex type are used by entities. By default, Entity Framework will concatenate the name of the complex type with an underscore and the name of the property.\"), mdx(\"p\", null, \"If you prefer not having complex type name, you can simply specify the column name you desire.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" modelBuilder .ComplexType<Audit>()\\n .Property(type => type.CreatedBy)\\n .HasColumnName(\\\"CreatedBy\\\"); \\n\")), mdx(\"p\", null, \"In the database instead of having a field with \\\"Audit_CreatedBy\\\" you will have only \\\"CreatedBy\\\". This may be useful in some situation, but by experience it's easier to do the mapping between complex type when you \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"keep\"), \" the prefix. It's up to you, and your coding/database standard, to figure out if it's appropriate or not.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"aeb0a48f-926b-58b6-a448-b853cb594b35","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}