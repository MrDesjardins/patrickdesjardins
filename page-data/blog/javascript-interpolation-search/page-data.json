{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/javascript-interpolation-search",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Interpolation Search","date":"June 22, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Interpolation Search\",\n  \"date\": \"2017-06-22\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If an array contains element that are uniformly distributed, it's possible to each an asymptotic analysis of Big O(log log n).\"), mdx(\"p\", null, \"The whole problem is about determining the position. This is done by finding the position. This is the iterative solution.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var arrayToSearch = [2, 6, 8, 12, 14, 16, 20, 24, 26, 28, 30, 31, 35];\\n\\nconsole.log(\\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 2));\\nconsole.log(\\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 12));\\nconsole.log(\\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 35));\\nconsole.log(\\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 44444));\\n\\nfunction interpolationSearch(arrayToSearch, valueToSearch) {\\n  var length = arrayToSearch.length;\\n  var low = 0;\\n  var high = length - 1;\\n  var position = -1;\\n  var delta = -1;\\n  while (\\n    low <= high &&\\n    valueToSearch >= arrayToSearch[low] &&\\n    valueToSearch <= arrayToSearch[high]\\n  ) {\\n    delta =\\n      (valueToSearch - arrayToSearch[low]) /\\n      (arrayToSearch[high] - arrayToSearch[low]);\\n    position = low + Math.floor((high - low) * delta);\\n    if (arrayToSearch[position] == valueToSearch) {\\n      return position;\\n    }\\n    if (arrayToSearch[position] < valueToSearch) {\\n      low = position + 1;\\n    } else {\\n      high = position - 1;\\n    }\\n  }\\n\\n  return -1;\\n}\\n\")), mdx(\"p\", null, \"This can be easily transformed into the a recursive algorithm.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var arrayToSearch = [2, 6, 8, 12, 14, 16, 20, 24, 26, 28, 30, 31, 35];\\nvar length = arrayToSearch.length;\\nvar low = 0;\\nvar high = length - 1;\\nconsole.log(\\n  \\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 2, 0, high)\\n);\\nconsole.log(\\n  \\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 12, 0, high)\\n);\\nconsole.log(\\n  \\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 35, 0, high)\\n);\\nconsole.log(\\n  \\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 44444, 0, high)\\n);\\n\\nfunction interpolationSearch(arrayToSearch, valueToSearch, low, high) {\\n  if (\\n    low <= high &&\\n    valueToSearch >= arrayToSearch[low] &&\\n    valueToSearch <= arrayToSearch[high]\\n  ) {\\n    var delta =\\n      (valueToSearch - arrayToSearch[low]) /\\n      (arrayToSearch[high] - arrayToSearch[low]);\\n    var position = low + Math.floor((high - low) * delta);\\n    if (arrayToSearch[position] == valueToSearch) {\\n      return position;\\n    }\\n    if (arrayToSearch[position] < valueToSearch) {\\n      low = position + 1;\\n    } else {\\n      high = position - 1;\\n    }\\n    return interpolationSearch(arrayToSearch, valueToSearch, low, high);\\n  }\\n\\n  return -1;\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"76e13cf8-d8b5-587d-8196-fbc9d633066a","totalPages":69}},
    "staticQueryHashes": ["3159585216"]}