{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/accessing-input-control-of-a-parent-inside-a-child-frame",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Accessing input control of a parent inside a child frame?","date":"November 19, 2011"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Accessing input control of a parent inside a child frame?\",\n  \"date\": \"2011-11-19\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Not long time ago, I had to modify a code which was using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Frameset\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Frame\"), \".\"), mdx(\"p\", null, \"I had an issue because the code was written for Internet Explorer only and it was accessing the hidden field by using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parent.window.document.myhiddenfield.value\"), \".\"), mdx(\"p\", null, \"My first reflex was to remove the window and use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getElementById\"), \". Like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"parent.document.getElementById('myhiddenfield').value \\n\")), mdx(\"p\", null, \"This doesn't work with Firefox either. After some search, I found that we can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self.ownerDocument\"), \". Like this: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"self.ownerDocument.getElementById('bar'); \\n\")), mdx(\"p\", null, \"Unfortunately, this doesn't work with Internet Explorer, just Firefox.\"), mdx(\"p\", null, \"My last try was to use JQuery, which solve most of the compatibility problem.\"), mdx(\"p\", null, \"This is the current implementation that works to get hidden input control (or any other input) from a child frame to a parent that hold the frameset.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"parent.$(\\\"#myhiddenfield\\\").val() \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"19d76dfe-154b-5d99-bf6b-ba01dea6e290","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}