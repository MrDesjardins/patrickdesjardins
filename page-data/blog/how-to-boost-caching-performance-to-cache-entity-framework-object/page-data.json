{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-boost-caching-performance-to-cache-entity-framework-object",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to boost caching performance to cache Entity Framework object","date":"October 12, 2016"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to boost caching performance to cache Entity Framework object\",\n  \"date\": \"2016-10-12\",\n  \"categories\": [\"entity-framework\", \"redis\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Entity Framework objects are dangerous for caching because of their nature to keep references to object. If you have an object that contains a list of object that can contain back the initial object, you come in a scenario where you have a infinite deepness of reference. While this is not a problem in memory, since it's just pointer. However, if you serialize, it can be problematic. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./serializing-complex-object-for-redis\"\n  }, \"Json.Net provides some way to serialize reference\"), \" which will serialize once and then refer to the object by a $ref id. However, this can still be expensive because the framework needs to navigate through the objects tree to determine if or not it needs more serialization. Another way to optimize the serialization with Json.Net is to have a custom ContractResolver where you can evaluate the level of deepness you are and stop serializing. The reference + custom ContractResolver looks like this: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static class Serialization { public static string Serialize<T>(T objectToSerialize, int maxDepth = 5) { using (var performanceLog = new GlimpseCodeSection(\\\"Serialize\\\")) { using (var strWriter = new StringWriter()) { using (var jsonWriter = new CustomJsonTextWriter(strWriter)) { Func<bool> include = () => jsonWriter != null && jsonWriter.CurrentDepth <= maxDepth; var resolver = new DepthContractResolver(include); var serializer = new JsonSerializer(); serializer.Formatting = Formatting.Indented; serializer.ContractResolver = resolver; serializer.ReferenceLoopHandling = ReferenceLoopHandling.Serialize; serializer.PreserveReferencesHandling = PreserveReferencesHandling.Objects; serializer.TypeNameHandling = TypeNameHandling.All; serializer.ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor; serializer.NullValueHandling = NullValueHandling.Include; serializer.Serialize(jsonWriter, objectToSerialize); } return strWriter.ToString(); }\\n\\n} }\\n\\npublic static T Deserialize<T>(string objectSerialized) { using (var performanceLog = new GlimpseCodeSection(\\\"Deserialize\\\")) { var contractResolver = new PrivateResolver(); var obj = JsonConvert.DeserializeObject<T>(objectSerialized , new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Serialize, PreserveReferencesHandling = PreserveReferencesHandling.Objects, TypeNameHandling = TypeNameHandling.All, ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor, ContractResolver = contractResolver, NullValueHandling = NullValueHandling.Include }); return obj; } }\\n\\n/// <summary> /// Allow to have private method to be written in the serialization /// </summary> public class PrivateResolver : DefaultContractResolver { protected override JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization) { var prop = base.CreateProperty(member, memberSerialization);\\n\\nif (!prop.Writable) { var property = member as PropertyInfo; if (property != null) { var hasPrivateSetter = property.GetSetMethod(true) != null; prop.Writable = hasPrivateSetter; } }\\n\\nreturn prop; } }\\n\\npublic class DepthContractResolver : DefaultContractResolver { private readonly Func<bool> includeProperty;\\n\\npublic DepthContractResolver(Func<bool> includeProperty) { this.includeProperty = includeProperty; }\\n\\nprotected override JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization) { var property = base.CreateProperty(member, memberSerialization); //See if we should serialize with the depth var shouldSerialize = property.ShouldSerialize; property.ShouldSerialize = obj => this.includeProperty() && (shouldSerialize == null || shouldSerialize(obj));\\n\\n//Setter if private is okay to serialize if (!property.Writable) { var propertyInfo = member as PropertyInfo; if (propertyInfo != null) { var hasPrivateSetter = propertyInfo.GetSetMethod(true) != null; property.Writable = hasPrivateSetter; } }\\n\\nreturn property; }\\n\\nprotected override IList<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization) { IList<JsonProperty> props = base.CreateProperties(type, memberSerialization); var propertyToSerialize = new List<JsonProperty>(); foreach (var property in props) { if (property.Writable) { propertyToSerialize.Add(property); } else { var propertyInfo = type.GetProperty(property.PropertyName); if (propertyInfo != null) { var hasPrivateSetter = propertyInfo.GetSetMethod(true) != null; if (hasPrivateSetter) { propertyToSerialize.Add(property); } } } } return propertyToSerialize; }\\n\\n}\\n\\npublic class CustomJsonTextWriter : JsonTextWriter { public int CurrentDepth { get; private set; } = 0; public CustomJsonTextWriter(TextWriter textWriter) : base(textWriter) { }\\n\\npublic override void WriteStartObject() { this.CurrentDepth++; base.WriteStartObject(); }\\n\\npublic override void WriteEndObject() { this.CurrentDepth--; base.WriteEndObject(); } } } \\n\")), mdx(\"p\", null, \"The problem is that even with those optimizations, the time can be long. One common pattern is that you have a big Entity Framework object that you want to serialize. Before sending the object to serialize, you want to cut some branches by setting to null properties. For example, if you have the main entity that has many collections, you may want to null the collection and just setting the object with less sub-objects into Redis. The problem is that if you null a property, the main object will have some missing data and your object is in a bad state. So, the pattern is to serialize the object once and deserialize it right away. Null some properties on that deserialized object, which is a total clone. Any changes doesn't affect the real object. From that clone, you can serialize this one and set it to Redis. The problem is that it takes 2 serializations operation and 1 deserialization while the best case scenario would be 1 serialization.\"), mdx(\"p\", null, \"The pattern remains good, but the way to achieve it is wrong. A better approach would be to clone the object in C#. The benefit is the speed, the disadvantage is that you need to have cloning method on all your classes which can be time consuming. It's also difficult to know how to clone each object. Often you will need a shallow clone and a deep clone. Depending of the situation and the class, you need to call the right cloning method. The speed is varying a lot but on big cloning object where the graph is huge I saw result going from 500ms to 4ms. Very good for a first clone operation. After, cutting some properties and serializing again, the same object can take about 20ms to serialize.\"), mdx(\"p\", null, \"Here is an example :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public Contest ShallowCloneManual() { var contest = (Contest)this.MemberwiseClone(); contest.RegistrationRules = this.registrationRules.DeepCloneManual(); contest.AllowedMarkets = this.AllowedMarkets?.ShallowCloneManual(); contest.ContestOrderType = this.contestOrderType?.DeepCloneManual(); contest.Creator = this.Creator?.ShallowCloneManual(); contest.DailyStatistics = this.DailyStatistics?.ShallowCloneManual(); contest.InitialCapital = this.InitialCapital.DeepCloneManual(); contest.Moderators = this.Moderators?.ShallowCloneManual(); contest.Name = this.Name.DeepCloneManual(); contest.TransactionRules = this.TransactionRules.DeepCloneManual(); contest.StockRules = this.StockRules?.DeepCloneManual(); contest.ShortRules = this.ShortRules?.DeepCloneManual(); contest.OptionRules = this.OptionRules?.DeepCloneManual(); contest.Portefolios = this.Portefolios?.ShallowCloneManual(); return contest; }\\n\\npublic Contest DeepCloneManual() { var contest = (Contest)this.MemberwiseClone(); contest.RegistrationRules = this.registrationRules.DeepCloneManual(); contest.AllowedMarkets = this.AllowedMarkets?.ShallowCloneManual(); contest.ContestOrderType = this.contestOrderType?.DeepCloneManual(); contest.Creator = this.Creator?.ShallowCloneManual(); contest.DailyStatistics = this.DailyStatistics?.ShallowCloneManual(); contest.InitialCapital = this.InitialCapital.DeepCloneManual(); contest.Moderators = this.Moderators?.DeepCloneManual(); contest.Name = this.Name.DeepCloneManual(); contest.TransactionRules = this.TransactionRules.DeepCloneManual(); contest.StockRules = this.StockRules?.DeepCloneManual(); contest.ShortRules = this.ShortRules?.DeepCloneManual(); contest.OptionRules = this.OptionRules?.DeepCloneManual(); contest.Portefolios = this.Portefolios?.DeepCloneManual(); return contest; } \\n\")), mdx(\"p\", null, \"Some improvements could be done to be more generic. For example, DeepCloneManual could take a static option object which track the deep level and stop cloning. The impact of doing the cloning in C# was significant on Azure Webjob where thousand of objects needed to be reduced and send to Azure Redis. You can see by yourself the drop in the following graph where the 75th percentile get down from 16 minutes to less than 4 minutes and the 95th percentile from +20 minutes to 4 minutes. \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1024px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/625bf455c0c5e3d05818964d7ebbfbdd/2bef9/CustomCSharpClone-1024x363.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"35.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA40lEQVQoz21R7W6EMAzj/R90EgIOaJpvTp5admx340dkJ6mcOB3cA8yGSgYRR2Qg4iYyzn4E8s+bjIBHYlx3zNOEoRWPDDwzYeI9nkeekXlxF4eygcluB+57BVHBwCxY2TAVwUyK8cGYVun4NdXffGUUNYQHKuk/wbZ1ZmKgWrGxYRXFJg0Nc1EspJ03XIriwYZxY5AY3AJcrQt8Cg/uflk+8t3mJ2/9aWOYB4QNpv52z1OwH/W96B8YP5u0DxBzLEV6fmd9eBEzg6ieKHrlaoZ9L523enNEVcBiIBJUkr7pS/AbGXUhw5tUnRMAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"CustomCSharpClone 1024x363\",\n    \"title\": \"CustomCSharpClone 1024x363\",\n    \"src\": \"/static/625bf455c0c5e3d05818964d7ebbfbdd/2bef9/CustomCSharpClone-1024x363.png\",\n    \"srcSet\": [\"/static/625bf455c0c5e3d05818964d7ebbfbdd/5a46d/CustomCSharpClone-1024x363.png 300w\", \"/static/625bf455c0c5e3d05818964d7ebbfbdd/0a47e/CustomCSharpClone-1024x363.png 600w\", \"/static/625bf455c0c5e3d05818964d7ebbfbdd/2bef9/CustomCSharpClone-1024x363.png 1024w\"],\n    \"sizes\": \"(max-width: 1024px) 100vw, 1024px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"To conclude, cloning by serializing and deserializing an Entity Framework object is expensive in term of processing but fast to use. It should be used with parsimony.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"03674ae2-7098-59ef-9d3a-96aa9a47c4c3","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}