{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-with-a-generic-react-component-that-use-generic-property",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript with a generic React Component that use generic property","date":"January 9, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript with a generic React Component that use generic property\",\n  \"date\": \"2018-01-09\",\n  \"categories\": [\"react\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"React is fairly straightforward for simple scenario and TypeScript integrates very well with the JSX syntax (called TSX for TypeScript).\\nHowever, like many systems, when we push on the limit a little, it starts to be less obvious.\\nOne case is the one that you want to have a component generic.\\nImagine that you want to create a reusable component and want to pass a specific format of information by property and regardless of the implementation you just require to have the object pass to have few fields and nothing else.\\nReact per se handle this kind of scenario with the flexibility of JavaScript. Although it's possible with TypeScript, it requires some nimble ability to achieve it.\"), mdx(\"p\", null, \"First of all, let's settle on a basic generic component and desire property.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface BaseModel {\\n    id: number;\\n}\\n\\ninterface MyTypeThatExtendBaseModelHere extends BaseModel {\\n}\\n\\ninterface GenericControlHereProps<T extends BaseModel> {\\n    items: T[];\\n}\\n\\nclass GenericControlHere<T extends BaseModel> extends React.Component<GenericControlHereProps><T, {}> {\\n    // ...\\n}\\n\")), mdx(\"p\", null, \"So far, nothing special else that we are using property that is taking a generic list of item which must have an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" field. This is what \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"extend\"), \" means. Nevertheless, there is a caveat which is generic when it's time to use the component.\"), mdx(\"p\", null, \"The following code will complain that the property passed is not of the right type. Saying that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"items\"), \" are not assignable to type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"never[]\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"//...\\n\\npublic render(): JSX.Element {\\n    return <GenericControlHere items={myList} />;\\n}\\n\\n//...\\n\")), mdx(\"p\", null, \"The trick is to create a type of component that will explicitly mention the generic type to use.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"type ExplicitUseMyType = new () => GenericControlHere<MyTypeThatExtendBaseModelHere>;\\nconst GenericControlHereWithExplicitDefinedProperty = GenericControlHere as ExplicitUseMyType;\\n\\n//...\\n\\npublic render(): JSX.Element {\\n        return <GenericControlHereWithExplicitDefinedProperty items={myList} >\\n}\\n\\n//...\\n\")), mdx(\"p\", null, \"This is a lot of gymnastics to satisfy TypeScript. The reason is that when calling directly the generic component that TypeScript cannot infer what will be the type of the property passed in relation to the component. By creating a new type which passes the generic type it fixes the problem. The component knowns that it of a specific type and the property passed is the same in the render, hence everything compiles.\"), mdx(\"p\", null, \"There is a little syntax detail which is that the type created using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new () =>\"), \". This indicates that it's not an object literal that respect the specific structure, but an instance of the type -- it needs to have a parameterless constructor which the React.Component is. The cast is not a pretty strategy but works fine since the type we are casting is having the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new ()\"), \" mention. When React will render the casted type, it will be able to invoke the constructor and create the component.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"4ec3ab07-9e7d-50cd-8e79-f89cf4307c4d","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}