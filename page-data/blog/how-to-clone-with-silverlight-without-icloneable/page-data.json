{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-clone-with-silverlight-without-icloneable",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to clone with Silverlight without ICloneable?","date":"October 13, 2011"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to clone with Silverlight without ICloneable?\",\n  \"date\": \"2011-10-13\",\n  \"categories\": [\"c-sharp\", \"silverlight\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The .Net Framework allow to clone \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ICloneable\"), \" interface. This interface has a single method that is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Clone\"), \". This interface is not available in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Silverlight\"), \". The reason is that \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://forums.silverlight.net/p/11495/36695.aspx#36695\"\n  }, \"Microsoft\"), \" have found that since it does not provide specification between deep copy or shallow copy that it was useless to port this interface into the Silverlight SDK. In fact, this interface has been \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://blogs.msdn.com/b/brada/archive/2004/05/03/125427.aspx\"\n  }, \"questionable since a long time ago\"), \".\"), mdx(\"p\", null, \"An other way to clone is to serialize and deserialize your object. By using this mechanism all references are not there but the value are. The problem, is that Silverlight does not have the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"System.Runtime.Serialization\"), \" has you may know in the .Net standard framework. You won't fine the the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IFormatter\"), \" interface neither the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"BinaryFormatter\"), \" class.\"), mdx(\"p\", null, \"So, how to clone an object in Silverlight?\"), mdx(\"p\", null, \"Here is a cloning method that is an extension for every object. It uses reflection to do it's cloning. This is not a deep copy!\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static class CloningExtension { public static T Clone<T>(this T source) { T cloned = (T) Activator.CreateInstance(source.GetType()); foreach (PropertyInfo curPropInfo in source.GetType().GetProperties()) { if (curPropInfo.GetGetMethod() != null && (curPropInfo.GetSetMethod() != null)) { // Handle Non-indexer properties if (curPropInfo.Name != \\\"Item\\\") { // get property from source object getValue = curPropInfo.GetGetMethod().Invoke(source, new object[] {}); // clone if needed if (getValue != null && getValue is DependencyObject) getValue = Clone((DependencyObject) getValue); // set property on cloned curPropInfo.GetSetMethod().Invoke(cloned, new object[] {getValue}); } // handle indexer else { // get count for indexer int numberofItemInColleciton =(int)curPropInfo.ReflectedType.GetProperty(\\\"Count\\\").GetGetMethod().Invoke(source, new object[] {}); // run on indexer for (int i = 0; i < numberofItemInColleciton; i++) { // get item through Indexer object getValue = curPropInfo.GetGetMethod().Invoke(source, new object[] {i}); // clone if needed if (getValue != null && getValue is DependencyObject) getValue = Clone((DependencyObject) getValue); // add item to collection curPropInfo.ReflectedType.GetMethod(\\\"Add\\\").Invoke(cloned, new object[] {getValue}); } } } } return cloned; } } \\n\")), mdx(\"p\", null, \"If you want more information you can read this \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://forums.silverlight.net/t/1730.aspx\"\n  }, \"forum thread\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"3a6994b9-49f1-5cec-9bdf-6b36516e168f","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}