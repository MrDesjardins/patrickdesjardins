{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/using-automapper-to-map-abstract-classes",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Using AutoMapper to Map Abstract Classes","date":"March 20, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Using AutoMapper to Map Abstract Classes\",\n  \"date\": \"2014-03-20\",\n  \"categories\": [\"automapper\", \"c-sharp\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AutoMapper\"), \" lets you map from one class to another class your object. It works fine until you want to map from a class to an abstract class. The reason is that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AutoMapper\"), \" instantiates the desired class type and since an abstract class cannot be instantiate will crash.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" //Mapping \\n Mapper.CreateMap<SelectorItem, OrderType>() \\n //Use the mapping \\n var model = AutoMapper.Mapper.Map<SelectorItem, OrderType>(viewModel); \\n\")), mdx(\"p\", null, \"The code create the map from SelectorItem that is a normal class and OrderType that is an abstract class. The use of this map will not work. To fix this problem the mapping configuration must be changed to specify to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AutoMapper\"), \" how to instantiate the OrderType class, the abstract class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" Mapper.CreateMap<SelectorItem, OrderType>() .ConstructUsing(OrderTypeCreator); \\n\")), mdx(\"p\", null, \"The mapping requires the use of ConstructUsing method that has two signatures.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" IMappingExpression<TSource, TDestination> ConstructUsing(Func<TSource, TDestination> ctor); \\n IMappingExpression<TSource, TDestination> ConstructUsing(Func<ResolutionContext, TDestination> ctor); \\n\")), mdx(\"p\", null, \"The first one is easy to use. It takes a method that has the source which is the class we start with and return a destination class that is the abstract class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" private OrderType OrderTypeCreator(SelectorItem arg) { return OrderType.GetFromId(arg.Id); } \\n\")), mdx(\"p\", null, \"This example takes from the concrete class the ID and use a factory to return the correct concrete class that inherit form the abstract OrderType class.\"), mdx(\"p\", null, \"This way, we have AutoMapper that can map to abstract Class without problem.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"82e377f2-3bd0-5691-aa94-7627a95ec961","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}