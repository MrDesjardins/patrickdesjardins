{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/conflicting-changes-to-the-role-x-of-the-relationship-y-have-been-detected",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Conflicting changes to the role X of the relationship Y have been detected.","date":"August 15, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Conflicting changes to the role X of the relationship Y have been detected.\",\n  \"date\": \"2012-08-15\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Entity Framework can be something hard to debug. This error was known by me when people use reference to an object and also an integer for the ID within the same object and change both of them. When this happen, Entity Framework raise an error because it cannot know which one is the correct reference.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"250px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/08f10bec6a2221185634e567f6230b81/0479a/ID-10078092.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"160%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAgABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAQCAwUB/8QAFgEBAQEAAAAAAAAAAAAAAAAAAAIB/9oADAMBAAIQAxAAAAFybMZNHClWFpxLxox//8QAHBAAAgIDAQEAAAAAAAAAAAAAAgMAAQQSEyEU/9oACAEBAAEFAsoSMsbpRRg+KutI3xXUlxBXamHsQrr6J//EABkRAAIDAQAAAAAAAAAAAAAAAAABAhARMv/aAAgBAwEBPwGo9axn/8QAGBEAAgMAAAAAAAAAAAAAAAAAEBEBITH/2gAIAQIBAT8BVsTg/8QAHRAAAgICAwEAAAAAAAAAAAAAAQIAERASIjFBcf/aAAgBAQAGPwIKDQjKxsYJike4b5NR5BtdwJqwF9zYJxx//8QAHRAAAQQDAQEAAAAAAAAAAAAAAQARITEQQVFhcf/aAAgBAQABPyGACygZlgMeYcuNNrUAXP3BuHZIGhB9RfHq4Rjtw1IVAAFkb8x//9oADAMBAAIAAwAAABCMx3//xAAYEQEBAQEBAAAAAAAAAAAAAAABEQAQQf/aAAgBAwEBPxCknvIAFMqrv//EABkRAQACAwAAAAAAAAAAAAAAAAEAMRARIf/aAAgBAgEBPxDbAqlw4T//xAAhEAEAAgEDBAMAAAAAAAAAAAABESEAEDFhcYGRoVGxwf/aAAgBAQABPxBtZSuwvbjCewYIl06fWlZQCIQle8cgo0d2FvqPGg2RIHlIPebxw1myuTvlewRILdPiMizqoCT4T9wcrRSuwNHXnT//2Q==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"ID 10078092\",\n    \"title\": \"ID 10078092\",\n    \"src\": \"/static/08f10bec6a2221185634e567f6230b81/0479a/ID-10078092.jpg\",\n    \"srcSet\": [\"/static/08f10bec6a2221185634e567f6230b81/0479a/ID-10078092.jpg 250w\"],\n    \"sizes\": \"(max-width: 250px) 100vw, 250px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class MyEntity { public virtual MySecondEntity MySecond{get;set;} public int MySecondEntityID{get;set;} } \\n``` The code above can trig the error :\\n\\n> Conflicting changes to the role X of the relationship Y have been detected.\\n\\nTo solve this problem, you only need to change the scalar property (integer) and not touching the complex attribute (the property).\\n\\nBut, let say that you have this error without having this kind of structure. Let say you only use reference to the object (like I do). \\n```csharp\\n public class MyEntity { public virtual MySecondEntity MySecond{get;set;} } \\n\")), mdx(\"p\", null, \"How can I have this error? Well, I had this problem when MyEntity was brand new (ID = 0) and when MySecond also a reference to MyEntity. This is because MySecondEntity has a reference to MyEntity which is ID = 0. Those 2 MyEntity will be treated as 2 differents entity by Entity Framework. The trick to solve this issue is to set to NULL the reference inside MySecondEntity and let Entity Framework set in the database the reference. This can be done because the new MyEntity does have a reference to the MySecondEntity property.\"), mdx(\"p\", null, \"To conclude, if you have a conflicting change and you are using code first with property reference, be sure that when you insert a new entity that not both reference to an entity with a new ID. Just one part of the navigation require to be defined.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"278791e2-b317-5e2b-9257-52095a642ece","totalPages":70}},
    "staticQueryHashes": ["3159585216"]}