{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/javascript-prototype-part-1",
    "result": {"data":{"mdx":{"frontmatter":{"title":"JavaScript Prototype Part 1","date":"May 11, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Prototype Part 1\",\n  \"date\": \"2017-05-11\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"JavaScript is a prototype language. Every object has a prototype which share properties between the same kind of object.\"), mdx(\"p\", null, \"The minimal prototype an object has is the default Object.prototype. However, any object can add members or function to its own object prototype by using \\\".prototype.\\\". The following code shows that an object type \\\"myTest\\\" with no member is having \\\"member1\\\" dynamically added as well as a member2 with the value \\\"m2\\\". We create a second instance and only member2, from the prototype is available. The member1 was added to the instance, not the prototype.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var myTest = {};\\nvar myTestInstance1 = Object.create(myTest);\\nmyTestInstance1.member1 = \\\"m1\\\";\\nmyTestInstance1.__proto__.member2 = \\\"m2\\\";\\n\\nvar myTestInstance2 = Object.create(myTest);\\n\\nconsole.log(\\\"instance1.member2:\\\" + myTestInstance1.member2); //m2\\nconsole.log(\\\"instance2.member2:\\\" + myTestInstance2.member2); //m2\\nconsole.log(\\\"instance1.member1:\\\" + myTestInstance2.member1); //m1\\nconsole.log(\\\"instance2.member1:\\\" + myTestInstance2.member1); //undefined\\n\")), mdx(\"p\", null, \"Prototype inheritance bring method and function. At anytime, it's possible for the instance to override the prototype member. Here is an example that the prototype is defined in a member to show \\\"m2\\\" and the first instance override it with \\\"Override\\\" string. When a new instance is created, the member will have the value of the prototype.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var myTest = {};\\nvar myTestInstance1 = Object.create(myTest);\\nmyTestInstance1.__proto__.member2 = \\\"m2\\\";\\nmyTestInstance1.member2 = \\\"OVERRIDE\\\";\\n\\nvar myTestInstance2 = Object.create(myTest);\\n\\nconsole.log(\\\"instance1.member2:\\\" + myTestInstance1.member2); //Override\\nconsole.log(\\\"instance2.member2:\\\" + myTestInstance2.member2); //m2\\n\")), mdx(\"p\", null, \"It's also possible to change the prototype at any time in the life of the object and have every object changed. In the following example, two instances are created and the prototype is defined afterward. The data is still accessible by both instance after the assignation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var myTest = {};\\nvar myTestInstance1 = Object.create(myTest);\\nvar myTestInstance2 = Object.create(myTest);\\nmyTestInstance1.__proto__.member2 = \\\"m2\\\";\\n\\nconsole.log(\\\"instance1.member2:\\\" + myTestInstance1.member2); //m2 console.log(\\\"instance2.member2:\\\"+myTestInstance2.member2);//m2\\n\")), mdx(\"p\", null, \"So far, the instance of the object was created by using create, but it's also possible to do it with \\\"new\\\".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var MyClass1 = function () {\\n  this.member1 = \\\"m1\\\";\\n};\\n\\nMyClass1.prototype.function1 = function () {\\n  return \\\"return from function1\\\";\\n};\\n\\nvar instance1 = new MyClass1();\\n\\nconsole.log(\\\"instance1.member1: \\\" + instance1.member1); //m1\\nconsole.log(\\\"instance1.function1: \\\" + instance1.function1()); //return from function1\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"85b4f9a7-5790-54d1-8afb-eb5ed89b5604","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}