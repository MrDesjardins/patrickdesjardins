{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-strictpropertyinitialization-should-be-turned-on",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript strictPropertyInitialization should be turned on","date":"March 27, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript strictPropertyInitialization should be turned on\",\n  \"date\": \"2018-03-27\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Finally, TypeScript with its version 2.7 brings more rigidity around class properties. For many years, it was possible to define class' properties without initializing them at the declaration level, neither in the constructor.\"), mdx(\"p\", null, \"Before 2.7, the only difference between an optional and a non optional class's property was that optional could receive the value of undefined while the other one was undefined until a value was set. After initialized, the non-optional protects the field to receive undefined. However, the case of declaring and not defining the value makes TypeScript less valuable by creating confusion. The nomenclature indicate that a field cannot be undefined but the missing initialization create a limbo where the value is something not allowed.\"), mdx(\"p\", null, \"TypeScript 2.7 brings a new compiler flag: \\\"strictPropertyInitialization\\\". This new strict flag indicates to TypeScript that any class property must initialize the field at the declaration time or inside the constructor of the class.\"), mdx(\"p\", null, \"Let's see an example that compile prior to the adoption of strictPropertyInitialization or if this flag is set to false. The following code shows three properties. The \\\"m1\\\" is initialized in the constructor. The \\\"m2\\\" is initialized at declaration. The \\\"m3\\\" is initialized by a call to a method from the constructor. The last example works only without the flag to true.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"class C { \\n  private m1: number; \\n  private m2: string = \\\"2\\\"; \\n  private m3: boolean;\\n\\n  public constructor() { \\n    this.m1 = 1; \\n    this.init(); \\n  } \\n  private init():void { \\n    this.m3 = true; \\n  } \\n} \\n\")), mdx(\"p\", null, \"The problem with initializing in a method is the lack of guarantee of invocation. The call to the method might be immediate or might be under a condition that make it not initialize or to initialize partially its properties. TypeScript can perform a deeper analysis if it concentrates on the each field and under a single method -- the constructor.\"), mdx(\"p\", null, \"Let's examine a second example where the compiler catches a missing initialization.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"class C { \\n  private m1: number; \\n  private m2: string = \\\"2\\\"; \\n  private m3: boolean;\\n\\n  public constructor(b: boolean) { \\n    this.m1 = 1; \\n    if (b) { \\n      this.m3 = true; \\n    } \\n  }\\n} \\n\")), mdx(\"p\", null, \" The second example initialize the field \\\"m3\\\" but not in every code path. TypeScript detects that the field might not be initialized, hence doesn't compile.\"), mdx(\"p\", null, \"An important detail is the flag enters in action when TypeScript configures the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"strickNullChecks\"), \" to true. Otherwise, TypeScript accepts undefined without mentioning optional. The combination of strict flags, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"strickNullChecks\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"strictPropertyInitialization\"), \" works hand in hand to reduce potential undesired undefined value for field doesn't mention the possibility of undefined.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"ea40fe6f-5a9c-500a-9e30-0a1a288fbcbc","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}