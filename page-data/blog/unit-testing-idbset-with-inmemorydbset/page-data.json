{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/unit-testing-idbset-with-inmemorydbset",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Unit Testing IDbSet with InMemoryDbSet","date":"February 27, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Unit Testing IDbSet with InMemoryDbSet\",\n  \"date\": \"2015-02-27\",\n  \"categories\": [\"entity-framework\", \"test\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Unit testing code near of your data access layer is not always easy. However, if you work design pattern like Unit of work or have at least regrouped your unit of DbSet in a centralized place, your unit tests can be not too hard to test. This is quite easy in fact if you are returning the IDbSet than you are in lock because you can Mock the DbSet and even use a nice Nuget's package called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.nuget.org/packages/FakeDbSet\"\n  }, \"FakeDbSet\"), \" which has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InMemoryDbSet\"), \".\"), mdx(\"p\", null, \"You can install in your unit of test the FakeDbSet with this Nuget's command. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" Install-Package FakeDbSet \\n\")), mdx(\"p\", null, \"Here is a real example of a unit test that is intended to verify that when we call the repository that we get specific entity. The repository has in fact a filter -- Entity Framework \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"where\"), \" clause -- that return only stock that is with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"status\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Waiting\"), \". This test verify that the Linq to Entity is really filtering correctly. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"stockOrderSet\"), \" is the fake.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" //Configuration in the constructor of the test machine this.stockOrderSet = new InMemoryDbSet<StockOrder>(true); this.UnitOfWork.Setup(d => d.Set<StockOrder>()).Returns(stockOrderSet); this.realTimeRepository = new RealTimeValuesRepository(base.UnitOfWork.Object); //... [TestMethod] public void GivenStocksSymbolToRefresh_WhenOrderActiveWithStockExpired_ThenGetOneToRefresh() { // Arrange this.stockOrderSet.Add(new StockOrder(){StockSymbol = \\\"A\\\", OrderStatus = OrderStatusType.Waiting}); this.stockOrderSet.Add(new StockOrder(){StockSymbol = \\\"B\\\", OrderStatus = OrderStatusType.Executed});\\n\\n// Act var stocks = realTimeRepository.GetStocksSymbolToRefresh();\\n\\n// Assert Assert.AreEqual(1, stocks.Count()); Assert.AreEqual(\\\"A\\\", stocks.First()); } \\n\")), mdx(\"p\", null, \"The initialization of the fake \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DbSet\"), \" is set by specifying that we do not want to retain any value set between tests. The Linq is executed as it would with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DbSet\"), \" connected to entity framework. As you can see, I am using a mocking framework to specify that every time the unit of work class's DbSet for the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"StockOrder\"), \" is used to use the fake DbSet. You can do the same if your repository has directly the the DbSet but these would require to be virtual to mock them. Everything is easy testable because of different pattern. Because we are injecting the unit of work (which contains the DbSet) into the repository, than it is easy to mock the unit of work to return the fake DbSet.\"), mdx(\"p\", null, \"The code of the FakeDbSet is available on GitHub (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/a-h/FakeDbSet\"\n  }, \"https://github.com/a-h/FakeDbSet\"), \").\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"c77bc3d4-fab5-54da-be5d-d82f3efa2388","totalPages":74}},
    "staticQueryHashes": ["3159585216"]}