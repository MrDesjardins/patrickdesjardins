{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/c-async-example",
    "result": {"data":{"mdx":{"frontmatter":{"title":"C# Async Example","date":"February 24, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"C# Async Example\",\n  \"date\": \"2015-02-24\",\n  \"categories\": [\"async\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Async\"), \" is a keyword that has been introduced since some time in the .Net framework. It got more popular with C# 5.0, about 4 years ago and recently, during the last year, we can see default templates using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Async\"), \" almost everywhere. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Async\"), \" is useful to have threads that are not waiting for nothing. The concept of asynchronous allows you to have multiple operations simultaneously. What make the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"async\"), \" keywords powerful is that you do not have to play with callbacks and thread -- the framework handles everything for you. Asynchronous code is very interesting when you have network requests, disk accesses or tasks that process for a long time. Async frees up the thread that is executing the task, which allows to framework to reuse it for something else. The framework optimizes the resources and give an easy way to do parallelism in your code without affecting too much your design. However, as you will note by using the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"async\"), \" keyword, this one must be spread from the first call to the end. You will not be able to use half asynchronous code with half synchronous code -- or not asynchronous.\"), mdx(\"p\", null, \"Let's start a Console application to do something simple. Doing a console application is interesting because Console applications are not async. They start in a single process - in a single thread. This is the nature of the console to do sequential tasks. Creating a new Web Api project or a new Web project with the latest framework, would have been more natural because Asp.Net framework include all async from the reception of the request and beyond. Therefore, let's take the hard way to understand more what is going on. First, two keywords must be used : \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"await\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"async\"), \". Second, by convention, method that are async must be prefixed by \\\"Async\\\" string. For example, we are going to create an async method that write into the console a string and wait few milliseconds to simulate an intensive I/O (input / output) task. Since we are going to make it \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"async\"), \", it will be named with its name followed by \\\"Async\\\" : \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GiveMeAStringAsync\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" private static async Task<string> GiveMeAStringAsync(string suffixe, int millisecondTaskTake) { Console.WriteLine(\\\"Begin GiveMeAString:\\\" + suffixe + \\\" for \\\" + millisecondTaskTake); await Task.Delay(millisecondTaskTake); Console.WriteLine(\\\"End GiveMeAString:\\\" + suffixe + \\\" for \\\" + millisecondTaskTake); return \\\"GiveMeString execute \\\" + suffixe; } \\n\")), mdx(\"p\", null, \"The method is like any other method but as before the return type the keyword \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"async\"), \". The second difference is the return type. In a nutshell, the return type must be of type \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Task\"), \" or its generic version \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Task\"), \". It can be also \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"void\"), \" for the case of \\\"fire-and-forget\\\". In that latest case, we will never get any news about the task. Most of the time, we should not return \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"void\"), \" and we want to handle the answer from the task. The task is a king of bookmark that will tell the to thread some information about the task that it must execute. Any async method return a task that is automatically returned, without any delay until this one is awaited. In the code posted above this paragraph, we have a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Task.Delay\"), \" method that return a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Task\"), \". We could have set the return of this method into a Task object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var myTask = Task.Delay(millisecondTaskTake); //Do something else here await myTask; \\n``` As you can see, dividing the task into a variable allows you to do something else without executing the whole concrete task, in this example, the delay. When the task, _myTask_, hits the await keyword, this one wait the completion of the task. In the example, the delay. Let's see a more complete example that use our async method. \\n```csharp\\n var allStrings = new List<Task<string>>(); Console.WriteLine(\\\"Start\\\"); Console.WriteLine(\\\"Add First\\\"); allStrings.Add(GiveMeAStringAsync(\\\"First\\\", 1000)); Console.WriteLine(\\\"Add Second\\\"); allStrings.Add(GiveMeAStringAsync(\\\"Second\\\", 500));\\n\\nConsole.WriteLine(\\\"Add Third\\\"); allStrings.Add(GiveMeAStringAsync(\\\"Third\\\", 3000)); string thirdTask = \\\"Default Third String\\\"; //thirdTask = await allStrings.Last(); Console.WriteLine(\\\"Add Forth\\\"); allStrings.Add(GiveMeAStringAsync(\\\"Forth\\\" + thirdTask, 200));\\n\\nConsole.WriteLine(\\\"Wait All\\\"); var task = allStrings.ToList(); var allAwaitedTask = await Task.WhenAll(task); foreach (var s in allAwaitedTask) { Console.WriteLine(\\\"->\\\" + s); } Console.WriteLine(\\\"Finish\\\"); \\n\")), mdx(\"p\", null, \"This code is huge but cover a lot of interesting scenarios. First, we create a collection of Task. This mean that we expect multiple methods that will return a string. This could have been your own class. It does not need to be a primitive type. In the example, I put several \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Console.WriteLine\"), \" to display in the console to order of the code. Then, I am adding to the collection a first method with a delay of 1 second, following by a second with a delay of half a second, a third one of 3 seconds and the last one with 200 milliseconds. They are all added to the list and are executed. The execution takes the time specified in the parameter because they are delayed by the method that simulate I/O tasks -- with the use of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Task.Delay\"), \". After adding all the tasks, and executing them, I have used the method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Task.WhenAll(listOfTaskHere)\"), \". This indicate to the thread to wait every tasks to be completed before continuing. We do it because we want to display the result of each of these methods. \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"400px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/4b1313c3e3c1abd7a713c6ad390b14e2/e17e5/AsyncExample1-400x228.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"57.00000000000001%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABoUlEQVQoz42Sa2+iYBCF8Yt4Q0VR8YICchGv1BZ31Qg2pqbp//8/Z3MmeXe7SW36YfLOOzAP58ygXYpX+L6H1WqFMAzgOBNYVheWZaHX66HdbqNpGGg0GvBcF7Y9gKZpjyN/vSGOIyyXS6zXa8xmMwENh0P0+33JO50O2qYpNdu2pbFUKn0NvN7eEEURdrudnI7jCIiNg8FAIN1uF4ZhwPf9v8CH8fb+gWWSCJAqPc8TyGQyEfBoNJIgXJ2EV6tVNJtN1Go1VCoVqXE82u3+jjiKsN/vMZ/PxbJqJth1XalRWavVwng8xnQ6led0o1yEYQjTNKH9Op5FVZZluN/vopQLStNUZrrZbORlqj+dTqJCqeOiqJCnwGj5cDzLll+yDEVRCCBJEoEyD4JA7DPP8/z7+THiZIWnNJWv03Ycx2KdQC6JOZXyN3q42c/hBRGOx98oiisOhwO22y0Wi4XkBNHu5XIR1Rw8rTJonXdardfr/4Dn/IqX52dRozbK30QthvNRM1IQ3rkgnqz9B7T6NnS9LEWlQNd1lMtlafqRzU/xB3u9Fue/za52AAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"AsyncExample1 400x228\",\n    \"title\": \"AsyncExample1 400x228\",\n    \"src\": \"/static/4b1313c3e3c1abd7a713c6ad390b14e2/e17e5/AsyncExample1-400x228.png\",\n    \"srcSet\": [\"/static/4b1313c3e3c1abd7a713c6ad390b14e2/5a46d/AsyncExample1-400x228.png 300w\", \"/static/4b1313c3e3c1abd7a713c6ad390b14e2/e17e5/AsyncExample1-400x228.png 400w\"],\n    \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var allStrings = new List<Task<string>>(); Console.WriteLine(\\\"Start\\\"); Console.WriteLine(\\\"Add First\\\"); allStrings.Add(GiveMeAStringAsync(\\\"First\\\", 1000)); Console.WriteLine(\\\"Add Second\\\"); allStrings.Add(GiveMeAStringAsync(\\\"Second\\\", 500)); Thread.Sleep(5000); Console.WriteLine(\\\"Add Third\\\"); allStrings.Add(GiveMeAStringAsync(\\\"Third\\\", 3000)); string thirdTask = \\\"Default Third String\\\"; //thirdTask = await allStrings.Last(); Console.WriteLine(\\\"Add Forth\\\"); allStrings.Add(GiveMeAStringAsync(\\\"Forth\\\" + thirdTask, 200));\\n\\nConsole.WriteLine(\\\"Wait All\\\"); var task = allStrings.ToList(); var allAwaitedTask = await Task.WhenAll(task); foreach (var s in allAwaitedTask) { Console.WriteLine(\\\"->\\\" + s); } Console.WriteLine(\\\"Finish\\\"); \\n``` ![](images/AsyncExample2-400x228.png)\\n\\nAnother example would be that a task depends on a previous task. For example, let's make the forth task use the third one result. That mean that the third task must be completed before the forth one to allow the forth task to use the result of the third one. \\n```csharp\\n var allStrings = new List<Task<string>>(); Console.WriteLine(\\\"Start\\\"); Console.WriteLine(\\\"Add First\\\"); allStrings.Add(GiveMeAStringAsync(\\\"First\\\", 1000)); Console.WriteLine(\\\"Add Second\\\"); allStrings.Add(GiveMeAStringAsync(\\\"Second\\\", 500)); //Thread.Sleep(5000); Console.WriteLine(\\\"Add Third\\\"); allStrings.Add(GiveMeAStringAsync(\\\"Third\\\", 3000)); string thirdTask = \\\"Default Third String\\\"; thirdTask = await allStrings.Last(); //We are awaiting the third task here to use the string into the forth's task Console.WriteLine(\\\"Add Forth\\\"); allStrings.Add(GiveMeAStringAsync(\\\"Forth\\\" + thirdTask, 200));\\n\\nConsole.WriteLine(\\\"Wait All\\\"); var task = allStrings.ToList(); var allAwaitedTask = await Task.WhenAll(task); foreach (var s in allAwaitedTask) { Console.WriteLine(\\\"->\\\" + s); } Console.WriteLine(\\\"Finish\\\"); \\n``` To make the forth task use the result of the third task, we need to **await** the third task before the call of the forth's one.![](images/AsyncExample3-400x206.png)\\n\\nIf you want to try this into a console by copy-pasting the code in this article, you will get into some problem. The reason is as stated at the beginning, console does not support async code. We need to create from the console a async task that will handle all the async code. This can be done by using **Task.Run(async()=>{/*You code here*/});** That mean that we would do: \\n```csharp\\n static void Main(string[] args) {\\n\\nTask.Run(async() => { var allStrings = new List<Task<string>>(); Console.WriteLine(\\\"Start\\\"); Console.WriteLine(\\\"Add First\\\"); allStrings.Add(GiveMeAStringAsync(\\\"First\\\", 1000)); Console.WriteLine(\\\"Add Second\\\"); allStrings.Add(GiveMeAStringAsync(\\\"Second\\\", 500)); //Thread.Sleep(5000); Console.WriteLine(\\\"Add Third\\\"); allStrings.Add(GiveMeAStringAsync(\\\"Third\\\", 3000)); string thirdTask = \\\"Default Third String\\\"; thirdTask = await allStrings.Last(); Console.WriteLine(\\\"Add Forth\\\"); allStrings.Add(GiveMeAStringAsync(\\\"Forth\\\" + thirdTask, 200));\\n\\nConsole.WriteLine(\\\"Wait All\\\"); var task = allStrings.ToList(); var allAwaitedTask = await Task.WhenAll(task); foreach (var s in allAwaitedTask) { Console.WriteLine(\\\"->\\\" + s); } Console.WriteLine(\\\"Finish\\\");\\n\\n}).Wait(); Console.WriteLine(\\\"Press Any Keys to stop\\\"); Console.ReadLine(); }\\n\\nprivate static async Task<string> GiveMeAStringAsync(string suffixe, int millisecondTaskTake) { Console.WriteLine(\\\"Begin GiveMeAString:\\\" + suffixe +\\\" for \\\" + millisecondTaskTake);\\n\\nawait Task.Delay(millisecondTaskTake);\\n\\nConsole.WriteLine(\\\"End GiveMeAString:\\\" + suffixe + \\\" for \\\" + millisecondTaskTake); return \\\"GiveMeString execute \\\" + suffixe; } \\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Async\"), \" works with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"await\"), \". Every time a code calls an asynchronous method, the code is executed until it reaches a task that is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"await\"), \". When the code is awaited, the thread is released and the flow continues on the caller code until it reaches another await call. In the example, every time we were calling the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GiveMeAStringAsync\"), \" method, the console was writting that it begins and then wait. From this wait, the code was going back to the caller -- the Main method -- and continue its way until it reaches and other await. This is why we were able to see all \\\"Begin GiveMeAString\\\" message at the beginning because the code was never stopping until it reaches the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Task.WhenAll\"), \" which was also in an await but this time was the last because it was running into a Task.Run with a Wait. Programming with asynchronous requires a new mind set. It is not easy, and I am not used to work this way too. Since the first 10 years with .Net we had to work in a more sequential ways or to use thread to create parallelism. Now, the syntax is clean, the superfluous of handling threads is abstracted with the await and async keyword. Working with async improves the resource of your system and is something that must be considered more and more in the future of high depend website and service to lower your cost and increase the performance of your system.\"), mdx(\"p\", null, \"You can find this code on GitHub : \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/AsyncTaskExperience\"\n  }, \"https://github.com/MrDesjardins/AsyncTaskExperience\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"c5b9d4d9-4d43-5cd4-8f71-a1e716f3bcf8","totalPages":68}},
    "staticQueryHashes": ["3159585216"]}