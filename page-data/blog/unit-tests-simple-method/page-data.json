{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/unit-tests-simple-method",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Unit Tests Simple Method","date":"January 18, 2016"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Unit Tests Simple Method\",\n  \"date\": \"2016-01-18\",\n  \"categories\": [\"javascript\", \"typescript\"],\n  \"tags\": [\"test\", \"unittest\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Unit tests are something that everyone agree to do, but not a lot write correctly. I found more and more code that has unit tests for the \\\"happy path\\\" and more common scenario while ignoring all other possible cases. Let's take the following small method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"public smallSimpleOneLineMethod (abc: string): boolean { \\n  return this.zzz && (this.zzz === abc); \\n} \\n\")), mdx(\"p\", null, \"This method is broken because we specify to return a boolean but it can return null. This is not possible in C#, but in TypeScript since it is converted to JavaScript it is.\"), mdx(\"p\", null, \"This is where Unit Test come to the rescue. We expect that method to return \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"abc\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"zzz\"), \" is different; \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" when the same. If \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"zzz\"), \" is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \", we expect to return \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \". Simple, no need unit test\\u2026 The problem is that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this.zzz\"), \" if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \" will remain \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \" in the first part of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&&\"), \" condition, not \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \". It means that we do : null && (true|false). What does that mean? It means that all the time, if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"zzz\"), \" is null that that method return \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \", not \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \".\"), mdx(\"p\", null, \"This method needs to be refactored to : \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"public simpleMethod (abc: string): boolean {\\n   return !!this.zzz && (this.zzz === abc); \\n} \\n\")), mdx(\"p\", null, \"To sum up that post, unit test every conditions, even simple one. It\\u2019s not because it works today that it won\\u2019t fail tomorrow. Tests all possible routes that your code allows. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"simpleMethod\"), \" has now 4 unit tests that test null from the parameter, from the this variable and with and without the same string variable.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"4c9557ed-9af9-5ab3-90d5-67386184d289","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}