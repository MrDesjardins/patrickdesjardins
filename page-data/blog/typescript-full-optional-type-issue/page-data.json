{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-full-optional-type-issue",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript Type with Full Optional Field Might Cause you Issue","date":"March 30, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript Type with Full Optional Field Might Cause you Issue\",\n  \"date\": \"2022-03-30\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I recently received a message from one of my teammates asking to look at a piece of code that was compiled but wrong. After a moment, I realized that the interface (type) that was used was coming from a generated package from one of our gRPC. Because all the gRPC Protobuf type had their fields optional, the generated types were also optional.\"), mdx(\"h1\", null, \"Example of the Issue\"), mdx(\"p\", null, \"Here are two types that illustrate the situation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface TypeA {\\n    id?: number;\\n    name?: string;\\n}\\ninterface TypeB {\\n    id?: number;\\n    age?: number;\\n}\\n\")), mdx(\"p\", null, \"The problem with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeB\"), \" having all their fields optional is that a valid \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \" can be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{}\"), \". And that a valid \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeB\"), \" can be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{}\"), \". By consequence, a function like the following accepts either type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function forEach(a: TypeA): void {\\n    console.log(a);\\n}\\n\")), mdx(\"p\", null, \"I did not choose the name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"forEach\"), \" by accident. The real \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"forEach\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" function suffers from the same behavior. If you expect a collection of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<T>\"), \" and that your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" is a type of full optional field, then you can fall into the illusion that you are passing the right object when you are actually not. Before diving any further, you can \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgCoE8AOECCyDeAsAFDJnLAAmA-AFzIgCuAtgEbQDcJ5DczEdZAGcwUUAHMuxAL4kSoSLEQoM2AEIFu5KoKZtOWsnHED6e9lCmziJGIxAIwwAPYhkMZ1ACiiABYAKOHpVXABKegA3ZypNUnIEVyFnABsIADpk53FA0Ks5YgSQEWQgtCxcZABeAgpKegBGABpefnoAIlQIETbkaSlC4tZg8o1q-FqG5uMIBoAGXqlbTx8EALhcpe8-f1YN4g8t1f98aVygA\"\n  }, \"play\"), \" with the following code to see by yourself how the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"forEach\"), \" that is expecting \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \" accept a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeB\"), \" and even \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{}\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface TypeA {\\n    id?: number;\\n    name?: string;\\n}\\n\\ninterface TypeB {\\n    id?: number;\\n    age?: number;\\n}\\n\\nfunction forEach(a: TypeA): void {\\n    console.log(a);\\n}\\n\\nconst a: TypeA = { id: 1, name: \\\"Test\\\" };\\nconst b: TypeB = { id: 1, age: 10 };\\n\\nforEach(a);\\nforEach(b);\\nforEach({});\\n\")), mdx(\"p\", null, \"Let's explain why with some examples.\"), mdx(\"h2\", null, \"Example 1: Implicit Declaration\"), mdx(\"p\", null, \"Let's define a variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const a = { id: 1, name: \\\"Test\\\" }; // Coubt be TypeA\\n\\n\")), mdx(\"p\", null, \"The variables \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" is not explicitly typed. It does not have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \": TypeA\"), \" after the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \". It is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not\"), \" officially a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \" but a \\\"on-the-fly\\\" unamed type that share the same structure. Thus, is is totally acceptable to \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const a: TypeA = { id: 1, name: \\\"Test\\\" }; \\n\")), mdx(\"p\", null, \"Hence, the variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" compiles when used in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"forEach\"), \" function. It is important to understand that we are not coercing the type to be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \". That would happen if we were doing:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const a = { id: 1, name: \\\"Test\\\" } as TypeA; // THIS IS BAD, DO NOT DO IT but it compiles\\n\")), mdx(\"p\", null, \"That should never be done since you can convert anything to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \" even if it is not true.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const x = {asd:123} as TypeA; // THIS IS WRONG but it compiles\\n\")), mdx(\"h2\", null, \"Example 2: Explicit Declaration\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"forEach\"), \" does not accept \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeB\"), \". Defining a variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" with the explicit type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeB\"), \" and providing only the field that is common with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \" is not enough to have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" to compile when passing to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"forEach\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const b: TypeB = { id: 1 };\\nforEach(b); // Does not work because we typed explicitly to TypeB (and having the right TypeB structure, hence no coearcing with as)\\n\")), mdx(\"p\", null, \"That makes sense in terms of \\\"naming\\\" being different. Hence, by being explicit, you are protecting yourself.\"), mdx(\"h2\", null, \"Example 3: Implicit or Explicit with Discriminant Field\"), mdx(\"p\", null, \"While I try to be as explicit as possible, there are many situations where being implicit is valid. \"), mdx(\"p\", null, \"There is an easy fix that is a default when using GraphQL. In GraphQL, when you generate your TypeScript type (interface), you receive all the translated properties from the GraphQL schema type to the TypeScript interface. However, it comes with a discriminant field. The discriminant field is a field in which the type is a unique string. It is critical to understand that the field type is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not\"), \" of string but a particular string. If we transform the previous example to have a discriminant field, the two types become:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{1,7}\",\n    \"{1,7}\": true\n  }, \"interface TypeA {\\n    __typename: \\\"TypeA\\\";\\n    id?: number;\\n    name?: string;\\n}\\n\\ninterface TypeB {\\n    __typename: \\\"TypeB\\\";\\n    id?: number;\\n    age?: number;\\n}\\n\")), mdx(\"p\", null, \"With the field in place, you can write:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const d = { __typename: \\\"TypeA\\\" as const, id: 1 }; // Match TypeA without specifying the type\\nforEach(d); // Works because __typename is defined\\n\")), mdx(\"p\", null, \"The variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"d\"), \" is not officially of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \" but it does respect the structure of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \" and hence can be used with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"forEach\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\",\n    \"metastring\": \"{1,7}\",\n    \"{1,7}\": true\n  }, \"interface TypeA {\\n    __typename?: \\\"TypeA\\\";\\n    id?: number;\\n    name?: string;\\n}\\n\\ninterface TypeB {\\n    __typename?: \\\"TypeB\\\";\\n    id?: number;\\n    age?: number;\\n}\\n\")), mdx(\"p\", null, \"Differently but with the same result, if you have the discriminant optional, it remains enough to block a type with a discriminant of a type that is not \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const e = { __typename: \\\"TypeB\\\" as const, id: 1 }; \\nforEach(e);\\n\")), mdx(\"p\", null, \"The reason is that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"forEach\"), \" expect \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \" or should we way a structure that respects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"__typename?: \\\"TypeA\\\";\\nid?: number;\\nname?: string;\\n\")), mdx(\"p\", null, \"We can see that because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__typename\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"e\"), \" is set to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeB\"), \" that it does not pass the structural comparison. The accepted values are for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__typename\"), \" to be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \" or nothing at all.\"), mdx(\"p\", null, \"Hence this compile:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const e = { __typename: undefined, id: 1 }; \\nconst f = { __typename: \\\"TypeA\\\" as const, id: 1 }; \\nconst g = { id: 1, name: undefined }; \\nforEach(e);\\nforEach(f);\\nforEach(g);\\n\")), mdx(\"p\", null, \"However, this one does not:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const h = { __typename: \\\"TypeA\\\" , id: 1 }; \\nforEach(g);\\n\")), mdx(\"p\", null, \"A keen observer understands that the type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h\"), \" is still not of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeA\"), \" but results in an unnamed type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{__typename: string; id: number}\"), \" which is not the same as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{__typename: \\\"TypeA\\\"; id: number}\"), \". We are using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as const\"), \" previously to have TypeScript narrowing down the type to is strictness definition.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"Interfaces and types are structural in TypeScript, and the name does not matter. However, it is essential to understand the concept, and it is potent as it does not require a lot of work around building an object with a name in mind. Relying on a discriminant field is one of my favorite patterns. It does not require creating a function to create a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates\"\n  }, \"user-defined guard\"), \" removing to work with casting and generating a lot of code as the amount of interface grow. Also, it works well even if all the fields are optional, which might happen as we saw in the scenario that a situation force you to have all the fields optional (e.g., Protobuf outside your control).\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"e6578d43-c998-59bf-839b-9ea4ab038b37","totalPages":76}},
    "staticQueryHashes": ["3159585216"]}