{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/integer-displaytemplates-editortemplates-and-nullable-value",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Integer DisplayTemplates, EditorTemplates and Nullable Value","date":"June 10, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Integer DisplayTemplates, EditorTemplates and Nullable Value\",\n  \"date\": \"2014-06-10\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"You can define templates in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DisplayTemplates\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EditorTemplates\"), \". If you define one template for integer your can have an error saying that the model item require a string.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The model item passed into the dictionary is of type 'System.Int32', but this dictionary requires a model item of type 'System.String'\")), mdx(\"p\", null, \"This error occurs if you name the template int.cshtml or integer.cshtml. Even if you have defined the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@model int\"), \" or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@model int?\"), \".\"), mdx(\"p\", null, \"The solution is to name the file \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Int32.cshtml\"), \". CLR type name are used and not C# alias.\"), mdx(\"p\", null, \"Another detail important to remember is that if you want to have \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"integer\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"nullable integer\"), \" you can only do it withing one template. So, always define the type with its nullable type. For example, the integer should be in the file Int32.cshtml and the template could be something like this (for DisplayTemplate):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" @model int? @if (Model.HasValue) { @Html.Raw(Model) } else { @:- } \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"e93b260c-2d7d-565c-845c-247643054b2e","totalPages":71}},
    "staticQueryHashes": ["3159585216"]}