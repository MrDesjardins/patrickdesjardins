{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-unit-test-private-method-in-typescript-part-2",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to unit test private method in TypeScript (part 2)","date":"April 13, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to unit test private method in TypeScript (part 2)\",\n  \"date\": \"2017-04-13\",\n  \"categories\": [\"test\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I already posted about \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./unit-testing-with-typescript-3-tricks-to-help-you-with-private-method\"\n  }, \"how to write unit tests for private method with TypeScript\"), \" about one year ago. Few days ago, I had the same discussion that I had in my previous team concerning private method. The situation is similar. Developers don't test private method and rely on public method to reach those private methods. At first, it may sound that we are going inside those private methods, therefore we are doing proper unit testing.\"), mdx(\"p\", null, \"The problem by going through intermediate methods to access the one we want to test is that any change on intermediate methods will make multiple test to fail. When a unit tests fail, the goal is to know which unit of your code is failing. Imagine the situation where you have class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A\"), \" that has method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a1\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a2\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a3\"), \". You want to to unit test \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a3\"), \", but the only entry point is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a1\"), \" which is the only method public. This one call \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a2\"), \", who call in some particular situation \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a3\"), \". You have multiple conditions in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a3\"), \" and you evaluate that you need 5 unit tests. The problem is that if \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a1\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a2\"), \" change in the future that all these 5 tests may fail, when they should not.\"), mdx(\"p\", null, \"At that point, most people understand the situation and agree to test the private methods. However, there is some good ways to do it and some bad ways. The worst way to do it to cast the class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A\"), \" to be of type any and call \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a3\"), \" directly. Something like :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"// Bad way: \\nvar a = new A(); (a as any).a3(); \\n\")), mdx(\"p\", null, \"The problem with the above code is that when you will refactor \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a3\"), \" to have a better name that no tool will find out this instance. More, this open the door to access private fields or inject new functions and fields to the class. At the end, it become a nightmare to maintain. We are using TypeScript to be strongly typed, our tests should continue to be as strong.\"), mdx(\"p\", null, \"In the previous article I wrote, I talked about 2 patterns. The first one is about working around encapsulation with an interface. The second had two variations.\"), mdx(\"p\", null, \"Let's remember the first pattern. The first pattern is that class A should have an interface IA that is used everywhere. IA would only expose the method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a1\"), \". Everywhere you use the interface and the only place where it doesn't it's when it's getting injected by the inversion of control container. However, we can leverage this abstraction to keep a strong encapsulation for the application and use the implementation that has every method public. This way, developers still have only access to a1 in our example, but in our test we have access to everything else. This might not sound a proper solution at first since we open the encapsulation on the implemented class, but it's the cheapest way to be able to test unit tests. That said, I am all with you that there is other solution like the pattern #2 presented in the previous article.\"), mdx(\"p\", null, \"The second pattern presented was about moving code around. In our example, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a2\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a3\"), \" are private and could be moved outside an other class. For example, let's say that A was a user class, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a1\"), \" was a method to get the user information to display to the screen, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a2\"), \" a method to get the address information and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a3\"), \" a method to format the street address. This could be refactored from :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"class User{ public getUserInformationToDisplay(){ \\n  //... \\n  this.getUserAddress(); \\n  //... }\\n\\n  private getUserAddress(){ \\n    //... \\n    this.formatStreet(); \\n    //... \\n  } \\n  private formatStreet(){ \\n    //... \\n  } \\n} \\n\")), mdx(\"p\", null, \"to: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"class User{ \\n  private address:Address; \\n  public getUserInformationToDisplay(){ \\n    //... \\n    address.getUserAddress(); \\n    //... \\n  } \\n} \\n\\nclass Address{ \\n  private format: StreetFormatter; \\n  public format(){ \\n    //... \\n    format.ToString(); \\n    //... \\n    } \\n} \\n\\nclass StreetFormatter{ \\n  public toString(){ \\n    // ... \\n  } \\n} \\n\")), mdx(\"p\", null, \"Originally, we wanted to test the private method formatStreet (a3), and now it's very easy because I do not even need to care about all the classes or function that call it, just to unit test the StreetFormatter class (which was the original a3). this is the best way to unit test private method : to divide it correctly into specific class. This is also costly in term of time.\"), mdx(\"p\", null, \"I always prefer the second approach, but time constraints and the high velocity of shipping features is always that is a higher priority -- even in software shop where the message is quality first. That said, I prefer using the first approach than not having any unit tests at all. It's a good compromise that work well what ever your framework. I used both approach in TypeScript code that was using proprietary framework, as well with React and now with Angular. At the end, the important is to have the best coverage while being sure that everything tested are solid to help the software and not slow down the whole development.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"798929a6-6032-524f-b2dd-dc04d096fe8d","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}