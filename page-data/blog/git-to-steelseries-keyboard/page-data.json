{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/git-to-steelseries-keyboard",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Display Git Pull Request Status on the Steelseries APEX 7 TKL keyboard OLED","date":"January 26, 2024"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Display Git Pull Request Status on the Steelseries APEX 7 TKL keyboard OLED\",\n  \"date\": \"2024-01-26\",\n  \"categories\": [\"python\", \"steelseries\", \"github\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://steelseries.com/gaming-keyboards/apex-7-tkl?switch=brown\"\n  }, \"Steelseries APEX 7 TKL keyboard\"), \" has a small OLED screen. Steelseries offers an application called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://steelseries.com/gg/engine\"\n  }, \"Steelseries GG Engine\"), \" where you can configure LED and OLED. The application is a marketplace with several game and application integrations. The most interesting is the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SteelSeries/gamesense-sdk\"\n  }, \"Steelseries Game Sense SDK\"), \". The SDK contains an HTTP  JSON API. The API, using JSON messages, allows you to create your application, which can post text to the OLED. In this article, we will connect to Github for active pull requests and determine which pull requests are ready to merge and which are blocked.\"), mdx(\"h1\", null, \"Pre-Requisites\"), mdx(\"p\", null, \"The script is in Python but can be written in any language. Prototyping with Python is quick, and performing a few HTTP requests does not require too much code.\\nThere are few dependencies. One is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"request\"), \" to perform an HTTP request to the API. The second is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule\"), \" as we want the code to fetch Git status at regular intervals but also send a periodic heartbeat to the application.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"requests==2.31.0\\nschedule==1.2.1\\n\")), mdx(\"h1\", null, \"Import, Constants and Class\"), mdx(\"p\", null, \"At first, few imports are required. The imports are mostly used to manage the HTTP requests and schedule them. Then, a few constants for status to compare from the GIT pull request API, then a few for registering the application and the event. Finally, the Git token to authenticate to GitHub. The username filters the list of pull requests to get only yours.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"import requests\\nimport json\\nfrom string import Template\\nimport schedule\\nimport time\\nimport re\\n\\nMERGEABLE = \\\"Mergeable\\\"\\nBLOCKED = \\\"Blocked\\\"\\ngameName = \\\"GITHUB\\\"\\nevent = \\\"TEXT_PR\\\"\\nGIT_TOKEN = \\\"<Redacted>\\\"\\nUSERNAME = \\\"pdesjardins\\\"  \\n\\nclass Result:\\n    def __init__(self, prId, prTitle, prStatus):\\n        self.prId, self.prTitle, self.prStatus = prId, prTitle, prStatus\\n\")), mdx(\"p\", null, \"The class will contain results from the filtered list of PR. Creating an array of objects in this class gives a clean way to move the data to the OLED keyboard.\"), mdx(\"h1\", null, \"Fetching Github\"), mdx(\"p\", null, \"The first piece of code is fetching from the Git repository. It can be the Github.com or your corporate, private Github repository. The following code has \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<redacted>\"), \", which needs to have your details. Ideally, this would be also in constants. What is essential is returning the list of pull requests.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def fetchGitHub():\\n    url = \\\"https://<redacted>/api/v3/repos/<redacted>/<redacted>/pulls\\\"\\n    headers = {\\n        \\\"Accept\\\": \\\"application/vnd.github+json\\\",\\n        \\\"Authorization\\\": f\\\"Bearer {GIT_TOKEN}\\\",\\n        \\\"X-GitHub-Api-Version\\\": \\\"2022-11-28\\\",\\n    }\\n    r = requests.get(url, headers=headers)\\n    responseJson = r.json()\\n    filtered_list = [\\n        {\\\"number\\\": e[\\\"number\\\"], \\\"title\\\": e[\\\"title\\\"], \\\"url\\\": e[\\\"url\\\"]}\\n        for e in responseJson\\n        if e[\\\"user\\\"][\\\"login\\\"] == USERNAME\\n    ]\\n    prs = []\\n    for e in filtered_list:\\n        urlTemplatePullRequest = Template(\\n            \\\"https://<redacted>/api/v3/repos/<redacted>/<redacted>/pulls/$number\\\"\\n        )\\n        url = urlTemplatePullRequest.substitute(number=e[\\\"number\\\"])\\n        r = requests.get(url, headers=headers)\\n        responseJson = r.json()\\n        status = \\\"True\\\" if responseJson[\\\"mergeable\\\"] == MERGEABLE else BLOCKED\\n        cleanTitle = re.sub(\\\"\\\\[[^]]*\\\\]\\\", lambda x: \\\"\\\", e[\\\"title\\\"]).strip()\\n        print(f'[{e[\\\"number\\\"]}]{cleanTitle} - {status}')\\n        prs.append(Result(e[\\\"number\\\"], cleanTitle, status))\\n    return prs\\n\")), mdx(\"h1\", null, \"Registering the game and events\"), mdx(\"p\", null, \"The way the API works is that you must register your \\\"game,\\\" which is your application. Then, you must tell the API what event you will send. Then, you send the events and heartbeat to the API every few seconds to keep your application alive.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"headers = {\\\"Content-Type\\\": \\\"application/json\\\"}\\nconfigFilePath = \\\"/Library/Application Support/SteelSeries Engine 3/coreProps.json\\\"\\nconfig = json.load(open(configFilePath))\\nkeyboardAddressPort = config[\\\"address\\\"]\\nurlBase = f\\\"http://{keyboardAddressPort}\\\"\\nurlUnregisterGame = f\\\"{urlBase}/remove_game\\\"\\nurlRegisterGame = f\\\"{urlBase}/game_metadata\\\"\\nurlBindGame = f\\\"{urlBase}/bind_game_event\\\"\\nurlGameEvent = f\\\"{urlBase}/game_event\\\"\\nurlHeartBeat = f\\\"{urlBase}/game_heartbeat\\\"\\n\\n### Register Game\\ndef registerGame():\\n    r = requests.post(urlUnregisterGame, json={\\\"game\\\": gameName})\\n    print(\\\"UnRegistering Game\\\")\\n    print(r.text)\\n    payload = {\\n        \\\"game\\\": gameName,\\n        \\\"game_display_name\\\": gameName,\\n        \\\"developer\\\": \\\"Patrick\\\",\\n        \\\"deinitialize_timer_length_ms\\\": 60000,\\n    }\\n    r = requests.post(urlRegisterGame, json=payload)\\n    print(\\\"Registering Game\\\")\\n    print(r.text)\\n\\n\\n### Bind Game\\ndef bindGame():\\n    payload = {\\n        \\\"game\\\": gameName,\\n        \\\"event\\\": event,\\n        \\\"icon_id\\\": 4,\\n        \\\"value_optional\\\": r'\\\"true\\\"',\\n        \\\"handlers\\\": [\\n            {\\n                \\\"device-type\\\": \\\"screened-128x40\\\",\\n                \\\"zone\\\": \\\"one\\\",\\n                \\\"mode\\\": \\\"screen\\\",\\n                \\\"datas\\\": [\\n                    {\\n                        \\\"lines\\\": [\\n                            {\\\"has-text\\\": True, \\\"context-frame-key\\\": \\\"line1\\\"},\\n                            {\\n                                \\\"has-text\\\": True,\\n                                \\\"context-frame-key\\\": \\\"line2\\\",\\n                            },\\n                        ],\\n                    }\\n                ],\\n            }\\n        ],\\n    }\\n    r = requests.post(urlBindGame, json=payload)\\n    print(\\\"Registering Game\\\")\\n    print(r.text)\\n\")), mdx(\"h1\", null, \"Sending The Data\"), mdx(\"p\", null, \"Sending data to the keyboard uses the previous step's registered game (application) and event. This time, we are sending the information from GitHub. The OLED has two lines.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"counter = 0\\n### Send Event\\ndef sendEvent(line1, line2):\\n    global counter\\n    payload = {\\n        \\\"game\\\": gameName,\\n        \\\"event\\\": event,\\n        \\\"value_optional\\\": r'\\\"true\\\"',\\n        \\\"device-type\\\": \\\"screened-128x40\\\",\\n        \\\"zone\\\": \\\"one\\\",\\n        \\\"mode\\\": \\\"screen\\\",\\n        \\\"data\\\": {\\n            \\\"value\\\": counter,\\n            \\\"frame\\\": {\\\"line1\\\": line1, \\\"line2\\\": line2},\\n        },\\n    }\\n    counter += 1\\n    r = requests.post(urlGameEvent, json=payload)\\n    print(\\\"Send Event Response\\\")\\n    print(r.text)\\n\")), mdx(\"h3\", null, \"Heart Beat\"), mdx(\"p\", null, \"Without a heartbeat, the application does not stay alive to receive future HTTP calls to update the screen. Thus, you must send a heartbeat.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def heartbeat():\\n    payload = {\\n        \\\"game\\\": gameName,\\n    }\\n    r = requests.post(urlHeartBeat, json=payload)\\n    print(\\\"Send Heartbeat\\\")\\n    print(r.text)\\n\")), mdx(\"h2\", null, \"Logic\"), mdx(\"p\", null, \"The code bridges the gap between the Git response and the OLED, which means that it gets a specific message. In that case, if a single pull request is made, the name is shown with the status. Otherwise, the first line is the number of PRs that can merge, and the second is the number of PRs that are blocked.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def fetchAndShow():\\n    prs = fetchGitHub()\\n    meargable = 0\\n    blocked = 0\\n    for pr in prs:\\n        if pr.prStatus == MERGEABLE:\\n            meargable += 1\\n        else:\\n            blocked += 1\\n    if meargable + blocked <= 1:\\n        now = time.localtime()\\n        current_time = time.strftime(\\\"%H:%M\\\", now)\\n        status = BLOCKED if blocked == 1 else MERGEABLE\\n        sendEvent(pr.prTitle, f\\\"Pr {status} at {current_time}\\\")\\n    else:\\n        sendEvent(\\n            f\\\"Pr Mergeable: {meargable}\\\",\\n            f\\\"Pr Blocked: {blocked}\\\",\\n        )\\n\")), mdx(\"h1\", null, \"Bringing Everything Together\"), mdx(\"p\", null, \"The last step is to call the methods. I amregistering, binding, and sending events. The first event never shows on the OLED. I'm sending a \\\"loading\\\" to ensure the real message works. Heartbeat is scheduled every five seconds, and every two minutes, the script fetch from Git and refresh the OLED.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"registerGame()\\nbindGame()\\nsendEvent(\\\"Github PR Status\\\", \\\"Loading...\\\")\\nfetchAndShow()\\nschedule.every(5).seconds.do(heartbeat)\\nschedule.every(2).minutes.do(fetchAndShow)\\nwhile True:\\n    schedule.run_pending()\\n    time.sleep(10)\\n\")), mdx(\"h1\", null, \"Links\"), mdx(\"p\", null, \"Here are excellent links that give more insight into using the API.\"), mdx(\"h2\", null, \"Examples Code for GitHub\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.github.com/en/enterprise-server@3.11/rest/guides/using-the-rest-api-to-interact-with-your-git-database?apiVersion=2022-11-28#checking-mergeability-of-pull-requests\"\n  }, \"https://docs.github.com/en/enterprise-server@3.11/rest/guides/using-the-rest-api-to-interact-with-your-git-database?apiVersion=2022-11-28#checking-mergeability-of-pull-requests\")), mdx(\"h2\", null, \"Examples Code for Steel Series GG\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/badaz/steelseries-gamesense-oled-fps-counter\"\n  }, \"https://github.com/badaz/steelseries-gamesense-oled-fps-counter\"), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/slattery-mark/SteelSeries-CKL-App/tree/master\"\n  }, \"https://github.com/slattery-mark/SteelSeries-CKL-App/tree/master\"), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.reddit.com/r/steelseries/comments/ol4uuu/custom_keyboard_lighting_app_python/\"\n  }, \"https://www.reddit.com/r/steelseries/comments/ol4uuu/custom_keyboard_lighting_app_python/\"), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/wolfinabox/Steelseries-OLED-Display-Mirror/blob/master\"\n  }, \"https://github.com/wolfinabox/Steelseries-OLED-Display-Mirror/blob/master\"), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/anishg24/gamesense/blob/ec6435378de1711c0c88f667bc30bbb3db9832cc/gamesense/gamesense.py\"\n  }, \"https://github.com/anishg24/gamesense/blob/ec6435378de1711c0c88f667bc30bbb3db9832cc/gamesense/gamesense.py\")), mdx(\"h2\", null, \"Official Docs for Steel Series GG\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SteelSeries/gamesense-sdk/blob/master/doc/api/json-handlers-screen.md\"\n  }, \"https://github.com/SteelSeries/gamesense-sdk/blob/master/doc/api/json-handlers-screen.md\"), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SteelSeries/gamesense-sdk/blob/master/doc/api/sending-game-events.md\"\n  }, \"https://github.com/SteelSeries/gamesense-sdk/blob/master/doc/api/sending-game-events.md\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"7fab9644-b038-5c4f-bfc8-1242b0526bde","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}