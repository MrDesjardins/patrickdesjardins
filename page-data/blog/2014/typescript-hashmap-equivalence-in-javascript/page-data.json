{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2014/typescript-hashmap-equivalence-in-javascript/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript Hashmap Equivalence in JavaScript","date":"October 21, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript Hashmap Equivalence in JavaScript\",\n  \"date\": \"2014-10-21\",\n  \"categories\": [\"javascript\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"TypeScript is transformed into JavaScript and sometime you start some of your code into TypeScript and finish into JavaScript. This is a scenario that you can see when developing some code in TypeScript and at some point is integrated into some existing JavaScript code.\"), mdx(\"p\", null, \"TypeScript allows to have hash map in which you define the type for your key and for the value that it will hold. Let's take the example of a hash map that has a string key and a string value. ```typescript\\nvar arr = { \", \"[path:string]\", \":string; }; //Hashmap that has for key a string and for value a string \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\n\\nIf you need to use this variable in JavaScript and be sure that it will continue to work when coming back into some JavaScript generated by TypeScript you have to keep in mind that this is in fact a double array. If you want to define some values for this variable, you must define for each key a property that contains an array of value. For example imagine two keys with two values each like the example below. ```typescript\\nvar arr = {'k1':['p1','p2'],'k2':['2p1','2p2']} \\n\")), mdx(\"p\", null, \"This is a working example that can be read back in TypeScript. It is also possible with JavaScript to get back all information by looping through all the keys and values even if the k1 and k2 of the previous example are properties.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"for (var key in arr) { var allValues = arr[key]; for (var keyValue in allValues) { console.log('Key ' + key + ' has value : ' + allValues[keyValue]); } } \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"b60a23e7-e4c3-5a8f-b01d-33f7767c77e4","slug":"2014/typescript-hashmap-equivalence-in-javascript","__params":{"slug":"2014"}}},
    "staticQueryHashes": ["3159585216"]}