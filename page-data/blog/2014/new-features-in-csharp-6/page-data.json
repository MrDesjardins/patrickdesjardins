{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2014/new-features-in-csharp-6/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"New Features in C# 6.0","date":"November 19, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"New Features in C# 6.0\",\n  \"date\": \"2014-11-19\",\n  \"categories\": [\"c-sharp\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Soon, Microsoft is releasing the new version of C#. Here are some of the most interesting feature that the version 6.0 provides. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Auto property\"), \" Auto-Properties can have only getter instead of having setter and getter. Before C# 6.0, you had to have a private setter. Now, you can have only the getter by ommiting the set keyword into the curly bracket. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public int {get;} \\n``` That say, it is also convenient that you can now have a initial value to the property. This is valid for property with only getter but also for property with setter and getter. \\n```csharp\\n public int {get;} = 5; \\n``` Static method does not need to specify the class where it belongs. For example, with C# 5, you have to specify the _Math_ method using the Absolute method, _Abs_. It does not mean that you have to use that shortcut. However, it can be useful to reduce the amount of repetition in your code if you are using intensively static methods. \\n```csharp\\n Math.Abs(-1); //Old way, that is still valid Abs(-1); //New way \\n``` **String.Format** String.Format has a new format with string **interpolation**. This mean that instead of relying on index to define placeholder, that you can use something more meaning full. For example, if you have a variable that you want to insert into a string, instead of specifying the index 0, you can simply use the backslash with the curly brace with the variable. \\n```csharp\\n return String.Format(\\\"This is my name '{0}'\\\", name); //Old way, that is still valid return \\\"This is my name '\\\\\\\\{name}'\\\"; //New way \\n``` **Methods** Methods can return lambda. This is quite interesting for small method. \\n```csharp\\n public string ReturnStringMethod() { return \\\"A string\\\"; } //Can be rewritten by : public string ReturnStringMethod() => \\\"A string\\\"; \\n``` You can also now use the **nameof** method to have a string that represent the variable name. This is very interesting because it reduces the problem while refactoring. The string that is present into the exception can now be dynamically link to the variable name which Visual Studio fully support during refactoring. \\n```csharp\\n public void YourMethod(Object yourArgument) { if(yourArgument == null) { throw New ArgumentNullException(\\\"yourArgument\\\", \\\"Cannot be null\\\") //Before we had to specify with a string } }\\n\\npublic void YourMethod(Object yourArgument) { if(yourArgument == null) { throw New ArgumentNullException(nameof(yourArgument), \\\"Cannot be null\\\") //Now we have a method } } \\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Index initializer\"), \" If you object define the square bracket operator you can now use the default initializer to set values. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" new YourObjectWithIndex{[\\\"var1\\\"] = 1, [\\\"var2\\\"] = 2}; \\n``` **Null conditional operators** A new operator is born to check if something is null. It is the **?.**. It verify if the variable before the operator is null. If yes, nothing after is executed. If it is not null, than it continue to execute what is on the right. \\n```csharp\\n //Before if(variable != null && variable.property != null) { variable.property.test = \\\"okay\\\"; } //Now variable?.property?.test = \\\"okay\\\" \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"70fb3ae3-fc4b-5db3-ac74-b8bd91f5972e","slug":"2014/new-features-in-csharp-6","__params":{"slug":"2014"}}},
    "staticQueryHashes": ["3159585216"]}