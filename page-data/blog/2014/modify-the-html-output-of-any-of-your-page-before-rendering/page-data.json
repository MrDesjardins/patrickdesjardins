{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2014/modify-the-html-output-of-any-of-your-page-before-rendering/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Modify the Html Output of any of your Page Before Rendering","date":"November 4, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Modify the Html Output of any of your Page Before Rendering\",\n  \"date\": \"2014-11-04\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In some situation, you may want to alter the html output that the Asp.Net MVC render. An interesting use case is that you may have several user controls that inject directly into the html some JavaScript or CSS. To keep your page loading fast, you want to have everything at the bottom of the html. Of course, other method exist but one can be to let Asp.Net MVC render everthing and just before sending back to the client the Html output to remove those JavaScript and CSS tag of the Html markup and to add them at the bottom of this Html. This article describe how to modify the Asp.Net MVC default rendering pipeline to inject your own hook that will be placed between the end of the Asp.Net MVC rendering engine and the sending of this one to the client. It will also explains how to have this option in an atomic scenario of only allowing this alteration for a specific action up to all requests.\"), mdx(\"p\", null, \"The first class to create is the class that will play with the content produced. I create a small filter called MyCustomStream that remove all Script tag and replace them by a comment and then add all Script tag before the closing Html tag. This way, all Script are set at the end of the page. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class MyCustomStream : Stream { private readonly Stream filter;\\n\\npublic MyCustomStream(Stream filter) { this.filter = filter; }\\n\\npublic override void Write(byte[] buffer, int offset, int count) { var allScripts = new StringBuilder(); string wholeHtmlDocument = Encoding.UTF8.GetString(buffer, offset, count); var regex = new Regex(@\\\"<script[^>]*>(?<script>([^<]|<[^/])*)</script>\\\", RegexOptions.IgnoreCase | RegexOptions.Multiline); //Remove all Script Tag wholeHtmlDocument = regex.Replace(wholeHtmlDocument, m => { allScripts.Append(m.Groups[\\\"script\\\"].Value); return \\\"<!-- Removed Script -->\\\"; });\\n\\n//Put all Script at the end if (allScripts.Length > 0) { wholeHtmlDocument = wholeHtmlDocument.Replace(\\\"</html>\\\", \\\"<script type='text/javascript'>\\\" + allScripts.ToString() + \\\"</script></html>\\\"); } buffer = Encoding.UTF8.GetBytes(wholeHtmlDocument); this.filter.Write(buffer, 0, buffer.Length); }\\n\\npublic override void Flush() { this.filter.Flush(); }\\n\\npublic override long Seek(long offset, SeekOrigin origin) { return this.filter.Seek(offset, origin); }\\n\\npublic override void SetLength(long value) { this.filter.SetLength(value); }\\n\\npublic override int Read(byte[] buffer, int offset, int count) { return this.filter.Read(buffer, offset, count); }\\n\\npublic override bool CanRead { get { return this.filter.CanRead; } }\\n\\npublic override bool CanSeek { get { return this.filter.CanSeek; } }\\n\\npublic override bool CanWrite { get { return this.filter.CanWrite; } }\\n\\npublic override long Length { get { return this.filter.Length; } }\\n\\npublic override long Position { get { return this.filter.Position; } set { this.filter.Position = value; } } } \\n\")), mdx(\"p\", null, \"To make it works for controller or action, you must create an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"attribute\"), \". When the action is executed and this one has the attribute (or if the controller of the action has the attribute) the filter is applied.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class MyCustomAttribute: ActionFilterAttribute { public override void OnActionExecuted(ActionExecutedContextfilterContext) { var response = filterContext.HttpContext.Response;\\n\\nif (response.ContentType == \\\"text/html\\\") { response.Filter = new MyCustomStream(filterContext.HttpContext.Response.Filter); } } } \\n\")), mdx(\"p\", null, \"You can also set it to all your controller by setting the attribute to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Global.Asax.cs\"), \" \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" protected void Application_Start() { GlobalFilters.Filters.Add(new MyCustomAttribute()); } \\n\")), mdx(\"p\", null, \"But, so far something is wrong. The filter is called multiple time because the stream is outputed in chunk of several bytes. Since we are playing with the Html rendering, we must replace html element when the whole document is loaded. This require us to modify a little bit the implementation above. The filter class must have a buffer. We will append all chunk into our buffer and when this one is full, we will act our transformation on this buffer and use this memory buffer to output into the filter stream.\"), mdx(\"p\", null, \"The first step is to have a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Stream\"), \" to buffer. I choose to use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"MemoryStream\"), \" because it has some method like ToArray() that simplify our life when it is the time to read the whole buffer. The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Flush\"), \" method needs modification to accumulate all bytes of the page before hooking the filter and write back the modified buffer. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class MyCustomStream : Stream {\\n\\nprivate readonly Stream filter; private readonly MemoryStream cacheStream = new MemoryStream();\\n\\npublic MyCustomStream(Stream filter) { this.filter = filter; }\\n\\npublic override void Write(byte[] buffer, int offset, int count) { cacheStream.Write(buffer, 0, count); }\\n\\npublic override void Flush() { if (cacheStream.Length > 0) { var allScripts = new StringBuilder(); string wholeHtmlDocument = Encoding.UTF8.GetString(cacheStream.ToArray(), 0, (int)cacheStream.Length); var regex = new Regex(@\\\"<script[^>]*>(?<script>([^<]|<[^/])*)</script>\\\", RegexOptions.IgnoreCase | RegexOptions.Multiline); //Remove all Script Tag wholeHtmlDocument = regex.Replace(wholeHtmlDocument, m => { allScripts.Append(m.Groups[0].Value); return \\\"<!-- Removed Script -->\\\"; });\\n\\n//Put all Script at the end if (allScripts.Length > 0) { wholeHtmlDocument = wholeHtmlDocument.Replace(\\\"</html>\\\", \\\"<script type='text/javascript'>\\\" + allScripts.ToString() + \\\"</script></html>\\\"); } var buffer = Encoding.UTF8.GetBytes(wholeHtmlDocument); this.filter.Write(buffer, 0, buffer.Length); cacheStream.SetLength(0); } this.filter.Flush(); }\\n\\npublic override long Seek(long offset, SeekOrigin origin) { return this.filter.Seek(offset, origin); }\\n\\npublic override void SetLength(long value) { this.filter.SetLength(value); }\\n\\npublic override int Read(byte[] buffer, int offset, int count) { return this.filter.Read(buffer, offset, count); }\\n\\npublic override bool CanRead { get { return this.filter.CanRead; } }\\n\\npublic override bool CanSeek { get { return this.filter.CanSeek; } }\\n\\npublic override bool CanWrite { get { return this.filter.CanWrite; } }\\n\\npublic override long Length { get { return this.filter.Length; } }\\n\\npublic override long Position { get { return this.filter.Position; } set { this.filter.Position = value; } } } \\n\")), mdx(\"p\", null, \"You can put what ever you want inside the if statement of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Flush\"), \" method. In my case, I remove all script of the file, replace them with a comment and finally put all scripts at the end of the file, just before the closing Html tag.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"400px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/patrickdesjardins/static/696a98ff3b98fecbdbd1b26e2daa4769/e17e5/MovingScriptToBottom-400x184.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"46%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQklEQVQoz5WRi46cMAwA+f9/7Ap2TywsLIdD3iTMKeEeumurqpZGliJ7YieN2jRGFPeXnmGYec4rWm0ocUhBeZTyrKtHxKBEEBGstnjvcc5V0p44joNmGDRaFI9xZFmEECK+FNmAdxHnI859ED4lwQdijKSUKjnnUzhNGqcN8/Rgnl/R2mI2jYhlU75OWCcVf55tG0qpukWRFkmJkqtwnhTOuCpJ+bxt3/eaP4prA1/x7fxd9CkUpYk+sK0bIQRiiHWlsnZO+beGf9EMd0vKAe0MYQ/wY5L/FooSVrPylCfWW/a0/yjiL3H8AWjmeeG5LixK8KH8Wibl4/y1nCrp/U3L256ks27P7IV4sMeMNZnm2gp9u/DSrbSXVy6XhcuviWs7cm2HStcKXWfoOk3XbVxvhsdgGXvN2FvmwXK/Gfqb5Q3fybyvK3NIigAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"MovingScriptToBottom 400x184\",\n    \"title\": \"MovingScriptToBottom 400x184\",\n    \"src\": \"/patrickdesjardins/static/696a98ff3b98fecbdbd1b26e2daa4769/e17e5/MovingScriptToBottom-400x184.png\",\n    \"srcSet\": [\"/patrickdesjardins/static/696a98ff3b98fecbdbd1b26e2daa4769/5a46d/MovingScriptToBottom-400x184.png 300w\", \"/patrickdesjardins/static/696a98ff3b98fecbdbd1b26e2daa4769/e17e5/MovingScriptToBottom-400x184.png 400w\"],\n    \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The result can be seen if you show the source in any browser. This method is efficient but as a cost that we are playing with the output result and indeed add some overhead in the rendering pipeline. This kind of filter must be used only in specific cases where it is the only way to accomplish a transformation. The case of JavaScript or CSS are two cases where it is logic to do if you are developing in an older oriented way where \\\"control/component/usercontrol\\\" inject their own JavaScript and CSS. However, in new system, you should not rely on this kind of replacement. It tends to develop bad habit to throw code everywhere without checking the consequence. It also add some performance penalty by having to pass through all the code instead of initially setting at the right place the code. This can be efficiently done by using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"section\"), \" with ASP.net MVC. Finally, this kind of replacement can cause problem because of dependencies. In this small example, nothing really is changed, but in bigger code base some JavaScript may need to be before specific Html elements or have dependencies to other JavaScript files. Moving with automatic process may require more code than the one shown in this article.\"), mdx(\"p\", null, \"You can find the source code of this example in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/FilterExample\"\n  }, \"GitHub\"), \" or download the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/FilterExample/archive/master.zip\"\n  }, \"zip file\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"f9775a27-db31-5456-bdaf-65e32d8a4686","slug":"2014/modify-the-html-output-of-any-of-your-page-before-rendering","__params":{"slug":"2014"}}},
    "staticQueryHashes": ["3159585216"]}