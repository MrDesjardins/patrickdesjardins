{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/using-transaction-with-wcf-services",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Using Transaction with WCF Services","date":"December 20, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Using Transaction with WCF Services\",\n  \"date\": \"2013-12-20\",\n  \"categories\": [\"wcf\", \"webservices\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you need to call two different WCF service and be sure that both are successful before committing, you'll need to use transaction. This will require that both service's operation contain the attribute \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TransactionFlow\"), \" with the option to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Allowed\"), \". Many other option could have been possible. NotAllowed is when you do not want to be part of transaction, which is the default value. Allowed allows to participate in a transaction if the client specify in his code a transaction scope. Finally, mandatory force that the operation is called within a transaction scope.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" [ServiceContract] public interface IServiceContractOne { [OperationContract] [TransactionFlow(TransactionFlowOption.Allowed)] void Method1(); } \\n\")), mdx(\"p\", null, \"The next step is the implementation of this contract. The method Method1() that has the TransactionFlow attribute needs to have also an attribute, this time it's \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"OperationBehavior\"), \". \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"\\n\\n[OperationBehavior(TransactionScopeRequired = true)] public void Method1() { //Entity Framework here } \\n\")), mdx(\"p\", null, \"The method of the contract has an operation behavior that tell that it's require to be inside a transaction scope.\"), mdx(\"p\", null, \"The next step is to configure the web.config. It needs to have for the binding the attribute transactionflow to true.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \" <configuration> <system.serviceModel> <bindings> <wsHttpBinding> <binding name=\\\"MyBinding\\\" transactionFlow=\\\"true\\\" /> </wsHttpBinding> ... ... \\n\")), mdx(\"p\", null, \"Once the binding is created, you need to use this binding.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \" <configuration> <system.serviceModel> <services> <service name=\\\"MyServiceA.Service1\\\"> <endpoint address=\\\"\\\" behaviorConfiguration=\\\"behavior1\\\" binding=\\\"wsHttpBinding\\\" bindingConfiguration=\\\"MyBinding\\\" contract=\\\"MyServiceA.IService1\\\" /> ... ... \\n\")), mdx(\"p\", null, \"I have chosen wshttpbinding because to use transaction you need to use a WS-Atomic Transaction or OleTransactions protocol.\"), mdx(\"p\", null, \"Finally, you can test the transaction by having an application that use the two services (or more) that you created with the contract that has transaction score required.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" using (var scope = new TransactionScope(TransactionScopeOption.RequiresNew)) { try { var obj = new ServiceReference1.Service1(); obj.Method1(); var obj1 = new ServiceReference2.Service1(); obj1.Method1(); ts.Complete(); //Commit everything! } catch (Exception ex) { ts.Dispose(); } } \\n\")), mdx(\"p\", null, \"If any exception occur during the scope of the transaction, everything is rollback.\"), mdx(\"p\", null, \"You can add additional information to the service that has method with transaction mandatory or allowed. It's done with ServiceBehavior. You can specify the transaction time out and also the transaction isolation level. The timeout is a time that you allow for the service to be executed. The isolation level is the same as when you use transaction without services. It tells how to lock the information during the transaction. By default, it's serializable which block everything to be changed. It's the most protective and also the worst in term of performance. I won't discuss about every type of isolation level but some allow you to insert new data while other allow you to simply change everything. You have to figure out which one is the correct for your needs. Do not forget to add System.Transaction reference into your project if you do want to use transaction.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" [ServiceBehavior(TransactionIsolationLevel=System.Transactions.IsolationLevel.Serializable, TransactionTimeout=\\\"00:00:30\\\")] \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"7afa6649-6540-58cd-8c99-5eaf00c9adc9","totalPages":69}},
    "staticQueryHashes": ["3159585216"]}