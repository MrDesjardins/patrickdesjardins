{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/helpchart-introduction",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to use Helm Chart to configure dynamically your Kubernetes file for beginner?","date":"September 14, 2122"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to use Helm Chart to configure dynamically your Kubernetes file for beginner?\",\n  \"date\": \"2122-09-14\",\n  \"categories\": [\"Kubernetes\", \"helm\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar TocAzureContainerSeries = makeShortcode(\"TocAzureContainerSeries\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Kubernetes is a powerful tool that allows you to deploy your servers, load-balancers, and other infrastructure with a common language. However, it does not handle the dynamic portion of the configuration. For example, you might want to inject a specific Docker image tag or an environment variable that changes depending on where the infrastructure is deployed (test/prod). Helm Chart is a templating engine that allows you to specify values in a tree fashion into your Kubernetes configuration.\"), mdx(\"h1\", null, \"Installing Helm Chart\"), mdx(\"p\", null, \"On a Windows machine, you can use Chocolatey:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"choco install kubernetes-helm\\n\")), mdx(\"p\", null, \"On macOS, you can use Brew.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"brew install helm\\n\")), mdx(\"p\", null, \"There is plenty of alternatives depending of your preference or operating system in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://helm.sh/docs/intro/install\"\n  }, \"the official installation page\"), \".\"), mdx(\"h1\", null, \"Getting Started\"), mdx(\"p\", null, \"The first step is to create a Helm. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"create\"), \" command creates a folder with many files and folders. My project already has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Kubernetes\"), \" folder. Hence I moved into it and used the Helm Chart's create command. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"helm create realtimepixel\\n\")), mdx(\"p\", null, \"The last word is your project name and the name of the created folder.\"), mdx(\"h1\", null, \"Generated Files\"), mdx(\"p\", null, \"The generated files are template files. The template files are what Helm is all about. Helm is the glue between Kubernetes configuration and configuration values. Helm takes the values from the file and push them into placeholders of the template files. Help templates are written in YAML and are in two formats: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".yaml\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".tpl\"), \" files. The former is the template files and the value files. The second, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".tpl\"), \" is for a template that can be injected inside the main templates. See, this second template has a way to reuse a portion of the template.\"), mdx(\"h1\", null, \"Template Files\"), mdx(\"p\", null, \"When starting, it can be overwhelming to see all these files and template placeholders. With time, it is customary to remove or add new template files. Most of the generated template contains a section that verify if values are configured. When not provided in the values.yaml file, Helm skips injecting any value making the generated Kubernetes configuration shorter.\"), mdx(\"h1\", null, \"Generated Kubernetes YAML from Heml Templates\"), mdx(\"p\", null, \"With Helm, the command executes toward your Kubernetes cluster. You do not see what is sent. However, there is a way to see what would be a hardcoded Kubernetes values without the template with all the substitution performed into a single file with all the Pods, Services, Controllers, etc.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"helm template realtimepixel ./kubernetes/realtimepixel \\\\\\n--set namespace=realtimepixel-prod \\\\\\n--set image.pullPolicy=Always \\\\\\n--set image.redis.repository=realtimepixel.azurecr.io/realtimepixel_redis \\\\\\n--set image.redis.tag=123123 \\\\\\n--set image.backend.repository=realtimepixel.azurecr.io/realtimepixel_backend \\\\\\n--set image.backend.tag=123123 \\\\\\n--set image.frontend.repository=realtimepixel.azurecr.io/realtimepixel_frontend \\\\\\n--set image.frontend.tag=123123 \\\\\\n> temp.yaml\\n\")), mdx(\"p\", null, \"The command starts with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"helm template realtimepixel ./kubernetes/realtimepixel\"), \" which tell helm to execute the template located on the last part of the command (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"./kubernetes/realtimepixel\"), \").\"), mdx(\"p\", null, \"The remaining commands are a collection of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--set key:value\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set\"), \" represents values that will override the ones defined in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"values.yaml\"), \". In my case, the values provided are the one that are dynamically changed, like the container tag that are injected by the Continous Environment to get the latest.\"), mdx(\"p\", null, \"Finally, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"> temp.yaml\"), \" is the portion that will output a single YAML file that is a Kubernetes configuration without a template. That is the place where you can see if the result generated is the desired.\"), mdx(\"h1\", null, \"Pushing the Configuration\"), mdx(\"p\", null, \"Pushing to Azure or any provider is a matter of having the right context defined in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kubectl\"), \" and upgrading/installing.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"# Get what is available\\nkubectl config get-clusters\\n\\n# Set what the context you want to upgrade or install\\nkubectl config use-context realpixelask2\\n\\n# Ensure you are in the right context\\nkubectl config current-context\\n\\n# Tell Heml to get the values into the template and apply an install if not already present or to upgrade if already there\\nhelm upgrade realtimepixel ./kubernetes/realtimepixel --install\\n\")), mdx(\"p\", null, \"The few commands above are what you need. If you do not have a context with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get-clusters\"), \" you will need to communicate with your Kubernetes provider. For example, with Azure:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"az aks get-credentials -g realtimepixel_resourcegroup -n realpixelask2\\n\")), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"I had the initial intention to dive deeper with Helm, but it is a vast system that is complex and, at the same time, with a limited goal: injecting value to form a value Kubernetes configuration file. So for now, let's wrap up with the main point to remember: Helm is a way to inject configuration into the Kubernetes configuration file. You can find online available Helm Chart for a typical pattern. For example, an NGINX Helm chart allows configuring a web server by passing a few values like ports and files.\"), mdx(TocAzureContainerSeries, {\n    mdxType: \"TocAzureContainerSeries\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"7ea92636-8d3a-5968-843c-8fe6f3c043b4","totalPages":73}},
    "staticQueryHashes": ["3159585216"]}