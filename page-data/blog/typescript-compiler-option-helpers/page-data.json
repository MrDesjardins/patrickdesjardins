{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/typescript-compiler-option-helpers",
    "result": {"data":{"mdx":{"frontmatter":{"title":"TypeScript ImportHelpers Compiler Options","date":"February 15, 2022"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript ImportHelpers Compiler Options\",\n  \"date\": \"2022-02-15\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"TypeScript transpiles your code into JavaScript. In the process, some common functions must be injected into the code if the target does not support the feature. For example, if you are using the spread operator and target an old version of ECMAScript that does not support it, TypeScript must shim a function that behaves at runtime like the spread operator.\"), mdx(\"p\", null, \"Each file that uses a not-supported feature will have an injection. It means that a big project might have hundreds or thousands of duplicated functions. TypeScript's compiler options have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"importHelpers\"), \" option that can be enabled to rely on a single instance of a shim for the whole transpilation.\"), mdx(\"p\", null, \"Here is an example of a tsconfig.json:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"{\\n    \\\"compilerOptions\\\": {\\n        \\\"importHelpers\\\": true\\n    }\\n}\\n\")), mdx(\"p\", null, \"One question that might scratch your mind is, why is it not the default? Well, the truth is that there is an additional step. To rely on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"importHelpers\"), \" you must also have a dependency on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tslib\"), \" package that contains all the functions that will be used by the TypeScript compiler. It is a matter of using the NPM (Node Package Manager) to download it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"npm install tslib --save\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"b926c339-aa76-56ef-a9bc-e4df2cfc608c","totalPages":77}},
    "staticQueryHashes": ["3159585216"]}