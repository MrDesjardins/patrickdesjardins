{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-log-with-entity-framework-4-0",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to log with Entity Framework 4.0?","date":"August 27, 2011"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to log with Entity Framework 4.0?\",\n  \"date\": \"2011-08-27\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Logging with Entity Framework is not the same as \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./how-to-log-with-linq-to-sql\",\n    \"title\": \"How to log with Linq to Sql?\"\n  }, \"logging with Linq to Sql\"), \". First, you need to have a .edx file with at least one entity declared on it because to be able to log, a query must be executed. Like the Linq to Sql, to have a log the query needs to be run and for that it needs to be executed. Here is a snippet of code showing how to log with Entity Framework.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"NorthwindEntities db = new NorthwindEntities(); var source = db.Customers.Where(c => c.CustomerID.StartsWith(\\\"A\\\")); this.gridEF.DataSource = source; this.gridEF.DataBind(); sqlEF.Text = (source as ObjectQuery).ToTraceString(); \\n\")), mdx(\"p\", null, \"The first line contain the Entity Framework ObjectContext that need to be created first. This is done by adding with Visual Studio a new Item of ADO.NET Entity Data Model. To get the log file, after the execution a call to ToTraceString() is required. This require a cast to ObjectQuery to the Query. The reason is that the Where clause return a IQueryable. The ObjectQuery inherit the IQueryable and also a lot other interface :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class ObjectQuery<T> : ObjectQuery, IOrderedQueryable<T>, IQueryable<T>, IEnumerable<T>, IOrderedQueryable, IQueryable, IEnumerable, IListSource \\n\")), mdx(\"p\", null, \"The ToTraceString() come from the inherited class ObjectQuery.\"), mdx(\"p\", null, \"The output of ToTraceString() is the SQL statement executed. Here is an example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" SELECT [Extent1].[CustomerID] AS [CustomerID], [Extent1].[CompanyName] AS [CompanyName] FROM [dbo].[Customers] AS [Extent1] WHERE [Extent1].[CustomerID] LIKE N'A%' \\n\")), mdx(\"p\", null, \"This is interesting if we compare the generated Sql from the Entity Framework and from the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./how-to-log-with-linq-to-sql\",\n    \"title\": \"How to log with Linq to Sql?\"\n  }, \"Linq to Sql\"), \". The \\xA0main difference is that Linq to SQL will use parameters substitution instead of directly add the value to the query. You can see it in the Where clause of the Sql query. The Linq to Sql code looks like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"WHERE [t0].[CustomerID] LIKE @p0\\n\")), mdx(\"p\", null, \"And the Entity Framework looks like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"WHERE [Extent1].[CustomerID] LIKE N'A%'\\n\")), mdx(\"p\", null, \"To conclude, if you want to log Entity Framework generated Sql Query do not forget to add a condition statement when you move into your production environment.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"5e21f4d2-01ea-5bc0-bb81-ee3dcbeb3f42","totalPages":72}},
    "staticQueryHashes": ["3159585216"]}