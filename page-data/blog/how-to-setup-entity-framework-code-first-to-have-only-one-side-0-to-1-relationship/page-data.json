{
    "componentChunkName": "component---src-templates-blog-article-tsx",
    "path": "/blog/how-to-setup-entity-framework-code-first-to-have-only-one-side-0-to-1-relationship",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to setup Entity Framework Code first to have only one side 0 to 1 relationship","date":"October 29, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to setup Entity Framework Code first to have only one side 0 to 1 relationship\",\n  \"date\": \"2013-10-29\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Let say you have an entity that can but doesn't mean will have a relation to another entity. This is a 0..1 to 1 or 0..1 to many.\"), mdx(\"p\", null, \"In this example, we show a scenario where we have one entity that has a relation to a second entity. The second entity doesn't have any reference to the first one.\"), mdx(\"p\", null, \"At first, we may think than this code below works.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" modelBuilder .Entity<EntityOne>() .HasOptional(d => d.EntityTwo) .WithOptionalDependent(); \\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"WithOptionalDependent\"), \" tells EF (Entity Framework) that EntityOne is the one of the two entities that hold the reference which is optional as stated with the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"HasOptional\"), \" property. No! This raise an error that tell that it cannot find EntityTwo_ID key. This is problematic because in the scenario we are talking about the foreign key has a special name. So, we have to configure the foreign key. Of course, if your FK is named EntityTwo_ID than you are all fine.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" modelBuilder .Entity<EntityOne>() .HasOptional(d => d.EntityTwo) .WithOptionalDependent() .Map(d => d.MapKey(\\\"EntityTwoID\\\"); \\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"HasForeignKey\"), \" is not available from \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"WithOptionalDependant\"), \", but with Map we can setup the foreign key name. Unfortunately, this won't work either. The error is an invalid column name. From here, we can realise that the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"MapKey\"), \" is used by the principal entity and not the dependent.\"), mdx(\"p\", null, \"Still, we want to have 0..1 relation. How can we setup this optional relation ship with Entity Framework without having on the other side the property to the other entity? We need to use HasOption and threat the whole situation not as 0..1 to 1 but 0..1 to many. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" modelBuilder .Entity<EntityOne>() .HasOptional(d => d.EntityTwo) .WithMany() .HasForeignKey(d => d.EntityTwoID) ; \\n\")), mdx(\"p\", null, \"To make it works, we use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"WithMany\"), \" without specifying the other side property (since we do not have it) and we use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"HasForeignKey\"), \" to specify the correct foreign key. And that's it! It works!\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"eca5cc3e-b50b-55a8-8d85-b1a0f3c1a2eb","totalPages":68}},
    "staticQueryHashes": ["3159585216"]}