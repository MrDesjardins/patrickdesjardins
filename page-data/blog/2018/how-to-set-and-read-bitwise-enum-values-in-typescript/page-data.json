{
    "componentChunkName": "component---src-pages-blog-mdx-slug-tsx",
    "path": "/blog/2018/how-to-set-and-read-bitwise-enum-values-in-typescript/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"How to set and read bitwise enum values in TypeScript","date":"June 19, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Using a bitwise number in an enum is the way to have a single variable with many potential values. A canonical example is to have a status that can be in several states at the same time. I recently create a generic interface in TypeScript to wrap an entity (any business logic type) to add additional data like the status.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"enum Status { Unknown = 0, New = 1 << 0, Dirty = 1 << 1, InError = 1 << 2, Processing = 1 << 3, PersistedEntity = 1 << 4 } \\n\")), mdx(\"p\", null, \"The similar enum can use a direct number that represents all power of 2 (2^0, 2^1, 2^2, 2^3, 2^4). The importance is to have a number that in binary occupy one spot (0, 10, 100, 1000, 10000).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"enum Status { Unknown = 0, New = 1, Dirty = 2, InError = 4, Processing = 8, PersistedEntity = 16 } \\n\")), mdx(\"p\", null, \"The idea is any variable of this enum type can assign a value directly or combine many values. To assign a single value, the use of the equal sign is good as you would do with an amount that is not bitwise. However, using the equal sign override any previous value assigned to the variable.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"let value: Status = Status.New; console.log(\\\"Only new\\\", value); value = Status.New | Status.Dirty; // New + Dirty value = Status.New; // Only new \\n\")), mdx(\"p\", null, \"A value can hold more than a single value. In the case that we want to persist the existing value intact and you need to use the sign \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"|=\"), \". To remove a particular status you need to use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"&= ~\"), \". Using these operators will swap the value at the right position in its binary format without affecting the remaining parts of the number.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"value |= Status.Processing; console.log(\\\"New and processing\\\", value); console.log(\\\"Is it new?\\\", value === Status.New); // Not the right way console.log(\\\"Is it new?\\\", Status.New === (value & Status.New)); // Right way console.log(\\\"Is it processing?\\\", Status.Processing === (value & Status.Processing)); value &= ~Status.Processing; \\n\")), mdx(\"p\", null, \"Finally, to check if the variable is of a particular status you must use the triple equal with the ampersand to the value you want to check against. This is often the mistake I see. People are using the triple equal or are using the ampersand without comparing it back to the desired value. The simple form of comparison is a mistake. The ampersand returns a number, not a boolean. The comparison needs to be against the value that we want to check.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"console.log(\\\"Is it new?\\\", Status.New === (value & Status.New)); console.log(\\\"Is it processing?\\\", Status.Processing === (value & Status.Processing)); \\n\")), mdx(\"p\", null, \"The output of the code all the previous code gives: ```\\nOnly new 1 New and processing 9 Is it new? false Is it new? true Is it processing? true Is it new? true Is it processing? false \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\nUsing bitwise number is harder to grasp at first glance and open code to error more easily even with TypeScript. It is recommended to use bitwise wisely and not to abuse it.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"How to set and read bitwise enum values in TypeScript\\\",\\\"date\\\":\\\"2018-06-19\\\",\\\"categories\\\":[\\\"typescript\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"453e7795-68eb-5172-9bb5-3bc7fe8b9f9e","slug":"2018/how-to-set-and-read-bitwise-enum-values-in-typescript","__params":{"slug":"2018"}}},
    "staticQueryHashes": ["3159585216"]}