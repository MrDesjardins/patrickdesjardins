{"data":{"mdx":{"frontmatter":{"title":"Registering with Microsoft Unity an interface to a concrete class with multiple constructors","date":"March 13, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you are using inversion of control, you may come into the scenario that you want to register your interface to a concrete class that has \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"multiple constructors\"), \". Registering with Microsoft Unity an interface to a concrete class with multiple constructors is something that require to specify to Unity which of the constructor to use.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" container .RegisterType<IMainDbContext, MainDbContext>(); \\n\")), mdx(\"p\", null, \"The code above can work if MainDbContext has only one constructor. Even if this one require several parameters, it does not matter. Unity will try to solve every parameters. However, in the case that MainDbContext has several constructor, Unity does not know which one to evaluate. Well, that is not totally true. In fact, Microsoft Unity try the one with the most parameters. This can be problematic if you have more than one parameter with the same amount of parameters.\"), mdx(\"p\", null, \"To select which constructors you have to use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"InjectionConstructor\"), \" class. This class allows to specify parameters type. You can use the ResolvedParameter that is generic. You can specify for every parameters the type you want.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" container .RegisterType<IMainDbContext, MainDbContext>( new InjectionConstructor( new ResolvedParameter<IRunningContext>() ) ); \\n``` As you can see, this indicate to Microsoft Unity to resolve the IRunningContext from its container to inject the object into the single parameter constructor of MainDbContext. In that case, we take the single constructor of MainDbContext that has its parameter of IRunningContext.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"Registering with Microsoft Unity an interface to a concrete class with multiple constructors\\\",\\\"date\\\":\\\"2014-03-13\\\",\\\"categories\\\":[\\\"unity\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"bdd2c11d-2cbd-52f7-9525-da56bf90b540","slug":"2014/registering-with-microsoft-unity-an-interface-to-a-concrete-class-with-multiple-constructors","__params":{"slug":"2014"}}}