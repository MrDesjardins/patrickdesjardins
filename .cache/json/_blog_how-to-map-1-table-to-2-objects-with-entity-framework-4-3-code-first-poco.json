{"data":{"mdx":{"frontmatter":{"title":"How to map 1 table to 2 objects with Entity Framework 4.3 Code-First (POCO)?","date":"June 20, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to map 1 table to 2 objects with Entity Framework 4.3 Code-First (POCO)?\",\n  \"date\": \"2012-06-20\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In some scenario, your database table may look different from your classes. You could have a class that contain an object which is a subdivision of some data with high cohesive representation and in the same time you may not want to divide this information in a 1-1 table. This is often the case if you cannot refactor an existing database or the case where information belong in a single table but since the data is conceptually better to be together in a second object that you need to be different from your database. In that case, Entity Framework call this scenario \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\\"Complex Type\\\"\"), \".\"), mdx(\"p\", null, \"Let say that you have a table with these fields:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[Table] -Field1 -Field2 -Field3 -Field4\")), mdx(\"p\", null, \"And let say that you end up having classes like this:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[Class1] -Field1 -Field2 -Class2 object here  [Class2] -Field3 -Field4\")), mdx(\"p\", null, \"In fact, as you can see, the Class1 can access Class2 data with the property Class2. For example : myClass1.Class2.Field3.\"), mdx(\"p\", null, \"To be able to map automatically data with Entity Framework, you need to setup a complex type.\"), mdx(\"p\", null, \"First of all, you need to ensure that the property doesn't have a null value. This mean that you have to initialize this property. The best way is to initialize the inner object (Class2) in the constructor of the main class (Class1).\"), mdx(\"p\", null, \"Second, Entity Framework will do his mapping of the property inside the inner object with the property name of this one. That mean that Entity Framework will think that the table look like this:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[Table] -Field1 -Field2 -Class2_Field3 -Class2_Field4\")), mdx(\"p\", null, \"If you do not want to alter your table, you will need to configure the Database Context.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Configuration.Add(new MyTable2Configuration()); //Add subsequent configuration... }\\n\\npublic class MyTable2Configuration: ComplexTypeConfiguration<Class2> { public MyTable2Configuration() { Property(o => o.Field3).HasColumnName(\\\"Field3\\\"); Property(o => o.Field4).HasColumnName(\\\"Field4\\\"); } } \\n\")), mdx(\"p\", null, \"You do not have to configure the Table1 class, only the complex type. If you need more information about Complex Type, you can always check this \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://weblogs.asp.net/manavi/archive/2011/03/28/associations-in-ef-4-1-code-first-part-2-complex-types.aspx\"\n  }, \"blog\"), \" which give additional information.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"7177ff5f-1812-5d59-a93e-6ac3887f8b2e"}}