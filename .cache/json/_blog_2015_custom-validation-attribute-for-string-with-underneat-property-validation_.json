{"data":{"mdx":{"frontmatter":{"title":"Custom Validation Attribute for String with Underneath Property Validation","date":"March 19, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Validation can occur with an attribute during client side and server side. For example, one simple validation can be to ensure that a property string is all to lower case. This can be a simple attribute like the following one.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" /// <summary> /// Validate that the string is in lower case /// </summary> [AttributeUsage(AttributeTargets.Property, AllowMultiple = false)] public class LowerCaseString : BaseDataAnnotation { protected override ValidationResult IsValid(object value, ValidationContext validationContext) { string model = value as string; if (model != null) { if(string.Equals(model, model.ToLowerInvariant(), StringComparison.InvariantCulture)) { return ValidationResult.Success; } } return base.ReturnDefaultErrorMessage(string.Format(Resources.DataAnnotationErrorMessage.StringNotLowerCase, validationContext.DisplayName) , new[] { validationContext.MemberName }); } } \\n``` ![](images/WebValidationAttribute-400x223.png)\\n```csharp\\n public class StockOrder { [Required] [LowerCaseString] [Display(ResourceType = typeof(ModelPropertyDisplayName), Name = \\\"StockSymbol\\\")] public Symbol StockSymbol { get; set; } } \\n``` You may think that you should set the LowerCaseString to the string property in the beneath property's class. However, we cannot only set the attribute on the property class because the graphical user interface need to add the validation to the property and not the property of a property. To fix this problem, it is possible to add a property to the attribute with the goal of specifying the property to validate underneath. \\n```csharp\\n [AttributeUsage(AttributeTargets.Property, AllowMultiple = false)] public class LowerCaseString : BaseDataAnnotation { public string InnerProperty { get; set; } protected override ValidationResult IsValid(object value, ValidationContext validationContext) { string model; if (value is string || String.IsNullOrEmpty(InnerProperty)) { model = value as string; } else { Type thisType = value.GetType(); PropertyInfo theMethod = thisType.GetProperty(InnerProperty); model = (string)theMethod.GetValue(value); } if (model != null) { if(string.Equals(model, model.ToLowerInvariant(), StringComparison.InvariantCulture)) { return ValidationResult.Success; } } return base.ReturnDefaultErrorMessage(string.Format(Resources.DataAnnotationErrorMessage.StringNotLowerCase, validationContext.DisplayName) , new[] { validationContext.MemberName }); } } \\n``` The _InnerProperty_ property is checked to see if set and if it is set on an attribute that is not a string than by reflection we get the property value and validate. The goal of verifying if the property is a string is for advanced scenario where the validation is done on a class on the Model and on a string on the ViewModel. This situation can occur if you are working with a Model-ViewModel architecture and that you transfer automatically with AutoMapper Data Annotation validation.\\n\\n\\n```csharp\\n public class StockOrder { [Required] [LowerCaseString(InnerProperty = \\\"Value\\\")] [Display(ResourceType = typeof(ModelPropertyDisplayName), Name = \\\"StockSymbol\\\")] public Symbol StockSymbol { get; set; } } \\n``` At the end, what is important is that you can specify inside an attribute which property to validate and having the option to be more specific in some scenario.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"Custom Validation Attribute for String with Underneath Property Validation\\\",\\\"date\\\":\\\"2015-03-19\\\",\\\"categories\\\":[\\\"asp-mvc\\\",\\\"c-sharp\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"f457f861-f72b-55cf-b4c6-c09d86e1c9aa","slug":"2015/custom-validation-attribute-for-string-with-underneat-property-validation","__params":{"slug":"2015"}}}