{"data":{"mdx":{"frontmatter":{"title":"Enterprise Asp.Net MVC Part 4: Repository","date":"November 2, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Enterprise Asp.Net MVC Part 4: Repository\",\n  \"date\": \"2012-11-02\",\n  \"categories\": [\"ado-net\", \"asp\", \"asp-mvc\", \"c-sharp\", \"enterprise\", \"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is the forth part of the series concerning enterprise \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Asp.Net MVC web site\"), \". In this article, we will discuss about how to design the repository. Has you can imagine, we won't use Entity Framework (or any other ORM) directly into controllers. Also, this article will focus on Entity Framework 5.0 but the concept behind is the same : the repository must be abstracted from the controller. The main reason is that we want to be able to respect the single responsibility principle. The controller responsibility is not about how to load or save entity but to know how to dispatch. This why we will follow separation of concern idea by having classes that will handle the repository. By separating the repository we will use many classes to have a set of cohesive class. The result will be an application well separated in concern.\"), mdx(\"p\", null, \"Before starting, let me just make one thing clear. I won't abstract \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Entity Framework\"), \" here. I do not believe that abstracting the ORM is a good idea. First, it's a lot of overhead. Second, the ORM already abstract the database implementation, and third, it's harder to maintain because if we want something specific to Entity Framework, we will need to do a lot of code.\"), mdx(\"h2\", null, \"Abstracting the repository : the plan\"), mdx(\"p\", null, \"The first thing that we need to keep in mind is that every entity will need to use the ORM. Entity Framework use what we call a DbContext. We need to be able to share this DbContext between repositories because we may want to save an entity that will use several other repository. The same is true for loading entity. You may want to load an entity and load a second one in a different repository. Sharing the same DbContext let you have the same transaction when saving and when loading let you have join instead of 2 queries (or more). It also open a single connection to the database instead of several.\"), mdx(\"p\", null, \"The second thing to have in mind is that every entity belong to a user. If UserA create an entity, this entity should belong to him. UserB should access his information. This is not the case of everything, but most of the time yes. Even a Facebook Message is owned by you (but shared to others). So, we need a mechanism to bind data to a user account. Also, we will need to have a way to impersonate in some case this mechanism. This will give us the leverage to save entity to a specific user. A simple case that I can tell you may be to load the database with test data for development purpose. We may want to create entity to several users without being logged to these users.\"), mdx(\"p\", null, \"The third thing to have in mind is that we want to be able to test without having to care about the database. It also mean that I do not want to have overhead when testing by mocking every method of Entity Framework. What we want is to simply mock the repository.\"), mdx(\"h2\", null, \"Factory Method Pattern\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://en.wikipedia.org/wiki/Factory_method_pattern\"\n  }, \"factory method pattern\"), \" let you construct object from a single point. The factory will return all repositories for every entity. It's a central point. The reason to use this pattern is that it will give use a lazy loading for all repositories creation but also will give us the possibility to share the DbContext between those repositories in the creation of them. It also give us the possibility to mock the whole factory for testing. The factory will be the classe shared between all controllers.\"), mdx(\"h3\", null, \"Repository Factory\"), mdx(\"p\", null, \"The repository factory inherit from an interface. This interface will contain all entity repository. That mean that if you want to add new entity that you need to add a new entry into this interface. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public interface IRepositoryFactory { IWorkoutRepository Workout { get; } IUserProfileRepository UserProfile { get; } //...Other entities... } \\n``` For example, in the code above, we have 2 entities. One is our domain, the Workout class, and the second is the UserProfile that is for the user (from the membership classes). If we wanted to add the Exercises entity, we would need to add a new property in the interface.\\n\\nYou can also notice that IRepositoryFactory contain interface to repository. So, a new entity means a new interface for its repository and for the concrete implementation of this repository.\\n\\nBefore going deeper with the repository class, let check a concrete implementation of IRepositoryFactory for Entity Framework 5.0 Code First approach.\\n\\n\\n```csharp\\n public class RepositoryFactory:IRepositoryFactory { private readonly IDatabaseContext_databaseContext; private IWorkoutRepository_workoutRepository; private IUserProfileRepository_userProfileRepository;\\n\\npublic RepositoryFactory(IDatabaseContext databaseContext) {_databaseContext = databaseContext; }\\n\\n#region Implementation of IRespositoryFactory\\n\\npublic IWorkoutRepository Workout { get { return_workoutRepository ?? (_workoutRepository = new WorkoutRepository(_databaseContext)); } }\\n\\npublic IUserProfileRepository UserProfile { get { return_userProfileRepository ?? (_userProfileRepository = new UserProfileRepository(_databaseContext)); } }\\n\\n#endregion } \\n\")), mdx(\"p\", null, \"This class takes in its constructor a IDatabaseContext. This will give us an interface to share between repository. Otherwise, the factory if very simple. It checks if the property has been already initialized, if not, it initialize it with the IDatabaseContext, otherwise, it simply reuse the repository. This class contains for every repository a property. That's it.\"), mdx(\"h3\", null, \"Repository Classes\"), mdx(\"p\", null, \"Every repository inherit from \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IRepository\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public interface IRepository<T> { \\n   IQueryable<T> GetAll(); T Get(int id); \\n   int Insert(T entity); \\n   int Update(T entity); \\n   int Delete(T entity); \\n} \\n\")), mdx(\"p\", null, \"This give us the 80% repository method that we need. Other more specific method like searching with filter will be added directly into the concrete implementation of the class.\"), mdx(\"p\", null, \"Also, every Repository inherit from a BaseRepository which will hold the DataContext reference. This is required because every call to the repository is done by the DbContext. When the Repository factory pass the IDatabaseContext to the repository, all repository will simply pass the object to the base in their constructor.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class BaseRepository { \\n  protected IDatabaseContext DatabaseContext { get; private set; }\\n\\n  protected BaseRepository(IDatabaseContext databaseContext) { DatabaseContext = databaseContext; } \\n} \\n\")), mdx(\"p\", null, \"Here is the example with the Workout entity. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class WorkoutRepository : BaseRepository, IWorkoutRepository { \\n  public WorkoutRepository(IDatabaseContext databaseContext) : base(databaseContext) { }\\n\\n  #region Implementation of IRepository<Workout>\\n\\n  public IQueryable<Workout> GetAll() { return DatabaseContext.SetOwnable<Workout>().Include(x => x.Sessions); }\\n\\n  public Workout Get(int id) { return DatabaseContext.SetOwnable<Workout>().Include(x => x.Sessions).Single(c => c.Id == id); }\\n\\n  public int Insert(Workout entity) { //To-do : Other stuff with complex type here DatabaseContext.SetOwnable<Workout>().Add(entity); return DatabaseContext.SaveChanges(); }\\n\\n  public int Update(Workout entity) { \\n    Workout fromDatabase = Get(entity.Id); \\n    DatabaseContext.Entry(fromDatabase).CurrentValues.SetValues(entity); \\n    DatabaseContext.Entry(fromDatabase).State = EntityState.Modified; \\n    //To-do : Other stuff with complex type here \\n    return DatabaseContext.SaveChanges(); \\n  }\\n\\n  public int Delete(Workout entity) { \\n    DatabaseContext.SetOwnable<Workout>().Remove(entity); \\n    return DatabaseContext.SaveChanges(); \\n  }\\n\\n  #endregion \\n} \\n\")), mdx(\"p\", null, \"It's quite neat! You do not see any detail of database connection.\\nThe only thing we see is task concerning saving and loading entity. We have direct access to Entry and we can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Set<>\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SetOwnable<>\"), \".\\nAs you can see, we do not need to have any access to the current user, neither to specific to whom the Workout belong because Workout inherit from IUserOwnable.\\nYou will see the detail about how it works on the next article concerning the DbContext (see part 5).\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"So far, so good. Now we have the controller that talk with the database. We are using Repository factory method to access the desired repository and every repository share the same instance of DbContext which give us the possibility to handle multiple entity with the same context (same transaction). Every classes has its own role. The controller handle http request, the service handle how the database is accessed, the repository factory manage all repositories, repository handle how their entity are stored and finally, the database context take care of the database connection. The next article of the series, part 5 will discuss more in detail about the database context (DbContext) and its role with Entity Framework 5.0.\"), mdx(\"h3\", null, \"Series Articles\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-part-1-mvc-the-planification\"\n  }, \"Article #1: Asp.Net MVC Enterprise Quality Web Application\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-2-building-the-model\"\n  }, \"Article #2: Asp.Net MVC Enterprise Quality Web Application Model\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-3-controller\"\n  }, \"Article #3: Asp.Net MVC Enterprise Quality Web Application Controller\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-4-repository\"\n  }, \"Article #4: Asp.Net MVC Enterprise Quality Web Repository Layer\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-5-database-context-and-impersonate-data\"\n  }, \"Article #5: Asp.Net MVC Enterprise Quality Web with Entity Framework\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-6-the-three-layers-of-validation\"\n  }, \"Article #6: Asp.Net MVC Enterprise Quality Layers\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./enterprise-asp-net-mvc-part-7-securing-action-with-role-authorization\"\n  }, \"Article #7: Asp.Net MVC Enterprise Quality Web Security\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/GymWorkout\"\n  }, \"Source code on GitHub\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"d62d14c7-0eb3-5688-bc25-13d3a0e81606"}}