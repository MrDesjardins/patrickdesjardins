{"data":{"mdx":{"frontmatter":{"title":"JavaScript Binary Search","date":"June 14, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Binary Search\",\n  \"date\": \"2017-06-14\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Previously we say the linear search which is having an asymptotic upper bound of O(n). This time, we increase the speed with a binary sort of O(log(n)). The speed is increased at the cost of having the requirement of initial array to be sorted.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var arrayToSearch = [2, 6, 8, 12, 43, 78, 99, 134, 144, 156, 199, 256, 500];\\n\\nconsole.log(\\\"Found at position :\\\" + binarySearch(arrayToSearch, 2));\\nconsole.log(\\\"Found at position :\\\" + binarySearch(arrayToSearch, 256));\\nconsole.log(\\\"Found at position :\\\" + binarySearch(arrayToSearch, 500));\\nconsole.log(\\\"Found at position :\\\" + binarySearch(arrayToSearch, 44444));\\n\\nfunction binarySearch(arrayToSearch, valueToSearch) {\\n  var start = 0;\\n  var end = arrayToSearch.length - 1;\\n\\n  while (start <= end) {\\n    var middle = Math.ceil((end + start) / 2);\\n    var middleValue = arrayToSearch[middle];\\n    if (middleValue === valueToSearch) {\\n      return middle;\\n    } else if (valueToSearch < middleValue) {\\n      end = middle - 1;\\n    } else {\\n      start = middle + 1;\\n    }\\n  }\\n  return -1;\\n}\\n\")), mdx(\"p\", null, \"The idea is so split the array in 2, then look in which half the value may be. If the value is lower than the middle value, we divide reject the upper half. We keep doing it until we found the value or that the gap between the lower and upper bound doesn't exist.\"), mdx(\"p\", null, \"In the case of finding 256, the lower bound start with the first index (value 2) and the length-1 (value 500). The middle is index 6 (value 99). Since we are searching for 256 the value above 99, hence we reject all values on the left (index 0 to index 6 inclusively). To do so, we move the start to index 6+1 (value 134) and keep the end bound to length-1 (500). And we iterate.\"), mdx(\"p\", null, \"The first algorithm is using a while to loop through, but as we just described, we are doing over and over the same thing, just with a reduction of the array. It means that it's like asking for different array the same logic. This means that we can transform the iterative approach into a recursive approach.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var arrayToSearch = [2, 6, 8, 12, 43, 78, 99, 134, 144, 156, 199, 256, 500];\\nvar start = 0;\\nvar end = arrayToSearch.length - 1;\\n\\nconsole.log(\\\"Found at position :\\\" + binarySearch(arrayToSearch, 2, start, end));\\nconsole.log(\\n  \\\"Found at position :\\\" + binarySearch(arrayToSearch, 256, start, end)\\n);\\nconsole.log(\\n  \\\"Found at position :\\\" + binarySearch(arrayToSearch, 500, start, end)\\n);\\nconsole.log(\\n  \\\"Found at position :\\\" + binarySearch(arrayToSearch, 44444, start, end)\\n);\\n\\nfunction binarySearch(arrayToSearch, valueToSearch, start, end) {\\n  if (start <= end) {\\n    var middle = Math.ceil((end + start) / 2);\\n    var middleValue = arrayToSearch[middle];\\n    if (middleValue === valueToSearch) {\\n      return middle;\\n    } else if (valueToSearch < middleValue) {\\n      end = middle - 1;\\n    } else {\\n      start = middle + 1;\\n    }\\n    return binarySearch(arrayToSearch, valueToSearch, start, end);\\n  }\\n  return -1;\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"1b33317a-ecda-5898-a077-8a04da75c4fe","slug":"2017/javascript-binary-search","__params":{"slug":"2017"}}}