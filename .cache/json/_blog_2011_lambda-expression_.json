{"data":{"mdx":{"frontmatter":{"title":"Lambda Expression","date":"September 28, 2011"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Lambda Expression\",\n  \"date\": \"2011-09-28\",\n  \"categories\": [\"linq\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Lambda Expression can be of two types:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Code Delegate (compiled)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Expression Tree Object (runtime)\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Code Delegate\"), \" is used a lot with Linq. Almost all extension like Where is a delegate function that is compiled into IL code. It's very fast because it's compiled. On the other hand, some situation when the data is not evaluate against direct memory or require some reflection against what is passed requires Expression Tree Object Lambda.\"), mdx(\"p\", null, \"In the code, you can know if it's a Code Delegate or Expression Tree with the declaration of the parameter. If the method you call use \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" Func<T,bool> predicate //bool can be something else \\n``` It's because it's a code delegate. In fact, the Func method is a predefined delegate that take one or more parameter with a return value. This can be compiled. Conversely, Expression Tree Object use \\n```csharp\\n Expression<Fun<T,bool>> predicate //bool can be something else \\n``` Instead of compiling into IL, this generate code to let the framework analyse the expression. It lets the developer know the type, the name of the object and the value of it. This is why Linq To Sql requires to use expression instead of compiled because it needs to read the delegate information and translate it into SQL statement.\\n\\n## Real Life Example\\n\\nI think a simple example could be the one of INotifiedPropertyChanged. This interface give a method that has for parameter a string that must be the name of the property that has changed. When using straight from this implementation, some problem may arise like not entering the name of the property correctly or when refactoring, the tool may not check the string value to change it. To solve this issue, you can use Expression Tree Object to get all methods of the current object and to select one of it.\\n\\n```csharp\\nprotected virtual void OnPropertyChanged(string propertyName) { PropertyChangedEventHandler handler = this.PropertyChanged; if (handler != null) { var e = new PropertyChangedEventArgs(propertyName); handler(this, e); } }\\n\\nprotected void OnPropertyChanged<T>(Expression<Func<T>> propertyChanged) { if (propertyChanged != null) { var expression = (MemberExpression)propertyChanged.Body; this.OnPropertyChanged(expression.Member.Name); } } \\n\")), mdx(\"p\", null, \"The line 11 contain the Expression Tree Object that contain the delegate Func. This mean that it doesn't take any parameter and return a value of type .\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" private MyObject myObject; public MyObject MyObject { get { return myObject; } set { myObject = value; base.OnPropertyChanged(() => MyObject); // This was before used like this : base.OnPropertyChanged(\\\"MyObject\\\"); } } \\n\")), mdx(\"p\", null, \"Line 7 contains the Lambda method and in the same line, in comment, you can see the original.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"84b1b1ff-a96b-5447-8eb5-08dbbc2a6a79","slug":"2011/lambda-expression","__params":{"slug":"2011"}}}