{"data":{"mdx":{"frontmatter":{"title":"DataReader and DataAdapters to read from the database","date":"September 29, 2011"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"DataReader and DataAdapters to read from the database\",\n  \"date\": \"2011-09-29\",\n  \"categories\": [\"ado-net\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"To read data from the database you need to use something else from DbCommand that was returning no data. Two options are available. The first one is the DataReader, the second is the DataAdapters.\"), mdx(\"h2\", null, \"DataReader\"), mdx(\"p\", null, \"This is the fastest way to read data from the database. To create a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataReader\"), \" object, the use of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ExecuteReader\"), \" from the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DbCommand\"), \" class is required. It's required because you will still need to give them the type of query you want and the SQL statement (or the stored procedure name). Then, the method ExecuteReader() return a DataReader. In the example below, the reader is a SqlDataReader. This one derive from DataReader and is more specialized for Microsoft Sql Server. The latest solution is really not performant.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" ConnectionStringSettings connectionStringSettings = ConfigurationManager.ConnectionStrings[\\\"ApplicationServices\\\"]; using (var connection = new SqlConnection(connectionStringSettings.ConnectionString)) { connection.Open(); using (var command = new SqlCommand()) { command.Connection = connection; command.CommandText = \\\"SELECT CustomerID, CompanyName FROM Customers WHERE country LIKE 'canada' \\\"; command.CommandType = System.Data.CommandType.Text; using (SqlDataReader reader = command.ExecuteReader()) { while (reader.Read()) { System.Diagnostics.Debug.WriteLine(string.Format(\\\"{0}:{1}\\\",reader[\\\"CustomerID\\\"], reader[\\\"CompanyName\\\"])); } } } connection.Close(); } \\n\")), mdx(\"p\", null, \"The DataReader acts like a cursor. It can only go forward. You can access the value of each row by using the square braquet []. You can put the name of the field or a integer that represent the index of the position of the field. For example, we could have replace\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" System.Diagnostics.Debug.WriteLine(string.Format(\\\"{0}:{1}\\\",reader[\\\"CustomerID\\\"], reader[\\\"CompanyName\\\"])); \\n``` by \\n```csharp\\n System.Diagnostics.Debug.WriteLine(string.Format(\\\"{0}:{1}\\\",reader[0], reader[1])); \\n``` The problem with the latest version is the maintainability. It's harder to know what will be displayed. Also, it can be problematic if the order of the returned data change. Let say that you get data from a stored procedure and for an unknown reason the database administrator change the order of the returned field. This would create a problem but not if the name were used.\\n\\nYou can also load the whole data set in one shot using the Load method. The data is loaded into a DataTable.\\n\\n```csharp\\nConnectionStringSettings connectionStringSettings = ConfigurationManager.ConnectionStrings[\\\"ApplicationServices\\\"]; DataTable datas = new DataTable(); using (var connection = new SqlConnection(connectionStringSettings.ConnectionString)) { connection.Open(); using (var command = new SqlCommand()) { command.Connection = connection; command.CommandText = \\\"SELECT CustomerID, CompanyName FROM Customers WHERE country LIKE 'canada' \\\"; command.CommandType = System.Data.CommandType.Text; using (SqlDataReader reader = command.ExecuteReader()) { datas.Load(reader, LoadOption.Upsert); } } connection.Close(); System.Diagnostics.Debug.WriteLine(\\\"Number of rows loaded : \\\" + datas.Rows.Count); } \\n\")), mdx(\"p\", null, \"One problem with DataReader is that it uses a cursor on the server and it keeps the connection to the server open while looping. The second problem is that while looping you won't be able to execute an other query withing the loop. To solve that problem you can load all the data and loop after or use the Load method. Another option is to use a DbConnection with a special connection string. This connection string will require to have the attribute \\\"MultipleActiveResultSets=True\\\". This let have multiple command but at the cost of performance issue. It has to be used with cautiousness.\"), mdx(\"h2\", null, \"Scalar\"), mdx(\"p\", null, \"Sometime, we want to have just a single value. This can be an ID from a username, but more often it will be to get a value from an aggregate function, like a count. We could use the DataReader but this give some overhead for a single value.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"ConnectionStringSettings connectionStringSettings = ConfigurationManager.ConnectionStrings[\\\"ApplicationServices\\\"]; using (var connection = new SqlConnection(connectionStringSettings.ConnectionString)) { connection.Open(); using (var command = new SqlCommand()) { command.Connection = connection; command.CommandText = \\\"SELECT count(CustomerID) FROM Customers WHERE country LIKE 'canada' \\\"; command.CommandType = System.Data.CommandType.Text; int countValue = (int)command.ExecuteScalar(); System.Diagnostics.Debug.WriteLine(\\\"Count value:\\\" + countValue); } connection.Close(); } \\n\")), mdx(\"p\", null, \"As you can see, line 10 use the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ExecuteScalar\"), \" from the DbCommand to return an Object. In our case, we return an integer.\"), mdx(\"h2\", null, \"DbDataAdapter\"), mdx(\"p\", null, \"The DbDataAdapter is the reader that give you the more leverage in data functionality. Not only it let you get the data but it let you update them.\"), mdx(\"p\", null, \"The DbDataAdapter class derive from DataAdapter. As the other command, a Microsoft Sql Server one exist and it's called : SqlDataAdapter.\"), mdx(\"p\", null, \"The DbDataAdapter contains a SelectCommand that use an ExecuteReader. Internally the data is loaded in a DataTable. This let the developer change the value inside the DataTable and if desired update them to the database or insert new rows added and also delete those who are not anymore in the DataTable. The DbDataApter is wise enough to open and close the connection. In the other end, it let the user open the connection if desired. In that case, the user will also need to close it. This can be useful when multiple calls is required because it won't open-close repetitively which is costly in performance. Here is an example of how to load data from the database into a DbDataAdapter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" ConnectionStringSettings connectionStringSettings = ConfigurationManager.ConnectionStrings[\\\"ApplicationServices\\\"]; DataSet returnedValuesSet = new DataSet(); using (var connection = new SqlConnection(connectionStringSettings.ConnectionString)) { connection.Open(); using (var command = new SqlCommand()) { command.Connection = connection; command.CommandText = \\\"SELECT CustomerID, CompanyName FROM Customers WHERE country LIKE 'canada' \\\"; command.CommandType = System.Data.CommandType.Text; using (var dataAdapter = new SqlDataAdapter(command)) { dataAdapter.Fill(returnedValuesSet); } } connection.Close(); System.Diagnostics.Debug.WriteLine(\\\"Number of rows loaded : \\\" + returnedValuesSet.Tables[0].Rows.Count); } \\n``` So, now the DataSet is filled up with the query data. It's a non-connected object but will still be able to do update later on. From this example, we can see that the SqlDataAdapter fill up with the _Fill_ method. This _Fill_ method can also takes a second argument that is the name of the name of the table. This mean we can modify the previous example with this one and instead of referring the data in the DataSet with an index, we will be able to use the string as a key.\\n\\n```csharp\\nConnectionStringSettings connectionStringSettings = ConfigurationManager.ConnectionStrings[\\\"ApplicationServices\\\"]; DataSet returnedValuesSet = new DataSet(); using (var connection = new SqlConnection(connectionStringSettings.ConnectionString)) { connection.Open(); using (var command = new SqlCommand()) { command.Connection = connection; command.CommandText = \\\"SELECT CustomerID, CompanyName FROM Customers WHERE country LIKE 'canada' \\\"; command.CommandType = System.Data.CommandType.Text; using (var dataAdapter = new SqlDataAdapter(command)) { dataAdapter.Fill(returnedValuesSet, \\\"Customers\\\"); } } connection.Close(); System.Diagnostics.Debug.WriteLine(\\\"Number of rows loaded : \\\" + returnedValuesSet.Tables[\\\"Customers\\\"].Rows.Count); } \\n\")), mdx(\"p\", null, \"The table name is important if you want to use other feature like insert, update and delete because the SqlAdapter will use this table to do the desired task. If you use a fake table name, you will get an exception. This exception is \\\"Update unable to find TableMapping\", \"['Table']\", \" or DataTable 'Table'.\\\".\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"400px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/0adcced1daae50dabb49bebff7c9db6b/e17e5/updateDataSetRowsFromDataTable-400x100.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"25%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABGklEQVQY023PS07CUBiGYZblxAW4JXdhYkzcgSNHDBAjEEyIOvESkUFp6eXn9PTCoeUUSaztayIMeZNn+iVfx9odjqNx5j6vb8847gyRlEWkcTODrC2B75OoJW3b7HHQ/tI0B+0vbdvSASjLgiB0WeUpttywKTaUZo1dF9TWslsZduabpmZfc3Ck/8GNLVkqQWIhShWhFrQWEhWQ6RiJI+aLLiIDlEwQ7wnld4nCG5K8R2a65OaFVbGlU9c1q3XOInSJkggvCQjyCE8HzBMfbVI+px/0h1fcjy94eDynNzyhPz7lbnhGb3BJf3TNaHLL+5dPxxhDVVVUtqL+qY/eEJUxnQnTWYzjaZLUI9YBaZah0y0q3iKqQFTKH/yecVZIsFH6AAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"updateDataSetRowsFromDataTable 400x100\",\n    \"title\": \"updateDataSetRowsFromDataTable 400x100\",\n    \"src\": \"/static/0adcced1daae50dabb49bebff7c9db6b/e17e5/updateDataSetRowsFromDataTable-400x100.png\",\n    \"srcSet\": [\"/static/0adcced1daae50dabb49bebff7c9db6b/5a46d/updateDataSetRowsFromDataTable-400x100.png 300w\", \"/static/0adcced1daae50dabb49bebff7c9db6b/e17e5/updateDataSetRowsFromDataTable-400x100.png 400w\"],\n    \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The correct code would be to provide in the InsertCommand property of the SqlDataAdapter a SQL statement with an Insert statement or a stored procedure. If you do not want to create every time the Insert, Update, Delete and Select statement, it's possible to use the SqlCommandBuilder.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"ConnectionStringSettings connectionStringSettings = ConfigurationManager.ConnectionStrings[\\\"ApplicationServices\\\"]; DataSet returnedValuesSet = new DataSet(); using (var connection = new SqlConnection(connectionStringSettings.ConnectionString)) { connection.Open(); using (var command = new SqlCommand()) { command.Connection = connection; command.CommandText = \\\"SELECT CustomerID, CompanyName FROM Customers WHERE country LIKE 'canada' \\\"; command.CommandType = System.Data.CommandType.Text; using (var dataAdapter = new SqlDataAdapter(command)) { dataAdapter.Fill(returnedValuesSet, \\\"Customers\\\"); var builder = new SqlCommandBuilder(dataAdapter); dataAdapter.InsertCommand = builder.GetInsertCommand(); returnedValuesSet.Tables[\\\"Customers\\\"].Rows.Add(\\\"-1\\\", \\\"My Company Name\\\");\\n\\ndataAdapter.Update(returnedValuesSet,\\\"Customers\\\"); } } connection.Close(); } \\n\")), mdx(\"p\", null, \"This will generate the InsertCommand as you can see in this screenshot: \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"400px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/84fe731ce1cba6fb1c5e31933b19e9e2/e17e5/createInsertStatementWithCommandBuilder-400x73.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"18.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4UlEQVQY03WLy07CQAAA+/+/ZKIxsVGCyqNCqWIUtl227KPUlrDdNo4JRm5OMreZqFSWstxTKEOuLdbVOO34BrSxiFwhdyVbIdmKgqJQFFKhbcWhbtiVFiE1vutpj55oNp2QZUvmyR2LRUz2ErNe3qNVyufmg6ubmOvbEeNJytMsY7p4Jx5NeRgnjB4TnuevrNY56VqQvm2JnLPUdYWzEmNyjl8G31aEcMQ5zSpNkFLxRz8M7Pca56qzVXXgdPKEEOhCIOq6wH8Y60iSGWIj6PvfbhgGrDE0TUPbtGe995fnB4ErKqqhZJz5AAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"createInsertStatementWithCommandBuilder 400x73\",\n    \"title\": \"createInsertStatementWithCommandBuilder 400x73\",\n    \"src\": \"/static/84fe731ce1cba6fb1c5e31933b19e9e2/e17e5/createInsertStatementWithCommandBuilder-400x73.png\",\n    \"srcSet\": [\"/static/84fe731ce1cba6fb1c5e31933b19e9e2/5a46d/createInsertStatementWithCommandBuilder-400x73.png 300w\", \"/static/84fe731ce1cba6fb1c5e31933b19e9e2/e17e5/createInsertStatementWithCommandBuilder-400x73.png 400w\"],\n    \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The created SQL statement use parameter style and is Sql injection protected.\"), mdx(\"p\", null, \"So far the DbDataAdapter commit 1 change at a time. This is because the DbDataAdapter has by default its \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UpdateBatchSize\"), \" to 1. You can select the size you want or set it to 0 to let the DbDataAdapter use the largest batch size. This will increase the performance of the application.\"), mdx(\"h2\", null, \"In practice\"), mdx(\"p\", null, \"When using Sql statement, stored procedure or direct Sql you should always use parameters. In practice, in your data access layer when you have a method that return data from the database it should query with a DataReader and return a DataSet. The reason is the DataSet let you close the connection and the DataReader is justified by its speed.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"ConnectionStringSettings connectionStringSettings = ConfigurationManager.ConnectionStrings[\\\"ApplicationServices\\\"]; DataSet returnedValuesSet = new DataSet(); DataTable returnedTable = new DataTable(); using (var connection = new SqlConnection(connectionStringSettings.ConnectionString)) { connection.Open(); using (var command = new SqlCommand()) { command.Connection = connection; command.CommandText = \\\"SELECT CustomerID, CompanyName FROM Customers WHERE country LIKE @country\\\"; command.CommandType = System.Data.CommandType.Text; SqlParameter paramCountry = new SqlParameter(\\\"country\\\",\\\"canada\\\"); command.Parameters.Add(paramCountry); using (var reader = command.ExecuteReader()) { returnedTable.Load(reader,LoadOption.Upsert); returnedValuesSet.Tables.Add(returnedTable); } } connection.Close(); } \\n\")), mdx(\"p\", null, \"For inserting, updating and deleting, parameters must be used too. Here is a good example of code that could be use in a data access layer methods. Your method should return the number of row and accept as parameter your model object of the Customer.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" ConnectionStringSettings connectionStringSettings = ConfigurationManager.ConnectionStrings[\\\"ApplicationServices\\\"]; DataSet returnedValuesSet = new DataSet(); DataTable returnedTable = new DataTable(); int rowsAffected; using (var connection = new SqlConnection(connectionStringSettings.ConnectionString)) { connection.Open(); using (var command = new SqlCommand()) { command.Connection = connection; command.CommandText = \\\"INSERT INTO customers (CustomerID, CompanyName) VALUES (@id, @name)\\\"; command.CommandType = System.Data.CommandType.Text; command.Parameters.Add(new SqlParameter(\\\"id\\\",\\\"P1\\\")); command.Parameters.Add(new SqlParameter(\\\"name\\\", \\\"MyName\\\")); rowsAffected = command.ExecuteNonQuery(); } connection.Close(); } \\n\")), mdx(\"p\", null, \"Do not forget to handling the DbAdapter's \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UpdateBatchSize\"), \" when you have a collection that you are going to update. Let say that you pass to your data access layer a collection ( IList ). Your method should check the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Count\"), \" of items and adjust the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UpdateBatchSize\"), \" to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Count\"), \". This way, your performance will increase by a lot.\"), mdx(\"p\", null, \"Last important thing is the use of Transaction. Usually when something goes wrong you would like to know about it and to cancel the current batch edition to restart it once the problem is fixed. Sql Transaction will be discussed in a future article but should be there for insert, update and delete queries.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"c4194da5-f07a-5596-97dc-a83a6a2c72b8"}}