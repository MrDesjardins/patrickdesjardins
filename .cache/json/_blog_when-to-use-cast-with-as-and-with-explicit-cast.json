{"data":{"mdx":{"frontmatter":{"title":"When to use cast with AS and with explicit cast","date":"August 3, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"When to use cast with AS and with explicit cast\",\n  \"date\": \"2012-08-03\",\n  \"categories\": [\"c-sharp\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"You can cast object into another object in many way in C#.\"), mdx(\"p\", null, \"Even if both technically do the same thing if successful, they shouldn't be used without thinking.\"), mdx(\"p\", null, \"I often see people using AS to cast and never check if the cast is successfully executed.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var myObject = myOtherObject as MyObject; myObject.Property1 = 1; \\n\")), mdx(\"p\", null, \"This is wrong. First, the cast can fail which will return null. In that case, a NullReference is trigged when the value 1 is set to the property. Second, why casting with AS? The goal of AS is to cast and if something wrong return the value NULL. This is good when NULL is an accepted state of the object which is not in the current example.\"), mdx(\"p\", null, \"What we want is that if the cast goes wrong to be notified because it should never go wrong.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var myObject = (MyObject)myOtherObject; myObject.Property1 = 1; \\n\")), mdx(\"p\", null, \"In the case that a possible error occur, an exception will be thrown with the good exception message : InvalidCast.\"), mdx(\"p\", null, \"Nevertheless, you can cast with AS and check if the value is NULL. This is a good way to cast if NULL value can happen and you need to act differently in this situation.\"), mdx(\"p\", null, \"For example, if you know that something, when casting, the value return Null than you should do :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var myObject = myOtherObject as MyObject; if(myObject != null) myObject.Property1 = 1; else //... \\n\")), mdx(\"p\", null, \"So, next time you need to cast, ask yourself if you expect to have NULL (you expect that it won't cast because of the design not because of a bug). If yes, you can use AS, otherwise, use the explicit cast with the parentheses which will trigger an exception.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"f0f35a08-6851-5e3d-9871-99eccfaaaa61"}}