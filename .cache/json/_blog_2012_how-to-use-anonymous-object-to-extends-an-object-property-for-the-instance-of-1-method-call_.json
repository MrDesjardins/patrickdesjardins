{"data":{"mdx":{"frontmatter":{"title":"How to use anonymous object to extends an object property for the instance of 1 method call.","date":"March 9, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I had to use a method that with reflection would take the properties name and value to create a SQL query. The problem is that the library was limited to methods directly inside the object passed and not value of inner object. For example, if the class A contain an object B, we were not able to access B properties.\"), mdx(\"p\", null, \"We could have done something pretty much nicer like looping through all objects to get desired sub-properties but to make it short and because we wanted just to have the unique identifier of those object that we decided to overload the method of the library to extend the properties for the time of this method call.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" MyMethod(myObject, new {MyNewPersonalMethodName1 = myObject.SubObject.Id1, MyNewPersonalMethodName2 = myObject.SubObject.Id2}); //or MyMethod(myObject, myOtherObjectToUseProperties); \\n``` This is a representation of how it was done. The MyMethod was overloaded to accept a second parameter. This one will be used to receive an anonymous object. This way, it's easy to have a name <-> value relationship and it gives us the possibility to pass a complete real object if desired or simply pass an anonymous object as parameter.\\n\\n\")), mdx(\"p\", null, \" public void MyMethod(object myObject, object extendedProperties) { //You can do something with all properties of myObject and its value here //Here you can do something with the extended properties if (extendedProperties != null) { var typeInfo = extendedProperties.GetType(); var propertyInfo = typeInfo.GetProperties(); foreach (PropertyInfo p in propertyInfo) { var nameToUpdate = p.Name; var valueToUpdate = (object)p.GetValue(extendedProperties, null); //Do somethind with nameToUpdate and valueToUpdate } } } \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\nThe next step is to use reflection to be able to get all properties' names and values. It's after that easy to be able to get the name to build a SQL query or a JSON object from object.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"How to use anonymous object to extends an object property for the instance of 1 method call.\\\",\\\"date\\\":\\\"2012-03-09\\\",\\\"categories\\\":[\\\"c-sharp\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"8850c5d7-25f1-5900-a5aa-3d6a2a052c9b","slug":"2012/how-to-use-anonymous-object-to-extends-an-object-property-for-the-instance-of-1-method-call","__params":{"slug":"2012"}}}