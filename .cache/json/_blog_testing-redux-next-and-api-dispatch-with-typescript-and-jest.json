{"data":{"mdx":{"frontmatter":{"title":"Testing Redux next and api.dispatch with TypeScript and Jest","date":"November 7, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Testing Redux next and api.dispatch with TypeScript and Jest\",\n  \"date\": \"2018-11-07\",\n  \"categories\": [\"jest\", \"redux\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A middleware in Redux can have quite a lot of logic. In fact, this is my favorite place to place logic. The rationale is that it can be triggered by an action, still, have the time to request data from the backend server with an Ajax call and can dispatch other actions that can be computed by another middleware or by a reducer. It becomes crucial to unit test any area where logic can go wrong, thus testing if specific logic dispatch or invoke next.\"), mdx(\"p\", null, \"Testing api.dispatch is a matter of leveraging Jest. If you are using React and Redux, it is the defacto testing framework. In fact, it is the one coming with the famous \\\"create-react-app\\\". To test if an action got dispatched from the api.dispatch, you need to mock the dispatch and verify that it has been called. The function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"toHavebeenCalledWith\"), \" can take another expect which can peek the content of an object passed. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"reducing-boilerplate-of-redux-with-typescript\"\n  }, \"Because every action contains a type and payload\"), \", it is possible to verify if an action has been invoked.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nmiddleware.myFunctionInMiddleware(next, api, payload);\\nexpect(api.dispatch).toHaveBeenCalledWith(\\n    expect.objectContaining({\\n        type: MY_ACTION_CONSTANT_HERE\\n    })\\n);\\n\\n\\n\")), mdx(\"p\", null, \"The case of next is similar. I found that while it is possible to use a similar logic than with api.dispatch, that sometimes it is not enough. For example, if you have a function that calls several times \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \". In that case, it is possible to pass a custom \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" that will be smarter than a simple mock.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nlet nextMock = nextPayloadTypeSpy(MY_ACTION_CONSTANT_HERE);\\nmiddleware.myFunctionInMiddleware(nextMock.mock, api, payload);\\nexpect(nextMock.getPayload()[0]).toBe(payload);\\nexpect(nextMock.hasBeenCalled()).toBeTruthy();\\n\")), mdx(\"p\", null, \"The code above this paragraph is a glimpse of how to use the smart \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \". The code accumulates in an array all invocation and allows to asset its content along the test. In that case, the test was testing the first execution of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" associated to a specific action (defined at the declaration of the object).\\xA0 The logic relies on a custom Jest's function that adds in an array all actions of a specific time when invoked by the tested function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nexport interface ActionsWithPayload<TypeAction, TypePayload> {\\n    type: TypeAction;\\n    payload: TypePayload;\\n}\\nexport interface SpyActionsWithPayload {\\n    mock: jest.Mock&lt;{}>;\\n    hasBeenCalled: () => boolean;\\n    getPayload: () => any[];\\n}\\n\\nexport function nextPayloadTypeSpy(type?: string): SpyActionsWithPayload {\\n    let typeFromCaller: string[] = [];\\n    let payloadFromCaller: any[] = [];\\n    let nextMock = jest.fn().mockImplementation((func: ActionsWithPayload<any, string>) => {\\n        typeFromCaller.push(func.type);\\n        if (func.type === type) {\\n            payloadFromCaller.push(func.payload);\\n        }\\n    });\\n    return {\\n        mock: nextMock,\\n        hasBeenCalled: () => {\\n            return type === undefined ? false : typeFromCaller.includes(type);\\n        },\\n        getPayload: () => payloadFromCaller\\n    };\\n}\\n\\n\")), mdx(\"p\", null, \"The code is tightly coupled with how you are handling your action. I strongly suggest using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"reducing-boilerplate-of-redux-with-typescript\"\n  }, \"Redux-TypeScript boilerplate \\\"free\\\"\"), \". It is really a relief to use in a term that you will create action within 30 seconds and to be type safe for the payload.\"), mdx(\"p\", null, \"The code uses a \\\"mock\\\" property which is a hook to a mock implementation that does nothing else than being recorded in an array. The actual action is doing nothing. The two functions aside the mock property are there to assert the test. Future improvements are obvious. For example, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasBeenCalled\"), \" could also take an index to ensure that a particular \\\"next\\\" has been called.\"), mdx(\"p\", null, \"To summarize, even if the middleware design is frightful, with types and some useful utility functions and patterns creating code and testing this one afterward is a breeze. I always enjoy having tests that are quick to build, and the discussed approach rationale with that mindset.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"94999d9a-6a70-5c4e-b7f1-7e5eb812a6d5"}}