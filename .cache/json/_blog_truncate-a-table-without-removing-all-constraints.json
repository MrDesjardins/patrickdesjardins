{"data":{"mdx":{"frontmatter":{"title":"Truncate a table without removing all constraints","date":"May 1, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Truncate a table without removing all constraints\",\n  \"date\": \"2014-05-01\",\n  \"categories\": [\"sql\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Truncated\"), \" a table as the advantage to remove every data without logging or locking every rows. This is a huge advantage over the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Delete\"), \" statement. This mean that truncated table cannot be restored, neither you can have a where clause into the SQL statement. Truncate also has the ability to reset the seed to its initial value. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"On delete\"), \" triggers are also not fired and all foreign keys constraint must be removed or disabled.\"), mdx(\"p\", null, \"Instead of removing all constraints, it is possible to tell SQL Server to not check foreign key.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" SET FOREIGN_KEY_CHECKS = 0; TRUNCATE TABLE [Schema].[Table]; SET FOREIGN_KEY_CHECKS = 1; \\n\")), mdx(\"p\", null, \"This will result to remove data of the table in the fastest way possible. If you want to have more details you can check that article that I previously wrote about \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./the-difference-between-sql-delete-statement-and-sql-truncate-statement\",\n    \"title\": \"The difference between SQL Delete statement and SQL Truncate statement\"\n  }, \"Truncate vs Delete\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"5bde5904-2f69-5334-9cbc-f6b060ba0d11"}}