{"data":{"mdx":{"frontmatter":{"title":"Animating a React Component","date":"June 26, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Animating a React Component\",\n  \"date\": \"2018-06-26\",\n  \"categories\": [\"react\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I have always been a fan of having user interfaces that are smooth for the eyes. One way to do it is to animate element that moves from one position to another one. When I was working at Microsoft in VSTS (Visual Studio Team Services) I developed the animation around widgets. A widget is a small block of a dashboard and one task possible is to edit this one. Instead of having the edit panel coming in place and having a blunt experience. I animated the panel to come from the right edge of the browser inside the viewport and also animating the widget to move from its position in the dashboard in the middle of the screen while blurring the background. The experience was great. The panel wasn't hiding a lot the viewport, the user knew exactly where was the widget before the edition and it was clear which widget was in an edition. This was done many years ago, all in JQuery with some CSS animation. It was dirty by today's standard but not a huge feat to accomplish in my perspective. Today, I am not relying on JQuery but on React and the process for something is similar with the difference that it requires a little bit more thought.\"), mdx(\"p\", null, \"React is great on many points but if you want to customize how a component change from a position/size to another it can be mesmerizing. The reason is that React when receiving new information will render and the rendered component will be at its final position. In this article, I will cover how to handle the case of a React's component that needs to move its \\\"left\\\" and \\\"top\\\" position but it could be any property you want.\"), mdx(\"p\", null, \"Before jumping in the code, let's describe what we will do. The idea is to get the actual data right before we are getting the new value and save a copy of it inside the component before it renders. A good place is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"componentWillReceiveProps\"), \" where you can access the DOM element by reference and save a copy of it before the new props are propagated into the whole React's lifecycle of your component. React render function does not paint to the screen when the render function is invoked. It is once the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"componentDidUpdate\"), \" is called that the browser paint. With the information in mind, and the data saved in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"componentWillReceiveProps\"), \" we can access the before and after the position/size of a component. The before being gathered in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"componentWillReceiveProps\"), \" and after in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"render\"), \" function.\"), mdx(\"p\", null, \"What you can do is to create one variable to hold the value that change and that you care for your animation. You also need one variable to have a reference to the HTML element. This should be a variable in the class component and not in the state. Changing the state invokes the lifecycle of your component to render again which is not required in that case. In the following example, I am saving my HTML element that I want to animate with the left and top position.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"private domCluster: HTMLDivElement | null = null; \\nprivate lastLeftPosition: number = 0; \\nprivate lastTopPosition: number = 0; \\n\")), mdx(\"p\", null, \"The next step is to save the actual value in the variable of the class. In my example, I'll get from the saved reference of the HTML element the top and left position using the JavaScript function getBoundingClientRect().\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"public componentWillReceiveProps(nextProps: FillWindowsClusterProps): void { \\n  if (this.domCluster !== null) { \\n    const coord = this.domCluster.getBoundingClientRect(); \\n    this.lastLeftPosition = coord.left; \\n    this.lastTopPosition = coord.top; \\n  } \\n} \\n\")), mdx(\"p\", null, \"The next function to define is the render. The render function has the role to set up the component at its final place and to set up the reference to the HTML element.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"public render(): JSX.Element { \\n  return <div key={\\\"myComponentName_\\\" + this.props.elementUniqueId} \\n  ref={(e) => this.domCluster = e} \\n  style={ { left: this.props.left, top: this.props.top } } \\n  > \\n  Your Component \\n</div>; } \\n\")), mdx(\"p\", null, \"The last React piece is in the code in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"componentDidUpdate\"), \". This code will calculate the difference between the final position that we will get again using the getBoundingClientRect() from the element generated by the render function and the last position saved from the componentWillReceiveProps.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"public componentDidUpdate(previousProps: FillWindowsClusterProps): void { \\n  if (this.domCluster !== null) { \\n    const coord = this.domCluster.getBoundingClientRect(); \\n    const deltaPositionLeft = this.lastLeftPosition - coord.left; \\n    const deltaPositionTop = this.lastTopPosition - coord.top; \\n    if (this.domCluster !== null) { \\n      this.domCluster.style.transform = `translate(${deltaPositionLeft}px, ${deltaPositionTop}px)`; this.domCluster.style.transition = \\\"transform 0s\\\"; \\n    } \\n    requestAnimationFrame(() => { \\n      if (this.domCluster !== null) { \\n        this.domCluster.style.opacity = \\\"1\\\"; \\n        this.domCluster.style.transform = \\\"\\\"; \\n        this.domCluster.style.transition = \\\"transform 850ms, opacity 800ms\\\"; \\n      } \\n    }); \\n  } \\n} \\n\")), mdx(\"p\", null, \"The heavy lifting is done by CSS. The idea is to use translate on the x and y coordinates and to set the value back to the old position. Then, we are using requestAnimationFrame to tell the browser that on the next rendering loop to remove the transform setting back the position to the final one (the one determined in the last render).\"), mdx(\"p\", null, \"In the end, the animation will work flawlessly. The user will not see the trick we just put in place. In reality, we had a life cycle in React that position the element at its final place but we used CSS to return the element back into its original place -- the place the component was before the render. And then we let the browser render the element that has a style that put immediately the component into its initial place with an animation to let go the component into its final position.\"), mdx(\"p\", null, \"From a JQuery perspective, it's a lot of more work with React. However, that is the cost to pay to have an optimized framework that takes care of the DOM/HTML for you. In that particular case, where the HTML must be accessed, there is a little tax to set up everything correctly. However, since most of the React's components are not animated and that the core goal is to let React handle the painting it is a small pain for an overall nice performance gain.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"ef1bae94-7638-520e-9858-07398d698ee3"}}