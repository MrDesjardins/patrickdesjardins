{"data":{"mdx":{"frontmatter":{"title":"Asp.Net MVC With the ValidateAntiForgeryToken For Cross Site Request Forgeries","date":"January 2, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Asp.Net MVC With the ValidateAntiForgeryToken For Cross Site Request Forgeries\",\n  \"date\": \"2014-01-02\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Cross Site Request Forgeries is also know as CSRF. It is a type of malicious exploit that send commands from a user without his consent to another website. CSRF exploits the trust that a site has in a user's browser. For example, a website could try to execute a form to add something in your Amazon basket! This can be limited by adding an hidden field to a form and a cookie. Both will contain the same value and when the form is submitted the hidden field is compared to the cookie value. If it's the same value, we know that the user has sent the form. If it's not, we know it's a malicious attack.\"), mdx(\"p\", null, \"In Asp.Net MVC, ValidateAntiForgeryToken is a combination of an html helper (hidden field) and attribute(cookie) that allows to verify if the form as been created and sent by the same user.\"), mdx(\"p\", null, \"The first step is to add the HtmlHelper method @Html.AntiForgeryToken() inside the form in your view.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"@using (Html.BeginForm()) { @Html.AntiForgeryToken() //... \\n\")), mdx(\"p\", null, \"This generate an hidden field with the name \\\"__RequestVerificationToken\\\" and an unique value. This is an example of the output generated:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-html\",\n    \"metastring\": \"<form action=\\\"/House/Create\\\" method=\\\"post\\\" novalidate=\\\"novalidate\\\"> <input name=\\\"__RequestVerificationToken\\\" type=\\\"hidden\\\" value=\\\"KPyzBk0KGpjStJR96AVI38AbBujBInJNB-1XH-RwsbuifwgmxnGiF-0R2cMHjcYBiz7yOBUnv0fZwoE2oBwiuKXalBDvsRr2RRG7nmkOsq41\\\"> //...\",\n    \"<form\": true,\n    \"action\": \"\\\"/House/Create\\\"\",\n    \"method\": \"\\\"post\\\"\",\n    \"novalidate\": \"\\\"novalidate\\\">\",\n    \"<input\": true,\n    \"name\": \"\\\"__RequestVerificationToken\\\"\",\n    \"type\": \"\\\"hidden\\\"\",\n    \"value\": \"\\\"KPyzBk0KGpjStJR96AVI38AbBujBInJNB-1XH-RwsbuifwgmxnGiF-0R2cMHjcYBiz7yOBUnv0fZwoE2oBwiuKXalBDvsRr2RRG7nmkOsq41\\\">\",\n    \"//...\": true\n  }, \"\")), mdx(\"p\", null, \"The code behind the html helper is simple. It creates a MvcHtmlString from the AntiForgery class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public MvcHtmlString AntiForgeryToken() { return new MvcHtmlString(AntiForgery.GetHtml().ToString()); } \\n\")), mdx(\"p\", null, \"The AntiForgery class contains the GetHtml() used in the html helper but also some validation of the forgery. Both use the class AntiForgeryWorker.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static HtmlString GetHtml() { if (HttpContext.Current == null) throw new ArgumentException(WebPageResources.HttpContextUnavailable); else return AntiForgery._worker.GetFormInputElement((HttpContextBase) new HttpContextWrapper(HttpContext.Current)).ToHtmlString(TagRenderMode.SelfClosing); } \\n\")), mdx(\"p\", null, \"The_worker that we see in the code above is of type AntiForgeryWorker. This class is about 139 lines and the core of it is the GetFormInputElement used by the GetHtml.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public TagBuilder GetFormInputElement(HttpContextBase httpContext) { this.CheckSSLConfig(httpContext); AntiForgeryToken cookieTokenNoThrow = this.GetCookieTokenNoThrow(httpContext); AntiForgeryToken newCookieToken; AntiForgeryToken formToken; this.GetTokens(httpContext, cookieTokenNoThrow, out newCookieToken, out formToken); if (newCookieToken != null) this._tokenStore.SaveCookieToken(httpContext, newCookieToken); if (!this._config.SuppressXFrameOptionsHeader) httpContext.Response.AddHeader(\\\"X-Frame-Options\\\", \\\"SAMEORIGIN\\\"); TagBuilder tagBuilder = new TagBuilder(\\\"input\\\"); tagBuilder.Attributes[\\\"type\\\"] = \\\"hidden\\\"; tagBuilder.Attributes[\\\"name\\\"] = this._config.FormFieldName; tagBuilder.Attributes[\\\"value\\\"] = this._serializer.Serialize(formToken); return tagBuilder; } \\n\")), mdx(\"p\", null, \"This is interesting to see how the value is generated. As we can see, it's using the serializer to serialize the form token. The form token is build inside the class TokenValidator that take some property of the Identity. I won't go deeper because it goes a little beyond the scope of the article. Just remember that the token is unique for the user. However, the GetFormInputElement code above is also important for something else. The token store role is to create the cookie which set also the token.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public void SaveCookieToken(HttpContextBase httpContext, AntiForgeryToken token) { HttpCookie cookie = new HttpCookie(this._config.CookieName, this._serializer.Serialize(token)) { HttpOnly = true }; if (this._config.RequireSSL) cookie.Secure = true; httpContext.Response.Cookies.Set(cookie); } \\n\")), mdx(\"p\", null, \"The way the ValidateAntiForgeryToken attribute works is by checking to see that the cookie and hidden form field left by the Html.AntiForgeryToken() Html Helper essentially exists and match. If they do not exist or match, it throws an HttpAntiForgeryException.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"393px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/49a2fb428000c9e5e1be9fc3d9876b32/d72ec/ValidateAntiforgerytoken.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"36%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA2UlEQVQY05WO0WrDMAxF8/+/V9ggKaxbSUjiOHVk2ZJlyx4pDPYwBj0P0n24B6mTnDcfHiQHJWJur9ARxX5ahs0Nxk3O75FniDamLSZzoKr+J0sq4wTLChYQWIDFUQJiCPFxACXhXIJkzoVzKapZJP/QIZTbR4GjASeDcYa4BfbEZl3uX3cLOHsyGA3SiuSJY0BE9N5jCF3RrCrONZH2Kl1rrdZm96jaSlER1VrP/85dyznaM/4lq9ZnT6OE1brLxcwz9r39vLnhuq+Lf3vfxtFfhx1DPg/94hvwLZbkbPRFbwAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"ValidateAntiforgerytoken\",\n    \"title\": \"ValidateAntiforgerytoken\",\n    \"src\": \"/static/49a2fb428000c9e5e1be9fc3d9876b32/d72ec/ValidateAntiforgerytoken.png\",\n    \"srcSet\": [\"/static/49a2fb428000c9e5e1be9fc3d9876b32/5a46d/ValidateAntiforgerytoken.png 300w\", \"/static/49a2fb428000c9e5e1be9fc3d9876b32/d72ec/ValidateAntiforgerytoken.png 393w\"],\n    \"sizes\": \"(max-width: 393px) 100vw, 393px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The attribute does have a ValidateAntiForgeryTokenAttribute method that call the AntiForgery class. I have previously mentioned that it has not only the method to get the input but also for validation. Here is where it's used.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public ValidateAntiForgeryTokenAttribute() : this(new Action(AntiForgery.Validate)) { } \\n\")), mdx(\"p\", null, \"This method go through several method of the framework to end to the ValidateTokens(...) methods that look like the code below. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public void ValidateTokens(HttpContextBase httpContext, IIdentity identity, AntiForgeryToken sessionToken, AntiForgeryToken fieldToken) { if (sessionToken == null) throw HttpAntiForgeryException.CreateCookieMissingException(this._config.CookieName); if (fieldToken == null) throw HttpAntiForgeryException.CreateFormFieldMissingException(this._config.FormFieldName); if (!sessionToken.IsSessionToken || fieldToken.IsSessionToken) throw HttpAntiForgeryException.CreateTokensSwappedException(this._config.CookieName, this._config.FormFieldName); if (!object.Equals((object) sessionToken.SecurityToken, (object) fieldToken.SecurityToken)) throw HttpAntiForgeryException.CreateSecurityTokenMismatchException(); string str = string.Empty; BinaryBlob binaryBlob = (BinaryBlob) null; if (identity != null && identity.IsAuthenticated) { binaryBlob = this._claimUidExtractor.ExtractClaimUid(identity); if (binaryBlob == null) str = identity.Name ?? string.Empty; } bool flag = str.StartsWith(\\\"http://\\\", StringComparison.OrdinalIgnoreCase) || str.StartsWith(\\\"https://\\\", StringComparison.OrdinalIgnoreCase); if (!string.Equals(fieldToken.Username, str, flag ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase)) throw HttpAntiForgeryException.CreateUsernameMismatchException(fieldToken.Username, str); if (!object.Equals((object) fieldToken.ClaimUid, (object) binaryBlob)) throw HttpAntiForgeryException.CreateClaimUidMismatchException(); if (this._config.AdditionalDataProvider != null && !this._config.AdditionalDataProvider.ValidateAdditionalData(httpContext, fieldToken.AdditionalData)) throw HttpAntiForgeryException.CreateAdditionalDataCheckFailedException(); } \\n\")), mdx(\"p\", null, \"What interest us is all possible exception that are throws. You can see that is can raise HttpAntiForgeryException for several case like if the cookie is missing, which is the case for Cross Site Request Forgeries or if the form doesn't have the hidden field, or if the token mismatch between the cookie and the form.\"), mdx(\"p\", null, \"All the complexity of the mechanism is hidden by the Asp.Net MVC framework. At the end, you only need to remember to add the html helper to your form and to add the attribute to the action of your controller that receive the form inputs.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"6b35b510-c1ed-56bd-9ea0-8179e422bb05"}}