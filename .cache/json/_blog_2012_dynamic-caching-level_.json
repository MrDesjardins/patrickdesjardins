{"data":{"mdx":{"frontmatter":{"title":"Dynamic caching level","date":"September 4, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic caching level\",\n  \"date\": \"2012-09-04\",\n  \"categories\": [\"dynamic\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I have read an interesting article that talk about the different \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://geekswithblogs.net/simonc/archive/2012/08/20/inside-the-dlr---invoking-methods.aspx?utm_source=dlvr.it&utm_medium=twitter&utm_campaign=kodefuguru\"\n  }, \"level of caching\"), \" that Dynamic keyword use.\"), mdx(\"p\", null, \"The dynamic lookup is performed at runtime with 3 different ways. First, it checks if the last dynamic methods and arguments type correspond to the last call. If yes, it will reuse the compiled code. This is very fast, as fast as using something not dynamic minus the little extra step of validation.\"), mdx(\"p\", null, \"The second way is to check into the complete list of dynamic code that has been called to find a method signature corresponding. This is also very fast. If it found something, it will update the last called method to be faster next time otherwise, it will goes into the last step.\"), mdx(\"p\", null, \"The last step is so build the method call and to update the list of methods. The pseudo code of the logic is like that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" if (lastMethod = currentOneInvoked) { Invoke(currentOneInvoked); } else if(listMethod.Find(currentOneInvoked)) { Invoke(currentOneInvoked); } else { UpdateAndInvoke(currentOneInvoked, arg0, ...); } \\n\")), mdx(\"p\", null, \"So, dynamic method is slower but is optimized to be as must fast as possible.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"f4fb21f0-7671-5c9c-b79c-82f9e886de64","slug":"2012/dynamic-caching-level","__params":{"slug":"2012"}}}