{"data":{"mdx":{"frontmatter":{"title":"Re-Reselect your whole Redux State","date":"November 13, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Re-Reselect your whole Redux State\",\n  \"date\": \"2018-11-13\",\n  \"categories\": [\"redux\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Re-Reselect is a library that uses Reselect. Both have the capability to memoize a function returns by its input. It means that if the input of a determine function change, the function is executed and the return is saved in memory. The saved copy of the information is used until one of the specified parameter change. The goal is to avoid computation that is expensive. Once use case with Redux is denormalization. Denormalizing is the act of stitching together information in several places. Redux encourages separating the model in a normalized way to avoid duplicate, thus reducing issue of having more than one entity with different value. Re-Reselect has the advantage of having a set of input that can handle several other selector. The following image, from the official repository of Re-Reselect illustrate the difference.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"888px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/8e4d69a9030dff0d679cda753d57f91f/b04e4/reselect-and-re-reselect.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"37.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABAUlEQVQoz2WR22qDQBCG8/4PVHrZy5ZCoaQEayEiapJmo1HXU9zDVzzHZm+Wnfnnm39mN9ZawGIslLUijhPKuqUPY+nygwZuypLlEnGJqRvVx4Y8s2YzAbWBRNboVnKVJco8AvNaU9YVTVOSVe0KOGl7oBkLdoHgzXXZ+sc78QJsNXzsfV7dH0ReMZ8ZOjqcCuJC87RNiNJ2BexzecpvcuLdE7x8X4jiM/vQI5XZSruZHt3RxvD8GVA0j8BQBPinHd7RwQ0dwrODd/gizsQauBQNtg/XG0pblkbT0oeR8koTJQ22NzB85r2plcPuLiuJMWbpOu4Ixim0oqjktDz+1/8BwD8iigrhYncAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"reselect and re reselect\",\n    \"title\": \"reselect and re reselect\",\n    \"src\": \"/static/8e4d69a9030dff0d679cda753d57f91f/b04e4/reselect-and-re-reselect.png\",\n    \"srcSet\": [\"/static/8e4d69a9030dff0d679cda753d57f91f/5a46d/reselect-and-re-reselect.png 300w\", \"/static/8e4d69a9030dff0d679cda753d57f91f/0a47e/reselect-and-re-reselect.png 600w\", \"/static/8e4d69a9030dff0d679cda753d57f91f/b04e4/reselect-and-re-reselect.png 888w\"],\n    \"sizes\": \"(max-width: 888px) 100vw, 888px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Reselect versus Re-Reselect\"), mdx(\"p\", null, \"I am using Re-Reselect at Netflix in the Partner Portal application for denormalizing many entities. For example, I have selector for each of our organization we serve and each of them have sites around the world. Each site has appliances as well. When I am receiving information from the backend, depending of the endpoint, I need to invalidate more than one cache. So far, Re-Select is working well. However, I have custom logic to denormalize to handle cases that are beyond that blog post. These one require to access specific Redux store directly to compute information with different functions. It means that during the invalidation of the cache, and while a new value to be memoized I need to have an access to the Redux's state and pass this one to functions.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"public denormalizeSitePerformanceExpensive(appReduxState: AppReduxState,\\n  site: SiteNormalized | undefined,\\n  org: OrgNormalized | undefined,\\n  contactSelector: GenericMap<ContactNormalized>,\\n  deepDenormalize: boolean = true ): SiteDenormalized | undefined {\\n\")), mdx(\"p\", null, \"The function signature above is an example that to denormalize a site we need to pass the application \\\"head\\\" Redux state. The problem the memoization get invalidate on every change. The reason is not obvious if you never used ReSelect (or Re-Reselect). Because it is an input and because the reference of the head of Redux state will change at any change, then it invalidates the site cache. Here is the cache creation that shows the input that are used to invalidate the cache.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"private denormalizeSiteFunction = createCachedSelector(\\n    (state: AppReduxState) => state,\\n    (state: AppReduxState, siteNormalized: SiteNormalized | undefined) => siteNormalized,\\n    (state: AppReduxState, siteNormalized: SiteNormalized | undefined, orgNormalized: OrgNormalized | undefined) => orgNormalized, this.contactSelector, this.applianceSelector,\\n    (state: AppReduxState, siteNormalized: SiteNormalized | undefined, orgNormalized: OrgNormalized | undefined, deepDenormalizer: boolean) => deepDenormalizer,\\n    (state: AppReduxState, siteNormalized: SiteNormalized | undefined, orgNormalized: OrgNormalized | undefined, contactSelector: GenericMap<ContactNormalized>,\\n    applianceSelector: GenericMap<ApplianceNormalized>,\\n    deepNormalizer: boolean ) => this.denormalizeSitePerformanceExpensive(state, siteNormalized, orgNormalized, contactSelector, deepNormalizer) )();\\n\")), mdx(\"p\", null, \"The\\xA0quandary is to find a way to pass the state without having this one invalidating the selector when a change is done but keep having the function invalidated if any other selector in the parameter change. In the example posted, we want the site to denormalize to change if the normalized site change, or the organization the site belong change or a contact change or if an appliance change but not for all other selectors we have in the system, neither any data of the store.\"), mdx(\"p\", null, \"The idea is to build a custom input instead of relying on the shallow comparer that comes by default. It is possible to pass to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"createCachedSelector\"), \" an optional object with a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"selectorCreator\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"{\\n  selectorCreator: this.createShallowEqualSelector;\\n}\\n\")), mdx(\"p\", null, \"In my situation, it was a good opportunity to also have a feature to turn off completely the memoization. I always have an off switch to all my caching mechanism. It helps to debug and to preclude any issue with caching. To avoid impacting the memoization with the Redux's store, I am looking for specific children reducer and if they are present, I know that it is the head and I return true which mean that the parameter is equal and it will not invalidate the cache.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"private createShallowEqualSelector = createSelectorCreator( defaultMemoize,\\n  (previous: any, next: any, index: number): boolean => {\\n    if (this.isCacheEnabled) {\\n      // 1) Check if head of Redux state\\n      if ( previous !== undefined && \\n          previous.router !== undefined && \\n          previous.orgs !== undefined && // ... Simplified for this example \\n         )\\n      {\\n         return true; // AppReduxState no check!\\n      }\\n      // Logic removed that figure out if the input is the same or not return isTheSame;\\n    }\\n    else {\\n       return false;\\n    }\\n  } \\n);\\n\")), mdx(\"p\", null, \"The custom equalizer opens door to interesting pattern. For example, if you do not have all your entity with the same reference even if they are the same, you can provide a global logic that handle that case. For my scenario, I am using a property that each entity has which is the last updated date time from the server. You may wonder why not relying on the object reference. In a perfect world, it would make sense because it is the most efficient way to perform a comparison and have the best performance. However, Partner Portal uses many caching mechanisms. For example, we are using IndexDb which mean that depending of the source of the object, the object may have not changed in term of value but changed in term of reference. Also, at the moment, one flaw of the system is that the cached value is set into the Redux store even if the Redux store has the same value (there is not check before setting the value received by the data access layer). To avoid invaliding because the data was fetched again (Ajax) or from the cache, a simple check to the last updated avoid invalidating the cache.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"b4b60aac-08e1-591b-9d41-747ea1360825","slug":"2018/re-reselect-your-whole-redux-state","__params":{"slug":"2018"}}}