{"data":{"mdx":{"frontmatter":{"title":"TypeScript Boolean Function can Return Undefined","date":"August 3, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"As much as I like TypeScript, it sometime inherits of the bad side of JavaScript. In this article, I'll demonstrate a common example that cause problem. It goes in the line of what I wrote a year ago about the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./typescript-comparison-of-null-and-undefined\"\n  }, \"difference between \", mdx(\"em\", {\n    parentName: \"a\"\n  }, \"NULL\"), \" or \", mdx(\"em\", {\n    parentName: \"a\"\n  }, \"undefined\")), \". While it's always better to check for === undefined, lot of people keep having the habit of just checking the value with &&.\"), mdx(\"p\", null, \"Before getting into the core of the issue. Let's be on the same page. The following code compiles.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function test1(): boolean{ return undefined; } alert(test1()); \\n\")), mdx(\"p\", null, \"It doesn't look like it compiles, but it does. Which mean that the following code also compile and return \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" as well.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function test2(): boolean{ return true && undefined; } alert(test2()); \\n\")), mdx(\"p\", null, \"But you will say that you will never explicitly write \\\"undefined\\\" in an && condition. However, people write: ```typescript\\nfunction test3(myObject:any): boolean { return myObject && myObject.prop && myObject.prop.isOkay; } alert(test3()); \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" The alert in that case will be undefined if the \\\"prop\\\" is not defined or if the \\\"myObject\\\" is not defined. It won't be false.\\n\\nThere is two ways to solve that issue. The first one is the proper way, but longer way to write which is to check against what we are really evaluating -- undefined.\\n\\n```typescript\\nfunction test4(myObject:any): boolean { return myObject !== undefined && myObject.prop !== undefined && myObject.prop.isOkay; } alert(test4()); \\n\")), mdx(\"p\", null, \" This is the most explicit and clear way to have exactly the result expected. It returns true or it returns false; it cannot return \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"undefined\"), \".\"), mdx(\"p\", null, \"A more succinct way to write this validation is to use the double bang (!!). ```typescript\\nfunction test5(myObject:any): boolean { return !!myObject && !!myObject.prop && myObject.prop.isOkay; } alert(test5()); \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" This latest will also evaluate for _null_ as well as _undefined_ and also _true/false_.\\n\\nAt the end, you should always avoid to simply rely that an undefined value will return false in a chain of condition. JavaScript return the last value that is not true in the chain, which we saw that can be undefined. TypeScript is not smart enough to catch this possibility and will let the function returning _undefined_ instead of a boolean.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"TypeScript Boolean Function can Return Undefined\\\",\\\"date\\\":\\\"2017-08-03\\\",\\\"categories\\\":[\\\"typescript\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"43815052-cd47-50d6-b7bf-399872bfa3da"}}