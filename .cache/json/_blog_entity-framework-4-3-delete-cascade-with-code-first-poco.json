{"data":{"mdx":{"frontmatter":{"title":"Entity Framework 4.3 delete cascade with code first (Poco)","date":"April 19, 2012"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Entity Framework 4.3 delete cascade with code first (Poco)\",\n  \"date\": \"2012-04-19\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you have a parent->child relationship between two of your classes and you delete the parent, you may want to delete all children. To do, you need to have a \\\"DELETE CASCADE\\\" statement on your foreign key. Here is a simple example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \" CREATE TABLE [Parent]( [ID] [int] IDENTITY(1,1) NOT NULL, [Description] [nvarchar](100) NULL, CONSTRAINT [PK_Parent] PRIMARY KEY CLUSTERED GO\\n\\nCREATE TABLE [ParentDetail]( [ID] [int] IDENTITY(1,1) NOT NULL, [Parent_ID] [int] NOT NULL, CONSTRAINT [PK_ParentDetail] PRIMARY KEY CLUSTERED GO\\n\\nALTER TABLE [ParentDetail] WITH CHECK ADD CONSTRAINT [FK_ParentDetail_Parent] FOREIGN KEY([Parent_ID]) REFERENCES [Parent] ([ID]) ON DELETE CASCADE GO \\n\")), mdx(\"p\", null, \"The problem is that if you are using Entity Framework 4.3 and try to delete a Parent entity, you will end having this error :\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"An error occurred while saving entities that do not expose foreign key properties for their relationships. The EntityEntries property will return null because a single entity cannot be identified as the source of the exception. Handling of exceptions while saving can be made easier by exposing foreign key properties in your entity types. See the InnerException for details.\")), mdx(\"p\", null, \"The inner exception message will contain something similar to this:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Cannot insert the value NULL into column 'Parent_ID', table 'ParentDetail'; column does not allow nulls. UPDATE fails. The statement has been terminated.\")), mdx(\"p\", null, \"So, what does it means? It tries to delete the Parent and to set into each ParentDetail the ID NULL because it's been erased. This is not what we want. In fact, we would like to have all ParentDetail to me removed as well. This is a little bit the reason why we have specify on the SQL to have a cascade.\"), mdx(\"p\", null, \"You can do it manually in your project:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var listDetail = parent.ParentDetails.ToList(); foreach (var ParentDetail in listDetail){ Database.ParentDetails.Remove(ParentDetail); }\\n\\nDatabase.Parents.Remove(Parent); Database.SaveChanges(); \\n\")), mdx(\"p\", null, \"This will produce multiple amount of SQL statement on the SQL Server. One for each details and 1 for the Parent itself.\"), mdx(\"p\", null, \"But, if you go to your database context and you specify in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"OnModelCreating\"), \" a rule about the cascade it will work as it's suppose to do.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" protected override void OnModelCreating(DbModelBuilder modelBuilder) { //... modelBuilder.Entity<Parent>().HasMany(e => e.ParentDetails).WithOptional(s => s.Parent).WillCascadeOnDelete(true); //... \\n\")), mdx(\"p\", null, \"That's it! Now you can simply delete the Parent without having to delete manually every children.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" Database.Parents.Remove(Parent); Database.SaveChanges(); \\n\")), mdx(\"p\", null, \"On the SQL server side, you can see the database to have the same amount of delete statement executed. So, you do not save on the amount of query but save on the amount of logic to handle on the C# side because you do not have to care to delete every details.\"), mdx(\"p\", null, \"On a special note, you do not need to have the table having a reference with the On Delete Cascade. You can handle the cascade only on the Entity DbContext with OnModelCreating. If you specify it on the Sql Server Database side, this only will enforce the integrity on the database side but won't be automatically applied on the delete with EF.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"3ddf61c5-de51-5584-98f4-c24d533bd111"}}