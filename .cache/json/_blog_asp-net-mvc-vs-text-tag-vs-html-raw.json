{"data":{"mdx":{"frontmatter":{"title":"Asp.Net MVC @: vs text tag vs Html.Raw","date":"July 3, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Asp.Net MVC offers several ways to output Html from a Razor page, also know as a .cshtml page or the view.\"), mdx(\"p\", null, \"The first way is to use the syntax shortcut \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"@:\"), \". This indicate to MVC that the rest of the line is a content block. The advantage of this way to output is that Visual Studio handles closing and opening tag and will continue to work by showing you if a closing tag is missing. The disadvantage is that you cannot use this for Html tag that is over multiple lines.\"), mdx(\"p\", null, \"The second way is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"text\"), \" tag. Very similar to the shortcut syntax but this time it goes on several line. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" <text> This is super to output something like the date : @DateTime.Now </text> \\n\")), mdx(\"p\", null, \"Finally, you can use the Html Helper .\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Raw\"), \". You have to remember that the helper return a HtmlString. This require you to use the @ before the Html Helper. Otherwise, the method will return the value but nothing will be rendered.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" @Html.Raw(\\\"<div>It works</div>\\\") Html.Raw(\\\"<div>This does not work</div>\\\") \\n\")), mdx(\"p\", null, \"If you are within a multi-statement block @{...} and that you want to output Html than you have all three choices. The first one is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"@:\"), \" and the second is the Html Helper \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Raw\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" <div class=\\\"row\\\"> @{ foreach (var contest in Model.SubscribedContests) { if (iSubScribe != 0 && iSubScribe % itemPerColumnSubScribe == 0) { @Html.Raw(\\\"</div>\\\"); @:</div> } } } </div> \\n``` As you can see, the two closing divisions are legal. Both output the div html tag. You cannot use directly the html because it expects to have C# code. Visual Studio will not be able to resolve the Html.\\n\\nThe rules of thumb is that if you need to output Html content to the browser to have this one interpreted it, than you need to send non-encoded html, which require to send \\\"raw\\\" html. Otherwise, you should always send html encoded element which is more safe. This is the default behavior because it protects you to have user trying to embedded undesirable html in your web page.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"Asp.Net MVC @: vs text tag vs Html.Raw\\\",\\\"date\\\":\\\"2014-07-03\\\",\\\"categories\\\":[\\\"asp-mvc\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"2c5dc38e-8370-5d69-9745-55fa3d070fd9"}}