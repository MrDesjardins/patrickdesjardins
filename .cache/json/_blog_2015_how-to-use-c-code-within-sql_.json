{"data":{"mdx":{"frontmatter":{"title":"How to use C# code within SQL","date":"September 1, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to use C# code within SQL\",\n  \"date\": \"2015-09-01\",\n  \"categories\": [\"c-sharp\", \"sql\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is the first time I had to have something that require a special business logic inside the database that I could not do directly in TSQL. Usually, I get around or I simply do something outside SQL like a small C# console that will handle everything. I decided to take a look a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CLR SQL Server User-Defined Function\"), \". This article describes how to create your own C# method and use it within your TSQL. Albeit the feasibility and the success of the method, I removed the code at the end to make a console application and I will explain to you why.\"), mdx(\"p\", null, \"First thing to do is to create a SQL Server Project. \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"400px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/719e4e4bbbd51ce981c70787f1c71742/e17e5/SqlUserDefinedFunction-400x180.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"44.99999999999999%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB5klEQVQoz02Q227TQBCG87JcoMIdz4FAlYpUQvsAUFEaWqT2CbhClWjpgcaJHcfntddnr9f7obiEMtJczOH/NP9Mrj6+5ufRLjfH77g53uPX5z3mZ1Pm36bcn+5zNXvP7emUy6Ndfnx6y93ZIcvzQ+yLA5yLQ+zzA+yLD1inU6733zBx5nMe7IBQlMRpTVYqrFXI7dxhHQiSrETIGlnW5FVFuNmpNF6U4XgRfpwhZEVeK/K6YtIXMUHgE4U+xvRswvPWBKHHoDW96tC9GvsYg8xSBt2TigTHXpKmgrqqKMuSppBMujxmaTsslw5Vpel78IOAMApo25ZtDMPAMGiklCilGAaD1hpjzNOOah+Bt/cW1sLDshqEUIhUkgiBzAuyTNK23SjQehjrTim2mA1wzM28a5j0pSCKIsLAwwyPwjgKiUOPppTkaUxdZDC+Y6CUYqPc4sbcXjkC1wuLhROw9hP8MKNsNHdLn8sHnzu/5tqRLJIeOzMs0oHrVc48VtQtqM6gFKP9f8Dl3GYV1rhhxSooccOa4+8ur74Ins8MOzPFi1nPzteBZyeG5yc9L88Ml787/HWD77d0nX4CurbLOm5wgwI3LPDjBsv2iEVGllckWUEsJGXTobQhyXLqrv9rV49v+N/yH4Lqns3FCGpKAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"SqlUserDefinedFunction 400x180\",\n    \"title\": \"SqlUserDefinedFunction 400x180\",\n    \"src\": \"/static/719e4e4bbbd51ce981c70787f1c71742/e17e5/SqlUserDefinedFunction-400x180.png\",\n    \"srcSet\": [\"/static/719e4e4bbbd51ce981c70787f1c71742/5a46d/SqlUserDefinedFunction-400x180.png 300w\", \"/static/719e4e4bbbd51ce981c70787f1c71742/e17e5/SqlUserDefinedFunction-400x180.png 400w\"],\n    \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Finally, you write your own method. Mine was returning a single string so I had to return a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"SqlString\"), \". \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public partial class UserDefinedFunctions { [Microsoft.SqlServer.Server.SqlFunction] public static SqlString HashPassword(string plainPassword) { byte[] salt; byte[] buffer2; using (var bytes = new Rfc2898DeriveBytes(plainPassword, 0x10, 0x3e8)) { salt = bytes.Salt; buffer2 = bytes.GetBytes(0x20); } byte[] dst = new byte[0x31]; Buffer.BlockCopy(salt, 0, dst, 1, 0x10); Buffer.BlockCopy(buffer2, 0, dst, 0x11, 0x20); return new SqlString (Convert.ToBase64String(dst)); } } \\n``` This is the code I used. It does the hash of a plain password and return the hashed password. This algorithm is compatible with Entity Framework so it was a way to convert legacy password into Entity Framework format. You can see that not only that class is partial to a specific class, but it also has an attribute. The **Microsoft.SqlServer.Server.SqlFunction** is required to specify the type of the method for SQL. It also allows to add additional information like if the function is deterministic.\\n\\nThe last step is to **publish**. You need to right click the project, select Publish. This will raise a dialog where you need to select the database server, the database name, and the script to generate. This will build (if not already done) the project. The bin folder will contains the code (dll) but also a dacpac and a SQL file. ![](images/SqlUserDefinedFunction-400x180.png)\\n\\n![](images/SqlUserDefinedFunctionBinFolder.png)\\n\\nThe dacpac is what is installed by Visual Studio into Sql Server. This is a file that contains SQL objects. It is used not only by C# code but could contains any SQL object like Sql Procedure for example. The format cannot be read by NotePad because it is a compressed file. You can unzip it if you are curious. And we are curious! So here is the code above dacpac unzipped file structures. ![](images/dacpactunzipped-400x94.png)\\n\\nThe interesting file is the _model.xml_. It contains a reference to the DLL file but also the function metadata we created and the source of the code inside a CDATA. ![](images/insidedacpac-400x260.png)\\n\\n![](images/ScalarValueFunctionSqlServer.png)\\n\\nFrom here, you can just use a simple select, pass your parameter and you are all set.\\n\\nIf you cannot have you database working with CLR, it maybe because it is disabled. To enable, you need to do the following command once. \\n```sql\\n sp_configure 'show advanced options', 1; GO RECONFIGURE; GO sp_configure 'clr enabled', 1; GO RECONFIGURE; GO \\n\")), mdx(\"p\", null, \"The problem I ran into is the performance. This is very slow compared to any native SQL code. It is also slower than execute the same code directly inside a simple Console application that loop through all the data. For example, removing that call take 7 seconds. Even if it wasn't converting the password and keeping this one plain, the time was reasonable. Using the CRL SQL Server User-Defined Function the time raise to 11 minutes. Doing the loop in a console by reading the data and updating the value with ADO.Net took half of the time. The time is getting high because of the code itself which is not a simple task. Even if it takes few milliseconds to execute in a console, the hashing process is still little expensive to do. Also, CRL in SQL add a layer of slowness because the SQL engine need to stub inside your SQL query Microsoft intermediate language (MSIL) a bridge to the function. This generated stub is compiled into optimized code for the SQL Server you are executing this one to.\"), mdx(\"p\", null, \"That said, the performance was quite slow from few seconds to several minutes. I had a huge script that was converting a lot of data, gigs and gigs of data across a lot of tables from one database to another. The overhead was not something I wanted to paid during the conversion and could be executed afterward by a small console job later. I could also use the CLR function in a second script later because even if the performance was several minutes, creating the console application wasn't saving much more. That said, during the creation of the CLR function for SQL I got curious about performance and I learned that this is far from being a subject that is black or white. Most of the time, it depends of the operation executed to know if it worth it or not to use a C# CLR function. I personally believe it should be limited. Even if it is possible to debug with Visual Studio those function remotely, I believe that business logic should remain in the application tier --t he database should be used only for persisting the information. Nevertheless, special case like using Regex on string, doing special data manipulations can be not possible with SQL only. This is a great tool to have on your belt and should be used wisely.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"0f46104c-60db-5639-8539-03475beabdde","slug":"2015/how-to-use-c-code-within-sql","__params":{"slug":"2015"}}}