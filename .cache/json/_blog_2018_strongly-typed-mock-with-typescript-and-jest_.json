{"data":{"mdx":{"frontmatter":{"title":"Strongly Typed Mock with TypeScript and Jest","date":"March 13, 2018"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Strongly Typed Mock with TypeScript and Jest\",\n  \"date\": \"2018-03-13\",\n  \"categories\": [\"jest\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"TypeScript strongly typed nature help reducing the number of tests but unit tests will always be needed to test logic. Jest comes for free when using the React ecosystem and the project \\\"create-react-app\\\" which is also available with TypeScript as the transpiler. In this article, we will see a way to mock an interface that got injected into a class in a strongly typed fashion.\"), mdx(\"p\", null, \"Before getting too far into the detail of the implementation, here is a basic interface that a class use in the application and a class that uses that interface by injection to another class. The goal will be to unit test the class that receives the injected interface. We want to abstract the implementation of the concrete injected class and rely on mocking the interface with Jest.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface IClassToInject { \\n  run(): boolean; \\n} \\n\\nclass ClassToInject implements IClassToInject { \\n  public run(): boolean { \\n    return Math.random() >= 0.5; \\n  } \\n} \\n\\nclass ClassToTest { \\n  constructor(private injectedClass: IClassToInject) { } \\n}\\n\\nconst myClass = new ClassToTest(new ClassToInject());\\n\")), mdx(\"p\", null, \"The idea will be to use jest.Mock which is generic. The problem that we want to have Jest using the same object but not the real type. The idea is to have Jest using the same structure but with the type swapped to use Jest's stub. TypeScript type mapping can be handy in a situation where we want to preserve the structure but change the type. The type, that I called \\\"Mockify\\\" allows doing exactly this transformation for you. Instead of injecting the interface directly, we inject the Mockify interface. Creating a Mockify version force the definition of each property which you can set to jest.fn(). There is a little of boilerplate that could be automated but overall, the idea is to have the strongly typed nature available. If the interface adds a new member, delete, or rename, the transpiler will raise an error in your test! The notification brings extra validation very soon in the development flow.\"), mdx(\"p\", null, \"The next step is to create a variable that will hold the mocked interface where you can set returned value depending on what is tested in each test. Finally, we set the mock object to the class by injecting the mock by the constructor.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"type Mockify<T> = { [P in \\xDFkeyof T]: jest.Mock<{}>; }; \\nlet mockInterfaceToInject: Mockify<IClassToInject> = { run: jest.fn() };\\n\\nmockInterfaceToInject.run.mockReturnValue(false); const classToTest = new ClassToTest(mockInterfaceToInject); \\n\")), mdx(\"p\", null, \"In this article, we saw that it's possible to keep an existing interface and to map its structure with new returned values that are from Jest's mocking framework. It allows keeping in sync with the model and flexible by adding testing capability like giving returned value or count how many time a property is called.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"858ec889-7941-52ed-a182-8f8a0a121304","slug":"2018/strongly-typed-mock-with-typescript-and-jest","__params":{"slug":"2018"}}}