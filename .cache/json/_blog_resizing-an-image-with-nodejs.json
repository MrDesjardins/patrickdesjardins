{"data":{"mdx":{"frontmatter":{"title":"Resizing an Image with NodeJs","date":"August 1, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Resizing an Image with NodeJs\",\n  \"date\": \"2017-08-01\",\n  \"categories\": [\"azure\", \"cognitive-api\", \"javascript\", \"nodejs-web\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is the second post about project of creating a search tool for local pictures. As mentioned in the first post, this tool needs to use a web service to get information about the picture. This mean we need to upload the image that Microsoft Cognitive Vision/Face service will analyze and return a JSON object with information about the picture. Like most service, there is some constraints in term of the minimum and maximum of the size of what you can upload. Also, even for us, we do not want to send a 25 megs picture when it is not necessary. This article discuss about how to resize picture before sending a request to the web service. This will not only allow to be withing the range of the acceptable values, but also speed up the upload.\"), mdx(\"p\", null, \"I decide to take the arbitrary value of sending picture with the widest side of 640px. This produce in average a file 30kb which is tiny but still enough for the cognitive service to give very good result. This value may not be good if you are building something similar where people are far or if you are not using portrait pictures. In my case, the main subjects are always close range, hence very easy to get detail at that small resolution.\"), mdx(\"p\", null, \"Resizing a file requires to use a third-party library. This is something easy to find with JavaScript and NPM has a library named \\\"Sharp\\\" that do it perfectly. The TypeScript definition file is also available, so we are in business!\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"npm install --save sharp npm install --save-dev @types/sharp\\n\")), mdx(\"p\", null, \"Before anything, even if this project is for myself, I defined some configuration variables. Some rigor is required when it's cheap to do! The three first constant is the maximum size we want to output the image. I choose 640 pixel. The directory name is the constant of the folder where we will save the image we will send and where we will late save the JSON file with the analysed data. We save the resized image because on the website later, we will use this small image instead of the full resolution image. The website will be snappy and since we have the file, why not using this optimization for free. At 30kb for 2000 images, we only use 58 megs. The last constant is the glob pattern to get all underscore JPEG pictures. We will talk about glob very soon.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const maxSize = 640;\\nconst directoryName = \\\"metainfo\\\";\\nconst pathImagesDirectory = path.join(imagesDirectory, \\\"**/_*.+(jpg|JPG)\\\");\\n\")), mdx(\"p\", null, \"The second pre-task is to find the images to resize. Again, this will require a third-party library to simplify our life. We could recursively navigate folders, but it would be nicer to have a singe glob pattern that handle it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"npm install --save glob npm install --save-dev @types/glob\\n\")), mdx(\"p\", null, \"From there, we need to import the module. We will bring the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"path\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fs\"), \" module of NodeJs to be able to create proper path syntax and to save file on disk. ```typescript\\nimport \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \" as g from \\\"glob\\\"; import \"), \" as path from \\\"path\\\"; import \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \" as sharp from \\\"sharp\\\"; import \"), \" as fs from \\\"fs\\\";\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\n\\nThe first function that we need to create is the one that return a list of string that represent the file to resize. This will be all our underscore aka best pictures. We want to be sure that we can re-run this function multiple times, thus we need to ignore the output folder where we will save resized images. This function returns the list in a promise fashion because the glob library is asynchronous. Here is the first version which call the module function \\\"Glob\\\" and add everything into an array while sending in the console the file for debugging purpose.\\n\\n```typescript\\nfunction getImageToAnalyze(): Promise<string[]> { const fullPathFiles: string[] = []; const promise = new Promise<string[]>((resolve, reject) => { const glob = new g.Glob(pathImagesDirectory, { ignore: \\\"**/\\\" + directoryName + \\\"/**\\\" } as g.IOptions, (err: Error, matches: string[]) => { matches.forEach((file: string) => { console.log(file); fullPathFiles.push(file); }); resolve(fullPathFiles); }); }); return promise; }\\n\")), mdx(\"p\", null, \"This can be simplified by just returning the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"matches\"), \" string array and returning the promise instead of using a variable. At the end, if you are not debugging you can use :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function getImageToAnalyze(): Promise<string[]> {\\n  return new Promise<string[]>((resolve, reject) => {\\n    const glob = new g.Glob(\\n      pathImagesDirectory,\\n      { ignore: \\\"**/\\\" + directoryName + \\\"/**\\\" } as g.IOptions,\\n      (err: Error, matches: string[]) => {\\n        resolve(matches);\\n      }\\n    );\\n  });\\n}\\n\")), mdx(\"p\", null, \"As mentioned, the quality of this code is average. In reality, some loves are missing around the error scenario. Right now, if something is wrong, the rejection promise bubble up.\"), mdx(\"p\", null, \"At this point, we can call the method with :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"console.log(\\\"Step 1 : Getting images to analyze \\\" + pathImagesDirectory);\\ngetImageToAnalyze().then((fullPathFiles: string[]) => {\\n  console.log(\\\"Step 2 : Resize \\\" + fullPathFiles.length + \\\" files\\\");\\n  return resize(fullPathFiles);\\n});\\n\")), mdx(\"p\", null, \"The code inside the \\\"then\\\" is the one executed if the promise is resolved successfully. It will start resizing the list of pictures and pass this list into the function that we will create in an instant.\"), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"resize\"), \" function is not the one that will do the resize. It will call the function that does the resize only if the picture has not been yet resized. This is great if something happen to fail and you need to re-run. The resize function will check in the \\\"metainfo\\\" folder, where we output the resized picture and only resize this one if not present. In both case, this function return a promise. The type of the promise is a list of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IImage\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface IImage {\\n  thumbnailPath: string;\\n  originalFullPathImage: string;\\n}\\n\")), mdx(\"p\", null, \"This type allows to have the detail about the full path of the thumbnail \\\"resized\\\" picture and the original picture. When we have already resized, we just create an instance, when we do not have an image we create this one and then return a new instance. This method waits all resize to occur before resolving. This is the reason of the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \".all\"), \". We are doing so just to have a clear cut before moving to the next step and since we are launching multiple resizes in parallel, we are waiting to have them all done before analyzing.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function resize(fullPathFiles: string[]): Promise<IImage[]> {\\n  const listPromises: Array<Promise<IImage>> = [];\\n  const promise = new Promise<IImage[]>((resolve, reject) => {\\n    for (const imagePathFile of fullPathFiles) {\\n      const thumb = getThumbnailPathAndFileName(imagePathFile);\\n      if (fs.existsSync(thumb)) {\\n        listPromises.push(\\n          Promise.resolve({\\n            thumbnailPath: thumb,\\n            originalFullPathImage: imagePathFile,\\n          } as IImage)\\n        );\\n      } else {\\n        listPromises.push(resizeImage(imagePathFile));\\n      }\\n    }\\n    Promise.all(listPromises).then((value: IImage[]) => resolve(value));\\n  });\\n  return promise;\\n}\\n\")), mdx(\"p\", null, \"This function use a function to get the thumbnail path to lookup if it's been already created or not. This function call another one too, and both of these methods are having the same goal of providing a path. The first one, the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"getThumbnailPathAndFileName\"), \" get the original full quality picture path and return the full image path of where the resized thumbnail is stored. The second one is a function that will be resused in some occasion and it gives the metainfo directory. This is where the resized picture are stored, but also the JSON file with the analytic data are saved.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function getThumbnailPathAndFileName(imageFullPath: string): string {\\n  const dir = getMetainfoDirectoryPath(imageFullPath);\\n  const imageFilename = path.parse(imageFullPath);\\n  const thumbnail = path.join(dir, imageFilename.base);\\n  return thumbnail;\\n}\\n\\nfunction getMetainfoDirectoryPath(imageFullPath: string): string {\\n  const onlyPath = path.dirname(imageFullPath);\\n  const imageFilename = path.parse(imageFullPath);\\n  const thumbnail = path.join(onlyPath, \\\"/\\\" + directoryName + \\\"/\\\");\\n  return thumbnail;\\n}\\n\")), mdx(\"p\", null, \"The last method is the actual resize logic. The first line of the method create a \\\"sharp\\\" object for the desired picture. Then we invoke the \\\"metadata\\\" method that will give us access to the image information. We need this to get the actual width and height and do some computation to get the wider side and find the ratio of resizing. Once we know the height and the width of the thumbnail we need to create the destination folder before saving. Finally, we need to call the \\\"resize\\\" method with the height and width calculated. The \\\"webp\\\" method is the one that generate the image. From there, we could generate a buffered image and use a stream to handle it in memory or to store it on disk like we will do with the method \\\"toFile\\\". This return a promise that we use to generate and return the IImage.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function resizeImage(imageToProceed: string): Promise<IImage> {\\n  const sharpFile = sharp(imageToProceed);\\n  return sharpFile.metadata().then(\\n    (metadata: sharp.Metadata) => {\\n      const actualWidth = metadata.width;\\n      const actualHeight = metadata.height;\\n      let ratio = 1;\\n      if (actualWidth > actualHeight) {\\n        ratio = actualWidth / maxSize;\\n      } else {\\n        ratio = actualHeight / maxSize;\\n      }\\n      const newHeight = Math.round(actualHeight / ratio);\\n      const newWidth = Math.round(actualWidth / ratio);\\n      const thumbnailPath = getThumbnailPathAndFileName(imageToProceed); // Create directory thumbnail first const dir = getMetainfoDirectoryPath(imageToProceed); if (!fs.existsSync(dir)) { fs.mkdirSync(dir); }\\n\\n      return sharpFile\\n        .resize(newWidth, newHeight)\\n        .webp()\\n        .toFile(thumbnailPath)\\n        .then((image: sharp.OutputInfo) => {\\n          return {\\n            thumbnailPath: thumbnailPath,\\n            originalFullPathImage: imageToProceed,\\n          } as IImage;\\n        });\\n    },\\n    (reason: any) => {\\n      console.error(reason);\\n    }\\n  );\\n}\\n\")), mdx(\"p\", null, \"This conclude the resize part of the project. It's not as straight forward as it may seem, but noting is space rocket science either. This code can be optimized to start resizing without having analyzed if all the image are present or not. Some refactoring could be done around the ratio logic within the promise callback of sharp's metadata method. We could also optimize the write to remain in memory and hence having not to reload the thumbnail from the disk but working the on the memory buffer. The last optimization wasn't done because I wanted every step to be re-executed what ever the state in which they were stopped. I didn't wanted to bring more logic to reload in memory if already generated. That said, it could be done. The full project is available on GitHub : \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/CognitiveImagesCollection\"\n  }, \"https://github.com/MrDesjardins/CognitiveImagesCollection\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"59f4fc8e-4193-5f18-9a70-ace389886955"}}