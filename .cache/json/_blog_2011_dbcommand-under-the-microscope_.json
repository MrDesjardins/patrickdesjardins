{"data":{"mdx":{"frontmatter":{"title":"DbCommand under the microscope","date":"September 27, 2011"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"DbCommand under the microscope\",\n  \"date\": \"2011-09-27\",\n  \"categories\": [\"ado-net\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"DbCommand uses the DbConnection to be able to send SQL query or call a stored procedure. It can also execute DDL (Data Definition Language) query to create table or to modify table structure.\"), mdx(\"p\", null, \"Here is an example of update a row with the SqlCommand that inherit from DbCommand.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"ConnectionStringSettings connectionStringSettings = ConfigurationManager.ConnectionStrings[\\\"ApplicationServices\\\"]; using (var connection = new SqlConnection(connectionStringSettings.ConnectionString)) { connection.Open(); using (var command = new SqlCommand()) { command.Connection = connection; command.CommandType = System.Data.CommandType.Text; command.CommandText = \\\"UPDATE Region SET RegionDescription = 'Estern Yes!' WHERE RegionID=1\\\"; command.ExecuteNonQuery(); connection.Close(); } } \\n\")), mdx(\"p\", null, \"So, from this example you must have guess that SqlCommand that inherit from DbCommand derive also from IDisposable. This is why the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"using\"), \" statement is still use in this example. The command got the connection that was opened previously and than the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"CommandType\"), \" is set to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Text\"), \" to execute directly SQL query.\"), mdx(\"p\", null, \"From there the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ExecuteNonQuery\"), \" method is executed. This method is perfect to call stored procedure or Sql statement that does not return data. Also, this command can return the number of row affected.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" int amountOfRowAffected = command.ExecuteNonQuery(); \\n\")), mdx(\"p\", null, \"To execute stored procedure, the command type need to be changed and the command text must have the stored procedure name. To make a test lets create to the Northwind database the stored procedure.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"\\n\\nALTER PROCEDURE [dbo].[UpdateRegion] ( @id INT ,@txt VARCHAR(50) ) AS BEGIN UPDATE region SET RegionDescription = @txt WHERE RegionID = @id END \\n\")), mdx(\"p\", null, \"To execute lets use this code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"ConnectionStringSettings connectionStringSettings = ConfigurationManager.ConnectionStrings[\\\"ApplicationServices\\\"]; using (var connection = new SqlConnection(connectionStringSettings.ConnectionString)) { connection.Open(); using (var command = new SqlCommand()) { command.Connection = connection; command.CommandType = System.Data.CommandType.StoredProcedure; command.CommandText = \\\"UpdateRegion\\\"; command.Parameters.Add(new SqlParameter(\\\"id\\\",\\\"1\\\")); command.Parameters.Add(new SqlParameter(\\\"txt\\\", \\\"Est\\\")); command.ExecuteNonQuery(); connection.Close(); } } \\n\")), mdx(\"p\", null, \"Not only the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"CommandType\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"CommandText\"), \" have changed, but a new addition appear with parameter. Since the stored procedure take the id of the region and the text to display as new description, the command must be aware of what to pass to the stored procedure.\"), mdx(\"p\", null, \"The creation of the parameter can also be create with the use of the command. That's it, you can create parameter with the CreateParameter method of the DbCommand class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"ConnectionStringSettings connectionStringSettings = ConfigurationManager.ConnectionStrings[\\\"ApplicationServices\\\"]; using (var connection = new SqlConnection(connectionStringSettings.ConnectionString)) { connection.Open(); using (var command = new SqlCommand()) { command.Connection = connection; command.CommandType = System.Data.CommandType.StoredProcedure; command.CommandText = \\\"UpdateRegion\\\"; SqlParameter param1 = command.CreateParameter(); param1.ParameterName = \\\"id\\\"; param1.Value = \\\"1\\\"; command.Parameters.Add(param1); command.Parameters.Add(new SqlParameter(\\\"txt\\\", \\\"Estern\\\")); command.ExecuteNonQuery(); connection.Close(); } } \\n\")), mdx(\"p\", null, \"The DbParameter, in the few example above was of type SqlParameter. The class SqlParameter derives from DbParameter and contains additional specification for Sql Server. For example, the Db Type are more specific to Sql Server. Also, you can find multiple additional methods to specify the direction of the parameter, the type, the direction, etc.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" SqlParameter param1 = command.CreateParameter(); param1.ParameterName = \\\"id\\\"; param1.Value = \\\"1\\\"; param1.Direction = System.Data.ParameterDirection.Input; param1.SqlDbType = System.Data.SqlDbType.Int; param1.IsNullable = false; \\n\")), mdx(\"p\", null, \"To conclude, the DbCommand is the class to use when you need to execute a query that does not return any data.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"a5cd1dc2-7df0-55c3-87e0-ef82fa2592ad","slug":"2011/dbcommand-under-the-microscope","__params":{"slug":"2011"}}}