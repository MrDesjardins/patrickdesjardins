{"data":{"mdx":{"frontmatter":{"title":"C# Allow External Library To Access Internal Visibility","date":"December 19, 2014"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"C# Allow External Library To Access Internal Visibility\",\n  \"date\": \"2014-12-19\",\n  \"categories\": [\"c-sharp\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I am not a fan of what I will show you here but it can be a life safer someday in your career. What I will show you is how to access an internal type from an external library. You have read it correctly. Even if the goal of internal visibility is to hide the type to be used outside the assembly, it is possible since framework 2.0 to create an exception by naming which assembly/library that can use the internal type.\"), mdx(\"p\", null, \"Why would we want that? Well, a simple case could be that you want to unit test some internal classes and that you are doing all your unit test in a unit test project. This one needs to access the internal type and you must use a special attribute to allow that. Another case would be that you have the getter public but the setter internal. If you want a specify assembly to be able to write and no other one than you can use this attribute. This force you to have only one way to set information into your property.\"), mdx(\"p\", null, \"The attribute is set anywhere in the code of your assembly. It can be at the top of a class or in AssemblyInfo file. Even if it is at the top of a class, remember that it allows to access the complete assembly. This is why it is a better approach to set the attribute in the AssemblyInfo file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" [assembly:InternalsVisibleTo(\\\"MyBusinessAssembly\\\")] [assembly:InternalsVisibleTo(\\\"MyOtherBusinessRelatedAssembly\\\")] [assembly:InternalsVisibleTo(\\\"MyUnitTestProjectName\\\")] \\n\")), mdx(\"p\", null, \"If you are using signed DLL, than you will need to use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"sn.exe\"), \" command line tool. This one can be used directly in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Visual Studio Command Prompt\"), \". It will produce a public token that can be used in the InternalsVisibleTo attribute.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" sn -Tp c:\\\\\\\\yourpath\\\\\\\\toyourdll\\\\\\\\abc.dll \\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" [assembly:InternalsVisibleTo(\\\"MyBusinessAssembly, PublicKey=00000000000111111111111122222222222.....\\\")] [assembly:InternalsVisibleTo(\\\"MyOtherBusinessRelatedAssembly, PublicKey=00000000000111111111111122222222222.....\\\")] [assembly:InternalsVisibleTo(\\\"MyUnitTestProjectName, PublicKey=00000000000111111111111122222222222.....\\\")] \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"e6b1a389-38ae-5530-ab2b-45d3fc4be3bb"}}