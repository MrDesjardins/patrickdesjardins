{"data":{"mdx":{"frontmatter":{"title":"How to load hierarchical structure with recursive with Entity Framework 5","date":"August 22, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to load hierarchical structure with recursive with Entity Framework 5\",\n  \"date\": \"2013-08-22\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Everything has many way to do it, here is two ways to handle data structure that is recursive. The structure in which the solution that I will present you work is a structure that look like a tree. A main parent node with children in which can have entity or/and have itself a parent node to start a sub-tree. Also, children cannot contain parent that are already used somewhere in the tree, which could raise additional problems, like having infinite recursion.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"400px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/36050c9b6050cb4d24f66a7287757800/e17e5/hiearchicalStructure-400x400.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"100%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB6klEQVQ4y52U627bMAyF/f6P1QEd9mPYMKwr2ibLclkTOanji3yJbfEbZM3XpBkyIYZlhjw64iHpMVki7hnuh9//Wt45oI0SB8RgP7DfBDgEtb+qxu07MLnK9h2GUBl4jBS7LCVIoDaMGA5TcRGwd3RsTiV8zO+Z8QG/fEPpqmN4La/eZUGEJAdfC0t9ZJ7u+B3C/CBEuVxn2Ca8fddGKGsoKiEr4TWEJAMjwiaEX4HzaWOmQnnT3OkCVCyEGSSFsDoKBy2EOc07zmEb0YBOhRoxtCutTmzTnNeod9onkFfSfUdFxToueNM0N5nm1GtPMDW8JHu+mDsWcUxZwSaqmQen5tqnWjAG5pHmW/2JWbHgoFvACcO/ZooSZm8VP1RzNH6W8507chKOqfOyeZ0HJQ/7tElJm64RQ2uwp+uT8OyDn7hge62NTnkJclTsbMdMWAU0z/oIxowL3bNOlXEKPvnCXhselaASp+yTgs9ruF+4Q1UibCNp2FkCZwxbdPunZaFCVyq2Bi3ALnaBp6oXwHXN5Y7xus6oYKlDHvRPlknUAQxLYhh4aSqNAAurahqjeGZdqE4EI/Ju8MXW6w2CH8PXFYQpTV6vtdiV8dXXkWWzDg1lLeMxdsPyxlPmfPbJbXi9yv878qeAfwBtXSdcgkKcGAAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"hiearchicalStructure 400x400\",\n    \"title\": \"hiearchicalStructure 400x400\",\n    \"src\": \"/static/36050c9b6050cb4d24f66a7287757800/e17e5/hiearchicalStructure-400x400.png\",\n    \"srcSet\": [\"/static/36050c9b6050cb4d24f66a7287757800/5a46d/hiearchicalStructure-400x400.png 300w\", \"/static/36050c9b6050cb4d24f66a7287757800/e17e5/hiearchicalStructure-400x400.png 400w\"],\n    \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"In the graphic above, you can see that we have two types of container. One is green and the other one is having a white background. In fact, the green container is a node that can have either children of a specify entity which cannot contain any other structural entity or can contain an other green container which are those who contain a list of children.\"), mdx(\"p\", null, \"So, since we do not know how the tree is structured, it's not possible to use eager loading as we do normally by including property desired.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"_context.Parent .Include(d => d.OtherProperty) .Include(d => d.Children) .Include(d => d.Children.Select(dd=>dd.OtherProperty) .Include(d => d.Children.Select(dd=>dd.Children) .Include(d => d.Children.Select(dd=>dd.OtherProperty........) //We cannot proceed this way because we do not know how many level .Include(d => d.Children.Select(dd=>dd.Children.......)//We cannot proceed this way because we do not know how many level .Single(p => p.ID == id); \\n\")), mdx(\"p\", null, \"This give us the option to load the Children, if this one has children then load it the way we just load the parent since every child become a parent. This require recursive method. The problem is that it work but every load will create a new parent. We need to map every values to the first parent to have at the end a single hierarchical tree.\"), mdx(\"p\", null, \"Here is how we can do it with eager loading. We need to every property set back to the object that we have receive to, at the end, have a tree fully loaded.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" private Parent RecursiveLoad(Guid id) { var ParentFromDatabase =_context.Parent .Include(d => d.Children) .Include(d => d.Children.Select(dd => dd.OtherProperty)) .Single(p => p.ID == id); foreach (var child in ParentFromDatabase.Children) { var childNotLoaded = child; var childFullyLoaded =_context.Child .Include(d => d.Parent) .Include(d => d.OtherProperty) .Single(d => d.ID == childNotLoaded.ID);\\n\\nchild.OtherProperty = childFullyLoaded.OtherProperty; //Require to set back the value because we want by reference to have everything in the tree child.Parent = RecursiveLoad(childFullyLoaded.Parent.ID); //Require to set back the value because we want by reference to have everything in the tree } return ParentFromDatabase; } \\n\")), mdx(\"p\", null, \"But, we can do better with explicit loading. One of the positive characteristic of explicit loading is that it load itself. No need to map the loaded object to the existing one, it's already been loaded into it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" private Parent RecursiveLoad(Parent parent) { var ParentFromDatabase =_context.Entry(parent).Collection(d=>d.Children);//Children are loaded, we can loop them now foreach (var child in parent.Children) {_context.Entry(child).Reference(d=>d.OtherProperty).Load(); RecursiveLoad(child); } return ParentFromDatabase; } \\n\")), mdx(\"p\", null, \"This has the advantage to remove every mapping since the object is loaded itself by entity framework. Still, this kind of loading come with a price. If we have 40 leafs in the tree, this mean that every of them will be loaded by the database which result to 40 SQL queries. One approach that can reduce the amount of request is to have the ID (int or Guid) inside the object, from there you can check if this one has a value. This will reduce the amount of call to the database at the amount of parent only (not final leaf which return 0 element). Still, the amount is huge and for large application, a custom solution with a view returning a bunch of data and parsed manually may be a good solution. Nevertheless, if you need to save the tree, you could end up with problem which you do not have when having the whole structure loaded by Entity Framework.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"34561960-ac7d-5095-8eef-3a254b4ddabc"}}