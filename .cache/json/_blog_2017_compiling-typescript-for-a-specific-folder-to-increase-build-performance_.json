{"data":{"mdx":{"frontmatter":{"title":"Compiling TypeScript for a specific folder to increase build performance","date":"April 11, 2017"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Compiling TypeScript for a specific folder to increase build performance\",\n  \"date\": \"2017-04-11\",\n  \"categories\": [\"gulp\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you are using Gulp to build your TypeScript you may use the default configuration that is used in a lot of website which is letter the tsconfig.json to handle what to include and having Gulp to use Gulp-TypeScript to read the tsconfig.json file. However, if you want to build just a portion of the TypeScript, let say a single folder, you will be out of luck.\"), mdx(\"p\", null, \"So the idea is to not use this kind of configuration in tsconfig.json \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"{ \\n  \\\"compilerOptions\\\": \\n  { \\\"sourceMap\\\": true, \\n  \\\"target\\\": \\\"es6\\\", \\n  \\\"module\\\": \\\"amd\\\", \\n  \\\"outDir\\\": \\\"./deploy/output\\\", \\n  \\\"types\\\": [ \\\"jquery\\\", \\\"requirejs\\\", \\\"lodash\\\", \\\"reflect-metadata\\\" ], \\n  \\\"experimentalDecorators\\\": true, \\n  \\\"emitDecoratorMetadata\\\": true \\n  }, \\n  \\\"include\\\": [ \\\"app/scripts/**/*\\\" ], \\\"exclude\\\": [ \\\"node_modules\\\", \\\"**/*.spec.ts\\\" ] \\n} \\n\")), mdx(\"p\", null, \"and not this task in Gulp task code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"gulp.task(\\\"build\\\", () => { \\n  const r = \\\"./app/output\\\"; \\n  var compilationResults = tsProject.src() \\n    .pipe(sourcemaps.init()) \\n    .pipe(tsProject()); \\n  compilationResults.dts.pipe(gulp.dest(r)); \\n  return compilationResults.js \\n    .pipe(sourcemaps.write('.')) \\n    .pipe(gulp.dest(r)); \\n}); \\n\")), mdx(\"p\", null, \"But to use this tsconfig.json:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"{ \\n  \\\"compilerOptions\\\": { \\n    \\\"sourceMap\\\": true, \\n    \\\"target\\\": \\\"es6\\\", \\n    \\\"module\\\": \\\"amd\\\", \\n    \\\"outDir\\\": \\\"./deploy/output\\\", \\n    \\\"types\\\": [ \\\"jquery\\\", \\\"requirejs\\\", \\\"lodash\\\", \\\"reflect-metadata\\\" ], \\n    \\\"experimentalDecorators\\\": true, \\n    \\\"emitDecoratorMetadata\\\": true \\n    }, \\n    \\\"exclude\\\": [ \\\"node_modules\\\", \\\"**/*.spec.ts\\\" ] \\n} \\n\")), mdx(\"p\", null, \" and this Gulp task code: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"gulp.task(\\\"build\\\", () => { \\n const outFolder = \\\"./app/output\\\"; \\n var compilationResults = gulp.src(\\\"app/scripts/**/*.ts\\\") \\n   .pipe(sourcemaps.init()) \\n   .pipe(tsProject());\\n compilationResults.dts.pipe(gulp.dest(outFolder)); \\n return compilationResults.js \\n   .pipe(sourcemaps.write('.')) \\n   .pipe(gulp.dest(outFolder)); \\n}); \\n\")), mdx(\"p\", null, \"The whole idea is that you can move the include files outside TypeScript configuration file, but inject the files from Gulp. So far, everything is build from the root of the app/script folder, but you could define a new task that take a sub folder like the following code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"gulp.task(\\\"buildgeneral\\\", () => { \\n  const outFolder = \\\"deploy/output/general\\\"; \\n  var compilationResults = gulp.src(\\\"app/scripts/general/*.ts\\\")\\n    .pipe(sourcemaps.init())\\n    .pipe(tsProject());\\n  compilationResults.dts.pipe(gulp.dest(outFolder)); \\n  return compilationResults.js\\n    .pipe(sourcemaps.write('.'))\\n    .pipe(gulp.dest(outFolder)); \\n}); \\n\")), mdx(\"p\", null, \"This is very interesting if you have a project with thousand files. Instead of building the whole project every time, you can just build the file or the folder that the file reside.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"3d9db6c1-8e8b-595b-8611-6dbdd0adf1eb","slug":"2017/compiling-typescript-for-a-specific-folder-to-increase-build-performance","__params":{"slug":"2017"}}}