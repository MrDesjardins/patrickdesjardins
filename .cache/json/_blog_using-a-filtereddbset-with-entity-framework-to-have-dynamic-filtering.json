{"data":{"mdx":{"frontmatter":{"title":"Using a FilteredDbSet with Entity Framework to have dynamic Filtering","date":"March 21, 2013"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you are using an application that require to have your user to own data and not let other to see or edit it, you need to specify to each of your entity a user id to whom the entity belong. All my entities that belong to a user inherit from \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IUserOwnable\"), \". This interface force the entity to have a UserId.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public interface IUserOwnable { int UserId { get; set; } } \\n``` From here, when I want to get the list of entity of my user I just need to specify in the where clause the logged user id and Entity Framework get me all entities that belong to this one. The following example show you how to get all workout from the logged user.\\n\\n\\n```csharp\\n public override IQueryable<Workout> GetAll() { return DatabaseContext.Set<Workout>().Where(e=>e.UserId == logguedUserId); } \\n\")), mdx(\"p\", null, \"The problem is that you need to set the UserId every time. This can lead to a problem of security if a developer forget to add the condition. It also a pain to repeat this code everywhere. This is why a better way to do it is to have a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"FilteredDbSet\"), \" which will automatically add this condition. Here is the FilteredDbSet class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class FilteredDbSet<TEntity> : IDbSet<TEntity>, IOrderedQueryable<TEntity>, IListSource where TEntity : class { private readonly DbSet<TEntity>_set; private readonly Action<TEntity>_initializeEntity; private readonly Expression<Func<TEntity, bool>>_filter;\\n\\npublic FilteredDbSet(DbContext context, Expression<Func<TEntity, bool>> filter, Action<TEntity> initializeEntity) : this(context.Set<TEntity>(), filter, initializeEntity) { }\\n\\npublic IQueryable<TEntity> Include(string path) { return_set.Include(path).Where(_filter).AsQueryable(); }\\n\\nprivate FilteredDbSet(DbSet<TEntity> set, Expression<Func<TEntity, bool>> filter, Action<TEntity> initializeEntity) {_set = set;_filter = filter;_initializeEntity = initializeEntity; }\\n\\npublic IQueryable<TEntity> Unfiltered() { return_set; }\\n\\npublic TEntity Add(TEntity entity) { DoInitializeEntity(entity); return_set.Add(entity); } public void AddOrUpdate(TEntity entity) { DoInitializeEntity(entity);_set.AddOrUpdate(entity); } public TEntity Attach(TEntity entity) { DoInitializeEntity(entity); return_set.Attach(entity); }\\n\\npublic TDerivedEntity Create<TDerivedEntity>() where TDerivedEntity : class, TEntity { var entity =_set.Create<TDerivedEntity>(); DoInitializeEntity(entity); return entity; }\\n\\npublic TEntity Create() { var entity =_set.Create(); DoInitializeEntity(entity); return entity; }\\n\\npublic TEntity Find(params object[] keyValues) { var entity =_set.Find(keyValues); if (entity == null) return null;\\n\\nreturn entity; }\\n\\npublic TEntity Remove(TEntity entity) { if (!_set.Local.Contains(entity)) {_set.Attach(entity); } return_set.Remove(entity); }\\n\\npublic ObservableCollection<TEntity> Local { get { return_set.Local; } }\\n\\nIEnumerator<TEntity> IEnumerable<TEntity>.GetEnumerator() { return_set.Where(_filter).GetEnumerator(); }\\n\\nIEnumerator IEnumerable.GetEnumerator() { return_set.Where(_filter).GetEnumerator(); }\\n\\nType IQueryable.ElementType { get { return typeof(TEntity); } }\\n\\nExpression IQueryable.Expression { get { return_set.Where(_filter).Expression; } }\\n\\nIQueryProvider IQueryable.Provider { get { return_set.AsQueryable().Provider; } }\\n\\nbool IListSource.ContainsListCollection { get { return false; } }\\n\\nIList IListSource.GetList() { throw new InvalidOperationException(); }\\n\\nvoid DoInitializeEntity(TEntity entity) { if (_initializeEntity != null)_initializeEntity(entity); }\\n\\npublic DbSqlQuery<TEntity> SqlQuery(string sql, params object[] parameters) { return_set.SqlQuery(sql, parameters); } } \\n\")), mdx(\"p\", null, \"From here, you just need to call the DbSet that is filtered instead of the default one.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public override IQueryable<Workout> GetAll() { return DatabaseContext.SetOwnable<Workout>(); } \\n\")), mdx(\"p\", null, \"Of course, the DatabaseContext is your class that inherit from DbContext. The SetOwnable method will call the FilteredDbSet.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public IDbSet<TEntity> SetOwnable<TEntity>() where TEntity : class, IUserOwnable { return new FilteredDbSet<TEntity>(this, entity => entity.UserId == CurrentUser.UserId, entity => entity.UserId = CurrentUser.UserId); } \\n``` As you can see, we create a **FilteredDbSet** and assign the user Id with the CurrentUser which is the logged user.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"Using a FilteredDbSet with Entity Framework to have dynamic Filtering\\\",\\\"date\\\":\\\"2013-03-21\\\",\\\"categories\\\":[\\\"entity-framework\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"cfbc1792-2cb7-50f5-837e-cc3c1175d6cc"}}