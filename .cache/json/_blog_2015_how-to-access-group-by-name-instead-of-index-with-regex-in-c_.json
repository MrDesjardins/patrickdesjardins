{"data":{"mdx":{"frontmatter":{"title":"How to Access Group by Name Instead of Index with Regex in C#","date":"February 5, 2015"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to Access Group by Name Instead of Index with Regex in C#\",\n  \"date\": \"2015-02-05\",\n  \"categories\": [\"c-sharp\", \"regex\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When you are searching with a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Regex Expression\"), \" you may have multiple groups and you may do not one to rely on the position to have access to the information. The good news is that Regex allows to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"name\"), \" every group directly into the Regex Expression. This is done by adding inside the group parentheses a question mark followed by the less greater sign, the name and closing the name with the greater sign.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" const string PATTERN_WITHOUT_NAME = @\\\"(parser)\\\\\\\\((.*?)\\\\\\\\)\\\"; //This has 3 groups const string PATTERN_WITH_NAME= @\\\"(parser)\\\\\\\\((?<parameterName>.*?)\\\\\\\\)\\\"; //This also has 3 groups \\n\")), mdx(\"p\", null, \"This code is searching for every thing inside the parse method. For example: \\\"This is parser(abc) and it is awesome\\\". This would result to get \\\"abc\\\". This is also working for multiple instances of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"parser\"), \" method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var regex = new Regex(PATTERN_WITH_NAME, RegexOptions.IgnoreCase);\\n\\nvar matches = regex.Matches(stringToSearch); foreach (Match match in matches) { var url = match.Groups[\\\"parameterName\\\"].Value; } \\n\")), mdx(\"p\", null, \"Something that can be also interesting is to replace the named group from your Regex. This can be done with the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"MatchEvaluator\"), \" delegate function that the Regex' Replace method use. This deletage is called every time a match is found. From here, you must return what you want to do.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" transformedString = regex.Replace(originalContent, match => { var group = match.Groups[\\\"parameterName\\\"]; if (group != null) { var parameter = match.Groups[\\\"parameterName\\\"].Value; //Do your transformation logic here return string.Format(\\\"parser({0})\\\", transformedParameter); } return match.ToString(); }); \\n\")), mdx(\"p\", null, \"In this example, every time the Regex pattern match, the delegate is called. We get the parameter and could do something with like and return the whole match string. This is important to understand that you cannot return only a single group. For example, if you desired to just modify the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"parameterName\"), \" and not the whole \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"parser\"), \" method this cannot be done.\"), mdx(\"p\", null, \"This article shows you how to use Regex to match and to replace a part of a string even if the logic of replacement is complex. The MatchEvaluator allows you to have a lot of flexibility about how to figure out how to handle group within the match.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"74b282c4-fd43-53ce-9ee6-1bbd0ba9166a","slug":"2015/how-to-access-group-by-name-instead-of-index-with-regex-in-c","__params":{"slug":"2015"}}}