{"expireTime":9007200886478388000,"key":"gatsby-plugin-mdx-entire-payload-8bc846adb47b2094c8db47703d9a7375--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"I found very strange that it is not a simple task to login with an email in Asp.Net MVC. You cannot simply decide what property is the identifier. Asp.Net MVC decides for you that it is the UserName property.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":209,"offset":209},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":209,"offset":209},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Here is a the IdentityUser class from Microsoft.AspNet.Identity.EntityFramework.","position":{"start":{"line":4,"column":1,"offset":211},"end":{"line":4,"column":81,"offset":291},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":211},"end":{"line":4,"column":81,"offset":291},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" namespace Microsoft.AspNet.Identity.EntityFramework { public class IdentityUser : IUser { public virtual string Id { get; set; } public virtual string UserName { get; set; } public virtual string PasswordHash { get; set; } public virtual string SecurityStamp { get; set; } public virtual ICollection<IdentityUserRole> Roles { get; private set; } public virtual ICollection<IdentityUserClaim> Claims { get; private set; } public virtual ICollection<IdentityUserLogin> Logins { get; private set; } public IdentityUser() { this.Id = Guid.NewGuid().ToString(); this.Claims = (ICollection<IdentityUserClaim>) new List<IdentityUserClaim>(); this.Roles = (ICollection<IdentityUserRole>) new List<IdentityUserRole>(); this.Logins = (ICollection<IdentityUserLogin>) new List<IdentityUserLogin>(); } public IdentityUser(string userName): this() { this.UserName = userName; } } } ","position":{"start":{"line":7,"column":1,"offset":294},"end":{"line":9,"column":4,"offset":1178},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The first step to use email is to add an email property to this class. Microsoft Identity team has not sealed the class, so it is possible to inherit from it and add you own property. This will extend what we can do with Identity.","position":{"start":{"line":11,"column":1,"offset":1180},"end":{"line":11,"column":231,"offset":1410},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":1180},"end":{"line":11,"column":231,"offset":1410},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public class ApplicationUser : IdentityUser { public string Email { get; set; } } ","position":{"start":{"line":14,"column":1,"offset":1413},"end":{"line":16,"column":4,"offset":1510},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"That's it for the model. Entity Framework will use this class instead of the default one if you define you DbContext with a special class.","position":{"start":{"line":18,"column":1,"offset":1512},"end":{"line":18,"column":139,"offset":1650},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":1512},"end":{"line":18,"column":139,"offset":1650},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public class MainDbContext : IdentityDbContext<ApplicationUser>{//...} \n``` That is what is required. This create in the background a DbSet of your class that inherit from IdentityUser. I have called mine ApplicationUser, but you can use whatever you prefer. **IdentityDbContext** override the OnModelCreating. This is important that if you inherit from it that you call the base class to still have all the configuration provided by the **IdentityDbContext**. To be more detailed, the OnModelCreating associate the custom class to AspNetUsers table. It does plenty of others thing, but from what it concerns us right now, this is it. From here, if you instruct Entity Framework to build your database, you should see in the database your field in Identity table. ![](images/AspNetUserEmailProperty.png)\n\nThe next step is to change the View Model and the View. The View Model for the registration use an UserName property. We can remove this and add one for Email.\n\n\n```csharp\n public class RegisterViewModel { [Required] [StringLength(100, ErrorMessage = \"The {0} must be at least {2} characters long.\", MinimumLength = 6)] [DataType(DataType.Password)] [Display(Name = \"Password\")] public string Password { get; set; }\n\n[DataType(DataType.Password)] [Display(Name = \"Confirm password\")] [Compare(\"Password\", ErrorMessage = \"The password and confirmation password do not match.\")] public string ConfirmPassword { get; set; }\n\n[Required] [Display(Name=\"Email\")] [DataType(DataType.EmailAddress)] public string Email { get; set; } } ","position":{"start":{"line":21,"column":1,"offset":1653},"end":{"line":34,"column":4,"offset":3200},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This is the place where you can add additional data annotation to have more validation. Then, we need to change the view that use the Register View Model. We need to remove the username form group to add a new one for email.","position":{"start":{"line":36,"column":1,"offset":3202},"end":{"line":36,"column":225,"offset":3426},"indent":[]}}],"position":{"start":{"line":36,"column":1,"offset":3202},"end":{"line":36,"column":225,"offset":3426},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" <div class=\"form-group\"> @Html.LabelFor(m => m.Email, new { @class = \"col-md-2 control-label\" }) <div class=\"col-md-10\"> @Html.TextBoxFor(m => m.Email, new { @class = \"form-control\" }) </div> </div> ","position":{"start":{"line":39,"column":1,"offset":3429},"end":{"line":41,"column":4,"offset":3643},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The last step is to change the controller to do something with the email and username. Since Identity still use username and password combination than we have to trick the system.","position":{"start":{"line":43,"column":1,"offset":3645},"end":{"line":43,"column":180,"offset":3824},"indent":[]}}],"position":{"start":{"line":43,"column":1,"offset":3645},"end":{"line":43,"column":180,"offset":3824},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"First of all, we need to generate a user name from the email. It is not possible to use directly the email because it has some invalid characters like @. You can have a small method that transform the user name. ","position":{"start":{"line":45,"column":1,"offset":3826},"end":{"line":45,"column":213,"offset":4038},"indent":[]}}],"position":{"start":{"line":45,"column":1,"offset":3826},"end":{"line":45,"column":213,"offset":4038},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public string GenerateUserName(string email) { return email.Replace(\"@\", \"\").Replace(\".\", \"\").Replace(\"-\", \"\"); } \n``` From here, you can create a new ApplicationUser and assign your generated user name into the property. The next code remains the same by calling the UserManager.\n\nSecond, we need to modify the login because user will enter an email and you need to transform it to user name. The login ViewModel needs to be changed.\n\n\n```csharp\n public class LoginViewModel {\n\n[Required] [DataType(DataType.EmailAddress)] [Display(Name=\"Email\")] public string Email { get; set; } [Required] [DataType(DataType.Password)] [Display(Name = \"Password\")] public string Password { get; set; }\n\n[Display(Name = \"Remember me?\")] public bool RememberMe { get; set; } } ","position":{"start":{"line":46,"column":1,"offset":4039},"end":{"line":59,"column":4,"offset":4816},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The view also change by not having input for an username but for an email. This is the same way we have done for the registration page. I will not put the code here to keep it simple.","position":{"start":{"line":61,"column":1,"offset":4818},"end":{"line":61,"column":184,"offset":5001},"indent":[]}}],"position":{"start":{"line":61,"column":1,"offset":4818},"end":{"line":61,"column":184,"offset":5001},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Finally, the controller must be changed too. Not a lot of thing need to be changed but since we ask for an email and that the system use a username than we must convert it. ","position":{"start":{"line":63,"column":1,"offset":5003},"end":{"line":63,"column":174,"offset":5176},"indent":[]}}],"position":{"start":{"line":63,"column":1,"offset":5003},"end":{"line":63,"column":174,"offset":5176},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" var user = await userService.FindAsync(GenerateUserName(model.Email), model.Password); ","position":{"start":{"line":64,"column":1,"offset":5177},"end":{"line":66,"column":4,"offset":5279},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"In conclusion, it requires some manipulation but it is not difficult. It would be cleaner not to manipulate the UserName property but it is still not a nightmare to proceed.","position":{"start":{"line":68,"column":1,"offset":5281},"end":{"line":68,"column":174,"offset":5454},"indent":[]}}],"position":{"start":{"line":68,"column":1,"offset":5281},"end":{"line":68,"column":174,"offset":5454},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Concerning the user name","position":{"start":{"line":70,"column":5,"offset":5460},"end":{"line":70,"column":29,"offset":5484},"indent":[]}}],"position":{"start":{"line":70,"column":1,"offset":5456},"end":{"line":70,"column":29,"offset":5484},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The algorithm that generate the user name is not strong. Collision can occur if you have the concatenation this way. This is not a huge deal since it will fail to save in the database but still a better way is to have something unique. To save character like @ as user name, the framework allows you to configure the UserManager to have not only alphanumeric characters.","position":{"start":{"line":72,"column":1,"offset":5486},"end":{"line":72,"column":371,"offset":5856},"indent":[]}}],"position":{"start":{"line":72,"column":1,"offset":5486},"end":{"line":72,"column":371,"offset":5856},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public UserManager(IMainDbContext dbContext) { var dbMainContext = dbContext.GetDbContext(); this.userManager = new UserManager<ApplicationUser>(new UserStore<ApplicationUser>(dbMainContext));\n\n//Allow to have email in the username this.userManager.UserValidator = new UserValidator<ApplicationUser>(this.userManager) { AllowOnlyAlphanumericUserNames = false }; } \n``` As you can see, you can set a new **UserValidator** and set the **AllowOnlyAlphanumericUserNames** to false. This is way better!\n\n\nexport const _frontmatter = {\"title\":\"Asp.Net MVC Login with email instead of UserName with Identity\",\"date\":\"2014-03-04\",\"categories\":[\"asp-mvc\",\"identity\"]}","position":{"start":{"line":75,"column":1,"offset":5859},"end":{"line":82,"column":159,"offset":6528},"indent":[1,1,1,1,1,1,1]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":82,"column":159,"offset":6528}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I found very strange that it is not a simple task to login with an email in Asp.Net MVC. You cannot simply decide what property is the identifier. Asp.Net MVC decides for you that it is the UserName property.\"), mdx(\"p\", null, \"Here is a the IdentityUser class from Microsoft.AspNet.Identity.EntityFramework.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" namespace Microsoft.AspNet.Identity.EntityFramework { public class IdentityUser : IUser { public virtual string Id { get; set; } public virtual string UserName { get; set; } public virtual string PasswordHash { get; set; } public virtual string SecurityStamp { get; set; } public virtual ICollection<IdentityUserRole> Roles { get; private set; } public virtual ICollection<IdentityUserClaim> Claims { get; private set; } public virtual ICollection<IdentityUserLogin> Logins { get; private set; } public IdentityUser() { this.Id = Guid.NewGuid().ToString(); this.Claims = (ICollection<IdentityUserClaim>) new List<IdentityUserClaim>(); this.Roles = (ICollection<IdentityUserRole>) new List<IdentityUserRole>(); this.Logins = (ICollection<IdentityUserLogin>) new List<IdentityUserLogin>(); } public IdentityUser(string userName): this() { this.UserName = userName; } } } \\n\")), mdx(\"p\", null, \"The first step to use email is to add an email property to this class. Microsoft Identity team has not sealed the class, so it is possible to inherit from it and add you own property. This will extend what we can do with Identity.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class ApplicationUser : IdentityUser { public string Email { get; set; } } \\n\")), mdx(\"p\", null, \"That's it for the model. Entity Framework will use this class instead of the default one if you define you DbContext with a special class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class MainDbContext : IdentityDbContext<ApplicationUser>{//...} \\n``` That is what is required. This create in the background a DbSet of your class that inherit from IdentityUser. I have called mine ApplicationUser, but you can use whatever you prefer. **IdentityDbContext** override the OnModelCreating. This is important that if you inherit from it that you call the base class to still have all the configuration provided by the **IdentityDbContext**. To be more detailed, the OnModelCreating associate the custom class to AspNetUsers table. It does plenty of others thing, but from what it concerns us right now, this is it. From here, if you instruct Entity Framework to build your database, you should see in the database your field in Identity table. ![](images/AspNetUserEmailProperty.png)\\n\\nThe next step is to change the View Model and the View. The View Model for the registration use an UserName property. We can remove this and add one for Email.\\n\\n\\n```csharp\\n public class RegisterViewModel { [Required] [StringLength(100, ErrorMessage = \\\"The {0} must be at least {2} characters long.\\\", MinimumLength = 6)] [DataType(DataType.Password)] [Display(Name = \\\"Password\\\")] public string Password { get; set; }\\n\\n[DataType(DataType.Password)] [Display(Name = \\\"Confirm password\\\")] [Compare(\\\"Password\\\", ErrorMessage = \\\"The password and confirmation password do not match.\\\")] public string ConfirmPassword { get; set; }\\n\\n[Required] [Display(Name=\\\"Email\\\")] [DataType(DataType.EmailAddress)] public string Email { get; set; } } \\n\")), mdx(\"p\", null, \"This is the place where you can add additional data annotation to have more validation. Then, we need to change the view that use the Register View Model. We need to remove the username form group to add a new one for email.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" <div class=\\\"form-group\\\"> @Html.LabelFor(m => m.Email, new { @class = \\\"col-md-2 control-label\\\" }) <div class=\\\"col-md-10\\\"> @Html.TextBoxFor(m => m.Email, new { @class = \\\"form-control\\\" }) </div> </div> \\n\")), mdx(\"p\", null, \"The last step is to change the controller to do something with the email and username. Since Identity still use username and password combination than we have to trick the system.\"), mdx(\"p\", null, \"First of all, we need to generate a user name from the email. It is not possible to use directly the email because it has some invalid characters like @. You can have a small method that transform the user name. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public string GenerateUserName(string email) { return email.Replace(\\\"@\\\", \\\"\\\").Replace(\\\".\\\", \\\"\\\").Replace(\\\"-\\\", \\\"\\\"); } \\n``` From here, you can create a new ApplicationUser and assign your generated user name into the property. The next code remains the same by calling the UserManager.\\n\\nSecond, we need to modify the login because user will enter an email and you need to transform it to user name. The login ViewModel needs to be changed.\\n\\n\\n```csharp\\n public class LoginViewModel {\\n\\n[Required] [DataType(DataType.EmailAddress)] [Display(Name=\\\"Email\\\")] public string Email { get; set; } [Required] [DataType(DataType.Password)] [Display(Name = \\\"Password\\\")] public string Password { get; set; }\\n\\n[Display(Name = \\\"Remember me?\\\")] public bool RememberMe { get; set; } } \\n\")), mdx(\"p\", null, \"The view also change by not having input for an username but for an email. This is the same way we have done for the registration page. I will not put the code here to keep it simple.\"), mdx(\"p\", null, \"Finally, the controller must be changed too. Not a lot of thing need to be changed but since we ask for an email and that the system use a username than we must convert it. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var user = await userService.FindAsync(GenerateUserName(model.Email), model.Password); \\n\")), mdx(\"p\", null, \"In conclusion, it requires some manipulation but it is not difficult. It would be cleaner not to manipulate the UserName property but it is still not a nightmare to proceed.\"), mdx(\"h3\", null, \"Concerning the user name\"), mdx(\"p\", null, \"The algorithm that generate the user name is not strong. Collision can occur if you have the concatenation this way. This is not a huge deal since it will fail to save in the database but still a better way is to have something unique. To save character like @ as user name, the framework allows you to configure the UserManager to have not only alphanumeric characters.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public UserManager(IMainDbContext dbContext) { var dbMainContext = dbContext.GetDbContext(); this.userManager = new UserManager<ApplicationUser>(new UserStore<ApplicationUser>(dbMainContext));\\n\\n//Allow to have email in the username this.userManager.UserValidator = new UserValidator<ApplicationUser>(this.userManager) { AllowOnlyAlphanumericUserNames = false }; } \\n``` As you can see, you can set a new **UserValidator** and set the **AllowOnlyAlphanumericUserNames** to false. This is way better!\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"Asp.Net MVC Login with email instead of UserName with Identity\\\",\\\"date\\\":\\\"2014-03-04\\\",\\\"categories\\\":[\\\"asp-mvc\\\",\\\"identity\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`I found very strange that it is not a simple task to login with an email in Asp.Net MVC. You cannot simply decide what property is the identifier. Asp.Net MVC decides for you that it is the UserName property.`}</p>\n    <p>{`Here is a the IdentityUser class from Microsoft.AspNet.Identity.EntityFramework.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` namespace Microsoft.AspNet.Identity.EntityFramework { public class IdentityUser : IUser { public virtual string Id { get; set; } public virtual string UserName { get; set; } public virtual string PasswordHash { get; set; } public virtual string SecurityStamp { get; set; } public virtual ICollection<IdentityUserRole> Roles { get; private set; } public virtual ICollection<IdentityUserClaim> Claims { get; private set; } public virtual ICollection<IdentityUserLogin> Logins { get; private set; } public IdentityUser() { this.Id = Guid.NewGuid().ToString(); this.Claims = (ICollection<IdentityUserClaim>) new List<IdentityUserClaim>(); this.Roles = (ICollection<IdentityUserRole>) new List<IdentityUserRole>(); this.Logins = (ICollection<IdentityUserLogin>) new List<IdentityUserLogin>(); } public IdentityUser(string userName): this() { this.UserName = userName; } } } \n`}</code></pre>\n    <p>{`The first step to use email is to add an email property to this class. Microsoft Identity team has not sealed the class, so it is possible to inherit from it and add you own property. This will extend what we can do with Identity.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public class ApplicationUser : IdentityUser { public string Email { get; set; } } \n`}</code></pre>\n    <p>{`That's it for the model. Entity Framework will use this class instead of the default one if you define you DbContext with a special class.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public class MainDbContext : IdentityDbContext<ApplicationUser>{//...} \n\\`\\`\\` That is what is required. This create in the background a DbSet of your class that inherit from IdentityUser. I have called mine ApplicationUser, but you can use whatever you prefer. **IdentityDbContext** override the OnModelCreating. This is important that if you inherit from it that you call the base class to still have all the configuration provided by the **IdentityDbContext**. To be more detailed, the OnModelCreating associate the custom class to AspNetUsers table. It does plenty of others thing, but from what it concerns us right now, this is it. From here, if you instruct Entity Framework to build your database, you should see in the database your field in Identity table. ![](images/AspNetUserEmailProperty.png)\n\nThe next step is to change the View Model and the View. The View Model for the registration use an UserName property. We can remove this and add one for Email.\n\n\n\\`\\`\\`csharp\n public class RegisterViewModel { [Required] [StringLength(100, ErrorMessage = \"The {0} must be at least {2} characters long.\", MinimumLength = 6)] [DataType(DataType.Password)] [Display(Name = \"Password\")] public string Password { get; set; }\n\n[DataType(DataType.Password)] [Display(Name = \"Confirm password\")] [Compare(\"Password\", ErrorMessage = \"The password and confirmation password do not match.\")] public string ConfirmPassword { get; set; }\n\n[Required] [Display(Name=\"Email\")] [DataType(DataType.EmailAddress)] public string Email { get; set; } } \n`}</code></pre>\n    <p>{`This is the place where you can add additional data annotation to have more validation. Then, we need to change the view that use the Register View Model. We need to remove the username form group to add a new one for email.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` <div class=\"form-group\"> @Html.LabelFor(m => m.Email, new { @class = \"col-md-2 control-label\" }) <div class=\"col-md-10\"> @Html.TextBoxFor(m => m.Email, new { @class = \"form-control\" }) </div> </div> \n`}</code></pre>\n    <p>{`The last step is to change the controller to do something with the email and username. Since Identity still use username and password combination than we have to trick the system.`}</p>\n    <p>{`First of all, we need to generate a user name from the email. It is not possible to use directly the email because it has some invalid characters like @. You can have a small method that transform the user name. `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public string GenerateUserName(string email) { return email.Replace(\"@\", \"\").Replace(\".\", \"\").Replace(\"-\", \"\"); } \n\\`\\`\\` From here, you can create a new ApplicationUser and assign your generated user name into the property. The next code remains the same by calling the UserManager.\n\nSecond, we need to modify the login because user will enter an email and you need to transform it to user name. The login ViewModel needs to be changed.\n\n\n\\`\\`\\`csharp\n public class LoginViewModel {\n\n[Required] [DataType(DataType.EmailAddress)] [Display(Name=\"Email\")] public string Email { get; set; } [Required] [DataType(DataType.Password)] [Display(Name = \"Password\")] public string Password { get; set; }\n\n[Display(Name = \"Remember me?\")] public bool RememberMe { get; set; } } \n`}</code></pre>\n    <p>{`The view also change by not having input for an username but for an email. This is the same way we have done for the registration page. I will not put the code here to keep it simple.`}</p>\n    <p>{`Finally, the controller must be changed too. Not a lot of thing need to be changed but since we ask for an email and that the system use a username than we must convert it. `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` var user = await userService.FindAsync(GenerateUserName(model.Email), model.Password); \n`}</code></pre>\n    <p>{`In conclusion, it requires some manipulation but it is not difficult. It would be cleaner not to manipulate the UserName property but it is still not a nightmare to proceed.`}</p>\n    <h3>{`Concerning the user name`}</h3>\n    <p>{`The algorithm that generate the user name is not strong. Collision can occur if you have the concatenation this way. This is not a huge deal since it will fail to save in the database but still a better way is to have something unique. To save character like @ as user name, the framework allows you to configure the UserManager to have not only alphanumeric characters.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public UserManager(IMainDbContext dbContext) { var dbMainContext = dbContext.GetDbContext(); this.userManager = new UserManager<ApplicationUser>(new UserStore<ApplicationUser>(dbMainContext));\n\n//Allow to have email in the username this.userManager.UserValidator = new UserValidator<ApplicationUser>(this.userManager) { AllowOnlyAlphanumericUserNames = false }; } \n\\`\\`\\` As you can see, you can set a new **UserValidator** and set the **AllowOnlyAlphanumericUserNames** to false. This is way better!\n\n\nexport const _frontmatter = {\"title\":\"Asp.Net MVC Login with email instead of UserName with Identity\",\"date\":\"2014-03-04\",\"categories\":[\"asp-mvc\",\"identity\"]}\n`}</code></pre>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}