{"expireTime":9007200886478387000,"key":"gatsby-plugin-mdx-entire-payload-6cfe789ba421273acb82bd582bed3043--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Unit tests are something that are easier than ever with the Owin standard because everything is modular which make mocking easily. However, some basic output may be not as intuitive as we are used to be. For example, during unit testing routing I stumble into an error which say that the Http Status was to 500 instead of 200. No exception was provided. How do you get the exception that thrown the Http Status Code 500? The solution is to get the output of the Html and see the error.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":486,"offset":486},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":486,"offset":486},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"First, if you are unit testing routing, you should use the ","position":{"start":{"line":4,"column":1,"offset":488},"end":{"line":4,"column":60,"offset":547},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Nancy.Testing","position":{"start":{"line":4,"column":62,"offset":549},"end":{"line":4,"column":75,"offset":562},"indent":[]}}],"position":{"start":{"line":4,"column":60,"offset":547},"end":{"line":4,"column":77,"offset":564},"indent":[]}},{"type":"text","value":" Nuget's package. This one give you a ","position":{"start":{"line":4,"column":77,"offset":564},"end":{"line":4,"column":115,"offset":602},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Browser","position":{"start":{"line":4,"column":117,"offset":604},"end":{"line":4,"column":124,"offset":611},"indent":[]}}],"position":{"start":{"line":4,"column":115,"offset":602},"end":{"line":4,"column":126,"offset":613},"indent":[]}},{"type":"text","value":" object that allows to simulate an Http query. You can execute the path that you want to test by using the ","position":{"start":{"line":4,"column":126,"offset":613},"end":{"line":4,"column":233,"offset":720},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Get","position":{"start":{"line":4,"column":235,"offset":722},"end":{"line":4,"column":238,"offset":725},"indent":[]}}],"position":{"start":{"line":4,"column":233,"offset":720},"end":{"line":4,"column":240,"offset":727},"indent":[]}},{"type":"text","value":" method. This return a ","position":{"start":{"line":4,"column":240,"offset":727},"end":{"line":4,"column":263,"offset":750},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"BrowserResponse","position":{"start":{"line":4,"column":265,"offset":752},"end":{"line":4,"column":280,"offset":767},"indent":[]}}],"position":{"start":{"line":4,"column":263,"offset":750},"end":{"line":4,"column":282,"offset":769},"indent":[]}},{"type":"text","value":". Getting the status code is available by verifying the StatusCode.","position":{"start":{"line":4,"column":282,"offset":769},"end":{"line":4,"column":349,"offset":836},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":488},"end":{"line":4,"column":349,"offset":836},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" // Arrange var browser = new Browser(bootstrapper); // Act var result = browser.Get(\"/\", with => with.HttpRequest());\n\n// Assert Assert.AreEqual(HttpStatusCode.OK, result.StatusCode); ","position":{"start":{"line":7,"column":1,"offset":839},"end":{"line":11,"column":4,"offset":1038},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The problem is when the assert fail. You do not have any indication of why the Nancy Routing failed. If you are debugging and that you check the BrowserResponse object, you will see a Body property but it is of type Byte[]. This type is not humanely understandable. The trick is to use the extension method ","position":{"start":{"line":13,"column":1,"offset":1040},"end":{"line":13,"column":308,"offset":1347},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"AsString()","position":{"start":{"line":13,"column":310,"offset":1349},"end":{"line":13,"column":320,"offset":1359},"indent":[]}}],"position":{"start":{"line":13,"column":308,"offset":1347},"end":{"line":13,"column":322,"offset":1361},"indent":[]}},{"type":"text","value":" to get the Html output and read the error message.","position":{"start":{"line":13,"column":322,"offset":1361},"end":{"line":13,"column":373,"offset":1412},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":1040},"end":{"line":13,"column":373,"offset":1412},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" var html = result.Body.AsString(); ","position":{"start":{"line":16,"column":1,"offset":1415},"end":{"line":18,"column":4,"offset":1465},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"That say, most of the time is that the app.config does not have the reference to Razor page. You just need to include the Nancy.ViewEngines.Razor and be sure that the app.config has the Razor configuration and you will be able to have a HttpStatus of 200. ","position":{"start":{"line":20,"column":1,"offset":1467},"end":{"line":20,"column":257,"offset":1723},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":1467},"end":{"line":20,"column":257,"offset":1723},"indent":[]}},{"type":"code","lang":"xml","meta":null,"value":"\n\n<system.web.webPages.razor> <pages pageBaseType=\"Nancy.ViewEngines.Razor.NancyRazorViewBase\"> <namespaces> <add namespace=\"Nancy.ViewEngines.Razor\" /> </namespaces> </pages> </system.web.webPages.razor> ","position":{"start":{"line":21,"column":1,"offset":1724},"end":{"line":25,"column":4,"offset":1940},"indent":[1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Nancy Unit Debugging Routing Error Details\",\"date\":\"2015-02-18\",\"categories\":[\"owin\"]}","position":{"start":{"line":29,"column":1,"offset":1944},"end":{"line":29,"column":125,"offset":2068},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":29,"column":125,"offset":2068}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Nancy Unit Debugging Routing Error Details\",\n  \"date\": \"2015-02-18\",\n  \"categories\": [\"owin\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Unit tests are something that are easier than ever with the Owin standard because everything is modular which make mocking easily. However, some basic output may be not as intuitive as we are used to be. For example, during unit testing routing I stumble into an error which say that the Http Status was to 500 instead of 200. No exception was provided. How do you get the exception that thrown the Http Status Code 500? The solution is to get the output of the Html and see the error.\"), mdx(\"p\", null, \"First, if you are unit testing routing, you should use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Nancy.Testing\"), \" Nuget's package. This one give you a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Browser\"), \" object that allows to simulate an Http query. You can execute the path that you want to test by using the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Get\"), \" method. This return a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"BrowserResponse\"), \". Getting the status code is available by verifying the StatusCode.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" // Arrange var browser = new Browser(bootstrapper); // Act var result = browser.Get(\\\"/\\\", with => with.HttpRequest());\\n\\n// Assert Assert.AreEqual(HttpStatusCode.OK, result.StatusCode); \\n\")), mdx(\"p\", null, \"The problem is when the assert fail. You do not have any indication of why the Nancy Routing failed. If you are debugging and that you check the BrowserResponse object, you will see a Body property but it is of type Byte[]. This type is not humanely understandable. The trick is to use the extension method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AsString()\"), \" to get the Html output and read the error message.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var html = result.Body.AsString(); \\n\")), mdx(\"p\", null, \"That say, most of the time is that the app.config does not have the reference to Razor page. You just need to include the Nancy.ViewEngines.Razor and be sure that the app.config has the Razor configuration and you will be able to have a HttpStatus of 200. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"\\n\\n<system.web.webPages.razor> <pages pageBaseType=\\\"Nancy.ViewEngines.Razor.NancyRazorViewBase\\\"> <namespaces> <add namespace=\\\"Nancy.ViewEngines.Razor\\\" /> </namespaces> </pages> </system.web.webPages.razor> \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Nancy Unit Debugging Routing Error Details\",\n  \"date\": \"2015-02-18\",\n  \"categories\": [\"owin\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Unit tests are something that are easier than ever with the Owin standard because everything is modular which make mocking easily. However, some basic output may be not as intuitive as we are used to be. For example, during unit testing routing I stumble into an error which say that the Http Status was to 500 instead of 200. No exception was provided. How do you get the exception that thrown the Http Status Code 500? The solution is to get the output of the Html and see the error.`}</p>\n    <p>{`First, if you are unit testing routing, you should use the `}<strong parentName=\"p\">{`Nancy.Testing`}</strong>{` Nuget's package. This one give you a `}<strong parentName=\"p\">{`Browser`}</strong>{` object that allows to simulate an Http query. You can execute the path that you want to test by using the `}<strong parentName=\"p\">{`Get`}</strong>{` method. This return a `}<strong parentName=\"p\">{`BrowserResponse`}</strong>{`. Getting the status code is available by verifying the StatusCode.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` // Arrange var browser = new Browser(bootstrapper); // Act var result = browser.Get(\"/\", with => with.HttpRequest());\n\n// Assert Assert.AreEqual(HttpStatusCode.OK, result.StatusCode); \n`}</code></pre>\n    <p>{`The problem is when the assert fail. You do not have any indication of why the Nancy Routing failed. If you are debugging and that you check the BrowserResponse object, you will see a Body property but it is of type Byte[]. This type is not humanely understandable. The trick is to use the extension method `}<strong parentName=\"p\">{`AsString()`}</strong>{` to get the Html output and read the error message.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` var html = result.Body.AsString(); \n`}</code></pre>\n    <p>{`That say, most of the time is that the app.config does not have the reference to Razor page. You just need to include the Nancy.ViewEngines.Razor and be sure that the app.config has the Razor configuration and you will be able to have a HttpStatus of 200. `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-xml\"\n      }}>{`\n\n<system.web.webPages.razor> <pages pageBaseType=\"Nancy.ViewEngines.Razor.NancyRazorViewBase\"> <namespaces> <add namespace=\"Nancy.ViewEngines.Razor\" /> </namespaces> </pages> </system.web.webPages.razor> \n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}