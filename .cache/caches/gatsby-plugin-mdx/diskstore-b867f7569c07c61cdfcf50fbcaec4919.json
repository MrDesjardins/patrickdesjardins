{"expireTime":9007200886478392000,"key":"gatsby-plugin-mdx-entire-payload-e37cf58836a35c639b7f068a7e3b4cab--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Entity Framework has a standard with the naming of column. This is also the case with complex type which will be added to every tables where complex type are used by entities. By default, Entity Framework will concatenate the name of the complex type with an underscore and the name of the property.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":300,"offset":300},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":300,"offset":300},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If you prefer not having complex type name, you can simply specify the column name you desire.","position":{"start":{"line":4,"column":1,"offset":302},"end":{"line":4,"column":95,"offset":396},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":302},"end":{"line":4,"column":95,"offset":396},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" modelBuilder .ComplexType<Audit>() .Property(type => type.CreatedBy) .HasColumnName(\"CreatedBy\"); ","position":{"start":{"line":7,"column":1,"offset":399},"end":{"line":9,"column":4,"offset":512},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"In the database instead of having a field with \"Audit_CreatedBy\" you will have only \"CreatedBy\". This may be useful in some situation, but by experience it's easier to do the mapping between complex type when you ","position":{"start":{"line":11,"column":1,"offset":514},"end":{"line":11,"column":214,"offset":727},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"keep","position":{"start":{"line":11,"column":216,"offset":729},"end":{"line":11,"column":220,"offset":733},"indent":[]}}],"position":{"start":{"line":11,"column":214,"offset":727},"end":{"line":11,"column":222,"offset":735},"indent":[]}},{"type":"text","value":" the prefix. It's up to you, and your coding/database standard, to figure out if it's appropriate or not.","position":{"start":{"line":11,"column":222,"offset":735},"end":{"line":11,"column":327,"offset":840},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":514},"end":{"line":11,"column":327,"offset":840},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"How to rename complex type to not having the prefix of the class name\",\"date\":\"2013-06-13\",\"categories\":[\"entity-framework\"]}","position":{"start":{"line":14,"column":1,"offset":843},"end":{"line":14,"column":164,"offset":1006},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":14,"column":164,"offset":1006}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to rename complex type to not having the prefix of the class name\",\n  \"date\": \"2013-06-13\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Entity Framework has a standard with the naming of column. This is also the case with complex type which will be added to every tables where complex type are used by entities. By default, Entity Framework will concatenate the name of the complex type with an underscore and the name of the property.\"), mdx(\"p\", null, \"If you prefer not having complex type name, you can simply specify the column name you desire.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" modelBuilder .ComplexType<Audit>() .Property(type => type.CreatedBy) .HasColumnName(\\\"CreatedBy\\\"); \\n\")), mdx(\"p\", null, \"In the database instead of having a field with \\\"Audit_CreatedBy\\\" you will have only \\\"CreatedBy\\\". This may be useful in some situation, but by experience it's easier to do the mapping between complex type when you \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"keep\"), \" the prefix. It's up to you, and your coding/database standard, to figure out if it's appropriate or not.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"How to rename complex type to not having the prefix of the class name\",\n  \"date\": \"2013-06-13\",\n  \"categories\": [\"entity-framework\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Entity Framework has a standard with the naming of column. This is also the case with complex type which will be added to every tables where complex type are used by entities. By default, Entity Framework will concatenate the name of the complex type with an underscore and the name of the property.`}</p>\n    <p>{`If you prefer not having complex type name, you can simply specify the column name you desire.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` modelBuilder .ComplexType<Audit>() .Property(type => type.CreatedBy) .HasColumnName(\"CreatedBy\"); \n`}</code></pre>\n    <p>{`In the database instead of having a field with \"Audit_CreatedBy\" you will have only \"CreatedBy\". This may be useful in some situation, but by experience it's easier to do the mapping between complex type when you `}<strong parentName=\"p\">{`keep`}</strong>{` the prefix. It's up to you, and your coding/database standard, to figure out if it's appropriate or not.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}