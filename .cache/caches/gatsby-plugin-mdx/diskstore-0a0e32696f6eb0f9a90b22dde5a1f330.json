{"expireTime":9007200886478389000,"key":"gatsby-plugin-mdx-entire-payload-446f85ecb904e90d7aafb5bb226879ec--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Html helper allows to have reusable code around your application about html creation. For example, the Html helper for a textbox create a Html Input of type text. It allows to set the name and the value from the model. Html helpers are a must to use with Asp.Net MVC.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":268,"offset":268},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":268,"offset":268},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"At some point, custom helpers are required to be developed in house for specific needs. A simple approach is to simply create an extension method to the html helper. Here is a small example of creating an Html helper. The Html helper is an extension to the HtmlHelper class.","position":{"start":{"line":4,"column":1,"offset":270},"end":{"line":4,"column":275,"offset":544},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":270},"end":{"line":4,"column":275,"offset":544},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public static class MyHtmlHelpers { public static MvcHtmlString OutputName(this HtmlHelper helper, string name) { return new MvcHtmlString(string.Format(\"<h1>{0}</h1>\",name)); } } ","position":{"start":{"line":7,"column":1,"offset":547},"end":{"line":9,"column":4,"offset":742},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This can be used into views this way:","position":{"start":{"line":11,"column":1,"offset":744},"end":{"line":11,"column":38,"offset":781},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":744},"end":{"line":11,"column":38,"offset":781},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" @Html.OutputName(\"Patrick\") ","position":{"start":{"line":14,"column":1,"offset":784},"end":{"line":16,"column":4,"offset":827},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The problem with this approach is that is become harder and harder with the time to know which Html Helper are from Asp.Net MVC and which ones is a custom ones. It become also cumbersome to not have namespace inside the helpers.","position":{"start":{"line":18,"column":1,"offset":829},"end":{"line":18,"column":229,"offset":1057},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":829},"end":{"line":18,"column":229,"offset":1057},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This problem converge us to this blog post, we will put all customs Html helper into a specific method inside the HtmlHelper. What we want is to create segmentation of all Html Helpers. The following code is the result of what we want to create. Inside the HtmlHelper class, we will inject method that will be our namespaces. We could set all our inputs controler into Input and divide with other \"namespace\" other Html input. To be short, we will create only the input one in this blog post and only for the creation of a select list. As you will see, we will create a non-generic Helper, like in the code below, but also the generic one. This will give us the possibility to use a lambda expression to specify which property to use instead of specifying it with a string.","position":{"start":{"line":20,"column":1,"offset":1059},"end":{"line":20,"column":774,"offset":1832},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":1059},"end":{"line":20,"column":774,"offset":1832},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" @Html.Input().SelectorFor(\"MyPropertyName\", new[] { \"Item1\",\"Item2\"}) @Html.Image()... //And so on. ","position":{"start":{"line":23,"column":1,"offset":1835},"end":{"line":25,"column":4,"offset":1950},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"First, we need to inject the method for our namespaces.","position":{"start":{"line":27,"column":1,"offset":1952},"end":{"line":27,"column":56,"offset":2007},"indent":[]}}],"position":{"start":{"line":27,"column":1,"offset":1952},"end":{"line":27,"column":56,"offset":2007},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public static class HtmlHelperNameSpaces { public static HelperExtensionInputFactory Input(this HtmlHelper helper) { return new HelperExtensionInputFactory(helper); }\n\npublic static HelperExtensionInputFactory<TModel> Input<TModel>(this HtmlHelper<TModel> helper) { return new HelperExtensionInputFactory<TModel>(helper); } } ","position":{"start":{"line":30,"column":1,"offset":2010},"end":{"line":34,"column":4,"offset":2351},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"In the code above, we see that we have two Input method. One takes an HtmlHelper and the other one HtmlHelper. We can have more method for more namespace. The same logic apply. We need to take the HtmlHelper as the first parameter to create the extension. Then, we need to return the Html Helper that has the code.","position":{"start":{"line":36,"column":1,"offset":2353},"end":{"line":36,"column":315,"offset":2667},"indent":[]}}],"position":{"start":{"line":36,"column":1,"offset":2353},"end":{"line":36,"column":315,"offset":2667},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" /// <summary> /// Generic /// </summary> public class HelperExtensionInputFactory<TModel> : HelperExtensionInputFactory { private HtmlHelper<TModel> HtmlHelper { get; set; }\n\npublic HelperExtensionInputFactory(HtmlHelper<TModel> htmlHelper) : base(htmlHelper) { HtmlHelper = htmlHelper; }\n\npublic MvcHtmlString SelectorFor<TValue>(Expression<Func<TModel, TValue>> property, IEnumerable<string> items) { var meta = ModelMetadata.FromLambdaExpression(property, this.HtmlHelper.ViewData); string fullPropertyName = HtmlHelper.ViewContext.ViewData.TemplateInfo.GetFullHtmlFieldName(ExpressionHelper.GetExpressionText(property));\n\nvar selectBuilder = new TagBuilder(\"select\"); selectBuilder.MergeAttribute(\"name\", fullPropertyName); selectBuilder.MergeAttribute(\"id\", fullPropertyName); selectBuilder.MergeAttribute(\"class\", \"selector\");\n\nforeach (var item in items) { var optionBuilder = new TagBuilder(\"option\"); optionBuilder.MergeAttribute(\"value\", item); optionBuilder.SetInnerText(item); selectBuilder.InnerHtml += optionBuilder.ToString(); } return new MvcHtmlString(selectBuilder.ToString()); } }\n\n/// <summary> /// Non-Generic /// </summary> public class HelperExtensionInputFactory { private HtmlHelper HtmlHelper { get; set; }\n\npublic HelperExtensionInputFactory(HtmlHelper htmlHelper) { this.HtmlHelper = htmlHelper; }\n\npublic MvcHtmlString SelectorFor(string fullPropertyName, IEnumerable<string> items) {\n\nvar selectBuilder = new TagBuilder(\"select\"); selectBuilder.MergeAttribute(\"name\", fullPropertyName); selectBuilder.MergeAttribute(\"id\", fullPropertyName); selectBuilder.MergeAttribute(\"class\", \"selector\");\n\nforeach (var item in items) { var optionBuilder = new TagBuilder(\"option\"); optionBuilder.MergeAttribute(\"value\", item); optionBuilder.SetInnerText(item); selectBuilder.InnerHtml += optionBuilder.ToString(); } return new MvcHtmlString(selectBuilder.ToString()); } } ","position":{"start":{"line":39,"column":1,"offset":2670},"end":{"line":59,"column":4,"offset":4574},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The generic version inherit of the non-generic. Both take the HtmlHelper in parameter. This allow to use anything from the Html helper. It gives information about the ViewContext and give you the possibility to use other Html Helper within your Html Helper.","position":{"start":{"line":61,"column":1,"offset":4576},"end":{"line":61,"column":258,"offset":4833},"indent":[]}}],"position":{"start":{"line":61,"column":1,"offset":4576},"end":{"line":61,"column":258,"offset":4833},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The code in this blog post create an Html Select input for a property passed in parameter and fill everything from a list of string. This could be better to have distinction between caption and value but this is not the goal of this blog post. We could also reuse a lot of code between both... Nevertheless, the interesting part is how everything is bound together. As you can see, only the HtmlHelperNameSpacesis static. Everything underneath is concrete. It also gives the possibility the have generic and non-generic helpers. Finally, we can have several namespace by adding two methods every time to the HtmlHelperNameSpaces class.","position":{"start":{"line":63,"column":1,"offset":4835},"end":{"line":63,"column":636,"offset":5470},"indent":[]}}],"position":{"start":{"line":63,"column":1,"offset":4835},"end":{"line":63,"column":636,"offset":5470},"indent":[]}},{"type":"paragraph","children":[{"type":"image","title":null,"url":"images/HtmlHelper-400x79.png","alt":null,"position":{"start":{"line":65,"column":1,"offset":5472},"end":{"line":65,"column":34,"offset":5505},"indent":[]}}],"position":{"start":{"line":65,"column":1,"offset":5472},"end":{"line":65,"column":34,"offset":5505},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Here is a screen shot of the code explained above. You can find the source code of ","position":{"start":{"line":67,"column":1,"offset":5507},"end":{"line":67,"column":84,"offset":5590},"indent":[]}},{"type":"link","title":null,"url":"https://github.com/MrDesjardins/HtmlHelperExamples","children":[{"type":"text","value":"namespaced HtmlHelper at GitHub","position":{"start":{"line":67,"column":85,"offset":5591},"end":{"line":67,"column":116,"offset":5622},"indent":[]}}],"position":{"start":{"line":67,"column":84,"offset":5590},"end":{"line":67,"column":169,"offset":5675},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":67,"column":169,"offset":5675},"end":{"line":67,"column":170,"offset":5676},"indent":[]}}],"position":{"start":{"line":67,"column":1,"offset":5507},"end":{"line":67,"column":170,"offset":5676},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"How to create your own Asp.Net MVC Html Helper namespace\",\"date\":\"2014-02-20\",\"categories\":[\"asp-mvc\"]}","position":{"start":{"line":70,"column":1,"offset":5679},"end":{"line":70,"column":142,"offset":5820},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":70,"column":142,"offset":5820}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to create your own Asp.Net MVC Html Helper namespace\",\n  \"date\": \"2014-02-20\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Html helper allows to have reusable code around your application about html creation. For example, the Html helper for a textbox create a Html Input of type text. It allows to set the name and the value from the model. Html helpers are a must to use with Asp.Net MVC.\"), mdx(\"p\", null, \"At some point, custom helpers are required to be developed in house for specific needs. A simple approach is to simply create an extension method to the html helper. Here is a small example of creating an Html helper. The Html helper is an extension to the HtmlHelper class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static class MyHtmlHelpers { public static MvcHtmlString OutputName(this HtmlHelper helper, string name) { return new MvcHtmlString(string.Format(\\\"<h1>{0}</h1>\\\",name)); } } \\n\")), mdx(\"p\", null, \"This can be used into views this way:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" @Html.OutputName(\\\"Patrick\\\") \\n\")), mdx(\"p\", null, \"The problem with this approach is that is become harder and harder with the time to know which Html Helper are from Asp.Net MVC and which ones is a custom ones. It become also cumbersome to not have namespace inside the helpers.\"), mdx(\"p\", null, \"This problem converge us to this blog post, we will put all customs Html helper into a specific method inside the HtmlHelper. What we want is to create segmentation of all Html Helpers. The following code is the result of what we want to create. Inside the HtmlHelper class, we will inject method that will be our namespaces. We could set all our inputs controler into Input and divide with other \\\"namespace\\\" other Html input. To be short, we will create only the input one in this blog post and only for the creation of a select list. As you will see, we will create a non-generic Helper, like in the code below, but also the generic one. This will give us the possibility to use a lambda expression to specify which property to use instead of specifying it with a string.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" @Html.Input().SelectorFor(\\\"MyPropertyName\\\", new[] { \\\"Item1\\\",\\\"Item2\\\"}) @Html.Image()... //And so on. \\n\")), mdx(\"p\", null, \"First, we need to inject the method for our namespaces.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static class HtmlHelperNameSpaces { public static HelperExtensionInputFactory Input(this HtmlHelper helper) { return new HelperExtensionInputFactory(helper); }\\n\\npublic static HelperExtensionInputFactory<TModel> Input<TModel>(this HtmlHelper<TModel> helper) { return new HelperExtensionInputFactory<TModel>(helper); } } \\n\")), mdx(\"p\", null, \"In the code above, we see that we have two Input method. One takes an HtmlHelper and the other one HtmlHelper. We can have more method for more namespace. The same logic apply. We need to take the HtmlHelper as the first parameter to create the extension. Then, we need to return the Html Helper that has the code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" /// <summary> /// Generic /// </summary> public class HelperExtensionInputFactory<TModel> : HelperExtensionInputFactory { private HtmlHelper<TModel> HtmlHelper { get; set; }\\n\\npublic HelperExtensionInputFactory(HtmlHelper<TModel> htmlHelper) : base(htmlHelper) { HtmlHelper = htmlHelper; }\\n\\npublic MvcHtmlString SelectorFor<TValue>(Expression<Func<TModel, TValue>> property, IEnumerable<string> items) { var meta = ModelMetadata.FromLambdaExpression(property, this.HtmlHelper.ViewData); string fullPropertyName = HtmlHelper.ViewContext.ViewData.TemplateInfo.GetFullHtmlFieldName(ExpressionHelper.GetExpressionText(property));\\n\\nvar selectBuilder = new TagBuilder(\\\"select\\\"); selectBuilder.MergeAttribute(\\\"name\\\", fullPropertyName); selectBuilder.MergeAttribute(\\\"id\\\", fullPropertyName); selectBuilder.MergeAttribute(\\\"class\\\", \\\"selector\\\");\\n\\nforeach (var item in items) { var optionBuilder = new TagBuilder(\\\"option\\\"); optionBuilder.MergeAttribute(\\\"value\\\", item); optionBuilder.SetInnerText(item); selectBuilder.InnerHtml += optionBuilder.ToString(); } return new MvcHtmlString(selectBuilder.ToString()); } }\\n\\n/// <summary> /// Non-Generic /// </summary> public class HelperExtensionInputFactory { private HtmlHelper HtmlHelper { get; set; }\\n\\npublic HelperExtensionInputFactory(HtmlHelper htmlHelper) { this.HtmlHelper = htmlHelper; }\\n\\npublic MvcHtmlString SelectorFor(string fullPropertyName, IEnumerable<string> items) {\\n\\nvar selectBuilder = new TagBuilder(\\\"select\\\"); selectBuilder.MergeAttribute(\\\"name\\\", fullPropertyName); selectBuilder.MergeAttribute(\\\"id\\\", fullPropertyName); selectBuilder.MergeAttribute(\\\"class\\\", \\\"selector\\\");\\n\\nforeach (var item in items) { var optionBuilder = new TagBuilder(\\\"option\\\"); optionBuilder.MergeAttribute(\\\"value\\\", item); optionBuilder.SetInnerText(item); selectBuilder.InnerHtml += optionBuilder.ToString(); } return new MvcHtmlString(selectBuilder.ToString()); } } \\n\")), mdx(\"p\", null, \"The generic version inherit of the non-generic. Both take the HtmlHelper in parameter. This allow to use anything from the Html helper. It gives information about the ViewContext and give you the possibility to use other Html Helper within your Html Helper.\"), mdx(\"p\", null, \"The code in this blog post create an Html Select input for a property passed in parameter and fill everything from a list of string. This could be better to have distinction between caption and value but this is not the goal of this blog post. We could also reuse a lot of code between both... Nevertheless, the interesting part is how everything is bound together. As you can see, only the HtmlHelperNameSpacesis static. Everything underneath is concrete. It also gives the possibility the have generic and non-generic helpers. Finally, we can have several namespace by adding two methods every time to the HtmlHelperNameSpaces class.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"400px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/72489a6c2aa808157083d8ecf56a3a61/e17e5/HtmlHelper-400x79.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"19.666666666666668%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/UlEQVQY033OTUsCURhA4fnPQbvaZCJBWENEZFFRLVxUm4KoVpEGfbuQItOaxo/S8d65ju9Vc/QE0aZNB579cTzPo1IuU697iMDxaYGJ1Byz7hrJhR0S6QyTM8usbma4zm9xf7XNZX6PdCaLu55lfmWXxOIG06klppIuTrXqUyq9Uix+0GwOODl74uLhFrE+um0JQ43tWqw2mJbGSp//cvq9HsPhCN8fYgwUH0scnd8QqBpKGYJA0TURvbDDl1gYjxnFMXE8+hX/4URRhLWCSEi9Ztg/uOMwl+P5pYDnfVKpvFN9q9HwG5hmgAQaabXRaoBS8nMuukOn1UbE8g2e7R8AX1yB2QAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"HtmlHelper 400x79\",\n    \"title\": \"HtmlHelper 400x79\",\n    \"src\": \"/static/72489a6c2aa808157083d8ecf56a3a61/e17e5/HtmlHelper-400x79.png\",\n    \"srcSet\": [\"/static/72489a6c2aa808157083d8ecf56a3a61/5a46d/HtmlHelper-400x79.png 300w\", \"/static/72489a6c2aa808157083d8ecf56a3a61/e17e5/HtmlHelper-400x79.png 400w\"],\n    \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Here is a screen shot of the code explained above. You can find the source code of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/MrDesjardins/HtmlHelperExamples\"\n  }, \"namespaced HtmlHelper at GitHub\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"How to create your own Asp.Net MVC Html Helper namespace\",\n  \"date\": \"2014-02-20\",\n  \"categories\": [\"asp-mvc\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Html helper allows to have reusable code around your application about html creation. For example, the Html helper for a textbox create a Html Input of type text. It allows to set the name and the value from the model. Html helpers are a must to use with Asp.Net MVC.`}</p>\n    <p>{`At some point, custom helpers are required to be developed in house for specific needs. A simple approach is to simply create an extension method to the html helper. Here is a small example of creating an Html helper. The Html helper is an extension to the HtmlHelper class.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public static class MyHtmlHelpers { public static MvcHtmlString OutputName(this HtmlHelper helper, string name) { return new MvcHtmlString(string.Format(\"<h1>{0}</h1>\",name)); } } \n`}</code></pre>\n    <p>{`This can be used into views this way:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` @Html.OutputName(\"Patrick\") \n`}</code></pre>\n    <p>{`The problem with this approach is that is become harder and harder with the time to know which Html Helper are from Asp.Net MVC and which ones is a custom ones. It become also cumbersome to not have namespace inside the helpers.`}</p>\n    <p>{`This problem converge us to this blog post, we will put all customs Html helper into a specific method inside the HtmlHelper. What we want is to create segmentation of all Html Helpers. The following code is the result of what we want to create. Inside the HtmlHelper class, we will inject method that will be our namespaces. We could set all our inputs controler into Input and divide with other \"namespace\" other Html input. To be short, we will create only the input one in this blog post and only for the creation of a select list. As you will see, we will create a non-generic Helper, like in the code below, but also the generic one. This will give us the possibility to use a lambda expression to specify which property to use instead of specifying it with a string.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` @Html.Input().SelectorFor(\"MyPropertyName\", new[] { \"Item1\",\"Item2\"}) @Html.Image()... //And so on. \n`}</code></pre>\n    <p>{`First, we need to inject the method for our namespaces.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public static class HtmlHelperNameSpaces { public static HelperExtensionInputFactory Input(this HtmlHelper helper) { return new HelperExtensionInputFactory(helper); }\n\npublic static HelperExtensionInputFactory<TModel> Input<TModel>(this HtmlHelper<TModel> helper) { return new HelperExtensionInputFactory<TModel>(helper); } } \n`}</code></pre>\n    <p>{`In the code above, we see that we have two Input method. One takes an HtmlHelper and the other one HtmlHelper. We can have more method for more namespace. The same logic apply. We need to take the HtmlHelper as the first parameter to create the extension. Then, we need to return the Html Helper that has the code.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` /// <summary> /// Generic /// </summary> public class HelperExtensionInputFactory<TModel> : HelperExtensionInputFactory { private HtmlHelper<TModel> HtmlHelper { get; set; }\n\npublic HelperExtensionInputFactory(HtmlHelper<TModel> htmlHelper) : base(htmlHelper) { HtmlHelper = htmlHelper; }\n\npublic MvcHtmlString SelectorFor<TValue>(Expression<Func<TModel, TValue>> property, IEnumerable<string> items) { var meta = ModelMetadata.FromLambdaExpression(property, this.HtmlHelper.ViewData); string fullPropertyName = HtmlHelper.ViewContext.ViewData.TemplateInfo.GetFullHtmlFieldName(ExpressionHelper.GetExpressionText(property));\n\nvar selectBuilder = new TagBuilder(\"select\"); selectBuilder.MergeAttribute(\"name\", fullPropertyName); selectBuilder.MergeAttribute(\"id\", fullPropertyName); selectBuilder.MergeAttribute(\"class\", \"selector\");\n\nforeach (var item in items) { var optionBuilder = new TagBuilder(\"option\"); optionBuilder.MergeAttribute(\"value\", item); optionBuilder.SetInnerText(item); selectBuilder.InnerHtml += optionBuilder.ToString(); } return new MvcHtmlString(selectBuilder.ToString()); } }\n\n/// <summary> /// Non-Generic /// </summary> public class HelperExtensionInputFactory { private HtmlHelper HtmlHelper { get; set; }\n\npublic HelperExtensionInputFactory(HtmlHelper htmlHelper) { this.HtmlHelper = htmlHelper; }\n\npublic MvcHtmlString SelectorFor(string fullPropertyName, IEnumerable<string> items) {\n\nvar selectBuilder = new TagBuilder(\"select\"); selectBuilder.MergeAttribute(\"name\", fullPropertyName); selectBuilder.MergeAttribute(\"id\", fullPropertyName); selectBuilder.MergeAttribute(\"class\", \"selector\");\n\nforeach (var item in items) { var optionBuilder = new TagBuilder(\"option\"); optionBuilder.MergeAttribute(\"value\", item); optionBuilder.SetInnerText(item); selectBuilder.InnerHtml += optionBuilder.ToString(); } return new MvcHtmlString(selectBuilder.ToString()); } } \n`}</code></pre>\n    <p>{`The generic version inherit of the non-generic. Both take the HtmlHelper in parameter. This allow to use anything from the Html helper. It gives information about the ViewContext and give you the possibility to use other Html Helper within your Html Helper.`}</p>\n    <p>{`The code in this blog post create an Html Select input for a property passed in parameter and fill everything from a list of string. This could be better to have distinction between caption and value but this is not the goal of this blog post. We could also reuse a lot of code between both... Nevertheless, the interesting part is how everything is bound together. As you can see, only the HtmlHelperNameSpacesis static. Everything underneath is concrete. It also gives the possibility the have generic and non-generic helpers. Finally, we can have several namespace by adding two methods every time to the HtmlHelperNameSpaces class.`}</p>\n    <p><span parentName=\"p\" {...{\n        \"className\": \"gatsby-resp-image-wrapper\",\n        \"style\": {\n          \"position\": \"relative\",\n          \"display\": \"block\",\n          \"marginLeft\": \"auto\",\n          \"marginRight\": \"auto\",\n          \"maxWidth\": \"400px\"\n        }\n      }}>{`\n      `}<a parentName=\"span\" {...{\n          \"className\": \"gatsby-resp-image-link\",\n          \"href\": \"/static/72489a6c2aa808157083d8ecf56a3a61/e17e5/HtmlHelper-400x79.png\",\n          \"style\": {\n            \"display\": \"block\"\n          },\n          \"target\": \"_blank\",\n          \"rel\": \"noopener\"\n        }}>{`\n    `}<span parentName=\"a\" {...{\n            \"className\": \"gatsby-resp-image-background-image\",\n            \"style\": {\n              \"paddingBottom\": \"19.666666666666668%\",\n              \"position\": \"relative\",\n              \"bottom\": \"0\",\n              \"left\": \"0\",\n              \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/UlEQVQY033OTUsCURhA4fnPQbvaZCJBWENEZFFRLVxUm4KoVpEGfbuQItOaxo/S8d65ju9Vc/QE0aZNB579cTzPo1IuU697iMDxaYGJ1Byz7hrJhR0S6QyTM8usbma4zm9xf7XNZX6PdCaLu55lfmWXxOIG06klppIuTrXqUyq9Uix+0GwOODl74uLhFrE+um0JQ43tWqw2mJbGSp//cvq9HsPhCN8fYgwUH0scnd8QqBpKGYJA0TURvbDDl1gYjxnFMXE8+hX/4URRhLWCSEi9Ztg/uOMwl+P5pYDnfVKpvFN9q9HwG5hmgAQaabXRaoBS8nMuukOn1UbE8g2e7R8AX1yB2QAAAABJRU5ErkJggg==')\",\n              \"backgroundSize\": \"cover\",\n              \"display\": \"block\"\n            }\n          }}></span>{`\n  `}<img parentName=\"a\" {...{\n            \"className\": \"gatsby-resp-image-image\",\n            \"alt\": \"HtmlHelper 400x79\",\n            \"title\": \"HtmlHelper 400x79\",\n            \"src\": \"/static/72489a6c2aa808157083d8ecf56a3a61/e17e5/HtmlHelper-400x79.png\",\n            \"srcSet\": [\"/static/72489a6c2aa808157083d8ecf56a3a61/5a46d/HtmlHelper-400x79.png 300w\", \"/static/72489a6c2aa808157083d8ecf56a3a61/e17e5/HtmlHelper-400x79.png 400w\"],\n            \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n            \"style\": {\n              \"width\": \"100%\",\n              \"height\": \"100%\",\n              \"margin\": \"0\",\n              \"verticalAlign\": \"middle\",\n              \"position\": \"absolute\",\n              \"top\": \"0\",\n              \"left\": \"0\"\n            },\n            \"loading\": \"lazy\",\n            \"decoding\": \"async\"\n          }}></img>{`\n  `}</a>{`\n    `}</span></p>\n    <p>{`Here is a screen shot of the code explained above. You can find the source code of `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/MrDesjardins/HtmlHelperExamples\"\n      }}>{`namespaced HtmlHelper at GitHub`}</a>{`.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}