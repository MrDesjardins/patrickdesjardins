{"expireTime":9007200886478378000,"key":"gatsby-plugin-mdx-entire-payload-711ee782c1cd7b30a23ccfb9aa829a92--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"I have been working in a GraphQL solution at Netflix for few months now. I am always keen to have insight about what is going on. While I created from the ground-up the GraphQL server with NodeJS I had in mind to find a way to give me, the software engineer, some insights by providing some direct feedback in the bash console running the server but also to send the data to an ElasticSearch cluster. Before rendering or sending the telemetry, we need to collect it. In this article, I'll write how I proceeded to get information on individual HTTP calls that the GraphQL query invoke to retrieve the information while resolving a graph of objects.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":649,"offset":649},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":649,"offset":649},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The solution is oriented toward the library RESTDataSource but it is exactly the same principle with Axios or other HTTP request library. The idea is to subscribe to a global event that is invoked when a request starts and when a response comes back. By having a hook at the beginning and the end, it is possible to collect the time elapsed without having to code something on every request.","position":{"start":{"line":4,"column":1,"offset":651},"end":{"line":4,"column":392,"offset":1042},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":651},"end":{"line":4,"column":392,"offset":1042},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"RESTDataSource Override","position":{"start":{"line":6,"column":4,"offset":1047},"end":{"line":6,"column":27,"offset":1070},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":1044},"end":{"line":6,"column":27,"offset":1070},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In the case of RESTDataSource, it is a matter of overriding the ","position":{"start":{"line":8,"column":1,"offset":1072},"end":{"line":8,"column":65,"offset":1136},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"willSendRequest","position":{"start":{"line":8,"column":66,"offset":1137},"end":{"line":8,"column":81,"offset":1152},"indent":[]}}],"position":{"start":{"line":8,"column":65,"offset":1136},"end":{"line":8,"column":82,"offset":1153},"indent":[]}},{"type":"text","value":" function. It takes a request parameter. We will use the request to add in the HTTP's header a unique identifier that will give the response function a reference to the originator. The second function to override is ","position":{"start":{"line":8,"column":82,"offset":1153},"end":{"line":8,"column":298,"offset":1369},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"didReceiveResponse","position":{"start":{"line":8,"column":299,"offset":1370},"end":{"line":8,"column":317,"offset":1388},"indent":[]}}],"position":{"start":{"line":8,"column":298,"offset":1369},"end":{"line":8,"column":318,"offset":1389},"indent":[]}},{"type":"text","value":". This one has two parameters: the request and the response.","position":{"start":{"line":8,"column":318,"offset":1389},"end":{"line":8,"column":378,"offset":1449},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":1072},"end":{"line":8,"column":378,"offset":1449},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":10,"column":1,"offset":1451},"end":{"line":10,"column":5,"offset":1455},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"willSendRequest","position":{"start":{"line":10,"column":6,"offset":1456},"end":{"line":10,"column":21,"offset":1471},"indent":[]}}],"position":{"start":{"line":10,"column":5,"offset":1455},"end":{"line":10,"column":22,"offset":1472},"indent":[]}},{"type":"text","value":" function performs three actions. The first one is to generate a GUID that will serve as a unique identifier. It is added into the HTTP header. Then, the second action is to add in the GraphQL's context a collection of HTTP requests. I created a type that will keep track of the time, the total bytes received, the URL, query string, the starting time and also the unique request identifier (GUID). The unique identifier is needed for the second function.","position":{"start":{"line":10,"column":22,"offset":1472},"end":{"line":10,"column":477,"offset":1927},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":1451},"end":{"line":10,"column":477,"offset":1927},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"export interface HttpStatsEndpoints {\n    requestUuid: string;\n    url: string;\n    urlSearchParams: URLSearchParams;\n    elapsedTimeMs: number;\n    totalBytes: number;\n}","position":{"start":{"line":12,"column":1,"offset":1929},"end":{"line":20,"column":4,"offset":2117},"indent":[1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":22,"column":1,"offset":2119},"end":{"line":22,"column":5,"offset":2123},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"didReceiveResponse","position":{"start":{"line":22,"column":6,"offset":2124},"end":{"line":22,"column":24,"offset":2142},"indent":[]}}],"position":{"start":{"line":22,"column":5,"offset":2123},"end":{"line":22,"column":25,"offset":2143},"indent":[]}},{"type":"text","value":" function gets a response, but also the request object. Because we have the request, we can peek at the GUID and extract from the GraphQL context the information and subtract the actual time from the time saved when the request started. The number of bytes and the elapsed time is saved in the context until read by the GraphQL Extension.","position":{"start":{"line":22,"column":25,"offset":2143},"end":{"line":22,"column":363,"offset":2481},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":2119},"end":{"line":22,"column":363,"offset":2481},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"public didReceiveResponse(response: Response, request: Request): Promise<any> {\n    return super.didReceiveResponse(response, request).then(result => {\n        const requestId = request.headers.get(HEADER_REQUEST_UUID);\n        const startTime = request.headers.get(HEADER_START_TIME);\n        const httpRequest = this.context.stats.httpRequests.find(d => d.requestUuid === requestId);\n        if (httpRequest !== undefined && startTime !== null) {\n            const totalNanoSecondsElapsed = process.hrtime();\n            const totalMilliSecondsElaspsed = this.convertNodeHrTimeToMs(totalNanoSecondsElapsed);\n            httpRequest.elapsedTimeMs = totalMilliSecondsElaspsed - Number(startTime);\n            httpRequest.totalBytes = JSON.stringify(result).length;\n        }\n        return result;\n    });\n}","position":{"start":{"line":24,"column":1,"offset":2483},"end":{"line":39,"column":4,"offset":3308},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"GraphQL Extension","position":{"start":{"line":41,"column":4,"offset":3313},"end":{"line":41,"column":21,"offset":3330},"indent":[]}}],"position":{"start":{"line":41,"column":1,"offset":3310},"end":{"line":41,"column":21,"offset":3330},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"At this point, when all requests are completed and the GraphQL is ready to send a response back, a custom extension can come into play. I covered the detail of a custom GraphQL Extension in a previous post concerning telemetry and how to display it on the console. The idea is the same, this time we can read the GraphQL context and while looping through the telemetry display the bytes and time taken for each request.","position":{"start":{"line":43,"column":1,"offset":3332},"end":{"line":43,"column":420,"offset":3751},"indent":[]}}],"position":{"start":{"line":43,"column":1,"offset":3332},"end":{"line":43,"column":420,"offset":3751},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Here are some of my GraphQL post of this series","position":{"start":{"line":45,"column":4,"offset":3756},"end":{"line":45,"column":51,"offset":3803},"indent":[]}}],"position":{"start":{"line":45,"column":1,"offset":3753},"end":{"line":45,"column":51,"offset":3803},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"getting-started-with-graphql-for-netflix-open-connect","children":[{"type":"text","value":"Getting Started with GraphQL for Netflix Open Connect","position":{"start":{"line":47,"column":4,"offset":3808},"end":{"line":47,"column":57,"offset":3861},"indent":[]}}],"position":{"start":{"line":47,"column":3,"offset":3807},"end":{"line":47,"column":113,"offset":3917},"indent":[]}}],"position":{"start":{"line":47,"column":3,"offset":3807},"end":{"line":47,"column":113,"offset":3917},"indent":[]}}],"position":{"start":{"line":47,"column":1,"offset":3805},"end":{"line":47,"column":113,"offset":3917},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"install-apollo-server-to-host-a-graphql-service","children":[{"type":"text","value":"Install Apollo Server to host a GraphQL service","position":{"start":{"line":48,"column":4,"offset":3921},"end":{"line":48,"column":51,"offset":3968},"indent":[]}}],"position":{"start":{"line":48,"column":3,"offset":3920},"end":{"line":48,"column":101,"offset":4018},"indent":[]}}],"position":{"start":{"line":48,"column":3,"offset":3920},"end":{"line":48,"column":101,"offset":4018},"indent":[]}}],"position":{"start":{"line":48,"column":1,"offset":3918},"end":{"line":48,"column":101,"offset":4018},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"apollo-server-and-secured-playground","children":[{"type":"text","value":"Apollo Server and Secured Playground","position":{"start":{"line":49,"column":4,"offset":4022},"end":{"line":49,"column":40,"offset":4058},"indent":[]}}],"position":{"start":{"line":49,"column":3,"offset":4021},"end":{"line":49,"column":79,"offset":4097},"indent":[]}}],"position":{"start":{"line":49,"column":3,"offset":4021},"end":{"line":49,"column":79,"offset":4097},"indent":[]}}],"position":{"start":{"line":49,"column":1,"offset":4019},"end":{"line":49,"column":79,"offset":4097},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"graphql-context","children":[{"type":"text","value":"GraphQL Context","position":{"start":{"line":50,"column":4,"offset":4101},"end":{"line":50,"column":19,"offset":4116},"indent":[]}}],"position":{"start":{"line":50,"column":3,"offset":4100},"end":{"line":50,"column":37,"offset":4134},"indent":[]}}],"position":{"start":{"line":50,"column":3,"offset":4100},"end":{"line":50,"column":37,"offset":4134},"indent":[]}}],"position":{"start":{"line":50,"column":1,"offset":4098},"end":{"line":50,"column":37,"offset":4134},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"graphql-query-with-argument","children":[{"type":"text","value":"GraphQL Query with Argument","position":{"start":{"line":51,"column":4,"offset":4138},"end":{"line":51,"column":31,"offset":4165},"indent":[]}}],"position":{"start":{"line":51,"column":3,"offset":4137},"end":{"line":51,"column":61,"offset":4195},"indent":[]}}],"position":{"start":{"line":51,"column":3,"offset":4137},"end":{"line":51,"column":61,"offset":4195},"indent":[]}}],"position":{"start":{"line":51,"column":1,"offset":4135},"end":{"line":51,"column":61,"offset":4195},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"apollo-graphql-resolvers-and-data-source-separation","children":[{"type":"text","value":"Apollo GraphQL Resolvers and Data Source separation","position":{"start":{"line":52,"column":4,"offset":4199},"end":{"line":52,"column":55,"offset":4250},"indent":[]}}],"position":{"start":{"line":52,"column":3,"offset":4198},"end":{"line":52,"column":109,"offset":4304},"indent":[]}}],"position":{"start":{"line":52,"column":3,"offset":4198},"end":{"line":52,"column":109,"offset":4304},"indent":[]}}],"position":{"start":{"line":52,"column":1,"offset":4196},"end":{"line":52,"column":109,"offset":4304},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"how-to-setup-a-typescript-nodejs-express-apollo-server-to-easy-debugging-with-vscode","children":[{"type":"text","value":"How to setup a TypeScript, NodeJS, Express Apollo Server to easy debugging with VsCode","position":{"start":{"line":53,"column":4,"offset":4308},"end":{"line":53,"column":90,"offset":4394},"indent":[]}}],"position":{"start":{"line":53,"column":3,"offset":4307},"end":{"line":53,"column":177,"offset":4481},"indent":[]}}],"position":{"start":{"line":53,"column":3,"offset":4307},"end":{"line":53,"column":177,"offset":4481},"indent":[]}}],"position":{"start":{"line":53,"column":1,"offset":4305},"end":{"line":53,"column":177,"offset":4481},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"graphql-resolvers-with-apollo","children":[{"type":"text","value":"GraphQL Resolvers with Apollo","position":{"start":{"line":54,"column":4,"offset":4485},"end":{"line":54,"column":33,"offset":4514},"indent":[]}}],"position":{"start":{"line":54,"column":3,"offset":4484},"end":{"line":54,"column":65,"offset":4546},"indent":[]}}],"position":{"start":{"line":54,"column":3,"offset":4484},"end":{"line":54,"column":65,"offset":4546},"indent":[]}}],"position":{"start":{"line":54,"column":1,"offset":4482},"end":{"line":54,"column":65,"offset":4546},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"configuring-apollo-playground-and-api-on-two-different-url","children":[{"type":"text","value":"Configuring Apollo Playground and API on two different URL","position":{"start":{"line":55,"column":4,"offset":4550},"end":{"line":55,"column":62,"offset":4608},"indent":[]}}],"position":{"start":{"line":55,"column":3,"offset":4549},"end":{"line":55,"column":123,"offset":4669},"indent":[]}}],"position":{"start":{"line":55,"column":3,"offset":4549},"end":{"line":55,"column":123,"offset":4669},"indent":[]}}],"position":{"start":{"line":55,"column":1,"offset":4547},"end":{"line":55,"column":123,"offset":4669},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"how-to-automatically-generate-typescript-for-consumer-of-your-graphql","children":[{"type":"text","value":"How to automatically generate TypeScript for consumers of your GraphQL","position":{"start":{"line":56,"column":4,"offset":4673},"end":{"line":56,"column":74,"offset":4743},"indent":[]}}],"position":{"start":{"line":56,"column":3,"offset":4672},"end":{"line":56,"column":146,"offset":4815},"indent":[]}}],"position":{"start":{"line":56,"column":3,"offset":4672},"end":{"line":56,"column":146,"offset":4815},"indent":[]}}],"position":{"start":{"line":56,"column":1,"offset":4670},"end":{"line":56,"column":146,"offset":4815},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"graphql-extension-to-collect-http-and-resolvers-telemetry","children":[{"type":"text","value":"GraphQL and HTTP Telemetry","position":{"start":{"line":57,"column":4,"offset":4819},"end":{"line":57,"column":30,"offset":4845},"indent":[]}}],"position":{"start":{"line":57,"column":3,"offset":4818},"end":{"line":57,"column":90,"offset":4905},"indent":[]}},{"type":"text","value":"  ","position":{"start":{"line":57,"column":90,"offset":4905},"end":{"line":57,"column":92,"offset":4907},"indent":[]}}],"position":{"start":{"line":57,"column":3,"offset":4818},"end":{"line":57,"column":92,"offset":4907},"indent":[]}}],"position":{"start":{"line":57,"column":1,"offset":4816},"end":{"line":57,"column":92,"offset":4907},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"how-to-consume-graphql-in-typescript-and-react","children":[{"type":"text","value":"GraphQL and TypeScript/React","position":{"start":{"line":58,"column":4,"offset":4911},"end":{"line":58,"column":32,"offset":4939},"indent":[]}}],"position":{"start":{"line":58,"column":3,"offset":4910},"end":{"line":58,"column":81,"offset":4988},"indent":[]}}],"position":{"start":{"line":58,"column":3,"offset":4910},"end":{"line":58,"column":81,"offset":4988},"indent":[]}}],"position":{"start":{"line":58,"column":1,"offset":4908},"end":{"line":58,"column":81,"offset":4988},"indent":[]}}],"position":{"start":{"line":47,"column":1,"offset":3805},"end":{"line":58,"column":81,"offset":4988},"indent":[1,1,1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"How to Collect HTTP Request Telemetry with GraphQL and RESTDataSource?\",\"date\":\"2019-05-28\",\"categories\":[\"graphql\"]}","position":{"start":{"line":60,"column":1,"offset":4990},"end":{"line":60,"column":156,"offset":5145},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":60,"column":156,"offset":5145}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to Collect HTTP Request Telemetry with GraphQL and RESTDataSource?\",\n  \"date\": \"2019-05-28\",\n  \"categories\": [\"graphql\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I have been working in a GraphQL solution at Netflix for few months now. I am always keen to have insight about what is going on. While I created from the ground-up the GraphQL server with NodeJS I had in mind to find a way to give me, the software engineer, some insights by providing some direct feedback in the bash console running the server but also to send the data to an ElasticSearch cluster. Before rendering or sending the telemetry, we need to collect it. In this article, I'll write how I proceeded to get information on individual HTTP calls that the GraphQL query invoke to retrieve the information while resolving a graph of objects.\"), mdx(\"p\", null, \"The solution is oriented toward the library RESTDataSource but it is exactly the same principle with Axios or other HTTP request library. The idea is to subscribe to a global event that is invoked when a request starts and when a response comes back. By having a hook at the beginning and the end, it is possible to collect the time elapsed without having to code something on every request.\"), mdx(\"h2\", null, \"RESTDataSource Override\"), mdx(\"p\", null, \"In the case of RESTDataSource, it is a matter of overriding the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"willSendRequest\"), \" function. It takes a request parameter. We will use the request to add in the HTTP's header a unique identifier that will give the response function a reference to the originator. The second function to override is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"didReceiveResponse\"), \". This one has two parameters: the request and the response.\"), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"willSendRequest\"), \" function performs three actions. The first one is to generate a GUID that will serve as a unique identifier. It is added into the HTTP header. Then, the second action is to add in the GraphQL's context a collection of HTTP requests. I created a type that will keep track of the time, the total bytes received, the URL, query string, the starting time and also the unique request identifier (GUID). The unique identifier is needed for the second function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface HttpStatsEndpoints {\\n    requestUuid: string;\\n    url: string;\\n    urlSearchParams: URLSearchParams;\\n    elapsedTimeMs: number;\\n    totalBytes: number;\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"didReceiveResponse\"), \" function gets a response, but also the request object. Because we have the request, we can peek at the GUID and extract from the GraphQL context the information and subtract the actual time from the time saved when the request started. The number of bytes and the elapsed time is saved in the context until read by the GraphQL Extension.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"public didReceiveResponse(response: Response, request: Request): Promise<any> {\\n    return super.didReceiveResponse(response, request).then(result => {\\n        const requestId = request.headers.get(HEADER_REQUEST_UUID);\\n        const startTime = request.headers.get(HEADER_START_TIME);\\n        const httpRequest = this.context.stats.httpRequests.find(d => d.requestUuid === requestId);\\n        if (httpRequest !== undefined && startTime !== null) {\\n            const totalNanoSecondsElapsed = process.hrtime();\\n            const totalMilliSecondsElaspsed = this.convertNodeHrTimeToMs(totalNanoSecondsElapsed);\\n            httpRequest.elapsedTimeMs = totalMilliSecondsElaspsed - Number(startTime);\\n            httpRequest.totalBytes = JSON.stringify(result).length;\\n        }\\n        return result;\\n    });\\n}\\n\")), mdx(\"h2\", null, \"GraphQL Extension\"), mdx(\"p\", null, \"At this point, when all requests are completed and the GraphQL is ready to send a response back, a custom extension can come into play. I covered the detail of a custom GraphQL Extension in a previous post concerning telemetry and how to display it on the console. The idea is the same, this time we can read the GraphQL context and while looping through the telemetry display the bytes and time taken for each request.\"), mdx(\"h2\", null, \"Here are some of my GraphQL post of this series\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"getting-started-with-graphql-for-netflix-open-connect\"\n  }, \"Getting Started with GraphQL for Netflix Open Connect\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"install-apollo-server-to-host-a-graphql-service\"\n  }, \"Install Apollo Server to host a GraphQL service\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"apollo-server-and-secured-playground\"\n  }, \"Apollo Server and Secured Playground\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"graphql-context\"\n  }, \"GraphQL Context\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"graphql-query-with-argument\"\n  }, \"GraphQL Query with Argument\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"apollo-graphql-resolvers-and-data-source-separation\"\n  }, \"Apollo GraphQL Resolvers and Data Source separation\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"how-to-setup-a-typescript-nodejs-express-apollo-server-to-easy-debugging-with-vscode\"\n  }, \"How to setup a TypeScript, NodeJS, Express Apollo Server to easy debugging with VsCode\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"graphql-resolvers-with-apollo\"\n  }, \"GraphQL Resolvers with Apollo\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"configuring-apollo-playground-and-api-on-two-different-url\"\n  }, \"Configuring Apollo Playground and API on two different URL\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"how-to-automatically-generate-typescript-for-consumer-of-your-graphql\"\n  }, \"How to automatically generate TypeScript for consumers of your GraphQL\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"graphql-extension-to-collect-http-and-resolvers-telemetry\"\n  }, \"GraphQL and HTTP Telemetry\"), \"  \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"how-to-consume-graphql-in-typescript-and-react\"\n  }, \"GraphQL and TypeScript/React\"))));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"How to Collect HTTP Request Telemetry with GraphQL and RESTDataSource?\",\n  \"date\": \"2019-05-28\",\n  \"categories\": [\"graphql\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`I have been working in a GraphQL solution at Netflix for few months now. I am always keen to have insight about what is going on. While I created from the ground-up the GraphQL server with NodeJS I had in mind to find a way to give me, the software engineer, some insights by providing some direct feedback in the bash console running the server but also to send the data to an ElasticSearch cluster. Before rendering or sending the telemetry, we need to collect it. In this article, I'll write how I proceeded to get information on individual HTTP calls that the GraphQL query invoke to retrieve the information while resolving a graph of objects.`}</p>\n    <p>{`The solution is oriented toward the library RESTDataSource but it is exactly the same principle with Axios or other HTTP request library. The idea is to subscribe to a global event that is invoked when a request starts and when a response comes back. By having a hook at the beginning and the end, it is possible to collect the time elapsed without having to code something on every request.`}</p>\n    <h2>{`RESTDataSource Override`}</h2>\n    <p>{`In the case of RESTDataSource, it is a matter of overriding the `}<em parentName=\"p\">{`willSendRequest`}</em>{` function. It takes a request parameter. We will use the request to add in the HTTP's header a unique identifier that will give the response function a reference to the originator. The second function to override is `}<em parentName=\"p\">{`didReceiveResponse`}</em>{`. This one has two parameters: the request and the response.`}</p>\n    <p>{`The `}<em parentName=\"p\">{`willSendRequest`}</em>{` function performs three actions. The first one is to generate a GUID that will serve as a unique identifier. It is added into the HTTP header. Then, the second action is to add in the GraphQL's context a collection of HTTP requests. I created a type that will keep track of the time, the total bytes received, the URL, query string, the starting time and also the unique request identifier (GUID). The unique identifier is needed for the second function.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`export interface HttpStatsEndpoints {\n    requestUuid: string;\n    url: string;\n    urlSearchParams: URLSearchParams;\n    elapsedTimeMs: number;\n    totalBytes: number;\n}\n`}</code></pre>\n    <p>{`The `}<em parentName=\"p\">{`didReceiveResponse`}</em>{` function gets a response, but also the request object. Because we have the request, we can peek at the GUID and extract from the GraphQL context the information and subtract the actual time from the time saved when the request started. The number of bytes and the elapsed time is saved in the context until read by the GraphQL Extension.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`public didReceiveResponse(response: Response, request: Request): Promise<any> {\n    return super.didReceiveResponse(response, request).then(result => {\n        const requestId = request.headers.get(HEADER_REQUEST_UUID);\n        const startTime = request.headers.get(HEADER_START_TIME);\n        const httpRequest = this.context.stats.httpRequests.find(d => d.requestUuid === requestId);\n        if (httpRequest !== undefined && startTime !== null) {\n            const totalNanoSecondsElapsed = process.hrtime();\n            const totalMilliSecondsElaspsed = this.convertNodeHrTimeToMs(totalNanoSecondsElapsed);\n            httpRequest.elapsedTimeMs = totalMilliSecondsElaspsed - Number(startTime);\n            httpRequest.totalBytes = JSON.stringify(result).length;\n        }\n        return result;\n    });\n}\n`}</code></pre>\n    <h2>{`GraphQL Extension`}</h2>\n    <p>{`At this point, when all requests are completed and the GraphQL is ready to send a response back, a custom extension can come into play. I covered the detail of a custom GraphQL Extension in a previous post concerning telemetry and how to display it on the console. The idea is the same, this time we can read the GraphQL context and while looping through the telemetry display the bytes and time taken for each request.`}</p>\n    <h2>{`Here are some of my GraphQL post of this series`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"getting-started-with-graphql-for-netflix-open-connect\"\n        }}>{`Getting Started with GraphQL for Netflix Open Connect`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"install-apollo-server-to-host-a-graphql-service\"\n        }}>{`Install Apollo Server to host a GraphQL service`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"apollo-server-and-secured-playground\"\n        }}>{`Apollo Server and Secured Playground`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"graphql-context\"\n        }}>{`GraphQL Context`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"graphql-query-with-argument\"\n        }}>{`GraphQL Query with Argument`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"apollo-graphql-resolvers-and-data-source-separation\"\n        }}>{`Apollo GraphQL Resolvers and Data Source separation`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"how-to-setup-a-typescript-nodejs-express-apollo-server-to-easy-debugging-with-vscode\"\n        }}>{`How to setup a TypeScript, NodeJS, Express Apollo Server to easy debugging with VsCode`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"graphql-resolvers-with-apollo\"\n        }}>{`GraphQL Resolvers with Apollo`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"configuring-apollo-playground-and-api-on-two-different-url\"\n        }}>{`Configuring Apollo Playground and API on two different URL`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"how-to-automatically-generate-typescript-for-consumer-of-your-graphql\"\n        }}>{`How to automatically generate TypeScript for consumers of your GraphQL`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"graphql-extension-to-collect-http-and-resolvers-telemetry\"\n        }}>{`GraphQL and HTTP Telemetry`}</a>{`  `}</li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"how-to-consume-graphql-in-typescript-and-react\"\n        }}>{`GraphQL and TypeScript/React`}</a></li>\n    </ul>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}