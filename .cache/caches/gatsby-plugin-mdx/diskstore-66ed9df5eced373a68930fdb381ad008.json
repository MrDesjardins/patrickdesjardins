{"expireTime":9007200886478398000,"key":"gatsby-plugin-mdx-entire-payload-21db64b84a8d5d6257e03323e2a7fb58--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Not long time ago, I had to modify a code which was using a ","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":61,"offset":61},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Frameset","position":{"start":{"line":2,"column":63,"offset":63},"end":{"line":2,"column":71,"offset":71},"indent":[]}}],"position":{"start":{"line":2,"column":61,"offset":61},"end":{"line":2,"column":73,"offset":73},"indent":[]}},{"type":"text","value":" with ","position":{"start":{"line":2,"column":73,"offset":73},"end":{"line":2,"column":79,"offset":79},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Frame","position":{"start":{"line":2,"column":81,"offset":81},"end":{"line":2,"column":86,"offset":86},"indent":[]}}],"position":{"start":{"line":2,"column":79,"offset":79},"end":{"line":2,"column":88,"offset":88},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":2,"column":88,"offset":88},"end":{"line":2,"column":89,"offset":89},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":89,"offset":89},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"I had an issue because the code was written for Internet Explorer only and it was accessing the hidden field by using ","position":{"start":{"line":4,"column":1,"offset":91},"end":{"line":4,"column":119,"offset":209},"indent":[]}},{"type":"inlineCode","value":"parent.window.document.myhiddenfield.value","position":{"start":{"line":4,"column":119,"offset":209},"end":{"line":4,"column":163,"offset":253},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":4,"column":163,"offset":253},"end":{"line":4,"column":164,"offset":254},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":91},"end":{"line":4,"column":164,"offset":254},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"My first reflex was to remove the window and use getElementById. Like this:","position":{"start":{"line":6,"column":1,"offset":256},"end":{"line":6,"column":76,"offset":331},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":256},"end":{"line":6,"column":76,"offset":331},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"parent.document.getElementById('myhiddenfield').value ","position":{"start":{"line":8,"column":1,"offset":333},"end":{"line":10,"column":5,"offset":406},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This doesn't work with Firefox either. After some search, I found that we can use ","position":{"start":{"line":13,"column":1,"offset":409},"end":{"line":13,"column":83,"offset":491},"indent":[]}},{"type":"inlineCode","value":"self.ownerDocument","position":{"start":{"line":13,"column":83,"offset":491},"end":{"line":13,"column":103,"offset":511},"indent":[]}},{"type":"text","value":". Like this: ```typescript\nself.ownerDocument.getElementById('bar'); ","position":{"start":{"line":13,"column":103,"offset":511},"end":{"line":14,"column":43,"offset":580},"indent":[1]}}],"position":{"start":{"line":13,"column":1,"offset":409},"end":{"line":14,"column":43,"offset":580},"indent":[1]}},{"type":"code","lang":null,"meta":null,"value":"\n\nUnfortunately, this doesn't work with Internet Explorer, just Firefox.\n\nMy last try was to use JQuery, which solve most of the compatibility problem.\n\nThis is the current implementation that works to get hidden input control (or any other input) from a child frame to a parent that hold the frameset.\n\n```typescript\nparent.$(\"#myhiddenfield\").val() ","position":{"start":{"line":15,"column":1,"offset":581},"end":{"line":26,"column":5,"offset":942},"indent":[1,1,1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Accessing input control of a parent inside a child frame?\",\"date\":\"2011-11-19\",\"categories\":[\"javascript\"]}","position":{"start":{"line":30,"column":1,"offset":946},"end":{"line":30,"column":146,"offset":1091},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":30,"column":146,"offset":1091}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Accessing input control of a parent inside a child frame?\",\n  \"date\": \"2011-11-19\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Not long time ago, I had to modify a code which was using a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Frameset\"), \" with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Frame\"), \".\"), mdx(\"p\", null, \"I had an issue because the code was written for Internet Explorer only and it was accessing the hidden field by using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parent.window.document.myhiddenfield.value\"), \".\"), mdx(\"p\", null, \"My first reflex was to remove the window and use getElementById. Like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"parent.document.getElementById('myhiddenfield').value \\n\")), mdx(\"p\", null, \"This doesn't work with Firefox either. After some search, I found that we can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self.ownerDocument\"), \". Like this: ```typescript\\nself.ownerDocument.getElementById('bar'); \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\n\\nUnfortunately, this doesn't work with Internet Explorer, just Firefox.\\n\\nMy last try was to use JQuery, which solve most of the compatibility problem.\\n\\nThis is the current implementation that works to get hidden input control (or any other input) from a child frame to a parent that hold the frameset.\\n\\n```typescript\\nparent.$(\\\"#myhiddenfield\\\").val() \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Accessing input control of a parent inside a child frame?\",\n  \"date\": \"2011-11-19\",\n  \"categories\": [\"javascript\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Not long time ago, I had to modify a code which was using a `}<strong parentName=\"p\">{`Frameset`}</strong>{` with `}<strong parentName=\"p\">{`Frame`}</strong>{`.`}</p>\n    <p>{`I had an issue because the code was written for Internet Explorer only and it was accessing the hidden field by using `}<inlineCode parentName=\"p\">{`parent.window.document.myhiddenfield.value`}</inlineCode>{`.`}</p>\n    <p>{`My first reflex was to remove the window and use getElementById. Like this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`parent.document.getElementById('myhiddenfield').value \n`}</code></pre>\n    <p>{`This doesn't work with Firefox either. After some search, I found that we can use `}<inlineCode parentName=\"p\">{`self.ownerDocument`}</inlineCode>{`. Like this: \\`\\`\\`typescript\nself.ownerDocument.getElementById('bar'); `}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`\n\nUnfortunately, this doesn't work with Internet Explorer, just Firefox.\n\nMy last try was to use JQuery, which solve most of the compatibility problem.\n\nThis is the current implementation that works to get hidden input control (or any other input) from a child frame to a parent that hold the frameset.\n\n\\`\\`\\`typescript\nparent.$(\"#myhiddenfield\").val() \n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}