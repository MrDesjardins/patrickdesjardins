{"expireTime":9007200886478392000,"key":"gatsby-plugin-mdx-entire-payload-884d636aba7e22cba763a07d5daa31ce--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"What is the difference between implicit and explicit interface?","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":64,"offset":64},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":64,"offset":64},"indent":[]}},{"type":"paragraph","children":[{"type":"image","title":null,"url":"images/ImplicitExplicitInterface-400x228.png","alt":null,"position":{"start":{"line":4,"column":1,"offset":66},"end":{"line":4,"column":50,"offset":115},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":66},"end":{"line":4,"column":50,"offset":115},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Implicit interface allow access the the method without having to cast the object to the interface type while explicit interface require you to cast your object to the interface. Why would you want to have explicit interface? Because if you have several method from different interface with the same signature, the only way to call the good method is to do it explicitly.","position":{"start":{"line":6,"column":1,"offset":117},"end":{"line":6,"column":371,"offset":487},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":117},"end":{"line":6,"column":371,"offset":487},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Here is an example of an implicit interface: ","position":{"start":{"line":8,"column":1,"offset":489},"end":{"line":8,"column":46,"offset":534},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":489},"end":{"line":8,"column":46,"offset":534},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public class Interface : IInterface { public void Method1() { throw new NotImplementedException(); } } ","position":{"start":{"line":9,"column":1,"offset":535},"end":{"line":11,"column":4,"offset":653},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Here is an example of an explicit interface: ","position":{"start":{"line":13,"column":1,"offset":655},"end":{"line":13,"column":46,"offset":700},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":655},"end":{"line":13,"column":46,"offset":700},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public class Interface : IInterface { public void IInterface.Method1() { throw new NotImplementedException(); } } ","position":{"start":{"line":14,"column":1,"offset":701},"end":{"line":16,"column":4,"offset":830},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"And you can use both in the same time: ","position":{"start":{"line":18,"column":1,"offset":832},"end":{"line":18,"column":40,"offset":871},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":832},"end":{"line":18,"column":40,"offset":871},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public class Interface : IInterface { void Method1() { throw new NotImplementedException(); }\n\nvoid IInterface.Method1() { throw new NotImplementedException(); } } ","position":{"start":{"line":19,"column":1,"offset":872},"end":{"line":23,"column":4,"offset":1051},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Let examine the following code :","position":{"start":{"line":25,"column":1,"offset":1053},"end":{"line":25,"column":33,"offset":1085},"indent":[]}}],"position":{"start":{"line":25,"column":1,"offset":1053},"end":{"line":25,"column":33,"offset":1085},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" class Program { static void Main(string[] args) { var x = new Interface(); x.Method1(); Console.ReadLine(); } }\n\npublic class Interface : IInterface, IInterfaceWithSameMethodSignature { public void Method1() { Console.WriteLine(\"IInterface:Method1 Implicit\"); }\n\nvoid IInterface.Method1() { Console.WriteLine(\"IInterface:Method1\"); }\n\nvoid IInterfaceWithSameMethodSignature.Method1() { Console.WriteLine(\"IInterfaceWithSameMethodSignature:Method1\"); } }\n\ninterface IInterface { void Method1(); } interface IInterfaceWithSameMethodSignature { void Method1(); } ","position":{"start":{"line":28,"column":1,"offset":1088},"end":{"line":38,"column":4,"offset":1663},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"As you can see, the Main method has a variable named 'x'. If we check the IntelliSence we see only the first Method1() of the Interface class. The reason is that we pass through the implicit method. If we want to use the explicit Method of the IInterface we need to cast 'x'. ","position":{"start":{"line":40,"column":1,"offset":1665},"end":{"line":40,"column":277,"offset":1941},"indent":[]}}],"position":{"start":{"line":40,"column":1,"offset":1665},"end":{"line":40,"column":277,"offset":1941},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" Interface x = new Interface(); x.Method1(); //Implicit prints: \"IInterface:Method1 Implicit\" ((IInterface)x).Method1(); //Explicit 1 prints: \"IInterface:Method1\" ((IInterfaceWithSameMethodSignature)x).Method1(); //Explicit 2 prints: \"IInterfaceWithSameMethodSignature:Method1\" ","position":{"start":{"line":41,"column":1,"offset":1942},"end":{"line":43,"column":4,"offset":2234},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This is handy because it disambiguates which methods to be called. This can be handy if the object is passed to a method that require the interface in a parameter. This one is cast when passed by parameters.","position":{"start":{"line":45,"column":1,"offset":2236},"end":{"line":45,"column":208,"offset":2443},"indent":[]}}],"position":{"start":{"line":45,"column":1,"offset":2236},"end":{"line":45,"column":208,"offset":2443},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" class Program { static void Main(string[] args) { var x = new Interface(); Method(x);\n\nConsole.ReadLine(); }\n\nstatic void Method(IInterfaceWithSameMethodSignature expl) { expl.Method1(); } } \n``` The Interface class is used with the x object. This one is passed to a method that require the interface _IInterfaceWithSameMethodSignature_. When Method1 is called, the one of _IInterfaceWithSameMethodSignature_ is called, the explicit method.\n\n\nexport const _frontmatter = {\"title\":\"Implicit Implementation of Interface vs Explicit Implementation of Interface\",\"date\":\"2013-10-22\",\"categories\":[\"c-sharp\"]}","position":{"start":{"line":48,"column":1,"offset":2446},"end":{"line":57,"column":162,"offset":3061},"indent":[1,1,1,1,1,1,1,1,1]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":57,"column":162,"offset":3061}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"What is the difference between implicit and explicit interface?\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"400px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/faa125b325f6585306076ff315dab6b3/e17e5/ImplicitExplicitInterface-400x228.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"57.00000000000001%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABX0lEQVQoz42Sy27bMBBF9f9/VKTLLorumkdbIIvYiiXLskKJokiJFIenkJ04cJsWGuCAT1wOZ24WJTCOQteCHaBtA6p9oWtnmuNM1/UopZCUSCvIAPreMQyRaQLnIs5ZplEYBsG5kWEYVomdBEMIhOABARLX8b5eLSgi/zx8Ez3fWUMiW+q020XUi1AfI41xVNqi3cRTWfGwzXmqD4QZJEEUkFfm+E48kcistczzfFJfMnljiU2+oSgesWaH0TuGvjjzOg/TgdnX+LFisiXBW7Il1XOtruu3aIaxRB2+cff9E78ePvPz/oYf9zeXMd98oSq+Ytpb+vYWaxWZ6YXDIaE11FqRN3tKVSMScaNwbCOboiffD2z3hufKXlj2t6Wh0YlGg5uEbJoCxghKRepjTVVXaNOfm5LSB53/KNLFJacve58wJtJrje403oerbov8nyvbeO9JKf795krf/enD30/JWRnAeyzAAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"ImplicitExplicitInterface 400x228\",\n    \"title\": \"ImplicitExplicitInterface 400x228\",\n    \"src\": \"/static/faa125b325f6585306076ff315dab6b3/e17e5/ImplicitExplicitInterface-400x228.png\",\n    \"srcSet\": [\"/static/faa125b325f6585306076ff315dab6b3/5a46d/ImplicitExplicitInterface-400x228.png 300w\", \"/static/faa125b325f6585306076ff315dab6b3/e17e5/ImplicitExplicitInterface-400x228.png 400w\"],\n    \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Implicit interface allow access the the method without having to cast the object to the interface type while explicit interface require you to cast your object to the interface. Why would you want to have explicit interface? Because if you have several method from different interface with the same signature, the only way to call the good method is to do it explicitly.\"), mdx(\"p\", null, \"Here is an example of an implicit interface: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class Interface : IInterface { public void Method1() { throw new NotImplementedException(); } } \\n\")), mdx(\"p\", null, \"Here is an example of an explicit interface: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class Interface : IInterface { public void IInterface.Method1() { throw new NotImplementedException(); } } \\n\")), mdx(\"p\", null, \"And you can use both in the same time: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class Interface : IInterface { void Method1() { throw new NotImplementedException(); }\\n\\nvoid IInterface.Method1() { throw new NotImplementedException(); } } \\n\")), mdx(\"p\", null, \"Let examine the following code :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" class Program { static void Main(string[] args) { var x = new Interface(); x.Method1(); Console.ReadLine(); } }\\n\\npublic class Interface : IInterface, IInterfaceWithSameMethodSignature { public void Method1() { Console.WriteLine(\\\"IInterface:Method1 Implicit\\\"); }\\n\\nvoid IInterface.Method1() { Console.WriteLine(\\\"IInterface:Method1\\\"); }\\n\\nvoid IInterfaceWithSameMethodSignature.Method1() { Console.WriteLine(\\\"IInterfaceWithSameMethodSignature:Method1\\\"); } }\\n\\ninterface IInterface { void Method1(); } interface IInterfaceWithSameMethodSignature { void Method1(); } \\n\")), mdx(\"p\", null, \"As you can see, the Main method has a variable named 'x'. If we check the IntelliSence we see only the first Method1() of the Interface class. The reason is that we pass through the implicit method. If we want to use the explicit Method of the IInterface we need to cast 'x'. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" Interface x = new Interface(); x.Method1(); //Implicit prints: \\\"IInterface:Method1 Implicit\\\" ((IInterface)x).Method1(); //Explicit 1 prints: \\\"IInterface:Method1\\\" ((IInterfaceWithSameMethodSignature)x).Method1(); //Explicit 2 prints: \\\"IInterfaceWithSameMethodSignature:Method1\\\" \\n\")), mdx(\"p\", null, \"This is handy because it disambiguates which methods to be called. This can be handy if the object is passed to a method that require the interface in a parameter. This one is cast when passed by parameters.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" class Program { static void Main(string[] args) { var x = new Interface(); Method(x);\\n\\nConsole.ReadLine(); }\\n\\nstatic void Method(IInterfaceWithSameMethodSignature expl) { expl.Method1(); } } \\n``` The Interface class is used with the x object. This one is passed to a method that require the interface _IInterfaceWithSameMethodSignature_. When Method1 is called, the one of _IInterfaceWithSameMethodSignature_ is called, the explicit method.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"Implicit Implementation of Interface vs Explicit Implementation of Interface\\\",\\\"date\\\":\\\"2013-10-22\\\",\\\"categories\\\":[\\\"c-sharp\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`What is the difference between implicit and explicit interface?`}</p>\n    <p><span parentName=\"p\" {...{\n        \"className\": \"gatsby-resp-image-wrapper\",\n        \"style\": {\n          \"position\": \"relative\",\n          \"display\": \"block\",\n          \"marginLeft\": \"auto\",\n          \"marginRight\": \"auto\",\n          \"maxWidth\": \"400px\"\n        }\n      }}>{`\n      `}<a parentName=\"span\" {...{\n          \"className\": \"gatsby-resp-image-link\",\n          \"href\": \"/static/faa125b325f6585306076ff315dab6b3/e17e5/ImplicitExplicitInterface-400x228.png\",\n          \"style\": {\n            \"display\": \"block\"\n          },\n          \"target\": \"_blank\",\n          \"rel\": \"noopener\"\n        }}>{`\n    `}<span parentName=\"a\" {...{\n            \"className\": \"gatsby-resp-image-background-image\",\n            \"style\": {\n              \"paddingBottom\": \"57.00000000000001%\",\n              \"position\": \"relative\",\n              \"bottom\": \"0\",\n              \"left\": \"0\",\n              \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABX0lEQVQoz42Sy27bMBBF9f9/VKTLLorumkdbIIvYiiXLskKJokiJFIenkJ04cJsWGuCAT1wOZ24WJTCOQteCHaBtA6p9oWtnmuNM1/UopZCUSCvIAPreMQyRaQLnIs5ZplEYBsG5kWEYVomdBEMIhOABARLX8b5eLSgi/zx8Ez3fWUMiW+q020XUi1AfI41xVNqi3cRTWfGwzXmqD4QZJEEUkFfm+E48kcistczzfFJfMnljiU2+oSgesWaH0TuGvjjzOg/TgdnX+LFisiXBW7Il1XOtruu3aIaxRB2+cff9E78ePvPz/oYf9zeXMd98oSq+Ytpb+vYWaxWZ6YXDIaE11FqRN3tKVSMScaNwbCOboiffD2z3hufKXlj2t6Wh0YlGg5uEbJoCxghKRepjTVVXaNOfm5LSB53/KNLFJacve58wJtJrje403oerbov8nyvbeO9JKf795krf/enD30/JWRnAeyzAAAAAAElFTkSuQmCC')\",\n              \"backgroundSize\": \"cover\",\n              \"display\": \"block\"\n            }\n          }}></span>{`\n  `}<img parentName=\"a\" {...{\n            \"className\": \"gatsby-resp-image-image\",\n            \"alt\": \"ImplicitExplicitInterface 400x228\",\n            \"title\": \"ImplicitExplicitInterface 400x228\",\n            \"src\": \"/static/faa125b325f6585306076ff315dab6b3/e17e5/ImplicitExplicitInterface-400x228.png\",\n            \"srcSet\": [\"/static/faa125b325f6585306076ff315dab6b3/5a46d/ImplicitExplicitInterface-400x228.png 300w\", \"/static/faa125b325f6585306076ff315dab6b3/e17e5/ImplicitExplicitInterface-400x228.png 400w\"],\n            \"sizes\": \"(max-width: 400px) 100vw, 400px\",\n            \"style\": {\n              \"width\": \"100%\",\n              \"height\": \"100%\",\n              \"margin\": \"0\",\n              \"verticalAlign\": \"middle\",\n              \"position\": \"absolute\",\n              \"top\": \"0\",\n              \"left\": \"0\"\n            },\n            \"loading\": \"lazy\",\n            \"decoding\": \"async\"\n          }}></img>{`\n  `}</a>{`\n    `}</span></p>\n    <p>{`Implicit interface allow access the the method without having to cast the object to the interface type while explicit interface require you to cast your object to the interface. Why would you want to have explicit interface? Because if you have several method from different interface with the same signature, the only way to call the good method is to do it explicitly.`}</p>\n    <p>{`Here is an example of an implicit interface: `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public class Interface : IInterface { public void Method1() { throw new NotImplementedException(); } } \n`}</code></pre>\n    <p>{`Here is an example of an explicit interface: `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public class Interface : IInterface { public void IInterface.Method1() { throw new NotImplementedException(); } } \n`}</code></pre>\n    <p>{`And you can use both in the same time: `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public class Interface : IInterface { void Method1() { throw new NotImplementedException(); }\n\nvoid IInterface.Method1() { throw new NotImplementedException(); } } \n`}</code></pre>\n    <p>{`Let examine the following code :`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` class Program { static void Main(string[] args) { var x = new Interface(); x.Method1(); Console.ReadLine(); } }\n\npublic class Interface : IInterface, IInterfaceWithSameMethodSignature { public void Method1() { Console.WriteLine(\"IInterface:Method1 Implicit\"); }\n\nvoid IInterface.Method1() { Console.WriteLine(\"IInterface:Method1\"); }\n\nvoid IInterfaceWithSameMethodSignature.Method1() { Console.WriteLine(\"IInterfaceWithSameMethodSignature:Method1\"); } }\n\ninterface IInterface { void Method1(); } interface IInterfaceWithSameMethodSignature { void Method1(); } \n`}</code></pre>\n    <p>{`As you can see, the Main method has a variable named 'x'. If we check the IntelliSence we see only the first Method1() of the Interface class. The reason is that we pass through the implicit method. If we want to use the explicit Method of the IInterface we need to cast 'x'. `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` Interface x = new Interface(); x.Method1(); //Implicit prints: \"IInterface:Method1 Implicit\" ((IInterface)x).Method1(); //Explicit 1 prints: \"IInterface:Method1\" ((IInterfaceWithSameMethodSignature)x).Method1(); //Explicit 2 prints: \"IInterfaceWithSameMethodSignature:Method1\" \n`}</code></pre>\n    <p>{`This is handy because it disambiguates which methods to be called. This can be handy if the object is passed to a method that require the interface in a parameter. This one is cast when passed by parameters.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` class Program { static void Main(string[] args) { var x = new Interface(); Method(x);\n\nConsole.ReadLine(); }\n\nstatic void Method(IInterfaceWithSameMethodSignature expl) { expl.Method1(); } } \n\\`\\`\\` The Interface class is used with the x object. This one is passed to a method that require the interface _IInterfaceWithSameMethodSignature_. When Method1 is called, the one of _IInterfaceWithSameMethodSignature_ is called, the explicit method.\n\n\nexport const _frontmatter = {\"title\":\"Implicit Implementation of Interface vs Explicit Implementation of Interface\",\"date\":\"2013-10-22\",\"categories\":[\"c-sharp\"]}\n`}</code></pre>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}