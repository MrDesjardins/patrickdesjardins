{"expireTime":9007200886478391000,"key":"gatsby-plugin-mdx-entire-payload-dab1347bc009526b0ee2e722d3b6227d--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"The TemplateInfo contains an interesting method which is ","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":58,"offset":58},"indent":[]}},{"type":"strong","children":[{"type":"emphasis","children":[{"type":"text","value":"HtmlFieldPrefix","position":{"start":{"line":2,"column":61,"offset":61},"end":{"line":2,"column":76,"offset":76},"indent":[]}}],"position":{"start":{"line":2,"column":60,"offset":60},"end":{"line":2,"column":77,"offset":77},"indent":[]}}],"position":{"start":{"line":2,"column":58,"offset":58},"end":{"line":2,"column":79,"offset":79},"indent":[]}},{"type":"text","value":" property. This property gives the same information than the method ","position":{"start":{"line":2,"column":79,"offset":79},"end":{"line":2,"column":147,"offset":147},"indent":[]}},{"type":"emphasis","children":[{"type":"strong","children":[{"type":"text","value":"GetFullHtmlFieldName(string.Empty)","position":{"start":{"line":2,"column":150,"offset":150},"end":{"line":2,"column":184,"offset":184},"indent":[]}}],"position":{"start":{"line":2,"column":148,"offset":148},"end":{"line":2,"column":186,"offset":186},"indent":[]}}],"position":{"start":{"line":2,"column":147,"offset":147},"end":{"line":2,"column":187,"offset":187},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":2,"column":187,"offset":187},"end":{"line":2,"column":188,"offset":188},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":188,"offset":188},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"What is interesting is that from an editor template you can know the property name which is sometime primordial if you want to build your editor or display template. This is required to be able to bind with the ModelBinder back the information to the server once the user will submit the page back to the server.","position":{"start":{"line":4,"column":1,"offset":190},"end":{"line":4,"column":313,"offset":502},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":190},"end":{"line":4,"column":313,"offset":502},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"For example, if you have a special editor template for a string, you can add on your property (usually over the property of your view model or model) the ","position":{"start":{"line":6,"column":1,"offset":504},"end":{"line":6,"column":155,"offset":658},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"UIHint","position":{"start":{"line":6,"column":156,"offset":659},"end":{"line":6,"column":162,"offset":665},"indent":[]}}],"position":{"start":{"line":6,"column":155,"offset":658},"end":{"line":6,"column":163,"offset":666},"indent":[]}},{"type":"text","value":" to make a link between the property and the template. Then, in the template you could create your control.","position":{"start":{"line":6,"column":163,"offset":666},"end":{"line":6,"column":270,"offset":773},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":504},"end":{"line":6,"column":270,"offset":773},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" @model string\n\n@{ var controlPropertyName = ViewData.TemplateInfo.HtmlFieldPrefix <input id=\"@controlPropertyName\" name=\"@controlPropertyName\" value=\"...\"> <input id=\"............... } ","position":{"start":{"line":9,"column":1,"offset":776},"end":{"line":13,"column":4,"offset":976},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The short snippet above show you what from a single property, you could have multiple input with different names and the one that will be bound will be the one that came from the ViewData.TemplateInfo.","position":{"start":{"line":15,"column":1,"offset":978},"end":{"line":15,"column":202,"offset":1179},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":978},"end":{"line":15,"column":202,"offset":1179},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Having several input may be something required in scenarios of multiple list of elements that needs to be selected for example. Let say that you have a textbox which can be loaded from a list of value. The template will contain the input with the property name to be bound later to the view model (or model) and others input are there only to select a possible value (via Javascript).","position":{"start":{"line":17,"column":1,"offset":1181},"end":{"line":17,"column":385,"offset":1565},"indent":[]}}],"position":{"start":{"line":17,"column":1,"offset":1181},"end":{"line":17,"column":385,"offset":1565},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Asp.Net MVC and the ViewData's TemplateInfo\",\"date\":\"2013-06-15\",\"categories\":[\"asp-mvc\"]}","position":{"start":{"line":20,"column":1,"offset":1568},"end":{"line":20,"column":129,"offset":1696},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":20,"column":129,"offset":1696}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Asp.Net MVC and the ViewData's TemplateInfo\",\n  \"date\": \"2013-06-15\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The TemplateInfo contains an interesting method which is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"HtmlFieldPrefix\")), \" property. This property gives the same information than the method \", mdx(\"em\", {\n    parentName: \"p\"\n  }, mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"GetFullHtmlFieldName(string.Empty)\")), \".\"), mdx(\"p\", null, \"What is interesting is that from an editor template you can know the property name which is sometime primordial if you want to build your editor or display template. This is required to be able to bind with the ModelBinder back the information to the server once the user will submit the page back to the server.\"), mdx(\"p\", null, \"For example, if you have a special editor template for a string, you can add on your property (usually over the property of your view model or model) the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UIHint\"), \" to make a link between the property and the template. Then, in the template you could create your control.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" @model string\\n\\n@{ var controlPropertyName = ViewData.TemplateInfo.HtmlFieldPrefix <input id=\\\"@controlPropertyName\\\" name=\\\"@controlPropertyName\\\" value=\\\"...\\\"> <input id=\\\"............... } \\n\")), mdx(\"p\", null, \"The short snippet above show you what from a single property, you could have multiple input with different names and the one that will be bound will be the one that came from the ViewData.TemplateInfo.\"), mdx(\"p\", null, \"Having several input may be something required in scenarios of multiple list of elements that needs to be selected for example. Let say that you have a textbox which can be loaded from a list of value. The template will contain the input with the property name to be bound later to the view model (or model) and others input are there only to select a possible value (via Javascript).\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Asp.Net MVC and the ViewData's TemplateInfo\",\n  \"date\": \"2013-06-15\",\n  \"categories\": [\"asp-mvc\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`The TemplateInfo contains an interesting method which is `}<strong parentName=\"p\"><em parentName=\"strong\">{`HtmlFieldPrefix`}</em></strong>{` property. This property gives the same information than the method `}<em parentName=\"p\"><strong parentName=\"em\">{`GetFullHtmlFieldName(string.Empty)`}</strong></em>{`.`}</p>\n    <p>{`What is interesting is that from an editor template you can know the property name which is sometime primordial if you want to build your editor or display template. This is required to be able to bind with the ModelBinder back the information to the server once the user will submit the page back to the server.`}</p>\n    <p>{`For example, if you have a special editor template for a string, you can add on your property (usually over the property of your view model or model) the `}<em parentName=\"p\">{`UIHint`}</em>{` to make a link between the property and the template. Then, in the template you could create your control.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` @model string\n\n@{ var controlPropertyName = ViewData.TemplateInfo.HtmlFieldPrefix <input id=\"@controlPropertyName\" name=\"@controlPropertyName\" value=\"...\"> <input id=\"............... } \n`}</code></pre>\n    <p>{`The short snippet above show you what from a single property, you could have multiple input with different names and the one that will be bound will be the one that came from the ViewData.TemplateInfo.`}</p>\n    <p>{`Having several input may be something required in scenarios of multiple list of elements that needs to be selected for example. Let say that you have a textbox which can be loaded from a list of value. The template will contain the input with the property name to be bound later to the view model (or model) and others input are there only to select a possible value (via Javascript).`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}