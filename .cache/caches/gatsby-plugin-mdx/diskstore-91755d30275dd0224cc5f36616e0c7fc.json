{"expireTime":9007200886478387000,"key":"gatsby-plugin-mdx-entire-payload-c647dbaffef5b5ca818f25e3863ba42a--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"In a previous post, I wrote how to enhance the standard ","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":57,"offset":57},"indent":[]}},{"type":"link","title":null,"url":"./asp-net-mvc-localized-url-without-having-to-specify-the-language-in-it","children":[{"type":"text","value":"Asp.Net MVC Routing to have localized URL with controller and action","position":{"start":{"line":2,"column":58,"offset":58},"end":{"line":2,"column":126,"offset":126},"indent":[]}}],"position":{"start":{"line":2,"column":57,"offset":57},"end":{"line":2,"column":201,"offset":201},"indent":[]}},{"type":"text","value":". This solution had some flaws that this article will cover. First of all, it was not working with area. Second, you were not able to use all functionalities like constraints and default values and third, it was a lot of configuration by having to use a lot of lists.","position":{"start":{"line":2,"column":201,"offset":201},"end":{"line":2,"column":468,"offset":468},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":468,"offset":468},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This article illustrates an easier way to define your routing configuration by adding a Fluent API but also by giving you all standard routing capabilities. This solution will let you configure every route possibles : values, defaults values, constraints, etc and will enhance the standard MVC routing by figuring out which language to display all your resources by setting the culture for you.","position":{"start":{"line":4,"column":1,"offset":470},"end":{"line":4,"column":395,"offset":864},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":470},"end":{"line":4,"column":395,"offset":864},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Before going any further, here is an example of what the system let you use without Fluent API.","position":{"start":{"line":6,"column":1,"offset":866},"end":{"line":6,"column":96,"offset":961},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":866},"end":{"line":6,"column":96,"offset":961},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" var controllerRoutes = new List<ControllerSectionLocalized>{ new ControllerSectionLocalized(\"Home\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Home\") ,new LocalizedSection(LocalizedSection.FR, \"Demarrer\") } ,new List<ActionSectionLocalized>{ new ActionSectionLocalized(\"Index\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Index\") ,new LocalizedSection(LocalizedSection.FR, \"Index\") } , new { id = \"\"} , null , \"{controller}/{action}/{id}\" )\n\n}) , new ControllerSectionLocalized(\"Account\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Account\") ,new LocalizedSection(LocalizedSection.FR, \"Compte\") } ,new List<ActionSectionLocalized>{ new ActionSectionLocalized(\"Profile\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Profile\") ,new LocalizedSection(LocalizedSection.FR, \"Profile\") } , new {username = UrlParameter.Optional } , null , \"{action}/{username}\" ) , new ActionSectionLocalized(\"DisplayBadges\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Badges\") ,new LocalizedSection(LocalizedSection.FR, \"Medailles\") } , null , null , \"{action}\" ) , new ActionSectionLocalized(\"Privilege\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Privilege-benefits\") ,new LocalizedSection(LocalizedSection.FR, \"benefice-des-privileges\") } , null , null , \"{action}\" ) , new ActionSectionLocalized(\"PrivilegeBuyConfirm\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Privilege-buy-confirm\") ,new LocalizedSection(LocalizedSection.FR, \"confirmation-achat-privilege\") } , null , null , \"{action}\" ) , new ActionSectionLocalized(\"Login\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Login\") ,new LocalizedSection(LocalizedSection.FR, \"Identification\") } , null , null , \"{controller}/{action}\" ) , new ActionSectionLocalized(\"ReSendingCreationEmail\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"SendValidationMail\") ,new LocalizedSection(LocalizedSection.FR, \"EnvoieCourrielDeValidation\") } , null , null , \"{controller}/{action}/{emailAddress}/now\"/* We need to be able to have more than just action translated but also text token for e.g. NOW*/ ) , new ActionSectionLocalized(\"ActivateAccount\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"ActivateAccount\") ,new LocalizedSection(LocalizedSection.FR, \"activer-compte\") } , null , null , \"{controller}/{action}/{emailAddress}/now\"/* We need to be able to have more than just action translated but also text token for e.g. NOW*/ ) } ) }; ","position":{"start":{"line":9,"column":1,"offset":964},"end":{"line":13,"column":4,"offset":3622},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"And with the Fluent Routing API:","position":{"start":{"line":15,"column":1,"offset":3624},"end":{"line":15,"column":33,"offset":3656},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":3624},"end":{"line":15,"column":33,"offset":3656},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" var controllerRoutes = FluentLocalizedRoute.BuildRoute() .ForBilingualController(\"Home\", \"Home\", \"Demarrer\") .WithBilingualAction(\"Index\", \"Index\", \"Index\") .WithDefaultValues(new { id = \"\" }) .UseDefaulUrl() .ForBilingualController(\"Account\", \"Account\", \"Compte\") .WithBilingualAction(\"Profile\", \"Profile\", \"Profile\") .WithDefaultValues(new { username = UrlParameter.Optional }) .WithUrl(\"{action}/{username}\") .And().WithBilingualAction(\"DisplayBadges\", \"Badges\", \"Medailles\") .WithUrl(\"{action}\") .And().WithBilingualAction(\"Privilege\", \"Privilege-benefits\", \"benefice-des-privileges\") .WithUrl(\"{action}\") .And().WithBilingualAction(\"PrivilegeBuyConfirm\", \"Privilege-buy-confirm\", \"confirmation-achat-privilege\") .WithUrl(\"{action}\") .And().WithBilingualAction(\"Login\", \"Login\", \"Identification\") .WithUrl(\"{controller}/{action}\") .And().WithBilingualAction(\"ReSendingCreationEmail\", \"SendValidationMail\", \"EnvoieCourrielDeValidation\") .WithUrl(\"{controller}/{action}/{emailAddress}/now\") .And().WithBilingualAction(\"ActivateAccount\", \"ActivateAccount\", \"activer-compte\") .WithUrl(\"{controller}/{action}/{emailAddress}/now\") .ToList() ; ","position":{"start":{"line":18,"column":1,"offset":3659},"end":{"line":20,"column":4,"offset":4815},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"As you can see, it's way more concise. Of course, the method used in the API focus on 2 languages but underneath you can have unlimited localization -- it's just more convenient for a lot of people to have a bilingual application, thus these helper methods. So what does this localized code will give you:","position":{"start":{"line":22,"column":1,"offset":4817},"end":{"line":22,"column":306,"offset":5122},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":4817},"end":{"line":22,"column":306,"offset":5122},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Url that can be in an unlimited language bound to Mvc code","position":{"start":{"line":24,"column":3,"offset":5126},"end":{"line":24,"column":61,"offset":5184},"indent":[]}}],"position":{"start":{"line":24,"column":3,"offset":5126},"end":{"line":24,"column":61,"offset":5184},"indent":[]}}],"position":{"start":{"line":24,"column":1,"offset":5124},"end":{"line":24,"column":61,"offset":5184},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Url that change the Culture and CultureUI without having to specify the local like en-us or fr-ca","position":{"start":{"line":25,"column":3,"offset":5187},"end":{"line":25,"column":100,"offset":5284},"indent":[]}}],"position":{"start":{"line":25,"column":3,"offset":5187},"end":{"line":25,"column":100,"offset":5284},"indent":[]}}],"position":{"start":{"line":25,"column":1,"offset":5185},"end":{"line":25,"column":100,"offset":5284},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"A system that handles Area, Controller and Action to be translated","position":{"start":{"line":26,"column":3,"offset":5287},"end":{"line":26,"column":69,"offset":5353},"indent":[]}}],"position":{"start":{"line":26,"column":3,"offset":5287},"end":{"line":26,"column":69,"offset":5353},"indent":[]}}],"position":{"start":{"line":26,"column":1,"offset":5285},"end":{"line":26,"column":69,"offset":5353},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"A system that generate subsequent URL with the default Asp.Net MVC Helper in the right language","position":{"start":{"line":27,"column":3,"offset":5356},"end":{"line":27,"column":98,"offset":5451},"indent":[]}}],"position":{"start":{"line":27,"column":3,"offset":5356},"end":{"line":27,"column":98,"offset":5451},"indent":[]}}],"position":{"start":{"line":27,"column":1,"offset":5354},"end":{"line":27,"column":98,"offset":5451},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"A system compatible with the current Asp.Net routing system, thus both can be run in parallel","position":{"start":{"line":28,"column":3,"offset":5454},"end":{"line":28,"column":96,"offset":5547},"indent":[]}}],"position":{"start":{"line":28,"column":3,"offset":5454},"end":{"line":28,"column":96,"offset":5547},"indent":[]}}],"position":{"start":{"line":28,"column":1,"offset":5452},"end":{"line":28,"column":96,"offset":5547},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"A Fluent API that let you write quickly routing","position":{"start":{"line":29,"column":3,"offset":5550},"end":{"line":29,"column":50,"offset":5597},"indent":[]}}],"position":{"start":{"line":29,"column":3,"offset":5550},"end":{"line":29,"column":50,"offset":5597},"indent":[]}}],"position":{"start":{"line":29,"column":1,"offset":5548},"end":{"line":29,"column":50,"offset":5597},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Full support of current Asp.Net feature with default values, constraints and even with custom language token that can be localized within the URL","position":{"start":{"line":30,"column":3,"offset":5600},"end":{"line":30,"column":148,"offset":5745},"indent":[]}}],"position":{"start":{"line":30,"column":3,"offset":5600},"end":{"line":30,"column":148,"offset":5745},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":5598},"end":{"line":30,"column":148,"offset":5745},"indent":[]}}],"position":{"start":{"line":24,"column":1,"offset":5124},"end":{"line":30,"column":148,"offset":5745},"indent":[1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Let's start without having the Fluent API because the Fluent API it's just something you add above the custom multilanguage Asp.Net Mvc routing system we are developing.","position":{"start":{"line":32,"column":1,"offset":5747},"end":{"line":32,"column":170,"offset":5916},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":5747},"end":{"line":32,"column":170,"offset":5916},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The first class that we need is the one that will hold the localized string.","position":{"start":{"line":34,"column":1,"offset":5918},"end":{"line":34,"column":77,"offset":5994},"indent":[]}}],"position":{"start":{"line":34,"column":1,"offset":5918},"end":{"line":34,"column":77,"offset":5994},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public class LocalizedSection { public static CultureInfo EN = CultureInfo.GetCultureInfo(\"en-US\"); public static CultureInfo FR = CultureInfo.GetCultureInfo(\"fr-FR\"); public CultureInfo CultureInfo { get; set; } public string TranslatedValue { get; set; } public LocalizedSection(CultureInfo culture, string translatedValue) { CultureInfo = culture; TranslatedValue = translatedValue; } } ","position":{"start":{"line":37,"column":1,"offset":5997},"end":{"line":39,"column":4,"offset":6402},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This ","position":{"start":{"line":41,"column":1,"offset":6404},"end":{"line":41,"column":6,"offset":6409},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"LocalizedSection","position":{"start":{"line":41,"column":7,"offset":6410},"end":{"line":41,"column":23,"offset":6426},"indent":[]}}],"position":{"start":{"line":41,"column":6,"offset":6409},"end":{"line":41,"column":24,"offset":6427},"indent":[]}},{"type":"text","value":" class is pretty simple by having a single constructor that take a culture and a string that is localized. Some static properties are there because I am developing an English-French system and wanted to have the culture that I will use defined once. Even if everything explained in this article is about a bilingual system in English and French, the system is already in shape to let you use other languages than these two but also more than two. Once you have that class, you need to defines the structure of how we will keep all localized sections for the system. The structure is the same as Asp.Net MVC routing which is area, controller and action. We will build everything to support Area-Controller-Action and Controller-Action. To do so, we need three classes.","position":{"start":{"line":41,"column":24,"offset":6427},"end":{"line":41,"column":791,"offset":7194},"indent":[]}}],"position":{"start":{"line":41,"column":1,"offset":6404},"end":{"line":41,"column":791,"offset":7194},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public class AreaSectionLocalized { public string AreaName { get; set; } public List<LocalizedSection> Translation { get; set; } public List<ControllerSectionLocalized> ControllerTranslations { get; set; }\n\npublic AreaSectionLocalized(string areaName, List<LocalizedSection> translation, List<ControllerSectionLocalized> controllersList) { this.AreaName = areaName; this.Translation = translation; this.ControllerTranslations = controllersList; } } public class ControllerSectionLocalized { public string ControllerName { get; set; } public List<LocalizedSection> Translation { get; set; } public List<ActionSectionLocalized> ActionTranslations { get; set; }\n\npublic ControllerSectionLocalized(string controllerName, List<LocalizedSection> translation, List<ActionSectionLocalized> actionsList) { this.ControllerName = controllerName; this.Translation = translation; this.ActionTranslations = actionsList; } } public class ActionSectionLocalized { public string ActionName { get; set; } public List<LocalizedSection> Translation { get; set; }\n\npublic object Values { get; set; } public object Constraints { get; set; } public string Url { get; set; } public ActionSectionLocalized(string actionName, List<LocalizedSection> translation, object values = null, object constraints = null, string url = \"\") { this.ActionName = actionName; this.Translation = translation; this.Values = values; this.Constraints = constraints; this.Url = url; } public Dictionary<string,List<LocalizedSection>> Tokens { get; set; } } ","position":{"start":{"line":44,"column":1,"offset":7197},"end":{"line":52,"column":4,"offset":8722},"indent":[1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":54,"column":1,"offset":8724},"end":{"line":54,"column":5,"offset":8728},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"AreaSectionLocalized","position":{"start":{"line":54,"column":6,"offset":8729},"end":{"line":54,"column":26,"offset":8749},"indent":[]}}],"position":{"start":{"line":54,"column":5,"offset":8728},"end":{"line":54,"column":27,"offset":8750},"indent":[]}},{"type":"text","value":" class is the one that contain the real area's name under the property named ","position":{"start":{"line":54,"column":27,"offset":8750},"end":{"line":54,"column":104,"offset":8827},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"AreaName","position":{"start":{"line":54,"column":106,"offset":8829},"end":{"line":54,"column":114,"offset":8837},"indent":[]}}],"position":{"start":{"line":54,"column":104,"offset":8827},"end":{"line":54,"column":116,"offset":8839},"indent":[]}},{"type":"text","value":". This one will be used to map when you request from Mvc Html Helper a route with the real name but also when you specify in the url a localized string from the ","position":{"start":{"line":54,"column":116,"offset":8839},"end":{"line":54,"column":277,"offset":9000},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"Translation","position":{"start":{"line":54,"column":278,"offset":9001},"end":{"line":54,"column":289,"offset":9012},"indent":[]}}],"position":{"start":{"line":54,"column":277,"offset":9000},"end":{"line":54,"column":290,"offset":9013},"indent":[]}},{"type":"text","value":" property. This list, ","position":{"start":{"line":54,"column":290,"offset":9013},"end":{"line":54,"column":312,"offset":9035},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"Translation","position":{"start":{"line":54,"column":313,"offset":9036},"end":{"line":54,"column":324,"offset":9047},"indent":[]}}],"position":{"start":{"line":54,"column":312,"offset":9035},"end":{"line":54,"column":325,"offset":9048},"indent":[]}},{"type":"text","value":" , is where you store the collection of localized area name for this area. For example, if you have an area in your code called \"Order\" than you can have the area to be displayed in the url has \"customer-area\" and \"commande-du-client\". Since it's a list, you can have unlimited translation -- each of them are linked to a ","position":{"start":{"line":54,"column":325,"offset":9048},"end":{"line":54,"column":647,"offset":9370},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"CultureInfo","position":{"start":{"line":54,"column":649,"offset":9372},"end":{"line":54,"column":660,"offset":9383},"indent":[]}}],"position":{"start":{"line":54,"column":647,"offset":9370},"end":{"line":54,"column":662,"offset":9385},"indent":[]}},{"type":"text","value":". The last important property of that class is the collection of controller. As you can see, we are building a three of routing. At the root will be a collection of area, with ","position":{"start":{"line":54,"column":662,"offset":9385},"end":{"line":54,"column":838,"offset":9561},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"AreaSectionLocalized","position":{"start":{"line":54,"column":839,"offset":9562},"end":{"line":54,"column":859,"offset":9582},"indent":[]}}],"position":{"start":{"line":54,"column":838,"offset":9561},"end":{"line":54,"column":860,"offset":9583},"indent":[]}},{"type":"text","value":". Each of area will have a list of controller, which will have a list of action. That is why the ","position":{"start":{"line":54,"column":860,"offset":9583},"end":{"line":54,"column":957,"offset":9680},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"ControllerSectionLocalized","position":{"start":{"line":54,"column":958,"offset":9681},"end":{"line":54,"column":984,"offset":9707},"indent":[]}}],"position":{"start":{"line":54,"column":957,"offset":9680},"end":{"line":54,"column":985,"offset":9708},"indent":[]}},{"type":"text","value":" look alike the area class. The action class, ","position":{"start":{"line":54,"column":985,"offset":9708},"end":{"line":54,"column":1031,"offset":9754},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"ActionSectionLocalized","position":{"start":{"line":54,"column":1032,"offset":9755},"end":{"line":54,"column":1054,"offset":9777},"indent":[]}}],"position":{"start":{"line":54,"column":1031,"offset":9754},"end":{"line":54,"column":1055,"offset":9778},"indent":[]}},{"type":"text","value":" is the class among the three that contains more information. It has also the same principle of having the action name which is the one that the controller class define and use in Asp.Net MVC Url Helper with a list of localized string but also multiple properties. Values, constraints, Url are all information used to build the URL in the standard Asp.Net MVC routing system. Here is a standard route :","position":{"start":{"line":54,"column":1055,"offset":9778},"end":{"line":54,"column":1457,"offset":10180},"indent":[]}}],"position":{"start":{"line":54,"column":1,"offset":8724},"end":{"line":54,"column":1457,"offset":10180},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" routes.MapRoute(Constants.Areas.CONTEST + \"_contest_detail\" , Constants.Areas.CONTEST + \"/{\" + Constants.RoutePortionName.ACTIVE_CURRENT_CONTEST_ID + \"}/Detail\" , new RouteValueDictionary { { Constants.RoutePortionName.ACTION, \"Detail\" }, { Constants.RoutePortionName.CONTROLLER, \"UserContest\" }} , new RouteValueDictionary {{ Constants.RoutePortionName.ACTIVE_CURRENT_CONTEST_ID,@\"\\\\d+\"} }); ","position":{"start":{"line":57,"column":1,"offset":10183},"end":{"line":59,"column":4,"offset":10591},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The second line is the URL, the third line is the value and the forth line is the constraint. We also do the same in the ","position":{"start":{"line":61,"column":1,"offset":10593},"end":{"line":61,"column":122,"offset":10714},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"ActionSectionLocalized","position":{"start":{"line":61,"column":123,"offset":10715},"end":{"line":61,"column":145,"offset":10737},"indent":[]}}],"position":{"start":{"line":61,"column":122,"offset":10714},"end":{"line":61,"column":146,"offset":10738},"indent":[]}},{"type":"text","value":" class. One custom new principle is the Tokens list. This is a dictionary of string that we will replace with a localized string. Item of the list represent a token, every value contains a list of localized text to replace in the URL. That mean that you can create an URL that look like this : \"/{area}/{controller}/{action}/always/{page}/{pagenumber} where the area, controller and action will be replaced with the according value as the standard Asp.Net MVC routing is normally doing, the same is true about the hard-coded \"always\" that will remains the same whatever the language and the {pagenumber} if defined in the URL will be used as a routing variable. The difference is that if we detect that {page} is not used as a routing value that we will lookup in the token list to see if it could be replaced with a localized value. We will see it in more detail later.","position":{"start":{"line":61,"column":146,"offset":10738},"end":{"line":61,"column":1016,"offset":11608},"indent":[]}}],"position":{"start":{"line":61,"column":1,"offset":10593},"end":{"line":61,"column":1016,"offset":11608},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The next one is one of the code class of the system, it's the new route class. This localized route class, named accordingly to its goal ","position":{"start":{"line":63,"column":1,"offset":11610},"end":{"line":63,"column":138,"offset":11747},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"LocalizedClass","position":{"start":{"line":63,"column":139,"offset":11748},"end":{"line":63,"column":153,"offset":11762},"indent":[]}}],"position":{"start":{"line":63,"column":138,"offset":11747},"end":{"line":63,"column":154,"offset":11763},"indent":[]}},{"type":"text","value":", inherit from the Asp.Net MVC's Route class. This way, it's possible to continue to use the same routing system without having to re-invent the wheel.","position":{"start":{"line":63,"column":154,"offset":11763},"end":{"line":63,"column":305,"offset":11914},"indent":[]}}],"position":{"start":{"line":63,"column":1,"offset":11610},"end":{"line":63,"column":305,"offset":11914},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public class LocalizedRoute : Route { public CultureInfo Culture { get; private set; } public ActionSectionLocalized ActionTranslation { get; private set; } public ControllerSectionLocalized ControllerTranslation { get; private set; } public AreaSectionLocalized AreaSectionLocalized { get; private set; }\n\npublic LocalizedRoute(AreaSectionLocalized areaSectionLocalized, ControllerSectionLocalized controllerTranslation, ActionSectionLocalized actionTranslation, string url , RouteValueDictionary defaults, RouteValueDictionary constraints, CultureInfo culture) : this(areaSectionLocalized, controllerTranslation, actionTranslation, url, defaults, constraints, null, new MvcRouteHandler(), culture) {\n\n}\n\npublic LocalizedRoute(AreaSectionLocalized areaSectionLocalized, ControllerSectionLocalized controllerTranslation, ActionSectionLocalized actionTranslation, string url , RouteValueDictionary defaults, RouteValueDictionary constraints, RouteValueDictionary dataTokens, IRouteHandler routeHandler, CultureInfo culture) : base(url, defaults, constraints, dataTokens, routeHandler) { this.AreaSectionLocalized = areaSectionLocalized;\n\nif (controllerTranslation == null) { throw new ArgumentNullException(\"controllerTranslation\"); } this.ControllerTranslation = controllerTranslation; if (actionTranslation == null) { throw new ArgumentNullException(\"actionTranslation\"); } this.ActionTranslation = actionTranslation;\n\nif (url == null) { throw new ArgumentNullException(\"url\"); }\n\nif (culture == null) { throw new ArgumentNullException(\"culture\"); } this.Culture = culture;\n\nif (dataTokens == null) { base.DataTokens = new RouteValueDictionary(); }\n\nif (base.Defaults != null && base.Defaults.Keys.Contains(Constants.AREA)) { if (base.DataTokens == null) { base.DataTokens = new RouteValueDictionary(); } base.DataTokens.Add(Constants.AREA, base.Defaults[Constants.AREA].ToString()); } }\n\n/// <summary> /// Set the thread culture with the route culture /// </summary> /// <param name=\"httpContext\"></param> /// <returns></returns> public override RouteData GetRouteData(HttpContextBase httpContext) { var returnRouteData = base.GetRouteData(httpContext); if (returnRouteData != null) { System.Threading.Thread.CurrentThread.CurrentCulture = this.Culture; System.Threading.Thread.CurrentThread.CurrentUICulture = this.Culture; } return returnRouteData; } protected override bool ProcessConstraint(HttpContextBase httpContext, object constraint, string parameterName, RouteValueDictionary values, RouteDirection routeDirection) { return base.ProcessConstraint(httpContext, constraint, parameterName, values, routeDirection); }\n\npublic override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { var currentThreadCulture = System.Threading.Thread.CurrentThread.CurrentUICulture; //First step is to avoid route in the wrong culture if (this.Culture.Name != currentThreadCulture.Name) { return null; }\n\n//Second, set the right Area/Controller/Action to have MVC generating the URL with the localized string bool replaceRoutingValues = true; LocalizedSection areaTranslated = null; LocalizedSection controllerTranslated = null; LocalizedSection actionTranslated = null; if (this.AreaSectionLocalized != null && values[Constants.AREA] !=null) //If added in the RouteValue, it will be just there later during GetVirtualPath (merge from MVC's route creation code) { var valueToken = values[Constants.AREA]; areaTranslated = this.AreaSectionLocalized.Translation.FirstOrDefault(d => d.CultureInfo.Name == currentThreadCulture.Name); replaceRoutingValues = (areaTranslated != null && areaTranslated.TranslatedValue == valueToken); }\n\nif (replaceRoutingValues && this.ControllerTranslation != null) { var valueToken = values[Constants.CONTROLLER]; controllerTranslated = this.ControllerTranslation.Translation.FirstOrDefault(d => d.CultureInfo.Name == currentThreadCulture.Name); replaceRoutingValues &= (controllerTranslated != null && controllerTranslated.TranslatedValue == valueToken); }\n\nif (replaceRoutingValues && this.ActionTranslation != null) { var valueToken = values[Constants.ACTION]; actionTranslated = this.ActionTranslation.Translation.FirstOrDefault(d => d.CultureInfo.Name == currentThreadCulture.Name); replaceRoutingValues &= (actionTranslated != null && actionTranslated.TranslatedValue == valueToken); }\n\n//We need to find a translation that fit at least Controller and Action //if (!replaceRoutingValues) //{ // return null; //}\n\n//Switch text token to the right language if (this.ActionTranslation != null) { base.Url = ReplaceTokens(base.Url, this.ActionTranslation.Tokens); }\n\n// Check with the new values if the system can get an URL with the values in the culture desired var vitualPathData = this.GetVirtualPathForLocalizedRoute(requestContext, values); //vitualPathData.DataTokens // Asp.Net MVC found a URL, time to enhance the URL with localization replacement if (vitualPathData != null) { //This is to replace {action}, {controller} and {area} with the localized version vitualPathData.VirtualPath = LocalizedSection.ReplaceSection(this.Url, areaTranslated, controllerTranslated, actionTranslated); //Enhance url with replace or append route value dictionary vitualPathData.VirtualPath = AdjustVirtualPathWithRoutes(vitualPathData.VirtualPath, values); //Default value if not defined in the route value vitualPathData.VirtualPath = AdjustVirtualPathWithActionTranslationDefaultValues(vitualPathData.VirtualPath, values); vitualPathData.VirtualPath = vitualPathData.VirtualPath.TrimEnd('/'); } return vitualPathData; }\n\n/// <summary> /// Adjust virtual path with action translation default value not in the route. This is because we can define default and the /// value of default is only used when not more specific from the route. /// /// Route has precedence on Default Value (this.ActionTranslation.Values) /// </summary> /// <param name=\"currentVirtualPath\"></param> /// <param name=\"values\"></param> /// <returns></returns> public string AdjustVirtualPathWithActionTranslationDefaultValues(string currentVirtualPath, RouteValueDictionary values) { if (string.IsNullOrEmpty(currentVirtualPath) || values == null) { return currentVirtualPath; } string finalVirtualPath = currentVirtualPath; //This is for the case that optional parameter in the action are not defined in the URL if (this.ActionTranslation != null) { var rc = new RouteValueDictionary(this.ActionTranslation.Values); // If defined {word} is not in the URL, then we use the value from the actionTranslated foreach (var key in rc.Keys.Where(q => !values.ContainsKey(q))) { string toReplace = \"{\" + key + \"}\"; finalVirtualPath = finalVirtualPath.Replace(toReplace, System.Net.WebUtility.UrlEncode(rc[key].ToString())); } } return finalVirtualPath; }\n\n/// <summary> /// Get all routes information that are not Area-Controller-Action and change the value from the URL. /// If not in the URL, add the data in query string /// </summary> /// <param name=\"currentVirtualPath\"></param> /// <param name=\"values\"></param> /// <returns></returns> public string AdjustVirtualPathWithRoutes(string currentVirtualPath, RouteValueDictionary values) { string finalVirtualPath = currentVirtualPath; if (values != null) { foreach (var key in values.Keys.Where(k => k != Constants.AREA && k != Constants.CONTROLLER && k != Constants.ACTION)) { string toReplace = \"{\" + key + \"}\"; if (values[key] != null) { string replaceWith = System.Net.WebUtility.UrlEncode(values[key].ToString()); if (currentVirtualPath.Contains(toReplace)) { finalVirtualPath = finalVirtualPath.Replace(toReplace, replaceWith); } else { finalVirtualPath = AddKeyValueToUrlAsQueryString(finalVirtualPath, toReplace, replaceWith); } } } }\n\nreturn finalVirtualPath; }\n\npublic string ReplaceTokens(string url, Dictionary<string, List<LocalizedSection>> tokens) { if (tokens!= null) { foreach (var key in tokens.Keys) { var tokenInCurrentCulture = tokens[key].FirstOrDefault(f => f.CultureInfo.Name == this.Culture.Name); if (tokenInCurrentCulture != null) { string toReplace = \"{\" + key + \"}\"; return url.Replace(toReplace, System.Net.WebUtility.UrlEncode(tokenInCurrentCulture.TranslatedValue)); } } } return url; }\n\npublic string AddKeyValueToUrlAsQueryString(string url, string key, string value) { if (!string.IsNullOrEmpty(key) && url!=null) { key = key.Replace(\"{\", \"\").Replace(\"}\", \"\"); if (url.Contains(\"?\")) { return url + \"&\" + key + \"=\" + value; } else { return url + \"?\" + key + \"=\" + value; } } return url; }\n\npublic virtual VirtualPathData GetVirtualPathForLocalizedRoute(RequestContext requestContext, RouteValueDictionary values) { return base.GetVirtualPath(requestContext, values); } } ","position":{"start":{"line":66,"column":1,"offset":11917},"end":{"line":112,"column":4,"offset":20618},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"I will not describe everything since I added comment directly inside the code but the gist of the class is to manipulate the URL and routing by overriding ","position":{"start":{"line":114,"column":1,"offset":20620},"end":{"line":114,"column":156,"offset":20775},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"GetVirtualPath","position":{"start":{"line":114,"column":157,"offset":20776},"end":{"line":114,"column":171,"offset":20790},"indent":[]}}],"position":{"start":{"line":114,"column":156,"offset":20775},"end":{"line":114,"column":172,"offset":20791},"indent":[]}},{"type":"text","value":" to be sure to convert the localized route section requested into the original Area-Controller-Action name, to use the default code to get url that would be generated by ASP.Net MVC and then enhance this one by localizing this one with Area-Controller-Action. You can see the ","position":{"start":{"line":114,"column":172,"offset":20791},"end":{"line":114,"column":448,"offset":21067},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"GetVirtualPath","position":{"start":{"line":114,"column":449,"offset":21068},"end":{"line":114,"column":463,"offset":21082},"indent":[]}}],"position":{"start":{"line":114,"column":448,"offset":21067},"end":{"line":114,"column":464,"offset":21083},"indent":[]}},{"type":"text","value":" as the entry point that is called for every route defined when you use any ASP.Net MVC mechanism to get an URL. The framework loops all the route by calling ","position":{"start":{"line":114,"column":464,"offset":21083},"end":{"line":114,"column":622,"offset":21241},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"GetVirtualPath","position":{"start":{"line":114,"column":623,"offset":21242},"end":{"line":114,"column":637,"offset":21256},"indent":[]}}],"position":{"start":{"line":114,"column":622,"offset":21241},"end":{"line":114,"column":638,"offset":21257},"indent":[]}},{"type":"text","value":" and if one return not NULL, it takes this one.","position":{"start":{"line":114,"column":638,"offset":21257},"end":{"line":114,"column":685,"offset":21304},"indent":[]}}],"position":{"start":{"line":114,"column":1,"offset":20620},"end":{"line":114,"column":685,"offset":21304},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This class also override ","position":{"start":{"line":116,"column":1,"offset":21306},"end":{"line":116,"column":26,"offset":21331},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"GetRouteData","position":{"start":{"line":116,"column":27,"offset":21332},"end":{"line":116,"column":39,"offset":21344},"indent":[]}}],"position":{"start":{"line":116,"column":26,"offset":21331},"end":{"line":116,"column":40,"offset":21345},"indent":[]}},{"type":"text","value":" which is used when the user enter an URL in a browser. That time, since we are still using the default route mechanism and that we store the route with the standard Area-Controller-Action + Constraint that we have almost nothing to do. We only set the current thread Culture from the culture defined by the route.","position":{"start":{"line":116,"column":40,"offset":21345},"end":{"line":116,"column":354,"offset":21659},"indent":[]}}],"position":{"start":{"line":116,"column":1,"offset":21306},"end":{"line":116,"column":354,"offset":21659},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The last remaining piece to be able to have everything work is to create an helper to add localized route to the ASP.Net MVC's ","position":{"start":{"line":118,"column":1,"offset":21661},"end":{"line":118,"column":128,"offset":21788},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"RouteCollection","position":{"start":{"line":118,"column":130,"offset":21790},"end":{"line":118,"column":145,"offset":21805},"indent":[]}}],"position":{"start":{"line":118,"column":128,"offset":21788},"end":{"line":118,"column":147,"offset":21807},"indent":[]}},{"type":"text","value":". I decided to create a static method that take the route and a list of ","position":{"start":{"line":118,"column":147,"offset":21807},"end":{"line":118,"column":219,"offset":21879},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"AreaSectionLocalized","position":{"start":{"line":118,"column":221,"offset":21881},"end":{"line":118,"column":241,"offset":21901},"indent":[]}}],"position":{"start":{"line":118,"column":219,"offset":21879},"end":{"line":118,"column":243,"offset":21903},"indent":[]}},{"type":"text","value":" or ","position":{"start":{"line":118,"column":243,"offset":21903},"end":{"line":118,"column":247,"offset":21907},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"ControllerSectionLocalized","position":{"start":{"line":118,"column":249,"offset":21909},"end":{"line":118,"column":275,"offset":21935},"indent":[]}}],"position":{"start":{"line":118,"column":247,"offset":21907},"end":{"line":118,"column":277,"offset":21937},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":118,"column":277,"offset":21937},"end":{"line":118,"column":278,"offset":21938},"indent":[]}}],"position":{"start":{"line":118,"column":1,"offset":21661},"end":{"line":118,"column":278,"offset":21938},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public static class RouteCollectionExtension {\n\npublic static void AddRoutes(this RouteCollection routes, List<AreaSectionLocalized> areaRoutes) { foreach (var area in areaRoutes) { routes.AddRoutes(area.ControllerTranslations, area); } }\n\npublic static void AddRoutes(this RouteCollection routes, List<ControllerSectionLocalized> controllerRoutes, AreaSectionLocalized areaSectionLocalized = null) { foreach (var controller in controllerRoutes) { foreach (var controllerTranslation in controller.Translation) { foreach (var action in controller.ActionTranslations) { var urlAction = action.Url;\n\nforeach (var actionTranslation in action.Translation) { if (controllerTranslation.CultureInfo == actionTranslation.CultureInfo) { RouteValueDictionary values = null; if (action.Values is RouteValueDictionary) { values = action.Values as RouteValueDictionary; } else { values = new RouteValueDictionary(action.Values); } LocalizedSection areaTranslation = null; if (areaSectionLocalized != null && areaSectionLocalized.Translation.Any(d => d.CultureInfo.Name == controllerTranslation.CultureInfo.Name)) { values[Constants.AREA] = areaSectionLocalized.AreaName; areaTranslation = areaSectionLocalized.Translation.FirstOrDefault(d => d.CultureInfo.Name == controllerTranslation.CultureInfo.Name); } values[Constants.CONTROLLER] = controller.ControllerName; values[Constants.ACTION] = action.ActionName; RouteValueDictionary constraints = null; if (action.Constraints is RouteValueDictionary) { constraints = action.Constraints as RouteValueDictionary; } else { constraints = new RouteValueDictionary(action.Constraints); } var newUrl = LocalizedSection.ReplaceSection(urlAction, areaTranslation, controllerTranslation, actionTranslation); routes.Add(new LocalizedRoute( areaSectionLocalized , controller , action , newUrl , values , constraints , actionTranslation.CultureInfo ) ); } } } } } } } ","position":{"start":{"line":121,"column":1,"offset":21941},"end":{"line":129,"column":4,"offset":23846},"indent":[1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The code is adding a route by looping through all areas, all controllers, all actions and for each language add the route. I will create a second article to describe to Fluent interface that help to have a more concise way to write the routing and also that gives Microsoft Intellisence support. So far, in this article, we have seen how to enhance the existing Asp.Net MVC routing system by having localized route. The code handles the thread culture, thus by changing the URL you have all your pages in the right local too. Finally, we saw that","position":{"start":{"line":131,"column":1,"offset":23848},"end":{"line":131,"column":547,"offset":24394},"indent":[]}}],"position":{"start":{"line":131,"column":1,"offset":23848},"end":{"line":131,"column":547,"offset":24394},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"How to Localized MVC Routing with Area Without Specifying Culture Short Name in the Url\",\"date\":\"2015-12-21\",\"categories\":[\"asp-mvc\"],\"tags\":[\"csharp\",\"css3\",\"dotnet\",\"html5\",\"localization\",\"routing\",\"web\"]}","position":{"start":{"line":134,"column":1,"offset":24397},"end":{"line":134,"column":246,"offset":24642},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":134,"column":246,"offset":24642}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to Localized MVC Routing with Area Without Specifying Culture Short Name in the Url\",\n  \"date\": \"2015-12-21\",\n  \"categories\": [\"asp-mvc\"],\n  \"tags\": [\"csharp\", \"css3\", \"dotnet\", \"html5\", \"localization\", \"routing\", \"web\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In a previous post, I wrote how to enhance the standard \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./asp-net-mvc-localized-url-without-having-to-specify-the-language-in-it\"\n  }, \"Asp.Net MVC Routing to have localized URL with controller and action\"), \". This solution had some flaws that this article will cover. First of all, it was not working with area. Second, you were not able to use all functionalities like constraints and default values and third, it was a lot of configuration by having to use a lot of lists.\"), mdx(\"p\", null, \"This article illustrates an easier way to define your routing configuration by adding a Fluent API but also by giving you all standard routing capabilities. This solution will let you configure every route possibles : values, defaults values, constraints, etc and will enhance the standard MVC routing by figuring out which language to display all your resources by setting the culture for you.\"), mdx(\"p\", null, \"Before going any further, here is an example of what the system let you use without Fluent API.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var controllerRoutes = new List<ControllerSectionLocalized>{ new ControllerSectionLocalized(\\\"Home\\\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \\\"Home\\\") ,new LocalizedSection(LocalizedSection.FR, \\\"Demarrer\\\") } ,new List<ActionSectionLocalized>{ new ActionSectionLocalized(\\\"Index\\\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \\\"Index\\\") ,new LocalizedSection(LocalizedSection.FR, \\\"Index\\\") } , new { id = \\\"\\\"} , null , \\\"{controller}/{action}/{id}\\\" )\\n\\n}) , new ControllerSectionLocalized(\\\"Account\\\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \\\"Account\\\") ,new LocalizedSection(LocalizedSection.FR, \\\"Compte\\\") } ,new List<ActionSectionLocalized>{ new ActionSectionLocalized(\\\"Profile\\\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \\\"Profile\\\") ,new LocalizedSection(LocalizedSection.FR, \\\"Profile\\\") } , new {username = UrlParameter.Optional } , null , \\\"{action}/{username}\\\" ) , new ActionSectionLocalized(\\\"DisplayBadges\\\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \\\"Badges\\\") ,new LocalizedSection(LocalizedSection.FR, \\\"Medailles\\\") } , null , null , \\\"{action}\\\" ) , new ActionSectionLocalized(\\\"Privilege\\\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \\\"Privilege-benefits\\\") ,new LocalizedSection(LocalizedSection.FR, \\\"benefice-des-privileges\\\") } , null , null , \\\"{action}\\\" ) , new ActionSectionLocalized(\\\"PrivilegeBuyConfirm\\\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \\\"Privilege-buy-confirm\\\") ,new LocalizedSection(LocalizedSection.FR, \\\"confirmation-achat-privilege\\\") } , null , null , \\\"{action}\\\" ) , new ActionSectionLocalized(\\\"Login\\\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \\\"Login\\\") ,new LocalizedSection(LocalizedSection.FR, \\\"Identification\\\") } , null , null , \\\"{controller}/{action}\\\" ) , new ActionSectionLocalized(\\\"ReSendingCreationEmail\\\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \\\"SendValidationMail\\\") ,new LocalizedSection(LocalizedSection.FR, \\\"EnvoieCourrielDeValidation\\\") } , null , null , \\\"{controller}/{action}/{emailAddress}/now\\\"/* We need to be able to have more than just action translated but also text token for e.g. NOW*/ ) , new ActionSectionLocalized(\\\"ActivateAccount\\\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \\\"ActivateAccount\\\") ,new LocalizedSection(LocalizedSection.FR, \\\"activer-compte\\\") } , null , null , \\\"{controller}/{action}/{emailAddress}/now\\\"/* We need to be able to have more than just action translated but also text token for e.g. NOW*/ ) } ) }; \\n\")), mdx(\"p\", null, \"And with the Fluent Routing API:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var controllerRoutes = FluentLocalizedRoute.BuildRoute() .ForBilingualController(\\\"Home\\\", \\\"Home\\\", \\\"Demarrer\\\") .WithBilingualAction(\\\"Index\\\", \\\"Index\\\", \\\"Index\\\") .WithDefaultValues(new { id = \\\"\\\" }) .UseDefaulUrl() .ForBilingualController(\\\"Account\\\", \\\"Account\\\", \\\"Compte\\\") .WithBilingualAction(\\\"Profile\\\", \\\"Profile\\\", \\\"Profile\\\") .WithDefaultValues(new { username = UrlParameter.Optional }) .WithUrl(\\\"{action}/{username}\\\") .And().WithBilingualAction(\\\"DisplayBadges\\\", \\\"Badges\\\", \\\"Medailles\\\") .WithUrl(\\\"{action}\\\") .And().WithBilingualAction(\\\"Privilege\\\", \\\"Privilege-benefits\\\", \\\"benefice-des-privileges\\\") .WithUrl(\\\"{action}\\\") .And().WithBilingualAction(\\\"PrivilegeBuyConfirm\\\", \\\"Privilege-buy-confirm\\\", \\\"confirmation-achat-privilege\\\") .WithUrl(\\\"{action}\\\") .And().WithBilingualAction(\\\"Login\\\", \\\"Login\\\", \\\"Identification\\\") .WithUrl(\\\"{controller}/{action}\\\") .And().WithBilingualAction(\\\"ReSendingCreationEmail\\\", \\\"SendValidationMail\\\", \\\"EnvoieCourrielDeValidation\\\") .WithUrl(\\\"{controller}/{action}/{emailAddress}/now\\\") .And().WithBilingualAction(\\\"ActivateAccount\\\", \\\"ActivateAccount\\\", \\\"activer-compte\\\") .WithUrl(\\\"{controller}/{action}/{emailAddress}/now\\\") .ToList() ; \\n\")), mdx(\"p\", null, \"As you can see, it's way more concise. Of course, the method used in the API focus on 2 languages but underneath you can have unlimited localization -- it's just more convenient for a lot of people to have a bilingual application, thus these helper methods. So what does this localized code will give you:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Url that can be in an unlimited language bound to Mvc code\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Url that change the Culture and CultureUI without having to specify the local like en-us or fr-ca\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A system that handles Area, Controller and Action to be translated\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A system that generate subsequent URL with the default Asp.Net MVC Helper in the right language\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A system compatible with the current Asp.Net routing system, thus both can be run in parallel\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A Fluent API that let you write quickly routing\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Full support of current Asp.Net feature with default values, constraints and even with custom language token that can be localized within the URL\")), mdx(\"p\", null, \"Let's start without having the Fluent API because the Fluent API it's just something you add above the custom multilanguage Asp.Net Mvc routing system we are developing.\"), mdx(\"p\", null, \"The first class that we need is the one that will hold the localized string.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class LocalizedSection { public static CultureInfo EN = CultureInfo.GetCultureInfo(\\\"en-US\\\"); public static CultureInfo FR = CultureInfo.GetCultureInfo(\\\"fr-FR\\\"); public CultureInfo CultureInfo { get; set; } public string TranslatedValue { get; set; } public LocalizedSection(CultureInfo culture, string translatedValue) { CultureInfo = culture; TranslatedValue = translatedValue; } } \\n\")), mdx(\"p\", null, \"This \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"LocalizedSection\"), \" class is pretty simple by having a single constructor that take a culture and a string that is localized. Some static properties are there because I am developing an English-French system and wanted to have the culture that I will use defined once. Even if everything explained in this article is about a bilingual system in English and French, the system is already in shape to let you use other languages than these two but also more than two. Once you have that class, you need to defines the structure of how we will keep all localized sections for the system. The structure is the same as Asp.Net MVC routing which is area, controller and action. We will build everything to support Area-Controller-Action and Controller-Action. To do so, we need three classes.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class AreaSectionLocalized { public string AreaName { get; set; } public List<LocalizedSection> Translation { get; set; } public List<ControllerSectionLocalized> ControllerTranslations { get; set; }\\n\\npublic AreaSectionLocalized(string areaName, List<LocalizedSection> translation, List<ControllerSectionLocalized> controllersList) { this.AreaName = areaName; this.Translation = translation; this.ControllerTranslations = controllersList; } } public class ControllerSectionLocalized { public string ControllerName { get; set; } public List<LocalizedSection> Translation { get; set; } public List<ActionSectionLocalized> ActionTranslations { get; set; }\\n\\npublic ControllerSectionLocalized(string controllerName, List<LocalizedSection> translation, List<ActionSectionLocalized> actionsList) { this.ControllerName = controllerName; this.Translation = translation; this.ActionTranslations = actionsList; } } public class ActionSectionLocalized { public string ActionName { get; set; } public List<LocalizedSection> Translation { get; set; }\\n\\npublic object Values { get; set; } public object Constraints { get; set; } public string Url { get; set; } public ActionSectionLocalized(string actionName, List<LocalizedSection> translation, object values = null, object constraints = null, string url = \\\"\\\") { this.ActionName = actionName; this.Translation = translation; this.Values = values; this.Constraints = constraints; this.Url = url; } public Dictionary<string,List<LocalizedSection>> Tokens { get; set; } } \\n\")), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"AreaSectionLocalized\"), \" class is the one that contain the real area's name under the property named \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AreaName\"), \". This one will be used to map when you request from Mvc Html Helper a route with the real name but also when you specify in the url a localized string from the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Translation\"), \" property. This list, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Translation\"), \" , is where you store the collection of localized area name for this area. For example, if you have an area in your code called \\\"Order\\\" than you can have the area to be displayed in the url has \\\"customer-area\\\" and \\\"commande-du-client\\\". Since it's a list, you can have unlimited translation -- each of them are linked to a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CultureInfo\"), \". The last important property of that class is the collection of controller. As you can see, we are building a three of routing. At the root will be a collection of area, with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"AreaSectionLocalized\"), \". Each of area will have a list of controller, which will have a list of action. That is why the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ControllerSectionLocalized\"), \" look alike the area class. The action class, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ActionSectionLocalized\"), \" is the class among the three that contains more information. It has also the same principle of having the action name which is the one that the controller class define and use in Asp.Net MVC Url Helper with a list of localized string but also multiple properties. Values, constraints, Url are all information used to build the URL in the standard Asp.Net MVC routing system. Here is a standard route :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" routes.MapRoute(Constants.Areas.CONTEST + \\\"_contest_detail\\\" , Constants.Areas.CONTEST + \\\"/{\\\" + Constants.RoutePortionName.ACTIVE_CURRENT_CONTEST_ID + \\\"}/Detail\\\" , new RouteValueDictionary { { Constants.RoutePortionName.ACTION, \\\"Detail\\\" }, { Constants.RoutePortionName.CONTROLLER, \\\"UserContest\\\" }} , new RouteValueDictionary {{ Constants.RoutePortionName.ACTIVE_CURRENT_CONTEST_ID,@\\\"\\\\\\\\d+\\\"} }); \\n\")), mdx(\"p\", null, \"The second line is the URL, the third line is the value and the forth line is the constraint. We also do the same in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ActionSectionLocalized\"), \" class. One custom new principle is the Tokens list. This is a dictionary of string that we will replace with a localized string. Item of the list represent a token, every value contains a list of localized text to replace in the URL. That mean that you can create an URL that look like this : \\\"/{area}/{controller}/{action}/always/{page}/{pagenumber} where the area, controller and action will be replaced with the according value as the standard Asp.Net MVC routing is normally doing, the same is true about the hard-coded \\\"always\\\" that will remains the same whatever the language and the {pagenumber} if defined in the URL will be used as a routing variable. The difference is that if we detect that {page} is not used as a routing value that we will lookup in the token list to see if it could be replaced with a localized value. We will see it in more detail later.\"), mdx(\"p\", null, \"The next one is one of the code class of the system, it's the new route class. This localized route class, named accordingly to its goal \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"LocalizedClass\"), \", inherit from the Asp.Net MVC's Route class. This way, it's possible to continue to use the same routing system without having to re-invent the wheel.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class LocalizedRoute : Route { public CultureInfo Culture { get; private set; } public ActionSectionLocalized ActionTranslation { get; private set; } public ControllerSectionLocalized ControllerTranslation { get; private set; } public AreaSectionLocalized AreaSectionLocalized { get; private set; }\\n\\npublic LocalizedRoute(AreaSectionLocalized areaSectionLocalized, ControllerSectionLocalized controllerTranslation, ActionSectionLocalized actionTranslation, string url , RouteValueDictionary defaults, RouteValueDictionary constraints, CultureInfo culture) : this(areaSectionLocalized, controllerTranslation, actionTranslation, url, defaults, constraints, null, new MvcRouteHandler(), culture) {\\n\\n}\\n\\npublic LocalizedRoute(AreaSectionLocalized areaSectionLocalized, ControllerSectionLocalized controllerTranslation, ActionSectionLocalized actionTranslation, string url , RouteValueDictionary defaults, RouteValueDictionary constraints, RouteValueDictionary dataTokens, IRouteHandler routeHandler, CultureInfo culture) : base(url, defaults, constraints, dataTokens, routeHandler) { this.AreaSectionLocalized = areaSectionLocalized;\\n\\nif (controllerTranslation == null) { throw new ArgumentNullException(\\\"controllerTranslation\\\"); } this.ControllerTranslation = controllerTranslation; if (actionTranslation == null) { throw new ArgumentNullException(\\\"actionTranslation\\\"); } this.ActionTranslation = actionTranslation;\\n\\nif (url == null) { throw new ArgumentNullException(\\\"url\\\"); }\\n\\nif (culture == null) { throw new ArgumentNullException(\\\"culture\\\"); } this.Culture = culture;\\n\\nif (dataTokens == null) { base.DataTokens = new RouteValueDictionary(); }\\n\\nif (base.Defaults != null && base.Defaults.Keys.Contains(Constants.AREA)) { if (base.DataTokens == null) { base.DataTokens = new RouteValueDictionary(); } base.DataTokens.Add(Constants.AREA, base.Defaults[Constants.AREA].ToString()); } }\\n\\n/// <summary> /// Set the thread culture with the route culture /// </summary> /// <param name=\\\"httpContext\\\"></param> /// <returns></returns> public override RouteData GetRouteData(HttpContextBase httpContext) { var returnRouteData = base.GetRouteData(httpContext); if (returnRouteData != null) { System.Threading.Thread.CurrentThread.CurrentCulture = this.Culture; System.Threading.Thread.CurrentThread.CurrentUICulture = this.Culture; } return returnRouteData; } protected override bool ProcessConstraint(HttpContextBase httpContext, object constraint, string parameterName, RouteValueDictionary values, RouteDirection routeDirection) { return base.ProcessConstraint(httpContext, constraint, parameterName, values, routeDirection); }\\n\\npublic override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { var currentThreadCulture = System.Threading.Thread.CurrentThread.CurrentUICulture; //First step is to avoid route in the wrong culture if (this.Culture.Name != currentThreadCulture.Name) { return null; }\\n\\n//Second, set the right Area/Controller/Action to have MVC generating the URL with the localized string bool replaceRoutingValues = true; LocalizedSection areaTranslated = null; LocalizedSection controllerTranslated = null; LocalizedSection actionTranslated = null; if (this.AreaSectionLocalized != null && values[Constants.AREA] !=null) //If added in the RouteValue, it will be just there later during GetVirtualPath (merge from MVC's route creation code) { var valueToken = values[Constants.AREA]; areaTranslated = this.AreaSectionLocalized.Translation.FirstOrDefault(d => d.CultureInfo.Name == currentThreadCulture.Name); replaceRoutingValues = (areaTranslated != null && areaTranslated.TranslatedValue == valueToken); }\\n\\nif (replaceRoutingValues && this.ControllerTranslation != null) { var valueToken = values[Constants.CONTROLLER]; controllerTranslated = this.ControllerTranslation.Translation.FirstOrDefault(d => d.CultureInfo.Name == currentThreadCulture.Name); replaceRoutingValues &= (controllerTranslated != null && controllerTranslated.TranslatedValue == valueToken); }\\n\\nif (replaceRoutingValues && this.ActionTranslation != null) { var valueToken = values[Constants.ACTION]; actionTranslated = this.ActionTranslation.Translation.FirstOrDefault(d => d.CultureInfo.Name == currentThreadCulture.Name); replaceRoutingValues &= (actionTranslated != null && actionTranslated.TranslatedValue == valueToken); }\\n\\n//We need to find a translation that fit at least Controller and Action //if (!replaceRoutingValues) //{ // return null; //}\\n\\n//Switch text token to the right language if (this.ActionTranslation != null) { base.Url = ReplaceTokens(base.Url, this.ActionTranslation.Tokens); }\\n\\n// Check with the new values if the system can get an URL with the values in the culture desired var vitualPathData = this.GetVirtualPathForLocalizedRoute(requestContext, values); //vitualPathData.DataTokens // Asp.Net MVC found a URL, time to enhance the URL with localization replacement if (vitualPathData != null) { //This is to replace {action}, {controller} and {area} with the localized version vitualPathData.VirtualPath = LocalizedSection.ReplaceSection(this.Url, areaTranslated, controllerTranslated, actionTranslated); //Enhance url with replace or append route value dictionary vitualPathData.VirtualPath = AdjustVirtualPathWithRoutes(vitualPathData.VirtualPath, values); //Default value if not defined in the route value vitualPathData.VirtualPath = AdjustVirtualPathWithActionTranslationDefaultValues(vitualPathData.VirtualPath, values); vitualPathData.VirtualPath = vitualPathData.VirtualPath.TrimEnd('/'); } return vitualPathData; }\\n\\n/// <summary> /// Adjust virtual path with action translation default value not in the route. This is because we can define default and the /// value of default is only used when not more specific from the route. /// /// Route has precedence on Default Value (this.ActionTranslation.Values) /// </summary> /// <param name=\\\"currentVirtualPath\\\"></param> /// <param name=\\\"values\\\"></param> /// <returns></returns> public string AdjustVirtualPathWithActionTranslationDefaultValues(string currentVirtualPath, RouteValueDictionary values) { if (string.IsNullOrEmpty(currentVirtualPath) || values == null) { return currentVirtualPath; } string finalVirtualPath = currentVirtualPath; //This is for the case that optional parameter in the action are not defined in the URL if (this.ActionTranslation != null) { var rc = new RouteValueDictionary(this.ActionTranslation.Values); // If defined {word} is not in the URL, then we use the value from the actionTranslated foreach (var key in rc.Keys.Where(q => !values.ContainsKey(q))) { string toReplace = \\\"{\\\" + key + \\\"}\\\"; finalVirtualPath = finalVirtualPath.Replace(toReplace, System.Net.WebUtility.UrlEncode(rc[key].ToString())); } } return finalVirtualPath; }\\n\\n/// <summary> /// Get all routes information that are not Area-Controller-Action and change the value from the URL. /// If not in the URL, add the data in query string /// </summary> /// <param name=\\\"currentVirtualPath\\\"></param> /// <param name=\\\"values\\\"></param> /// <returns></returns> public string AdjustVirtualPathWithRoutes(string currentVirtualPath, RouteValueDictionary values) { string finalVirtualPath = currentVirtualPath; if (values != null) { foreach (var key in values.Keys.Where(k => k != Constants.AREA && k != Constants.CONTROLLER && k != Constants.ACTION)) { string toReplace = \\\"{\\\" + key + \\\"}\\\"; if (values[key] != null) { string replaceWith = System.Net.WebUtility.UrlEncode(values[key].ToString()); if (currentVirtualPath.Contains(toReplace)) { finalVirtualPath = finalVirtualPath.Replace(toReplace, replaceWith); } else { finalVirtualPath = AddKeyValueToUrlAsQueryString(finalVirtualPath, toReplace, replaceWith); } } } }\\n\\nreturn finalVirtualPath; }\\n\\npublic string ReplaceTokens(string url, Dictionary<string, List<LocalizedSection>> tokens) { if (tokens!= null) { foreach (var key in tokens.Keys) { var tokenInCurrentCulture = tokens[key].FirstOrDefault(f => f.CultureInfo.Name == this.Culture.Name); if (tokenInCurrentCulture != null) { string toReplace = \\\"{\\\" + key + \\\"}\\\"; return url.Replace(toReplace, System.Net.WebUtility.UrlEncode(tokenInCurrentCulture.TranslatedValue)); } } } return url; }\\n\\npublic string AddKeyValueToUrlAsQueryString(string url, string key, string value) { if (!string.IsNullOrEmpty(key) && url!=null) { key = key.Replace(\\\"{\\\", \\\"\\\").Replace(\\\"}\\\", \\\"\\\"); if (url.Contains(\\\"?\\\")) { return url + \\\"&\\\" + key + \\\"=\\\" + value; } else { return url + \\\"?\\\" + key + \\\"=\\\" + value; } } return url; }\\n\\npublic virtual VirtualPathData GetVirtualPathForLocalizedRoute(RequestContext requestContext, RouteValueDictionary values) { return base.GetVirtualPath(requestContext, values); } } \\n\")), mdx(\"p\", null, \"I will not describe everything since I added comment directly inside the code but the gist of the class is to manipulate the URL and routing by overriding \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GetVirtualPath\"), \" to be sure to convert the localized route section requested into the original Area-Controller-Action name, to use the default code to get url that would be generated by ASP.Net MVC and then enhance this one by localizing this one with Area-Controller-Action. You can see the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GetVirtualPath\"), \" as the entry point that is called for every route defined when you use any ASP.Net MVC mechanism to get an URL. The framework loops all the route by calling \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GetVirtualPath\"), \" and if one return not NULL, it takes this one.\"), mdx(\"p\", null, \"This class also override \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GetRouteData\"), \" which is used when the user enter an URL in a browser. That time, since we are still using the default route mechanism and that we store the route with the standard Area-Controller-Action + Constraint that we have almost nothing to do. We only set the current thread Culture from the culture defined by the route.\"), mdx(\"p\", null, \"The last remaining piece to be able to have everything work is to create an helper to add localized route to the ASP.Net MVC's \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"RouteCollection\"), \". I decided to create a static method that take the route and a list of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AreaSectionLocalized\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ControllerSectionLocalized\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static class RouteCollectionExtension {\\n\\npublic static void AddRoutes(this RouteCollection routes, List<AreaSectionLocalized> areaRoutes) { foreach (var area in areaRoutes) { routes.AddRoutes(area.ControllerTranslations, area); } }\\n\\npublic static void AddRoutes(this RouteCollection routes, List<ControllerSectionLocalized> controllerRoutes, AreaSectionLocalized areaSectionLocalized = null) { foreach (var controller in controllerRoutes) { foreach (var controllerTranslation in controller.Translation) { foreach (var action in controller.ActionTranslations) { var urlAction = action.Url;\\n\\nforeach (var actionTranslation in action.Translation) { if (controllerTranslation.CultureInfo == actionTranslation.CultureInfo) { RouteValueDictionary values = null; if (action.Values is RouteValueDictionary) { values = action.Values as RouteValueDictionary; } else { values = new RouteValueDictionary(action.Values); } LocalizedSection areaTranslation = null; if (areaSectionLocalized != null && areaSectionLocalized.Translation.Any(d => d.CultureInfo.Name == controllerTranslation.CultureInfo.Name)) { values[Constants.AREA] = areaSectionLocalized.AreaName; areaTranslation = areaSectionLocalized.Translation.FirstOrDefault(d => d.CultureInfo.Name == controllerTranslation.CultureInfo.Name); } values[Constants.CONTROLLER] = controller.ControllerName; values[Constants.ACTION] = action.ActionName; RouteValueDictionary constraints = null; if (action.Constraints is RouteValueDictionary) { constraints = action.Constraints as RouteValueDictionary; } else { constraints = new RouteValueDictionary(action.Constraints); } var newUrl = LocalizedSection.ReplaceSection(urlAction, areaTranslation, controllerTranslation, actionTranslation); routes.Add(new LocalizedRoute( areaSectionLocalized , controller , action , newUrl , values , constraints , actionTranslation.CultureInfo ) ); } } } } } } } \\n\")), mdx(\"p\", null, \"The code is adding a route by looping through all areas, all controllers, all actions and for each language add the route. I will create a second article to describe to Fluent interface that help to have a more concise way to write the routing and also that gives Microsoft Intellisence support. So far, in this article, we have seen how to enhance the existing Asp.Net MVC routing system by having localized route. The code handles the thread culture, thus by changing the URL you have all your pages in the right local too. Finally, we saw that\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"How to Localized MVC Routing with Area Without Specifying Culture Short Name in the Url\",\n  \"date\": \"2015-12-21\",\n  \"categories\": [\"asp-mvc\"],\n  \"tags\": [\"csharp\", \"css3\", \"dotnet\", \"html5\", \"localization\", \"routing\", \"web\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`In a previous post, I wrote how to enhance the standard `}<a parentName=\"p\" {...{\n        \"href\": \"./asp-net-mvc-localized-url-without-having-to-specify-the-language-in-it\"\n      }}>{`Asp.Net MVC Routing to have localized URL with controller and action`}</a>{`. This solution had some flaws that this article will cover. First of all, it was not working with area. Second, you were not able to use all functionalities like constraints and default values and third, it was a lot of configuration by having to use a lot of lists.`}</p>\n    <p>{`This article illustrates an easier way to define your routing configuration by adding a Fluent API but also by giving you all standard routing capabilities. This solution will let you configure every route possibles : values, defaults values, constraints, etc and will enhance the standard MVC routing by figuring out which language to display all your resources by setting the culture for you.`}</p>\n    <p>{`Before going any further, here is an example of what the system let you use without Fluent API.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` var controllerRoutes = new List<ControllerSectionLocalized>{ new ControllerSectionLocalized(\"Home\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Home\") ,new LocalizedSection(LocalizedSection.FR, \"Demarrer\") } ,new List<ActionSectionLocalized>{ new ActionSectionLocalized(\"Index\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Index\") ,new LocalizedSection(LocalizedSection.FR, \"Index\") } , new { id = \"\"} , null , \"{controller}/{action}/{id}\" )\n\n}) , new ControllerSectionLocalized(\"Account\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Account\") ,new LocalizedSection(LocalizedSection.FR, \"Compte\") } ,new List<ActionSectionLocalized>{ new ActionSectionLocalized(\"Profile\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Profile\") ,new LocalizedSection(LocalizedSection.FR, \"Profile\") } , new {username = UrlParameter.Optional } , null , \"{action}/{username}\" ) , new ActionSectionLocalized(\"DisplayBadges\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Badges\") ,new LocalizedSection(LocalizedSection.FR, \"Medailles\") } , null , null , \"{action}\" ) , new ActionSectionLocalized(\"Privilege\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Privilege-benefits\") ,new LocalizedSection(LocalizedSection.FR, \"benefice-des-privileges\") } , null , null , \"{action}\" ) , new ActionSectionLocalized(\"PrivilegeBuyConfirm\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Privilege-buy-confirm\") ,new LocalizedSection(LocalizedSection.FR, \"confirmation-achat-privilege\") } , null , null , \"{action}\" ) , new ActionSectionLocalized(\"Login\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"Login\") ,new LocalizedSection(LocalizedSection.FR, \"Identification\") } , null , null , \"{controller}/{action}\" ) , new ActionSectionLocalized(\"ReSendingCreationEmail\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"SendValidationMail\") ,new LocalizedSection(LocalizedSection.FR, \"EnvoieCourrielDeValidation\") } , null , null , \"{controller}/{action}/{emailAddress}/now\"/* We need to be able to have more than just action translated but also text token for e.g. NOW*/ ) , new ActionSectionLocalized(\"ActivateAccount\" , new List<LocalizedSection>{ new LocalizedSection(LocalizedSection.EN, \"ActivateAccount\") ,new LocalizedSection(LocalizedSection.FR, \"activer-compte\") } , null , null , \"{controller}/{action}/{emailAddress}/now\"/* We need to be able to have more than just action translated but also text token for e.g. NOW*/ ) } ) }; \n`}</code></pre>\n    <p>{`And with the Fluent Routing API:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` var controllerRoutes = FluentLocalizedRoute.BuildRoute() .ForBilingualController(\"Home\", \"Home\", \"Demarrer\") .WithBilingualAction(\"Index\", \"Index\", \"Index\") .WithDefaultValues(new { id = \"\" }) .UseDefaulUrl() .ForBilingualController(\"Account\", \"Account\", \"Compte\") .WithBilingualAction(\"Profile\", \"Profile\", \"Profile\") .WithDefaultValues(new { username = UrlParameter.Optional }) .WithUrl(\"{action}/{username}\") .And().WithBilingualAction(\"DisplayBadges\", \"Badges\", \"Medailles\") .WithUrl(\"{action}\") .And().WithBilingualAction(\"Privilege\", \"Privilege-benefits\", \"benefice-des-privileges\") .WithUrl(\"{action}\") .And().WithBilingualAction(\"PrivilegeBuyConfirm\", \"Privilege-buy-confirm\", \"confirmation-achat-privilege\") .WithUrl(\"{action}\") .And().WithBilingualAction(\"Login\", \"Login\", \"Identification\") .WithUrl(\"{controller}/{action}\") .And().WithBilingualAction(\"ReSendingCreationEmail\", \"SendValidationMail\", \"EnvoieCourrielDeValidation\") .WithUrl(\"{controller}/{action}/{emailAddress}/now\") .And().WithBilingualAction(\"ActivateAccount\", \"ActivateAccount\", \"activer-compte\") .WithUrl(\"{controller}/{action}/{emailAddress}/now\") .ToList() ; \n`}</code></pre>\n    <p>{`As you can see, it's way more concise. Of course, the method used in the API focus on 2 languages but underneath you can have unlimited localization -- it's just more convenient for a lot of people to have a bilingual application, thus these helper methods. So what does this localized code will give you:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Url that can be in an unlimited language bound to Mvc code`}</li>\n      <li parentName=\"ul\">{`Url that change the Culture and CultureUI without having to specify the local like en-us or fr-ca`}</li>\n      <li parentName=\"ul\">{`A system that handles Area, Controller and Action to be translated`}</li>\n      <li parentName=\"ul\">{`A system that generate subsequent URL with the default Asp.Net MVC Helper in the right language`}</li>\n      <li parentName=\"ul\">{`A system compatible with the current Asp.Net routing system, thus both can be run in parallel`}</li>\n      <li parentName=\"ul\">{`A Fluent API that let you write quickly routing`}</li>\n      <li parentName=\"ul\">{`Full support of current Asp.Net feature with default values, constraints and even with custom language token that can be localized within the URL`}</li>\n    </ul>\n    <p>{`Let's start without having the Fluent API because the Fluent API it's just something you add above the custom multilanguage Asp.Net Mvc routing system we are developing.`}</p>\n    <p>{`The first class that we need is the one that will hold the localized string.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public class LocalizedSection { public static CultureInfo EN = CultureInfo.GetCultureInfo(\"en-US\"); public static CultureInfo FR = CultureInfo.GetCultureInfo(\"fr-FR\"); public CultureInfo CultureInfo { get; set; } public string TranslatedValue { get; set; } public LocalizedSection(CultureInfo culture, string translatedValue) { CultureInfo = culture; TranslatedValue = translatedValue; } } \n`}</code></pre>\n    <p>{`This `}<em parentName=\"p\">{`LocalizedSection`}</em>{` class is pretty simple by having a single constructor that take a culture and a string that is localized. Some static properties are there because I am developing an English-French system and wanted to have the culture that I will use defined once. Even if everything explained in this article is about a bilingual system in English and French, the system is already in shape to let you use other languages than these two but also more than two. Once you have that class, you need to defines the structure of how we will keep all localized sections for the system. The structure is the same as Asp.Net MVC routing which is area, controller and action. We will build everything to support Area-Controller-Action and Controller-Action. To do so, we need three classes.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public class AreaSectionLocalized { public string AreaName { get; set; } public List<LocalizedSection> Translation { get; set; } public List<ControllerSectionLocalized> ControllerTranslations { get; set; }\n\npublic AreaSectionLocalized(string areaName, List<LocalizedSection> translation, List<ControllerSectionLocalized> controllersList) { this.AreaName = areaName; this.Translation = translation; this.ControllerTranslations = controllersList; } } public class ControllerSectionLocalized { public string ControllerName { get; set; } public List<LocalizedSection> Translation { get; set; } public List<ActionSectionLocalized> ActionTranslations { get; set; }\n\npublic ControllerSectionLocalized(string controllerName, List<LocalizedSection> translation, List<ActionSectionLocalized> actionsList) { this.ControllerName = controllerName; this.Translation = translation; this.ActionTranslations = actionsList; } } public class ActionSectionLocalized { public string ActionName { get; set; } public List<LocalizedSection> Translation { get; set; }\n\npublic object Values { get; set; } public object Constraints { get; set; } public string Url { get; set; } public ActionSectionLocalized(string actionName, List<LocalizedSection> translation, object values = null, object constraints = null, string url = \"\") { this.ActionName = actionName; this.Translation = translation; this.Values = values; this.Constraints = constraints; this.Url = url; } public Dictionary<string,List<LocalizedSection>> Tokens { get; set; } } \n`}</code></pre>\n    <p>{`The `}<em parentName=\"p\">{`AreaSectionLocalized`}</em>{` class is the one that contain the real area's name under the property named `}<strong parentName=\"p\">{`AreaName`}</strong>{`. This one will be used to map when you request from Mvc Html Helper a route with the real name but also when you specify in the url a localized string from the `}<em parentName=\"p\">{`Translation`}</em>{` property. This list, `}<em parentName=\"p\">{`Translation`}</em>{` , is where you store the collection of localized area name for this area. For example, if you have an area in your code called \"Order\" than you can have the area to be displayed in the url has \"customer-area\" and \"commande-du-client\". Since it's a list, you can have unlimited translation -- each of them are linked to a `}<strong parentName=\"p\">{`CultureInfo`}</strong>{`. The last important property of that class is the collection of controller. As you can see, we are building a three of routing. At the root will be a collection of area, with `}<em parentName=\"p\">{`AreaSectionLocalized`}</em>{`. Each of area will have a list of controller, which will have a list of action. That is why the `}<em parentName=\"p\">{`ControllerSectionLocalized`}</em>{` look alike the area class. The action class, `}<em parentName=\"p\">{`ActionSectionLocalized`}</em>{` is the class among the three that contains more information. It has also the same principle of having the action name which is the one that the controller class define and use in Asp.Net MVC Url Helper with a list of localized string but also multiple properties. Values, constraints, Url are all information used to build the URL in the standard Asp.Net MVC routing system. Here is a standard route :`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` routes.MapRoute(Constants.Areas.CONTEST + \"_contest_detail\" , Constants.Areas.CONTEST + \"/{\" + Constants.RoutePortionName.ACTIVE_CURRENT_CONTEST_ID + \"}/Detail\" , new RouteValueDictionary { { Constants.RoutePortionName.ACTION, \"Detail\" }, { Constants.RoutePortionName.CONTROLLER, \"UserContest\" }} , new RouteValueDictionary {{ Constants.RoutePortionName.ACTIVE_CURRENT_CONTEST_ID,@\"\\\\\\\\d+\"} }); \n`}</code></pre>\n    <p>{`The second line is the URL, the third line is the value and the forth line is the constraint. We also do the same in the `}<em parentName=\"p\">{`ActionSectionLocalized`}</em>{` class. One custom new principle is the Tokens list. This is a dictionary of string that we will replace with a localized string. Item of the list represent a token, every value contains a list of localized text to replace in the URL. That mean that you can create an URL that look like this : \"/{area}/{controller}/{action}/always/{page}/{pagenumber} where the area, controller and action will be replaced with the according value as the standard Asp.Net MVC routing is normally doing, the same is true about the hard-coded \"always\" that will remains the same whatever the language and the {pagenumber} if defined in the URL will be used as a routing variable. The difference is that if we detect that {page} is not used as a routing value that we will lookup in the token list to see if it could be replaced with a localized value. We will see it in more detail later.`}</p>\n    <p>{`The next one is one of the code class of the system, it's the new route class. This localized route class, named accordingly to its goal `}<em parentName=\"p\">{`LocalizedClass`}</em>{`, inherit from the Asp.Net MVC's Route class. This way, it's possible to continue to use the same routing system without having to re-invent the wheel.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public class LocalizedRoute : Route { public CultureInfo Culture { get; private set; } public ActionSectionLocalized ActionTranslation { get; private set; } public ControllerSectionLocalized ControllerTranslation { get; private set; } public AreaSectionLocalized AreaSectionLocalized { get; private set; }\n\npublic LocalizedRoute(AreaSectionLocalized areaSectionLocalized, ControllerSectionLocalized controllerTranslation, ActionSectionLocalized actionTranslation, string url , RouteValueDictionary defaults, RouteValueDictionary constraints, CultureInfo culture) : this(areaSectionLocalized, controllerTranslation, actionTranslation, url, defaults, constraints, null, new MvcRouteHandler(), culture) {\n\n}\n\npublic LocalizedRoute(AreaSectionLocalized areaSectionLocalized, ControllerSectionLocalized controllerTranslation, ActionSectionLocalized actionTranslation, string url , RouteValueDictionary defaults, RouteValueDictionary constraints, RouteValueDictionary dataTokens, IRouteHandler routeHandler, CultureInfo culture) : base(url, defaults, constraints, dataTokens, routeHandler) { this.AreaSectionLocalized = areaSectionLocalized;\n\nif (controllerTranslation == null) { throw new ArgumentNullException(\"controllerTranslation\"); } this.ControllerTranslation = controllerTranslation; if (actionTranslation == null) { throw new ArgumentNullException(\"actionTranslation\"); } this.ActionTranslation = actionTranslation;\n\nif (url == null) { throw new ArgumentNullException(\"url\"); }\n\nif (culture == null) { throw new ArgumentNullException(\"culture\"); } this.Culture = culture;\n\nif (dataTokens == null) { base.DataTokens = new RouteValueDictionary(); }\n\nif (base.Defaults != null && base.Defaults.Keys.Contains(Constants.AREA)) { if (base.DataTokens == null) { base.DataTokens = new RouteValueDictionary(); } base.DataTokens.Add(Constants.AREA, base.Defaults[Constants.AREA].ToString()); } }\n\n/// <summary> /// Set the thread culture with the route culture /// </summary> /// <param name=\"httpContext\"></param> /// <returns></returns> public override RouteData GetRouteData(HttpContextBase httpContext) { var returnRouteData = base.GetRouteData(httpContext); if (returnRouteData != null) { System.Threading.Thread.CurrentThread.CurrentCulture = this.Culture; System.Threading.Thread.CurrentThread.CurrentUICulture = this.Culture; } return returnRouteData; } protected override bool ProcessConstraint(HttpContextBase httpContext, object constraint, string parameterName, RouteValueDictionary values, RouteDirection routeDirection) { return base.ProcessConstraint(httpContext, constraint, parameterName, values, routeDirection); }\n\npublic override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { var currentThreadCulture = System.Threading.Thread.CurrentThread.CurrentUICulture; //First step is to avoid route in the wrong culture if (this.Culture.Name != currentThreadCulture.Name) { return null; }\n\n//Second, set the right Area/Controller/Action to have MVC generating the URL with the localized string bool replaceRoutingValues = true; LocalizedSection areaTranslated = null; LocalizedSection controllerTranslated = null; LocalizedSection actionTranslated = null; if (this.AreaSectionLocalized != null && values[Constants.AREA] !=null) //If added in the RouteValue, it will be just there later during GetVirtualPath (merge from MVC's route creation code) { var valueToken = values[Constants.AREA]; areaTranslated = this.AreaSectionLocalized.Translation.FirstOrDefault(d => d.CultureInfo.Name == currentThreadCulture.Name); replaceRoutingValues = (areaTranslated != null && areaTranslated.TranslatedValue == valueToken); }\n\nif (replaceRoutingValues && this.ControllerTranslation != null) { var valueToken = values[Constants.CONTROLLER]; controllerTranslated = this.ControllerTranslation.Translation.FirstOrDefault(d => d.CultureInfo.Name == currentThreadCulture.Name); replaceRoutingValues &= (controllerTranslated != null && controllerTranslated.TranslatedValue == valueToken); }\n\nif (replaceRoutingValues && this.ActionTranslation != null) { var valueToken = values[Constants.ACTION]; actionTranslated = this.ActionTranslation.Translation.FirstOrDefault(d => d.CultureInfo.Name == currentThreadCulture.Name); replaceRoutingValues &= (actionTranslated != null && actionTranslated.TranslatedValue == valueToken); }\n\n//We need to find a translation that fit at least Controller and Action //if (!replaceRoutingValues) //{ // return null; //}\n\n//Switch text token to the right language if (this.ActionTranslation != null) { base.Url = ReplaceTokens(base.Url, this.ActionTranslation.Tokens); }\n\n// Check with the new values if the system can get an URL with the values in the culture desired var vitualPathData = this.GetVirtualPathForLocalizedRoute(requestContext, values); //vitualPathData.DataTokens // Asp.Net MVC found a URL, time to enhance the URL with localization replacement if (vitualPathData != null) { //This is to replace {action}, {controller} and {area} with the localized version vitualPathData.VirtualPath = LocalizedSection.ReplaceSection(this.Url, areaTranslated, controllerTranslated, actionTranslated); //Enhance url with replace or append route value dictionary vitualPathData.VirtualPath = AdjustVirtualPathWithRoutes(vitualPathData.VirtualPath, values); //Default value if not defined in the route value vitualPathData.VirtualPath = AdjustVirtualPathWithActionTranslationDefaultValues(vitualPathData.VirtualPath, values); vitualPathData.VirtualPath = vitualPathData.VirtualPath.TrimEnd('/'); } return vitualPathData; }\n\n/// <summary> /// Adjust virtual path with action translation default value not in the route. This is because we can define default and the /// value of default is only used when not more specific from the route. /// /// Route has precedence on Default Value (this.ActionTranslation.Values) /// </summary> /// <param name=\"currentVirtualPath\"></param> /// <param name=\"values\"></param> /// <returns></returns> public string AdjustVirtualPathWithActionTranslationDefaultValues(string currentVirtualPath, RouteValueDictionary values) { if (string.IsNullOrEmpty(currentVirtualPath) || values == null) { return currentVirtualPath; } string finalVirtualPath = currentVirtualPath; //This is for the case that optional parameter in the action are not defined in the URL if (this.ActionTranslation != null) { var rc = new RouteValueDictionary(this.ActionTranslation.Values); // If defined {word} is not in the URL, then we use the value from the actionTranslated foreach (var key in rc.Keys.Where(q => !values.ContainsKey(q))) { string toReplace = \"{\" + key + \"}\"; finalVirtualPath = finalVirtualPath.Replace(toReplace, System.Net.WebUtility.UrlEncode(rc[key].ToString())); } } return finalVirtualPath; }\n\n/// <summary> /// Get all routes information that are not Area-Controller-Action and change the value from the URL. /// If not in the URL, add the data in query string /// </summary> /// <param name=\"currentVirtualPath\"></param> /// <param name=\"values\"></param> /// <returns></returns> public string AdjustVirtualPathWithRoutes(string currentVirtualPath, RouteValueDictionary values) { string finalVirtualPath = currentVirtualPath; if (values != null) { foreach (var key in values.Keys.Where(k => k != Constants.AREA && k != Constants.CONTROLLER && k != Constants.ACTION)) { string toReplace = \"{\" + key + \"}\"; if (values[key] != null) { string replaceWith = System.Net.WebUtility.UrlEncode(values[key].ToString()); if (currentVirtualPath.Contains(toReplace)) { finalVirtualPath = finalVirtualPath.Replace(toReplace, replaceWith); } else { finalVirtualPath = AddKeyValueToUrlAsQueryString(finalVirtualPath, toReplace, replaceWith); } } } }\n\nreturn finalVirtualPath; }\n\npublic string ReplaceTokens(string url, Dictionary<string, List<LocalizedSection>> tokens) { if (tokens!= null) { foreach (var key in tokens.Keys) { var tokenInCurrentCulture = tokens[key].FirstOrDefault(f => f.CultureInfo.Name == this.Culture.Name); if (tokenInCurrentCulture != null) { string toReplace = \"{\" + key + \"}\"; return url.Replace(toReplace, System.Net.WebUtility.UrlEncode(tokenInCurrentCulture.TranslatedValue)); } } } return url; }\n\npublic string AddKeyValueToUrlAsQueryString(string url, string key, string value) { if (!string.IsNullOrEmpty(key) && url!=null) { key = key.Replace(\"{\", \"\").Replace(\"}\", \"\"); if (url.Contains(\"?\")) { return url + \"&\" + key + \"=\" + value; } else { return url + \"?\" + key + \"=\" + value; } } return url; }\n\npublic virtual VirtualPathData GetVirtualPathForLocalizedRoute(RequestContext requestContext, RouteValueDictionary values) { return base.GetVirtualPath(requestContext, values); } } \n`}</code></pre>\n    <p>{`I will not describe everything since I added comment directly inside the code but the gist of the class is to manipulate the URL and routing by overriding `}<em parentName=\"p\">{`GetVirtualPath`}</em>{` to be sure to convert the localized route section requested into the original Area-Controller-Action name, to use the default code to get url that would be generated by ASP.Net MVC and then enhance this one by localizing this one with Area-Controller-Action. You can see the `}<em parentName=\"p\">{`GetVirtualPath`}</em>{` as the entry point that is called for every route defined when you use any ASP.Net MVC mechanism to get an URL. The framework loops all the route by calling `}<em parentName=\"p\">{`GetVirtualPath`}</em>{` and if one return not NULL, it takes this one.`}</p>\n    <p>{`This class also override `}<em parentName=\"p\">{`GetRouteData`}</em>{` which is used when the user enter an URL in a browser. That time, since we are still using the default route mechanism and that we store the route with the standard Area-Controller-Action + Constraint that we have almost nothing to do. We only set the current thread Culture from the culture defined by the route.`}</p>\n    <p>{`The last remaining piece to be able to have everything work is to create an helper to add localized route to the ASP.Net MVC's `}<strong parentName=\"p\">{`RouteCollection`}</strong>{`. I decided to create a static method that take the route and a list of `}<strong parentName=\"p\">{`AreaSectionLocalized`}</strong>{` or `}<strong parentName=\"p\">{`ControllerSectionLocalized`}</strong>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public static class RouteCollectionExtension {\n\npublic static void AddRoutes(this RouteCollection routes, List<AreaSectionLocalized> areaRoutes) { foreach (var area in areaRoutes) { routes.AddRoutes(area.ControllerTranslations, area); } }\n\npublic static void AddRoutes(this RouteCollection routes, List<ControllerSectionLocalized> controllerRoutes, AreaSectionLocalized areaSectionLocalized = null) { foreach (var controller in controllerRoutes) { foreach (var controllerTranslation in controller.Translation) { foreach (var action in controller.ActionTranslations) { var urlAction = action.Url;\n\nforeach (var actionTranslation in action.Translation) { if (controllerTranslation.CultureInfo == actionTranslation.CultureInfo) { RouteValueDictionary values = null; if (action.Values is RouteValueDictionary) { values = action.Values as RouteValueDictionary; } else { values = new RouteValueDictionary(action.Values); } LocalizedSection areaTranslation = null; if (areaSectionLocalized != null && areaSectionLocalized.Translation.Any(d => d.CultureInfo.Name == controllerTranslation.CultureInfo.Name)) { values[Constants.AREA] = areaSectionLocalized.AreaName; areaTranslation = areaSectionLocalized.Translation.FirstOrDefault(d => d.CultureInfo.Name == controllerTranslation.CultureInfo.Name); } values[Constants.CONTROLLER] = controller.ControllerName; values[Constants.ACTION] = action.ActionName; RouteValueDictionary constraints = null; if (action.Constraints is RouteValueDictionary) { constraints = action.Constraints as RouteValueDictionary; } else { constraints = new RouteValueDictionary(action.Constraints); } var newUrl = LocalizedSection.ReplaceSection(urlAction, areaTranslation, controllerTranslation, actionTranslation); routes.Add(new LocalizedRoute( areaSectionLocalized , controller , action , newUrl , values , constraints , actionTranslation.CultureInfo ) ); } } } } } } } \n`}</code></pre>\n    <p>{`The code is adding a route by looping through all areas, all controllers, all actions and for each language add the route. I will create a second article to describe to Fluent interface that help to have a more concise way to write the routing and also that gives Microsoft Intellisence support. So far, in this article, we have seen how to enhance the existing Asp.Net MVC routing system by having localized route. The code handles the thread culture, thus by changing the URL you have all your pages in the right local too. Finally, we saw that`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}