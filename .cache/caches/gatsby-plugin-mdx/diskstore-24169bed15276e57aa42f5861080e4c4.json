{"expireTime":9007200886478396000,"key":"gatsby-plugin-mdx-entire-payload-8bfea91f376f09f0cfe8f49912d37988--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"One of my team mate would like to query some data with Linq but has always an error message saying that the Linq to Entity couldn't find the property desired. In fact, the exception was relevant because the property was made up in the model and were using two others properties available from the database.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":307,"offset":307},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":307,"offset":307},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"To figure out more about the problematic let say that in the database you have the field : Id, Name_Fr, Name_En. Let say that in your model you have : Id, Name_Fr, Name_En and also Name. You would like to sort data by name. If you use directly your Entity Framework's data context to query with Linq To Entity you will get an error because database context will try to do a SQL query with the field Name which doesn't exist. The solution is to use Linq to Entity to query everything and to sort with Linq to Object.","position":{"start":{"line":4,"column":1,"offset":309},"end":{"line":4,"column":516,"offset":824},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":309},"end":{"line":4,"column":516,"offset":824},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"So, instead of doing : ","position":{"start":{"line":6,"column":1,"offset":826},"end":{"line":6,"column":24,"offset":849},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":826},"end":{"line":6,"column":24,"offset":849},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" MyDatabaseContext.MyPeople.OrderBy(c=>c.Name); ","position":{"start":{"line":7,"column":1,"offset":850},"end":{"line":9,"column":4,"offset":912},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"You would have to do : ","position":{"start":{"line":11,"column":1,"offset":914},"end":{"line":11,"column":24,"offset":937},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":914},"end":{"line":11,"column":24,"offset":937},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" MyDatabaseContext.MyPeople.AsEnumerable().OrderBy(c=>c.Name); ","position":{"start":{"line":12,"column":1,"offset":938},"end":{"line":14,"column":4,"offset":1015},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":16,"column":1,"offset":1017},"end":{"line":16,"column":5,"offset":1021},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"AsEnumerable()","position":{"start":{"line":16,"column":7,"offset":1023},"end":{"line":16,"column":21,"offset":1037},"indent":[]}}],"position":{"start":{"line":16,"column":5,"offset":1021},"end":{"line":16,"column":23,"offset":1039},"indent":[]}},{"type":"text","value":" will execute the query which will return a collection of ","position":{"start":{"line":16,"column":23,"offset":1039},"end":{"line":16,"column":81,"offset":1097},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"IEnumerable","position":{"start":{"line":16,"column":82,"offset":1098},"end":{"line":16,"column":93,"offset":1109},"indent":[]}}],"position":{"start":{"line":16,"column":81,"offset":1097},"end":{"line":16,"column":94,"offset":1110},"indent":[]}},{"type":"text","value":" instead of ","position":{"start":{"line":16,"column":94,"offset":1110},"end":{"line":16,"column":106,"offset":1122},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"IQueryable","position":{"start":{"line":16,"column":107,"offset":1123},"end":{"line":16,"column":117,"offset":1133},"indent":[]}}],"position":{"start":{"line":16,"column":106,"offset":1122},"end":{"line":16,"column":118,"offset":1134},"indent":[]}},{"type":"text","value":". The difference is that MyPeople is IQueryable which doesn't execute the query until the collection is enumerated (with ForEach for example) or until the query it transformed into a list (for example with ToList()).","position":{"start":{"line":16,"column":118,"offset":1134},"end":{"line":16,"column":334,"offset":1350},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":1017},"end":{"line":16,"column":334,"offset":1350},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The difference between ","position":{"start":{"line":18,"column":1,"offset":1352},"end":{"line":18,"column":24,"offset":1375},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"AsEnumerable()","position":{"start":{"line":18,"column":26,"offset":1377},"end":{"line":18,"column":40,"offset":1391},"indent":[]}}],"position":{"start":{"line":18,"column":24,"offset":1375},"end":{"line":18,"column":42,"offset":1393},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":18,"column":42,"offset":1393},"end":{"line":18,"column":47,"offset":1398},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"ToList()","position":{"start":{"line":18,"column":49,"offset":1400},"end":{"line":18,"column":57,"offset":1408},"indent":[]}}],"position":{"start":{"line":18,"column":47,"offset":1398},"end":{"line":18,"column":59,"offset":1410},"indent":[]}},{"type":"text","value":" is concerning performance. The ","position":{"start":{"line":18,"column":59,"offset":1410},"end":{"line":18,"column":91,"offset":1442},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"AsEnumerable()","position":{"start":{"line":18,"column":93,"offset":1444},"end":{"line":18,"column":107,"offset":1458},"indent":[]}}],"position":{"start":{"line":18,"column":91,"offset":1442},"end":{"line":18,"column":109,"offset":1460},"indent":[]}},{"type":"text","value":" is faster if you do subsequent filtering (.Where for example) operation. The reason is that it will filter the query before looping instead of looping the whole collection and then looping to filter.","position":{"start":{"line":18,"column":109,"offset":1460},"end":{"line":18,"column":309,"offset":1660},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":1352},"end":{"line":18,"column":309,"offset":1660},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"How to use Linq to query a property that is not in your database but in your class model\",\"date\":\"2012-03-29\",\"categories\":[\"entity-framework\",\"linq\"]}","position":{"start":{"line":21,"column":1,"offset":1663},"end":{"line":21,"column":190,"offset":1852},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":21,"column":190,"offset":1852}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to use Linq to query a property that is not in your database but in your class model\",\n  \"date\": \"2012-03-29\",\n  \"categories\": [\"entity-framework\", \"linq\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"One of my team mate would like to query some data with Linq but has always an error message saying that the Linq to Entity couldn't find the property desired. In fact, the exception was relevant because the property was made up in the model and were using two others properties available from the database.\"), mdx(\"p\", null, \"To figure out more about the problematic let say that in the database you have the field : Id, Name_Fr, Name_En. Let say that in your model you have : Id, Name_Fr, Name_En and also Name. You would like to sort data by name. If you use directly your Entity Framework's data context to query with Linq To Entity you will get an error because database context will try to do a SQL query with the field Name which doesn't exist. The solution is to use Linq to Entity to query everything and to sort with Linq to Object.\"), mdx(\"p\", null, \"So, instead of doing : \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" MyDatabaseContext.MyPeople.OrderBy(c=>c.Name); \\n\")), mdx(\"p\", null, \"You would have to do : \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" MyDatabaseContext.MyPeople.AsEnumerable().OrderBy(c=>c.Name); \\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AsEnumerable()\"), \" will execute the query which will return a collection of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IEnumerable\"), \" instead of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \". The difference is that MyPeople is IQueryable which doesn't execute the query until the collection is enumerated (with ForEach for example) or until the query it transformed into a list (for example with ToList()).\"), mdx(\"p\", null, \"The difference between \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AsEnumerable()\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToList()\"), \" is concerning performance. The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AsEnumerable()\"), \" is faster if you do subsequent filtering (.Where for example) operation. The reason is that it will filter the query before looping instead of looping the whole collection and then looping to filter.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"How to use Linq to query a property that is not in your database but in your class model\",\n  \"date\": \"2012-03-29\",\n  \"categories\": [\"entity-framework\", \"linq\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`One of my team mate would like to query some data with Linq but has always an error message saying that the Linq to Entity couldn't find the property desired. In fact, the exception was relevant because the property was made up in the model and were using two others properties available from the database.`}</p>\n    <p>{`To figure out more about the problematic let say that in the database you have the field : Id, Name_Fr, Name_En. Let say that in your model you have : Id, Name_Fr, Name_En and also Name. You would like to sort data by name. If you use directly your Entity Framework's data context to query with Linq To Entity you will get an error because database context will try to do a SQL query with the field Name which doesn't exist. The solution is to use Linq to Entity to query everything and to sort with Linq to Object.`}</p>\n    <p>{`So, instead of doing : `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` MyDatabaseContext.MyPeople.OrderBy(c=>c.Name); \n`}</code></pre>\n    <p>{`You would have to do : `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` MyDatabaseContext.MyPeople.AsEnumerable().OrderBy(c=>c.Name); \n`}</code></pre>\n    <p>{`The `}<strong parentName=\"p\">{`AsEnumerable()`}</strong>{` will execute the query which will return a collection of `}<em parentName=\"p\">{`IEnumerable`}</em>{` instead of `}<em parentName=\"p\">{`IQueryable`}</em>{`. The difference is that MyPeople is IQueryable which doesn't execute the query until the collection is enumerated (with ForEach for example) or until the query it transformed into a list (for example with ToList()).`}</p>\n    <p>{`The difference between `}<strong parentName=\"p\">{`AsEnumerable()`}</strong>{` and `}<strong parentName=\"p\">{`ToList()`}</strong>{` is concerning performance. The `}<strong parentName=\"p\">{`AsEnumerable()`}</strong>{` is faster if you do subsequent filtering (.Where for example) operation. The reason is that it will filter the query before looping instead of looping the whole collection and then looping to filter.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}