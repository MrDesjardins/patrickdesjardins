{"expireTime":9007200886478387000,"key":"gatsby-plugin-mdx-entire-payload-59b5007104885b1fd6f442decb0e2e1e--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"The simple task of casting from a primitive type to another can be sometimes easier than we think. If you come from C# you may search within TypeScript the ","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":157,"offset":157},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Convert.ToInt32()","position":{"start":{"line":2,"column":159,"offset":159},"end":{"line":2,"column":176,"offset":176},"indent":[]}}],"position":{"start":{"line":2,"column":157,"offset":157},"end":{"line":2,"column":178,"offset":178},"indent":[]}},{"type":"text","value":" or ","position":{"start":{"line":2,"column":178,"offset":178},"end":{"line":2,"column":182,"offset":182},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Int32.Parse()","position":{"start":{"line":2,"column":184,"offset":184},"end":{"line":2,"column":197,"offset":197},"indent":[]}}],"position":{"start":{"line":2,"column":182,"offset":182},"end":{"line":2,"column":199,"offset":199},"indent":[]}},{"type":"text","value":" or maybe just use ","position":{"start":{"line":2,"column":199,"offset":199},"end":{"line":2,"column":218,"offset":218},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"(int)","position":{"start":{"line":2,"column":220,"offset":220},"end":{"line":2,"column":225,"offset":225},"indent":[]}}],"position":{"start":{"line":2,"column":218,"offset":218},"end":{"line":2,"column":227,"offset":227},"indent":[]}},{"type":"text","value":". None of these conversion syntaxes works with TypeScript. To cast a string to a number, you have to use JavaScript. This means that you can either use the ","position":{"start":{"line":2,"column":227,"offset":227},"end":{"line":2,"column":383,"offset":383},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"parseInt","position":{"start":{"line":2,"column":385,"offset":385},"end":{"line":2,"column":393,"offset":393},"indent":[]}}],"position":{"start":{"line":2,"column":383,"offset":383},"end":{"line":2,"column":395,"offset":395},"indent":[]}},{"type":"text","value":" function or to simply add a plus sign in from of your string.","position":{"start":{"line":2,"column":395,"offset":395},"end":{"line":2,"column":457,"offset":457},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":457,"offset":457},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"var myInt1 = +\"123\"; \nvar myInt2 = +myStringVariable; \nvar myInt3 = parseInt(\"123\", 10); \nvar myInt4 = Number(\"123\")","position":{"start":{"line":4,"column":1,"offset":459},"end":{"line":7,"column":27,"offset":575},"indent":[1,1,1]}}],"position":{"start":{"line":4,"column":1,"offset":459},"end":{"line":7,"column":27,"offset":575},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The output of the variables if they are proper number are:","position":{"start":{"line":9,"column":1,"offset":577},"end":{"line":9,"column":59,"offset":635},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":577},"end":{"line":9,"column":59,"offset":635},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"123\n(The number of value if the myStringVariable is a proper number)\n123\n123","position":{"start":{"line":11,"column":1,"offset":637},"end":{"line":14,"column":4,"offset":713},"indent":[1,1,1]}}],"position":{"start":{"line":11,"column":1,"offset":637},"end":{"line":14,"column":4,"offset":713},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"If the value are not a proper number, the result will be:","position":{"start":{"line":16,"column":1,"offset":715},"end":{"line":16,"column":58,"offset":772},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":715},"end":{"line":16,"column":58,"offset":772},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"NaN\nNaN\nNaN OR something else\nNan ","position":{"start":{"line":18,"column":1,"offset":774},"end":{"line":21,"column":5,"offset":808},"indent":[1,1,1]}}],"position":{"start":{"line":18,"column":1,"offset":774},"end":{"line":21,"column":5,"offset":808},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":23,"column":1,"offset":810},"end":{"line":23,"column":5,"offset":814},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"parseInt","position":{"start":{"line":23,"column":6,"offset":815},"end":{"line":23,"column":14,"offset":823},"indent":[]}}],"position":{"start":{"line":23,"column":5,"offset":814},"end":{"line":23,"column":15,"offset":824},"indent":[]}},{"type":"text","value":" can be deceiving. For example, if you try with \"123asd\" you will get 12 as an answer. However, if you parse \"asd\" you will get ","position":{"start":{"line":23,"column":15,"offset":824},"end":{"line":23,"column":143,"offset":952},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"NaN","position":{"start":{"line":23,"column":144,"offset":953},"end":{"line":23,"column":147,"offset":956},"indent":[]}}],"position":{"start":{"line":23,"column":143,"offset":952},"end":{"line":23,"column":148,"offset":957},"indent":[]}},{"type":"text","value":". I recommend using the function Number when the base is 10 and to relies on parseInt only if you are working with another base (hex for example).","position":{"start":{"line":23,"column":148,"offset":957},"end":{"line":23,"column":294,"offset":1103},"indent":[]}}],"position":{"start":{"line":23,"column":1,"offset":810},"end":{"line":23,"column":294,"offset":1103},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"TypeScript cast of string to number\",\"date\":\"2015-05-05\",\"categories\":[\"typescript\"]}","position":{"start":{"line":26,"column":1,"offset":1106},"end":{"line":26,"column":124,"offset":1229},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":26,"column":124,"offset":1229}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript cast of string to number\",\n  \"date\": \"2015-05-05\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The simple task of casting from a primitive type to another can be sometimes easier than we think. If you come from C# you may search within TypeScript the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Convert.ToInt32()\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Int32.Parse()\"), \" or maybe just use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"(int)\"), \". None of these conversion syntaxes works with TypeScript. To cast a string to a number, you have to use JavaScript. This means that you can either use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"parseInt\"), \" function or to simply add a plus sign in from of your string.\"), mdx(\"p\", null, \"var myInt1 = +\\\"123\\\";\\nvar myInt2 = +myStringVariable;\\nvar myInt3 = parseInt(\\\"123\\\", 10);\\nvar myInt4 = Number(\\\"123\\\")\"), mdx(\"p\", null, \"The output of the variables if they are proper number are:\"), mdx(\"p\", null, \"123\\n(The number of value if the myStringVariable is a proper number)\\n123\\n123\"), mdx(\"p\", null, \"If the value are not a proper number, the result will be:\"), mdx(\"p\", null, \"NaN\\nNaN\\nNaN OR something else\\nNan \"), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"parseInt\"), \" can be deceiving. For example, if you try with \\\"123asd\\\" you will get 12 as an answer. However, if you parse \\\"asd\\\" you will get \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"NaN\"), \". I recommend using the function Number when the base is 10 and to relies on parseInt only if you are working with another base (hex for example).\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"TypeScript cast of string to number\",\n  \"date\": \"2015-05-05\",\n  \"categories\": [\"typescript\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`The simple task of casting from a primitive type to another can be sometimes easier than we think. If you come from C# you may search within TypeScript the `}<strong parentName=\"p\">{`Convert.ToInt32()`}</strong>{` or `}<strong parentName=\"p\">{`Int32.Parse()`}</strong>{` or maybe just use `}<strong parentName=\"p\">{`(int)`}</strong>{`. None of these conversion syntaxes works with TypeScript. To cast a string to a number, you have to use JavaScript. This means that you can either use the `}<strong parentName=\"p\">{`parseInt`}</strong>{` function or to simply add a plus sign in from of your string.`}</p>\n    <p>{`var myInt1 = +\"123\";\nvar myInt2 = +myStringVariable;\nvar myInt3 = parseInt(\"123\", 10);\nvar myInt4 = Number(\"123\")`}</p>\n    <p>{`The output of the variables if they are proper number are:`}</p>\n    <p>{`123\n(The number of value if the myStringVariable is a proper number)\n123\n123`}</p>\n    <p>{`If the value are not a proper number, the result will be:`}</p>\n    <p>{`NaN\nNaN\nNaN OR something else\nNan `}</p>\n    <p>{`The `}<em parentName=\"p\">{`parseInt`}</em>{` can be deceiving. For example, if you try with \"123asd\" you will get 12 as an answer. However, if you parse \"asd\" you will get `}<em parentName=\"p\">{`NaN`}</em>{`. I recommend using the function Number when the base is 10 and to relies on parseInt only if you are working with another base (hex for example).`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}