{"expireTime":9007200886478395000,"key":"gatsby-plugin-mdx-entire-payload-3d80e5d371312e398dd0135be8e284eb--undefined","val":{"mdast":{"type":"root","children":[{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"{\"Schema specified is not valid. Errors: ","position":{"start":{"line":2,"column":3,"offset":3},"end":{"line":2,"column":44,"offset":44},"indent":[]}},{"type":"text","value":"\\","position":{"start":{"line":2,"column":44,"offset":44},"end":{"line":2,"column":46,"offset":46},"indent":[]}},{"type":"text","value":"r","position":{"start":{"line":2,"column":46,"offset":46},"end":{"line":2,"column":47,"offset":47},"indent":[]}},{"type":"text","value":"\\","position":{"start":{"line":2,"column":47,"offset":47},"end":{"line":2,"column":49,"offset":49},"indent":[]}},{"type":"text","value":"nThe mapping of CLR type to EDM type is ambiguous because multiple CLR types match the EDM type 'MyClassName'. Previously found CLR type 'MyNameSpaceContext.Context.MyClassName', newly found CLR type 'MyNameSpaceModel.Domain.MyClassName'.\"}","position":{"start":{"line":2,"column":49,"offset":49},"end":{"line":2,"column":289,"offset":289},"indent":[]}}],"position":{"start":{"line":2,"column":3,"offset":3},"end":{"line":2,"column":289,"offset":289},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":289,"offset":289},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This error occur only if you have 2 classes with the same name in different namespace. It can be quite easy to reproduce without having the goal to do it also. How it's done? It's done because the Linq to Entity use model classes instead of context classes. Entity Framework can only manipulate classes that are registered to it, context classes, and not other classes even if those one are very similar.","position":{"start":{"line":4,"column":1,"offset":291},"end":{"line":4,"column":405,"offset":695},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":291},"end":{"line":4,"column":405,"offset":695},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"For example, if you want to return a list of MyClassName (context) class which are inside a collection of MyClassName (domain model), you can have this problem.","position":{"start":{"line":6,"column":1,"offset":697},"end":{"line":6,"column":161,"offset":857},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":697},"end":{"line":6,"column":161,"offset":857},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" var fromDatabase =_dataContext.Set<MyClassName>().Where(p => listMyClass.Select(d => d.ID).Contains(p.ID)); ","position":{"start":{"line":9,"column":1,"offset":860},"end":{"line":11,"column":4,"offset":983},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This won't work because listMyClass contain a list of MyClassName, but from the domain model not the context. It's easy to get wrong because usually the service layer and the repository layer receive as parameter domain object and not directly the context. To solve this issue, you need to proceed into two steps. The select to get the list of id must be done outside Linq To Entity. This way, the code will be executed as Linq to Object and won't affect Entity Framework.","position":{"start":{"line":13,"column":1,"offset":985},"end":{"line":13,"column":473,"offset":1457},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":985},"end":{"line":13,"column":473,"offset":1457},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" var arrayId = listMyClass.Select(d => d.ID).ToArray(); var fromDatabase =_dataContext.Set<MyClassName>().Where(p => arrayId.Contains(p.ID)); ","position":{"start":{"line":16,"column":1,"offset":1460},"end":{"line":18,"column":4,"offset":1616},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"That's it! Now it works because listMyClass is transformed into an array of ID which Entity Framework understand.","position":{"start":{"line":20,"column":1,"offset":1618},"end":{"line":20,"column":114,"offset":1731},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":1618},"end":{"line":20,"column":114,"offset":1731},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Entity Framework Schema specified is not valid error\",\"date\":\"2012-12-12\",\"categories\":[\"entity-framework\"]}","position":{"start":{"line":23,"column":1,"offset":1734},"end":{"line":23,"column":147,"offset":1880},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":23,"column":147,"offset":1880}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Entity Framework Schema specified is not valid error\",\n  \"date\": \"2012-12-12\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"{\\\"Schema specified is not valid. Errors: \", \"\\\\\", \"r\", \"\\\\\", \"nThe mapping of CLR type to EDM type is ambiguous because multiple CLR types match the EDM type 'MyClassName'. Previously found CLR type 'MyNameSpaceContext.Context.MyClassName', newly found CLR type 'MyNameSpaceModel.Domain.MyClassName'.\\\"}\")), mdx(\"p\", null, \"This error occur only if you have 2 classes with the same name in different namespace. It can be quite easy to reproduce without having the goal to do it also. How it's done? It's done because the Linq to Entity use model classes instead of context classes. Entity Framework can only manipulate classes that are registered to it, context classes, and not other classes even if those one are very similar.\"), mdx(\"p\", null, \"For example, if you want to return a list of MyClassName (context) class which are inside a collection of MyClassName (domain model), you can have this problem.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var fromDatabase =_dataContext.Set<MyClassName>().Where(p => listMyClass.Select(d => d.ID).Contains(p.ID)); \\n\")), mdx(\"p\", null, \"This won't work because listMyClass contain a list of MyClassName, but from the domain model not the context. It's easy to get wrong because usually the service layer and the repository layer receive as parameter domain object and not directly the context. To solve this issue, you need to proceed into two steps. The select to get the list of id must be done outside Linq To Entity. This way, the code will be executed as Linq to Object and won't affect Entity Framework.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var arrayId = listMyClass.Select(d => d.ID).ToArray(); var fromDatabase =_dataContext.Set<MyClassName>().Where(p => arrayId.Contains(p.ID)); \\n\")), mdx(\"p\", null, \"That's it! Now it works because listMyClass is transformed into an array of ID which Entity Framework understand.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Entity Framework Schema specified is not valid error\",\n  \"date\": \"2012-12-12\",\n  \"categories\": [\"entity-framework\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <blockquote>\n      <p parentName=\"blockquote\">{`{\"Schema specified is not valid. Errors: `}{`\\\\`}{`r`}{`\\\\`}{`nThe mapping of CLR type to EDM type is ambiguous because multiple CLR types match the EDM type 'MyClassName'. Previously found CLR type 'MyNameSpaceContext.Context.MyClassName', newly found CLR type 'MyNameSpaceModel.Domain.MyClassName'.\"}`}</p>\n    </blockquote>\n    <p>{`This error occur only if you have 2 classes with the same name in different namespace. It can be quite easy to reproduce without having the goal to do it also. How it's done? It's done because the Linq to Entity use model classes instead of context classes. Entity Framework can only manipulate classes that are registered to it, context classes, and not other classes even if those one are very similar.`}</p>\n    <p>{`For example, if you want to return a list of MyClassName (context) class which are inside a collection of MyClassName (domain model), you can have this problem.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` var fromDatabase =_dataContext.Set<MyClassName>().Where(p => listMyClass.Select(d => d.ID).Contains(p.ID)); \n`}</code></pre>\n    <p>{`This won't work because listMyClass contain a list of MyClassName, but from the domain model not the context. It's easy to get wrong because usually the service layer and the repository layer receive as parameter domain object and not directly the context. To solve this issue, you need to proceed into two steps. The select to get the list of id must be done outside Linq To Entity. This way, the code will be executed as Linq to Object and won't affect Entity Framework.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` var arrayId = listMyClass.Select(d => d.ID).ToArray(); var fromDatabase =_dataContext.Set<MyClassName>().Where(p => arrayId.Contains(p.ID)); \n`}</code></pre>\n    <p>{`That's it! Now it works because listMyClass is transformed into an array of ID which Entity Framework understand.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}