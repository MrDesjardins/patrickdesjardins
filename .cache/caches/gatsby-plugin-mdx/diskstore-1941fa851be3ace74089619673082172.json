{"expireTime":9007200886478391000,"key":"gatsby-plugin-mdx-entire-payload-42a171552bf0f73f848cd8d4cc6db277--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Automapper gives you big leverage when it's the time to transfer values from one object into another object. While most of the transfer is done automatically with AutoMapper, sometimes, specific values must not be transferred. Imagine the case for a destination class that has not the property or for a class that has do not want the value from the source but will compute the value in its constructor.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":403,"offset":403},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":403,"offset":403},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Automapper gives the property ","position":{"start":{"line":4,"column":1,"offset":405},"end":{"line":4,"column":31,"offset":435},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Ignore","position":{"start":{"line":4,"column":33,"offset":437},"end":{"line":4,"column":39,"offset":443},"indent":[]}}],"position":{"start":{"line":4,"column":31,"offset":435},"end":{"line":4,"column":41,"offset":445},"indent":[]}},{"type":"text","value":" which tells the mapper to not take the value of a property from the source class. ","position":{"start":{"line":4,"column":41,"offset":445},"end":{"line":4,"column":124,"offset":528},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Ignore","position":{"start":{"line":4,"column":126,"offset":530},"end":{"line":4,"column":132,"offset":536},"indent":[]}}],"position":{"start":{"line":4,"column":124,"offset":528},"end":{"line":4,"column":134,"offset":538},"indent":[]}},{"type":"text","value":" not only ignore the mapping for the property, but also ignore the mapping of all inner properties. It means that if the property is not a primitive type, but another class, that if you are using ","position":{"start":{"line":4,"column":134,"offset":538},"end":{"line":4,"column":330,"offset":734},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Ignore","position":{"start":{"line":4,"column":332,"offset":736},"end":{"line":4,"column":338,"offset":742},"indent":[]}}],"position":{"start":{"line":4,"column":330,"offset":734},"end":{"line":4,"column":340,"offset":744},"indent":[]}},{"type":"text","value":", this class properties won't be mapped. So, A.B.C would be A.Null.","position":{"start":{"line":4,"column":340,"offset":744},"end":{"line":4,"column":407,"offset":811},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":405},"end":{"line":4,"column":407,"offset":811},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"But, if you have a scenario that you must not map a property, but map all inner properties should remain then you should use ","position":{"start":{"line":6,"column":1,"offset":813},"end":{"line":6,"column":126,"offset":938},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"UseDestinationValue","position":{"start":{"line":6,"column":128,"offset":940},"end":{"line":6,"column":147,"offset":959},"indent":[]}}],"position":{"start":{"line":6,"column":126,"offset":938},"end":{"line":6,"column":149,"offset":961},"indent":[]}},{"type":"text","value":". That will end to be A.B.C -> A.B.C (where B is from the destination class, not the source class, probably initialized in the destination's constructor).","position":{"start":{"line":6,"column":149,"offset":961},"end":{"line":6,"column":303,"offset":1115},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":813},"end":{"line":6,"column":303,"offset":1115},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"To conclude, ","position":{"start":{"line":8,"column":1,"offset":1117},"end":{"line":8,"column":14,"offset":1130},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Ignore","position":{"start":{"line":8,"column":16,"offset":1132},"end":{"line":8,"column":22,"offset":1138},"indent":[]}}],"position":{"start":{"line":8,"column":14,"offset":1130},"end":{"line":8,"column":24,"offset":1140},"indent":[]}},{"type":"text","value":" method will not map any property, neither the inner properties of the property defined to be ignored. ","position":{"start":{"line":8,"column":24,"offset":1140},"end":{"line":8,"column":127,"offset":1243},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"UseDestinationValue","position":{"start":{"line":8,"column":129,"offset":1245},"end":{"line":8,"column":148,"offset":1264},"indent":[]}}],"position":{"start":{"line":8,"column":127,"offset":1243},"end":{"line":8,"column":150,"offset":1266},"indent":[]}},{"type":"text","value":" will not map the property. It keeps the existing value of the property but will map the value of this one. It's the same with a collection. The reference of the collection stays the same while the object inside is mapped.","position":{"start":{"line":8,"column":150,"offset":1266},"end":{"line":8,"column":372,"offset":1488},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":1117},"end":{"line":8,"column":372,"offset":1488},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Automapper Ignore vs UseDestinationValue, what is the difference?\",\"date\":\"2013-05-17\",\"categories\":[\"automapper\"]}","position":{"start":{"line":11,"column":1,"offset":1491},"end":{"line":11,"column":154,"offset":1644},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":11,"column":154,"offset":1644}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Automapper Ignore vs UseDestinationValue, what is the difference?\",\n  \"date\": \"2013-05-17\",\n  \"categories\": [\"automapper\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Automapper gives you big leverage when it's the time to transfer values from one object into another object. While most of the transfer is done automatically with AutoMapper, sometimes, specific values must not be transferred. Imagine the case for a destination class that has not the property or for a class that has do not want the value from the source but will compute the value in its constructor.\"), mdx(\"p\", null, \"Automapper gives the property \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ignore\"), \" which tells the mapper to not take the value of a property from the source class. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ignore\"), \" not only ignore the mapping for the property, but also ignore the mapping of all inner properties. It means that if the property is not a primitive type, but another class, that if you are using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ignore\"), \", this class properties won't be mapped. So, A.B.C would be A.Null.\"), mdx(\"p\", null, \"But, if you have a scenario that you must not map a property, but map all inner properties should remain then you should use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"UseDestinationValue\"), \". That will end to be A.B.C -> A.B.C (where B is from the destination class, not the source class, probably initialized in the destination's constructor).\"), mdx(\"p\", null, \"To conclude, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ignore\"), \" method will not map any property, neither the inner properties of the property defined to be ignored. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"UseDestinationValue\"), \" will not map the property. It keeps the existing value of the property but will map the value of this one. It's the same with a collection. The reference of the collection stays the same while the object inside is mapped.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Automapper Ignore vs UseDestinationValue, what is the difference?\",\n  \"date\": \"2013-05-17\",\n  \"categories\": [\"automapper\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Automapper gives you big leverage when it's the time to transfer values from one object into another object. While most of the transfer is done automatically with AutoMapper, sometimes, specific values must not be transferred. Imagine the case for a destination class that has not the property or for a class that has do not want the value from the source but will compute the value in its constructor.`}</p>\n    <p>{`Automapper gives the property `}<strong parentName=\"p\">{`Ignore`}</strong>{` which tells the mapper to not take the value of a property from the source class. `}<strong parentName=\"p\">{`Ignore`}</strong>{` not only ignore the mapping for the property, but also ignore the mapping of all inner properties. It means that if the property is not a primitive type, but another class, that if you are using `}<strong parentName=\"p\">{`Ignore`}</strong>{`, this class properties won't be mapped. So, A.B.C would be A.Null.`}</p>\n    <p>{`But, if you have a scenario that you must not map a property, but map all inner properties should remain then you should use `}<strong parentName=\"p\">{`UseDestinationValue`}</strong>{`. That will end to be A.B.C -> A.B.C (where B is from the destination class, not the source class, probably initialized in the destination's constructor).`}</p>\n    <p>{`To conclude, `}<strong parentName=\"p\">{`Ignore`}</strong>{` method will not map any property, neither the inner properties of the property defined to be ignored. `}<strong parentName=\"p\">{`UseDestinationValue`}</strong>{` will not map the property. It keeps the existing value of the property but will map the value of this one. It's the same with a collection. The reference of the collection stays the same while the object inside is mapped.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}