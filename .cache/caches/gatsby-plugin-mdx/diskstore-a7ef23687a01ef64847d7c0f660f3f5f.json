{"expireTime":9007200886478381000,"key":"gatsby-plugin-mdx-entire-payload-51ce058a3b2f86f0a0ce81b34026e312--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"If an array contains element that are uniformly distributed, it's possible to each an asymptotic analysis of Big O(log log n).","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":127,"offset":127},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":127,"offset":127},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The whole problem is about determining the position. This is done by finding the position. This is the iterative solution.","position":{"start":{"line":4,"column":1,"offset":129},"end":{"line":4,"column":123,"offset":251},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":129},"end":{"line":4,"column":123,"offset":251},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var arrayToSearch = [2, 6, 8, 12, 14, 16, 20, 24, 26, 28, 30, 31, 35];\n\nconsole.log(\"Found at position :\" + interpolationSearch(arrayToSearch, 2));\nconsole.log(\"Found at position :\" + interpolationSearch(arrayToSearch, 12));\nconsole.log(\"Found at position :\" + interpolationSearch(arrayToSearch, 35));\nconsole.log(\"Found at position :\" + interpolationSearch(arrayToSearch, 44444));\n\nfunction interpolationSearch(arrayToSearch, valueToSearch) {\n  var length = arrayToSearch.length;\n  var low = 0;\n  var high = length - 1;\n  var position = -1;\n  var delta = -1;\n  while (\n    low <= high &&\n    valueToSearch >= arrayToSearch[low] &&\n    valueToSearch <= arrayToSearch[high]\n  ) {\n    delta =\n      (valueToSearch - arrayToSearch[low]) /\n      (arrayToSearch[high] - arrayToSearch[low]);\n    position = low + Math.floor((high - low) * delta);\n    if (arrayToSearch[position] == valueToSearch) {\n      return position;\n    }\n    if (arrayToSearch[position] < valueToSearch) {\n      low = position + 1;\n    } else {\n      high = position - 1;\n    }\n  }\n\n  return -1;\n}","position":{"start":{"line":6,"column":1,"offset":253},"end":{"line":41,"column":4,"offset":1335},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This can be easily transformed into the a recursive algorithm.","position":{"start":{"line":43,"column":1,"offset":1337},"end":{"line":43,"column":63,"offset":1399},"indent":[]}}],"position":{"start":{"line":43,"column":1,"offset":1337},"end":{"line":43,"column":63,"offset":1399},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var arrayToSearch = [2, 6, 8, 12, 14, 16, 20, 24, 26, 28, 30, 31, 35];\nvar length = arrayToSearch.length;\nvar low = 0;\nvar high = length - 1;\nconsole.log(\n  \"Found at position :\" + interpolationSearch(arrayToSearch, 2, 0, high)\n);\nconsole.log(\n  \"Found at position :\" + interpolationSearch(arrayToSearch, 12, 0, high)\n);\nconsole.log(\n  \"Found at position :\" + interpolationSearch(arrayToSearch, 35, 0, high)\n);\nconsole.log(\n  \"Found at position :\" + interpolationSearch(arrayToSearch, 44444, 0, high)\n);\n\nfunction interpolationSearch(arrayToSearch, valueToSearch, low, high) {\n  if (\n    low <= high &&\n    valueToSearch >= arrayToSearch[low] &&\n    valueToSearch <= arrayToSearch[high]\n  ) {\n    var delta =\n      (valueToSearch - arrayToSearch[low]) /\n      (arrayToSearch[high] - arrayToSearch[low]);\n    var position = low + Math.floor((high - low) * delta);\n    if (arrayToSearch[position] == valueToSearch) {\n      return position;\n    }\n    if (arrayToSearch[position] < valueToSearch) {\n      low = position + 1;\n    } else {\n      high = position - 1;\n    }\n    return interpolationSearch(arrayToSearch, valueToSearch, low, high);\n  }\n\n  return -1;\n}","position":{"start":{"line":45,"column":1,"offset":1401},"end":{"line":86,"column":4,"offset":2578},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"JavaScript Interpolation Search\",\"date\":\"2017-06-22\",\"categories\":[\"javascript\"]}","position":{"start":{"line":89,"column":1,"offset":2581},"end":{"line":89,"column":120,"offset":2700},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":89,"column":120,"offset":2700}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Interpolation Search\",\n  \"date\": \"2017-06-22\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If an array contains element that are uniformly distributed, it's possible to each an asymptotic analysis of Big O(log log n).\"), mdx(\"p\", null, \"The whole problem is about determining the position. This is done by finding the position. This is the iterative solution.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var arrayToSearch = [2, 6, 8, 12, 14, 16, 20, 24, 26, 28, 30, 31, 35];\\n\\nconsole.log(\\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 2));\\nconsole.log(\\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 12));\\nconsole.log(\\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 35));\\nconsole.log(\\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 44444));\\n\\nfunction interpolationSearch(arrayToSearch, valueToSearch) {\\n  var length = arrayToSearch.length;\\n  var low = 0;\\n  var high = length - 1;\\n  var position = -1;\\n  var delta = -1;\\n  while (\\n    low <= high &&\\n    valueToSearch >= arrayToSearch[low] &&\\n    valueToSearch <= arrayToSearch[high]\\n  ) {\\n    delta =\\n      (valueToSearch - arrayToSearch[low]) /\\n      (arrayToSearch[high] - arrayToSearch[low]);\\n    position = low + Math.floor((high - low) * delta);\\n    if (arrayToSearch[position] == valueToSearch) {\\n      return position;\\n    }\\n    if (arrayToSearch[position] < valueToSearch) {\\n      low = position + 1;\\n    } else {\\n      high = position - 1;\\n    }\\n  }\\n\\n  return -1;\\n}\\n\")), mdx(\"p\", null, \"This can be easily transformed into the a recursive algorithm.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var arrayToSearch = [2, 6, 8, 12, 14, 16, 20, 24, 26, 28, 30, 31, 35];\\nvar length = arrayToSearch.length;\\nvar low = 0;\\nvar high = length - 1;\\nconsole.log(\\n  \\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 2, 0, high)\\n);\\nconsole.log(\\n  \\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 12, 0, high)\\n);\\nconsole.log(\\n  \\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 35, 0, high)\\n);\\nconsole.log(\\n  \\\"Found at position :\\\" + interpolationSearch(arrayToSearch, 44444, 0, high)\\n);\\n\\nfunction interpolationSearch(arrayToSearch, valueToSearch, low, high) {\\n  if (\\n    low <= high &&\\n    valueToSearch >= arrayToSearch[low] &&\\n    valueToSearch <= arrayToSearch[high]\\n  ) {\\n    var delta =\\n      (valueToSearch - arrayToSearch[low]) /\\n      (arrayToSearch[high] - arrayToSearch[low]);\\n    var position = low + Math.floor((high - low) * delta);\\n    if (arrayToSearch[position] == valueToSearch) {\\n      return position;\\n    }\\n    if (arrayToSearch[position] < valueToSearch) {\\n      low = position + 1;\\n    } else {\\n      high = position - 1;\\n    }\\n    return interpolationSearch(arrayToSearch, valueToSearch, low, high);\\n  }\\n\\n  return -1;\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"JavaScript Interpolation Search\",\n  \"date\": \"2017-06-22\",\n  \"categories\": [\"javascript\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`If an array contains element that are uniformly distributed, it's possible to each an asymptotic analysis of Big O(log log n).`}</p>\n    <p>{`The whole problem is about determining the position. This is done by finding the position. This is the iterative solution.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var arrayToSearch = [2, 6, 8, 12, 14, 16, 20, 24, 26, 28, 30, 31, 35];\n\nconsole.log(\"Found at position :\" + interpolationSearch(arrayToSearch, 2));\nconsole.log(\"Found at position :\" + interpolationSearch(arrayToSearch, 12));\nconsole.log(\"Found at position :\" + interpolationSearch(arrayToSearch, 35));\nconsole.log(\"Found at position :\" + interpolationSearch(arrayToSearch, 44444));\n\nfunction interpolationSearch(arrayToSearch, valueToSearch) {\n  var length = arrayToSearch.length;\n  var low = 0;\n  var high = length - 1;\n  var position = -1;\n  var delta = -1;\n  while (\n    low <= high &&\n    valueToSearch >= arrayToSearch[low] &&\n    valueToSearch <= arrayToSearch[high]\n  ) {\n    delta =\n      (valueToSearch - arrayToSearch[low]) /\n      (arrayToSearch[high] - arrayToSearch[low]);\n    position = low + Math.floor((high - low) * delta);\n    if (arrayToSearch[position] == valueToSearch) {\n      return position;\n    }\n    if (arrayToSearch[position] < valueToSearch) {\n      low = position + 1;\n    } else {\n      high = position - 1;\n    }\n  }\n\n  return -1;\n}\n`}</code></pre>\n    <p>{`This can be easily transformed into the a recursive algorithm.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var arrayToSearch = [2, 6, 8, 12, 14, 16, 20, 24, 26, 28, 30, 31, 35];\nvar length = arrayToSearch.length;\nvar low = 0;\nvar high = length - 1;\nconsole.log(\n  \"Found at position :\" + interpolationSearch(arrayToSearch, 2, 0, high)\n);\nconsole.log(\n  \"Found at position :\" + interpolationSearch(arrayToSearch, 12, 0, high)\n);\nconsole.log(\n  \"Found at position :\" + interpolationSearch(arrayToSearch, 35, 0, high)\n);\nconsole.log(\n  \"Found at position :\" + interpolationSearch(arrayToSearch, 44444, 0, high)\n);\n\nfunction interpolationSearch(arrayToSearch, valueToSearch, low, high) {\n  if (\n    low <= high &&\n    valueToSearch >= arrayToSearch[low] &&\n    valueToSearch <= arrayToSearch[high]\n  ) {\n    var delta =\n      (valueToSearch - arrayToSearch[low]) /\n      (arrayToSearch[high] - arrayToSearch[low]);\n    var position = low + Math.floor((high - low) * delta);\n    if (arrayToSearch[position] == valueToSearch) {\n      return position;\n    }\n    if (arrayToSearch[position] < valueToSearch) {\n      low = position + 1;\n    } else {\n      high = position - 1;\n    }\n    return interpolationSearch(arrayToSearch, valueToSearch, low, high);\n  }\n\n  return -1;\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}