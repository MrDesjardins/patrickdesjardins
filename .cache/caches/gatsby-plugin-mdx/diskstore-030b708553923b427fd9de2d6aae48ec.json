{"expireTime":9007200886478396000,"key":"gatsby-plugin-mdx-entire-payload-5dd17af08436522264b8f3e379849c1d--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"It's really easy to have in ASP.NET MVC a function that return an anonymous type. I say in ASP.NET MVC but this could be also in ASP.NET. In fact, when you have an action inside a controller that return a JsonResult you can simply return an anonymous type and Javascript will be able to handle it as simple as using the same syntax that you would use with object in C#.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":370,"offset":370},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":370,"offset":370},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public JsonResult Update(MyObject o) { //... return Json(new { IsSaved = false, Id = 123}); } ","position":{"start":{"line":5,"column":1,"offset":373},"end":{"line":7,"column":4,"offset":482},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"In Javascript you would use :","position":{"start":{"line":9,"column":1,"offset":484},"end":{"line":9,"column":30,"offset":513},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":484},"end":{"line":9,"column":30,"offset":513},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"//...Ajax call success: function (data) { var x = data.IsSaved; var xx = data.Id; } ","position":{"start":{"line":11,"column":1,"offset":515},"end":{"line":13,"column":5,"offset":618},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"To unit test this scenario, you need to do two things. First, you need to use the ","position":{"start":{"line":16,"column":1,"offset":621},"end":{"line":16,"column":83,"offset":703},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"dynamic","position":{"start":{"line":16,"column":85,"offset":705},"end":{"line":16,"column":92,"offset":712},"indent":[]}}],"position":{"start":{"line":16,"column":83,"offset":703},"end":{"line":16,"column":94,"offset":714},"indent":[]}},{"type":"text","value":" keyword of .Net to be able to receive from the controller the response of the action which is anonymous.","position":{"start":{"line":16,"column":94,"offset":714},"end":{"line":16,"column":199,"offset":819},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":621},"end":{"line":16,"column":199,"offset":819},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" dynamic returnedData = myController.Update(new MyObject()); ","position":{"start":{"line":19,"column":1,"offset":822},"end":{"line":21,"column":4,"offset":897},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The problem is that everything that has been generated as anonymous in a DLL stay internal. If you are doing you unit testing in a separated assembly (DLL) you will need to explicitly say that you want to share internal values with another assembly. This can be done by modifying the assembly configuration by editing ","position":{"start":{"line":23,"column":1,"offset":899},"end":{"line":23,"column":319,"offset":1217},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"AssemblyInfo.cs","position":{"start":{"line":23,"column":321,"offset":1219},"end":{"line":23,"column":336,"offset":1234},"indent":[]}}],"position":{"start":{"line":23,"column":319,"offset":1217},"end":{"line":23,"column":338,"offset":1236},"indent":[]}},{"type":"text","value":". You need to open the file AssemblyInfo.cs of the tested controller and add the following statement.","position":{"start":{"line":23,"column":338,"offset":1236},"end":{"line":23,"column":439,"offset":1337},"indent":[]}}],"position":{"start":{"line":23,"column":1,"offset":899},"end":{"line":23,"column":439,"offset":1337},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" [assembly: InternalsVisibleTo(\"Tests.Unit\")] ","position":{"start":{"line":26,"column":1,"offset":1340},"end":{"line":28,"column":4,"offset":1400},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This will give the permission to see internal to the unit testing project called \"Tests.Unit\".","position":{"start":{"line":30,"column":1,"offset":1402},"end":{"line":30,"column":95,"offset":1496},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":1402},"end":{"line":30,"column":95,"offset":1496},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"How to unit test a method that return an anonymous type?\",\"date\":\"2012-04-02\",\"categories\":[\"asp-mvc\",\"c-sharp\",\"dynamic\"]}","position":{"start":{"line":33,"column":1,"offset":1499},"end":{"line":33,"column":162,"offset":1660},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":33,"column":162,"offset":1660}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to unit test a method that return an anonymous type?\",\n  \"date\": \"2012-04-02\",\n  \"categories\": [\"asp-mvc\", \"c-sharp\", \"dynamic\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"It's really easy to have in ASP.NET MVC a function that return an anonymous type. I say in ASP.NET MVC but this could be also in ASP.NET. In fact, when you have an action inside a controller that return a JsonResult you can simply return an anonymous type and Javascript will be able to handle it as simple as using the same syntax that you would use with object in C#.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public JsonResult Update(MyObject o) { //... return Json(new { IsSaved = false, Id = 123}); } \\n\")), mdx(\"p\", null, \"In Javascript you would use :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"//...Ajax call success: function (data) { var x = data.IsSaved; var xx = data.Id; } \\n\")), mdx(\"p\", null, \"To unit test this scenario, you need to do two things. First, you need to use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dynamic\"), \" keyword of .Net to be able to receive from the controller the response of the action which is anonymous.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" dynamic returnedData = myController.Update(new MyObject()); \\n\")), mdx(\"p\", null, \"The problem is that everything that has been generated as anonymous in a DLL stay internal. If you are doing you unit testing in a separated assembly (DLL) you will need to explicitly say that you want to share internal values with another assembly. This can be done by modifying the assembly configuration by editing \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AssemblyInfo.cs\"), \". You need to open the file AssemblyInfo.cs of the tested controller and add the following statement.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" [assembly: InternalsVisibleTo(\\\"Tests.Unit\\\")] \\n\")), mdx(\"p\", null, \"This will give the permission to see internal to the unit testing project called \\\"Tests.Unit\\\".\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"How to unit test a method that return an anonymous type?\",\n  \"date\": \"2012-04-02\",\n  \"categories\": [\"asp-mvc\", \"c-sharp\", \"dynamic\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`It's really easy to have in ASP.NET MVC a function that return an anonymous type. I say in ASP.NET MVC but this could be also in ASP.NET. In fact, when you have an action inside a controller that return a JsonResult you can simply return an anonymous type and Javascript will be able to handle it as simple as using the same syntax that you would use with object in C#.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public JsonResult Update(MyObject o) { //... return Json(new { IsSaved = false, Id = 123}); } \n`}</code></pre>\n    <p>{`In Javascript you would use :`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`//...Ajax call success: function (data) { var x = data.IsSaved; var xx = data.Id; } \n`}</code></pre>\n    <p>{`To unit test this scenario, you need to do two things. First, you need to use the `}<strong parentName=\"p\">{`dynamic`}</strong>{` keyword of .Net to be able to receive from the controller the response of the action which is anonymous.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` dynamic returnedData = myController.Update(new MyObject()); \n`}</code></pre>\n    <p>{`The problem is that everything that has been generated as anonymous in a DLL stay internal. If you are doing you unit testing in a separated assembly (DLL) you will need to explicitly say that you want to share internal values with another assembly. This can be done by modifying the assembly configuration by editing `}<strong parentName=\"p\">{`AssemblyInfo.cs`}</strong>{`. You need to open the file AssemblyInfo.cs of the tested controller and add the following statement.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` [assembly: InternalsVisibleTo(\"Tests.Unit\")] \n`}</code></pre>\n    <p>{`This will give the permission to see internal to the unit testing project called \"Tests.Unit\".`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}