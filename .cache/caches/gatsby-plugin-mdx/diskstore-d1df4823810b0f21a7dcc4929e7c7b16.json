{"expireTime":9007200886478388000,"key":"gatsby-plugin-mdx-entire-payload-f6e833353055f63fe2293cf1c5d62589--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"The EditorTemplate and the DisplayTemplate can be used with the HtmlHelper EditorFor and DisplayFor. It is also possible to pass in a second parameter custom html attributes. This is very interesting if you need to add style class.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":232,"offset":232},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":232,"offset":232},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" @Html.EditorFor(d => d.PriceLimit , new {htmlAttributes = new { @class = \"col-md-8 order-price-money-limit\" }}) ","position":{"start":{"line":5,"column":1,"offset":235},"end":{"line":7,"column":4,"offset":362},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The example above call the EditorFor on the PriceLimit property. It has in its second parameter an anonymous object that set htmlAttibutes. This one is also an anonymous object that set two classes. One class is for BootStrap and the second is a custom one.","position":{"start":{"line":9,"column":1,"offset":364},"end":{"line":9,"column":258,"offset":621},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":364},"end":{"line":9,"column":258,"offset":621},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If you have defined that the PriceLimit must use a custom home made template, than you may want to gather this information and use it on the html element you desire.","position":{"start":{"line":11,"column":1,"offset":623},"end":{"line":11,"column":166,"offset":788},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":623},"end":{"line":11,"column":166,"offset":788},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"For example, this is the custom editor template:","position":{"start":{"line":13,"column":1,"offset":790},"end":{"line":13,"column":49,"offset":838},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":790},"end":{"line":13,"column":49,"offset":838},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" <div ?????????> @Html.EditorFor(viewModel => viewModel.Current.Value) @Html.HiddenFor(viewModel => viewModel.Current.Currency.Id) </div> ","position":{"start":{"line":16,"column":1,"offset":841},"end":{"line":18,"column":4,"offset":993},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"As you can see, the first line would like to benefit of the html attributes passed by the EditorFor.","position":{"start":{"line":20,"column":1,"offset":995},"end":{"line":20,"column":101,"offset":1095},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":995},"end":{"line":20,"column":101,"offset":1095},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The task would have been easy if we only wanted to pass the html attribute to a TextBoxFor, or any existing defined Html helper because you could simply set the viewdata back to the second parameter. However, if you are in the scenario that you want to use the html attributes for any html element, than some code must be done. Also, we need to think about the possibility that the custom editor template (or display template) may want to have html attribute by default and just be enhanced by the html attributes passed by the Html Helper.","position":{"start":{"line":22,"column":1,"offset":1097},"end":{"line":22,"column":541,"offset":1637},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":1097},"end":{"line":22,"column":541,"offset":1637},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" <div class=\"constant-class-always-there ????\" ?????????> @Html.EditorFor(viewModel => viewModel.Current.Value) @Html.HiddenFor(viewModel => viewModel.Current.Currency.Id) </div> ","position":{"start":{"line":25,"column":1,"offset":1640},"end":{"line":27,"column":4,"offset":1833},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The first task is to handle the case that we may want to have default attribute. The code that is following this paragraph is set at the top of the Editor Template. In this example, we want to be sure that the class \"input-group\" is set. Whatever what is passed on the Html Helper EditorFor, we want to have this class set.","position":{"start":{"line":29,"column":1,"offset":1835},"end":{"line":29,"column":324,"offset":2158},"indent":[]}}],"position":{"start":{"line":29,"column":1,"offset":1835},"end":{"line":29,"column":324,"offset":2158},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" @{ object htmlAttributes = null; if (Html.ViewData.ContainsKey(\"htmlAttributes\")) { htmlAttributes = Html.Custom().RenderHtmlAttributes(ViewData[\"htmlAttributes\"], new { @class = \"input-group\" }); } else { htmlAttributes = Html.Custom().RenderHtmlAttributes(new{@class=\"input-group\"}); } } ","position":{"start":{"line":32,"column":1,"offset":2161},"end":{"line":34,"column":4,"offset":2466},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The IF check if the EditorFor html helper contains any html attributes, if it is the case, than it add it to the EditorFor html attributes, otherwise, it just set it without taking care of the view data passed by the html helper. Something may have catch your attention : the RenderHtmlAttributes method. This is a custom html helper that takes one or multiple object and create a MvcHtmlString to be used to your Razor code. The end result would look like this:","position":{"start":{"line":36,"column":1,"offset":2468},"end":{"line":36,"column":463,"offset":2930},"indent":[]}}],"position":{"start":{"line":36,"column":1,"offset":2468},"end":{"line":36,"column":463,"offset":2930},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":"@{ object htmlAttributes = null; if (Html.ViewData.ContainsKey(\"htmlAttributes\")) { htmlAttributes = Html.Custom().RenderHtmlAttributes(ViewData[\"htmlAttributes\"], new { @class = \"input-group\" }); } else { htmlAttributes = Html.Custom().RenderHtmlAttributes(new{@class=\"input-group\"}); } } <div @htmlAttributes> @Html.EditorFor(viewModel => viewModel.Current.Value) @Html.HiddenFor(viewModel => viewModel.Current.Currency.Id) </div> ","position":{"start":{"line":38,"column":1,"offset":2932},"end":{"line":40,"column":4,"offset":3379},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The RenderHtmlAttributes loops all html attributes object and extend each of them to create a final RouteValueDictionary. Finally, it creates a string.","position":{"start":{"line":42,"column":1,"offset":3381},"end":{"line":42,"column":152,"offset":3532},"indent":[]}}],"position":{"start":{"line":42,"column":1,"offset":3381},"end":{"line":42,"column":152,"offset":3532},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" /// <summary> /// Render one or many html attribute together /// </summary> /// <param name=\"htmlAttributes\"></param> /// <returns></returns> public MvcHtmlString RenderHtmlAttributes(params object[] htmlAttributes) { var finalRouteValue = new RouteValueDictionary(); foreach (var htmlAttribute in htmlAttributes) { var routeValue = new RouteValueDictionary(htmlAttribute); finalRouteValue = finalRouteValue.Extend(routeValue); } var htmlAttributesString = String.Join(\" \", finalRouteValue.Keys.Select(key => String.Format(\"{0}=\\\\\"{1}\\\\\"\", key, this.htmlHelper.Encode(finalRouteValue[key])))); return MvcHtmlString.Create(htmlAttributesString); } ","position":{"start":{"line":45,"column":1,"offset":3535},"end":{"line":47,"column":4,"offset":4197},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The heavy lift about handling if one html attribute object contains a key that has already been defined or not to handle the merge is done in the ","position":{"start":{"line":49,"column":1,"offset":4199},"end":{"line":49,"column":147,"offset":4345},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Extend","position":{"start":{"line":49,"column":149,"offset":4347},"end":{"line":49,"column":155,"offset":4353},"indent":[]}}],"position":{"start":{"line":49,"column":147,"offset":4345},"end":{"line":49,"column":157,"offset":4355},"indent":[]}},{"type":"text","value":" method. For example, if two html attributes define the key \"class\" than we want to merge both value to have in the final result a single \"class\" key with both class value defined.","position":{"start":{"line":49,"column":157,"offset":4355},"end":{"line":49,"column":337,"offset":4535},"indent":[]}}],"position":{"start":{"line":49,"column":1,"offset":4199},"end":{"line":49,"column":337,"offset":4535},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" /// <summary> /// The extend method takes values from the source and add them into the destination. You do not need to use the return value /// because the destination object will already have the element of the source. /// </summary> /// <param name=\"destination\"></param> /// <param name=\"source\"></param> /// <returns></returns> public static RouteValueDictionary Extend(this RouteValueDictionary destination, IEnumerable<KeyValuePair<string, object>> source) { foreach (var srcElement in source.ToList()) { if (destination.ContainsKey(srcElement.Key)) { destination[srcElement.Key] += \" \" + srcElement.Value; } else { destination[srcElement.Key] = srcElement.Value; } } return destination; } ","position":{"start":{"line":52,"column":1,"offset":4538},"end":{"line":54,"column":4,"offset":5249},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Here is two unit tests. The first one has two different keys. The end result is that both keys are not merged together. The second test has two route value with the same key. Each of them with different values. The result is that both value are in the first object.","position":{"start":{"line":56,"column":1,"offset":5251},"end":{"line":56,"column":266,"offset":5516},"indent":[]}}],"position":{"start":{"line":56,"column":1,"offset":5251},"end":{"line":56,"column":266,"offset":5516},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" [TestClass] public class RouteExtensionsTest { [TestMethod] public void GivenTwoRouteValueDictionary_WhenBothDoesNotContainSameKey_ThenValueAreNotMerged() { // Arrange var valueObject1 = new RouteValueDictionary { { \"key1\", \"value1\" } }; var valueObject2 = new RouteValueDictionary { { \"key2\", \"value2\" } };\n\n// Act valueObject1.Extend(valueObject2);\n\n// Assert Assert.AreEqual(\"value1\", valueObject1[\"key1\"].ToString()); }\n\n[TestMethod] public void GivenTwoRouteValueDictionary_WhenBothContainSameKey_ThenValueAreMerged() { // Arrange var valueObject1 = new RouteValueDictionary {{\"key1\", \"value1\"}}; var valueObject2 = new RouteValueDictionary {{\"key1\", \"value2\"}};\n\n// Act valueObject1.Extend(valueObject2);\n\n// Assert Assert.AreEqual(\"value1 value2\", valueObject1[\"key1\"].ToString()); } } ","position":{"start":{"line":59,"column":1,"offset":5519},"end":{"line":71,"column":4,"offset":6327},"indent":[1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"It requires some work to work with Editor Template and Display Template when you want to go beyond basic functionality. However, it is possible to extend everything with some Html Helper and Extension methods.","position":{"start":{"line":73,"column":1,"offset":6329},"end":{"line":73,"column":210,"offset":6538},"indent":[]}}],"position":{"start":{"line":73,"column":1,"offset":6329},"end":{"line":73,"column":210,"offset":6538},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Asp.Net MVC EditorTemplate and DisplayTemplate with HtmlAttributes On Custom Template\",\"date\":\"2014-09-02\",\"categories\":[\"asp-mvc\"]}","position":{"start":{"line":76,"column":1,"offset":6541},"end":{"line":76,"column":171,"offset":6711},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":76,"column":171,"offset":6711}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Asp.Net MVC EditorTemplate and DisplayTemplate with HtmlAttributes On Custom Template\",\n  \"date\": \"2014-09-02\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The EditorTemplate and the DisplayTemplate can be used with the HtmlHelper EditorFor and DisplayFor. It is also possible to pass in a second parameter custom html attributes. This is very interesting if you need to add style class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" @Html.EditorFor(d => d.PriceLimit , new {htmlAttributes = new { @class = \\\"col-md-8 order-price-money-limit\\\" }}) \\n\")), mdx(\"p\", null, \"The example above call the EditorFor on the PriceLimit property. It has in its second parameter an anonymous object that set htmlAttibutes. This one is also an anonymous object that set two classes. One class is for BootStrap and the second is a custom one.\"), mdx(\"p\", null, \"If you have defined that the PriceLimit must use a custom home made template, than you may want to gather this information and use it on the html element you desire.\"), mdx(\"p\", null, \"For example, this is the custom editor template:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" <div ?????????> @Html.EditorFor(viewModel => viewModel.Current.Value) @Html.HiddenFor(viewModel => viewModel.Current.Currency.Id) </div> \\n\")), mdx(\"p\", null, \"As you can see, the first line would like to benefit of the html attributes passed by the EditorFor.\"), mdx(\"p\", null, \"The task would have been easy if we only wanted to pass the html attribute to a TextBoxFor, or any existing defined Html helper because you could simply set the viewdata back to the second parameter. However, if you are in the scenario that you want to use the html attributes for any html element, than some code must be done. Also, we need to think about the possibility that the custom editor template (or display template) may want to have html attribute by default and just be enhanced by the html attributes passed by the Html Helper.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" <div class=\\\"constant-class-always-there ????\\\" ?????????> @Html.EditorFor(viewModel => viewModel.Current.Value) @Html.HiddenFor(viewModel => viewModel.Current.Currency.Id) </div> \\n\")), mdx(\"p\", null, \"The first task is to handle the case that we may want to have default attribute. The code that is following this paragraph is set at the top of the Editor Template. In this example, we want to be sure that the class \\\"input-group\\\" is set. Whatever what is passed on the Html Helper EditorFor, we want to have this class set.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" @{ object htmlAttributes = null; if (Html.ViewData.ContainsKey(\\\"htmlAttributes\\\")) { htmlAttributes = Html.Custom().RenderHtmlAttributes(ViewData[\\\"htmlAttributes\\\"], new { @class = \\\"input-group\\\" }); } else { htmlAttributes = Html.Custom().RenderHtmlAttributes(new{@class=\\\"input-group\\\"}); } } \\n\")), mdx(\"p\", null, \"The IF check if the EditorFor html helper contains any html attributes, if it is the case, than it add it to the EditorFor html attributes, otherwise, it just set it without taking care of the view data passed by the html helper. Something may have catch your attention : the RenderHtmlAttributes method. This is a custom html helper that takes one or multiple object and create a MvcHtmlString to be used to your Razor code. The end result would look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"@{ object htmlAttributes = null; if (Html.ViewData.ContainsKey(\\\"htmlAttributes\\\")) { htmlAttributes = Html.Custom().RenderHtmlAttributes(ViewData[\\\"htmlAttributes\\\"], new { @class = \\\"input-group\\\" }); } else { htmlAttributes = Html.Custom().RenderHtmlAttributes(new{@class=\\\"input-group\\\"}); } } <div @htmlAttributes> @Html.EditorFor(viewModel => viewModel.Current.Value) @Html.HiddenFor(viewModel => viewModel.Current.Currency.Id) </div> \\n\")), mdx(\"p\", null, \"The RenderHtmlAttributes loops all html attributes object and extend each of them to create a final RouteValueDictionary. Finally, it creates a string.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" /// <summary> /// Render one or many html attribute together /// </summary> /// <param name=\\\"htmlAttributes\\\"></param> /// <returns></returns> public MvcHtmlString RenderHtmlAttributes(params object[] htmlAttributes) { var finalRouteValue = new RouteValueDictionary(); foreach (var htmlAttribute in htmlAttributes) { var routeValue = new RouteValueDictionary(htmlAttribute); finalRouteValue = finalRouteValue.Extend(routeValue); } var htmlAttributesString = String.Join(\\\" \\\", finalRouteValue.Keys.Select(key => String.Format(\\\"{0}=\\\\\\\\\\\"{1}\\\\\\\\\\\"\\\", key, this.htmlHelper.Encode(finalRouteValue[key])))); return MvcHtmlString.Create(htmlAttributesString); } \\n\")), mdx(\"p\", null, \"The heavy lift about handling if one html attribute object contains a key that has already been defined or not to handle the merge is done in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Extend\"), \" method. For example, if two html attributes define the key \\\"class\\\" than we want to merge both value to have in the final result a single \\\"class\\\" key with both class value defined.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" /// <summary> /// The extend method takes values from the source and add them into the destination. You do not need to use the return value /// because the destination object will already have the element of the source. /// </summary> /// <param name=\\\"destination\\\"></param> /// <param name=\\\"source\\\"></param> /// <returns></returns> public static RouteValueDictionary Extend(this RouteValueDictionary destination, IEnumerable<KeyValuePair<string, object>> source) { foreach (var srcElement in source.ToList()) { if (destination.ContainsKey(srcElement.Key)) { destination[srcElement.Key] += \\\" \\\" + srcElement.Value; } else { destination[srcElement.Key] = srcElement.Value; } } return destination; } \\n\")), mdx(\"p\", null, \"Here is two unit tests. The first one has two different keys. The end result is that both keys are not merged together. The second test has two route value with the same key. Each of them with different values. The result is that both value are in the first object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" [TestClass] public class RouteExtensionsTest { [TestMethod] public void GivenTwoRouteValueDictionary_WhenBothDoesNotContainSameKey_ThenValueAreNotMerged() { // Arrange var valueObject1 = new RouteValueDictionary { { \\\"key1\\\", \\\"value1\\\" } }; var valueObject2 = new RouteValueDictionary { { \\\"key2\\\", \\\"value2\\\" } };\\n\\n// Act valueObject1.Extend(valueObject2);\\n\\n// Assert Assert.AreEqual(\\\"value1\\\", valueObject1[\\\"key1\\\"].ToString()); }\\n\\n[TestMethod] public void GivenTwoRouteValueDictionary_WhenBothContainSameKey_ThenValueAreMerged() { // Arrange var valueObject1 = new RouteValueDictionary {{\\\"key1\\\", \\\"value1\\\"}}; var valueObject2 = new RouteValueDictionary {{\\\"key1\\\", \\\"value2\\\"}};\\n\\n// Act valueObject1.Extend(valueObject2);\\n\\n// Assert Assert.AreEqual(\\\"value1 value2\\\", valueObject1[\\\"key1\\\"].ToString()); } } \\n\")), mdx(\"p\", null, \"It requires some work to work with Editor Template and Display Template when you want to go beyond basic functionality. However, it is possible to extend everything with some Html Helper and Extension methods.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Asp.Net MVC EditorTemplate and DisplayTemplate with HtmlAttributes On Custom Template\",\n  \"date\": \"2014-09-02\",\n  \"categories\": [\"asp-mvc\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`The EditorTemplate and the DisplayTemplate can be used with the HtmlHelper EditorFor and DisplayFor. It is also possible to pass in a second parameter custom html attributes. This is very interesting if you need to add style class.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` @Html.EditorFor(d => d.PriceLimit , new {htmlAttributes = new { @class = \"col-md-8 order-price-money-limit\" }}) \n`}</code></pre>\n    <p>{`The example above call the EditorFor on the PriceLimit property. It has in its second parameter an anonymous object that set htmlAttibutes. This one is also an anonymous object that set two classes. One class is for BootStrap and the second is a custom one.`}</p>\n    <p>{`If you have defined that the PriceLimit must use a custom home made template, than you may want to gather this information and use it on the html element you desire.`}</p>\n    <p>{`For example, this is the custom editor template:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` <div ?????????> @Html.EditorFor(viewModel => viewModel.Current.Value) @Html.HiddenFor(viewModel => viewModel.Current.Currency.Id) </div> \n`}</code></pre>\n    <p>{`As you can see, the first line would like to benefit of the html attributes passed by the EditorFor.`}</p>\n    <p>{`The task would have been easy if we only wanted to pass the html attribute to a TextBoxFor, or any existing defined Html helper because you could simply set the viewdata back to the second parameter. However, if you are in the scenario that you want to use the html attributes for any html element, than some code must be done. Also, we need to think about the possibility that the custom editor template (or display template) may want to have html attribute by default and just be enhanced by the html attributes passed by the Html Helper.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` <div class=\"constant-class-always-there ????\" ?????????> @Html.EditorFor(viewModel => viewModel.Current.Value) @Html.HiddenFor(viewModel => viewModel.Current.Currency.Id) </div> \n`}</code></pre>\n    <p>{`The first task is to handle the case that we may want to have default attribute. The code that is following this paragraph is set at the top of the Editor Template. In this example, we want to be sure that the class \"input-group\" is set. Whatever what is passed on the Html Helper EditorFor, we want to have this class set.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` @{ object htmlAttributes = null; if (Html.ViewData.ContainsKey(\"htmlAttributes\")) { htmlAttributes = Html.Custom().RenderHtmlAttributes(ViewData[\"htmlAttributes\"], new { @class = \"input-group\" }); } else { htmlAttributes = Html.Custom().RenderHtmlAttributes(new{@class=\"input-group\"}); } } \n`}</code></pre>\n    <p>{`The IF check if the EditorFor html helper contains any html attributes, if it is the case, than it add it to the EditorFor html attributes, otherwise, it just set it without taking care of the view data passed by the html helper. Something may have catch your attention : the RenderHtmlAttributes method. This is a custom html helper that takes one or multiple object and create a MvcHtmlString to be used to your Razor code. The end result would look like this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{`@{ object htmlAttributes = null; if (Html.ViewData.ContainsKey(\"htmlAttributes\")) { htmlAttributes = Html.Custom().RenderHtmlAttributes(ViewData[\"htmlAttributes\"], new { @class = \"input-group\" }); } else { htmlAttributes = Html.Custom().RenderHtmlAttributes(new{@class=\"input-group\"}); } } <div @htmlAttributes> @Html.EditorFor(viewModel => viewModel.Current.Value) @Html.HiddenFor(viewModel => viewModel.Current.Currency.Id) </div> \n`}</code></pre>\n    <p>{`The RenderHtmlAttributes loops all html attributes object and extend each of them to create a final RouteValueDictionary. Finally, it creates a string.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` /// <summary> /// Render one or many html attribute together /// </summary> /// <param name=\"htmlAttributes\"></param> /// <returns></returns> public MvcHtmlString RenderHtmlAttributes(params object[] htmlAttributes) { var finalRouteValue = new RouteValueDictionary(); foreach (var htmlAttribute in htmlAttributes) { var routeValue = new RouteValueDictionary(htmlAttribute); finalRouteValue = finalRouteValue.Extend(routeValue); } var htmlAttributesString = String.Join(\" \", finalRouteValue.Keys.Select(key => String.Format(\"{0}=\\\\\\\\\"{1}\\\\\\\\\"\", key, this.htmlHelper.Encode(finalRouteValue[key])))); return MvcHtmlString.Create(htmlAttributesString); } \n`}</code></pre>\n    <p>{`The heavy lift about handling if one html attribute object contains a key that has already been defined or not to handle the merge is done in the `}<strong parentName=\"p\">{`Extend`}</strong>{` method. For example, if two html attributes define the key \"class\" than we want to merge both value to have in the final result a single \"class\" key with both class value defined.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` /// <summary> /// The extend method takes values from the source and add them into the destination. You do not need to use the return value /// because the destination object will already have the element of the source. /// </summary> /// <param name=\"destination\"></param> /// <param name=\"source\"></param> /// <returns></returns> public static RouteValueDictionary Extend(this RouteValueDictionary destination, IEnumerable<KeyValuePair<string, object>> source) { foreach (var srcElement in source.ToList()) { if (destination.ContainsKey(srcElement.Key)) { destination[srcElement.Key] += \" \" + srcElement.Value; } else { destination[srcElement.Key] = srcElement.Value; } } return destination; } \n`}</code></pre>\n    <p>{`Here is two unit tests. The first one has two different keys. The end result is that both keys are not merged together. The second test has two route value with the same key. Each of them with different values. The result is that both value are in the first object.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` [TestClass] public class RouteExtensionsTest { [TestMethod] public void GivenTwoRouteValueDictionary_WhenBothDoesNotContainSameKey_ThenValueAreNotMerged() { // Arrange var valueObject1 = new RouteValueDictionary { { \"key1\", \"value1\" } }; var valueObject2 = new RouteValueDictionary { { \"key2\", \"value2\" } };\n\n// Act valueObject1.Extend(valueObject2);\n\n// Assert Assert.AreEqual(\"value1\", valueObject1[\"key1\"].ToString()); }\n\n[TestMethod] public void GivenTwoRouteValueDictionary_WhenBothContainSameKey_ThenValueAreMerged() { // Arrange var valueObject1 = new RouteValueDictionary {{\"key1\", \"value1\"}}; var valueObject2 = new RouteValueDictionary {{\"key1\", \"value2\"}};\n\n// Act valueObject1.Extend(valueObject2);\n\n// Assert Assert.AreEqual(\"value1 value2\", valueObject1[\"key1\"].ToString()); } } \n`}</code></pre>\n    <p>{`It requires some work to work with Editor Template and Display Template when you want to go beyond basic functionality. However, it is possible to extend everything with some Html Helper and Extension methods.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}