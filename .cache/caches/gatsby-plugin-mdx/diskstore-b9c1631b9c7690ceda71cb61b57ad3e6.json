{"expireTime":9007200886478396000,"key":"gatsby-plugin-mdx-entire-payload-0a1c6d88d43403ddec5f1b9afe515530--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"If you need to concatenate two expressions (with OR or AND) this can be done easily with the help of the ","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":106,"offset":106},"indent":[]}},{"type":"link","title":null,"url":"http://www.albahari.com/nutshell/linqkit.aspx","children":[{"type":"text","value":"LinqKit library","position":{"start":{"line":2,"column":107,"offset":107},"end":{"line":2,"column":122,"offset":122},"indent":[]}}],"position":{"start":{"line":2,"column":106,"offset":106},"end":{"line":2,"column":170,"offset":170},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":2,"column":170,"offset":170},"end":{"line":2,"column":171,"offset":171},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":171,"offset":171},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The idea is to Invoke both expression with the same model object.","position":{"start":{"line":4,"column":1,"offset":173},"end":{"line":4,"column":66,"offset":238},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":173},"end":{"line":4,"column":66,"offset":238},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" Expression<Func<Customer, bool>> filter1 = customer => customer.FirstName == \"Test\"; Expression<Func<Customer, bool>> filter2 = customer => customer.LastName == \"Test\"; Expression<Func<Customer, bool>> filter3 = customer => filter1 .Invoke(customer) || filter2.Invoke(customer); ","position":{"start":{"line":7,"column":1,"offset":241},"end":{"line":9,"column":4,"offset":535},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The last step is to use AsExpendable() and to you Expand to the last filter (filter3). ","position":{"start":{"line":11,"column":1,"offset":537},"end":{"line":11,"column":88,"offset":624},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":537},"end":{"line":11,"column":88,"offset":624},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" IEnumerable<Customer> customers = CustomerRepository.GetAll().AsExpandable().Where(filter3.Expand()).OrderBy(c => c.Id); ","position":{"start":{"line":12,"column":1,"offset":625},"end":{"line":14,"column":4,"offset":761},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The AsExpendable() method simple create a wrapper around the IQueryable to create a ExpendableQuery. From here, the provider will change with the concrete provider ExpendableQueryProvider which inherit from IQueryProvider. This one will call the .Expand() of the expression.","position":{"start":{"line":16,"column":1,"offset":763},"end":{"line":16,"column":275,"offset":1037},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":763},"end":{"line":16,"column":275,"offset":1037},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If you go check the source code of the method ExpendableQuery we can see the wrapping.","position":{"start":{"line":18,"column":1,"offset":1039},"end":{"line":18,"column":87,"offset":1125},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":1039},"end":{"line":18,"column":87,"offset":1125},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":"public static IQueryable<T> AsExpandable<T>(this IQueryable<T> query) { \n  if (query is ExpandableQuery<T>) \n    return query; \n  else \n    return (IQueryable<T>) new ExpandableQuery<T>(query); \n} ","position":{"start":{"line":20,"column":1,"offset":1127},"end":{"line":27,"column":4,"offset":1338},"indent":[1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The expand look like this : ","position":{"start":{"line":29,"column":1,"offset":1340},"end":{"line":29,"column":29,"offset":1368},"indent":[]}}],"position":{"start":{"line":29,"column":1,"offset":1340},"end":{"line":29,"column":29,"offset":1368},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":"public static Expression<TDelegate> Expand<TDelegate>(this Expression<TDelegate> expr) { \n   return (Expression<TDelegate>) new ExpressionExpander().Visit((Expression) expr); \n} ","position":{"start":{"line":30,"column":1,"offset":1369},"end":{"line":34,"column":5,"offset":1562},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"It call the Visit method of the ExpressionExpander from the Expression.","position":{"start":{"line":35,"column":1,"offset":1563},"end":{"line":35,"column":72,"offset":1634},"indent":[]}}],"position":{"start":{"line":35,"column":1,"offset":1563},"end":{"line":35,"column":72,"offset":1634},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In short, what you have to remember it the use of LinqKit.dll make you life really easier when you manipulate dynamic expression.","position":{"start":{"line":37,"column":1,"offset":1636},"end":{"line":37,"column":130,"offset":1765},"indent":[]}}],"position":{"start":{"line":37,"column":1,"offset":1636},"end":{"line":37,"column":130,"offset":1765},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"So you have appended two Linq To Entity expression ","position":{"start":{"line":39,"column":1,"offset":1767},"end":{"line":39,"column":52,"offset":1818},"indent":[]}},{"type":"link","title":null,"url":"http://stackoverflow.com/questions/1266742/append-to-an-expression-linq-c","children":[{"type":"text","value":"http://stackoverflow.com/questions/1266742/append-to-an-expression-linq-c","position":{"start":{"line":39,"column":52,"offset":1818},"end":{"line":39,"column":125,"offset":1891},"indent":[]}}],"position":{"start":{"line":39,"column":52,"offset":1818},"end":{"line":39,"column":125,"offset":1891},"indent":[]}}],"position":{"start":{"line":39,"column":1,"offset":1767},"end":{"line":39,"column":125,"offset":1891},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"How to extend (or add) conditionnal clause to Expression<T>\",\"date\":\"2012-09-27\",\"categories\":[\"c-sharp\",\"dynamic\",\"linq\"]}","position":{"start":{"line":42,"column":1,"offset":1894},"end":{"line":42,"column":162,"offset":2055},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":42,"column":162,"offset":2055}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to extend (or add) conditionnal clause to Expression<T>\",\n  \"date\": \"2012-09-27\",\n  \"categories\": [\"c-sharp\", \"dynamic\", \"linq\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you need to concatenate two expressions (with OR or AND) this can be done easily with the help of the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.albahari.com/nutshell/linqkit.aspx\"\n  }, \"LinqKit library\"), \".\"), mdx(\"p\", null, \"The idea is to Invoke both expression with the same model object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" Expression<Func<Customer, bool>> filter1 = customer => customer.FirstName == \\\"Test\\\"; Expression<Func<Customer, bool>> filter2 = customer => customer.LastName == \\\"Test\\\"; Expression<Func<Customer, bool>> filter3 = customer => filter1 .Invoke(customer) || filter2.Invoke(customer); \\n\")), mdx(\"p\", null, \"The last step is to use AsExpendable() and to you Expand to the last filter (filter3). \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" IEnumerable<Customer> customers = CustomerRepository.GetAll().AsExpandable().Where(filter3.Expand()).OrderBy(c => c.Id); \\n\")), mdx(\"p\", null, \"The AsExpendable() method simple create a wrapper around the IQueryable to create a ExpendableQuery. From here, the provider will change with the concrete provider ExpendableQueryProvider which inherit from IQueryProvider. This one will call the .Expand() of the expression.\"), mdx(\"p\", null, \"If you go check the source code of the method ExpendableQuery we can see the wrapping.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public static IQueryable<T> AsExpandable<T>(this IQueryable<T> query) { \\n  if (query is ExpandableQuery<T>) \\n    return query; \\n  else \\n    return (IQueryable<T>) new ExpandableQuery<T>(query); \\n} \\n\")), mdx(\"p\", null, \"The expand look like this : \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public static Expression<TDelegate> Expand<TDelegate>(this Expression<TDelegate> expr) { \\n   return (Expression<TDelegate>) new ExpressionExpander().Visit((Expression) expr); \\n} \\n\")), mdx(\"p\", null, \"It call the Visit method of the ExpressionExpander from the Expression.\"), mdx(\"p\", null, \"In short, what you have to remember it the use of LinqKit.dll make you life really easier when you manipulate dynamic expression.\"), mdx(\"p\", null, \"So you have appended two Linq To Entity expression \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://stackoverflow.com/questions/1266742/append-to-an-expression-linq-c\"\n  }, \"http://stackoverflow.com/questions/1266742/append-to-an-expression-linq-c\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"How to extend (or add) conditionnal clause to Expression<T>\",\n  \"date\": \"2012-09-27\",\n  \"categories\": [\"c-sharp\", \"dynamic\", \"linq\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`If you need to concatenate two expressions (with OR or AND) this can be done easily with the help of the `}<a parentName=\"p\" {...{\n        \"href\": \"http://www.albahari.com/nutshell/linqkit.aspx\"\n      }}>{`LinqKit library`}</a>{`.`}</p>\n    <p>{`The idea is to Invoke both expression with the same model object.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` Expression<Func<Customer, bool>> filter1 = customer => customer.FirstName == \"Test\"; Expression<Func<Customer, bool>> filter2 = customer => customer.LastName == \"Test\"; Expression<Func<Customer, bool>> filter3 = customer => filter1 .Invoke(customer) || filter2.Invoke(customer); \n`}</code></pre>\n    <p>{`The last step is to use AsExpendable() and to you Expand to the last filter (filter3). `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` IEnumerable<Customer> customers = CustomerRepository.GetAll().AsExpandable().Where(filter3.Expand()).OrderBy(c => c.Id); \n`}</code></pre>\n    <p>{`The AsExpendable() method simple create a wrapper around the IQueryable to create a ExpendableQuery. From here, the provider will change with the concrete provider ExpendableQueryProvider which inherit from IQueryProvider. This one will call the .Expand() of the expression.`}</p>\n    <p>{`If you go check the source code of the method ExpendableQuery we can see the wrapping.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{`public static IQueryable<T> AsExpandable<T>(this IQueryable<T> query) { \n  if (query is ExpandableQuery<T>) \n    return query; \n  else \n    return (IQueryable<T>) new ExpandableQuery<T>(query); \n} \n`}</code></pre>\n    <p>{`The expand look like this : `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{`public static Expression<TDelegate> Expand<TDelegate>(this Expression<TDelegate> expr) { \n   return (Expression<TDelegate>) new ExpressionExpander().Visit((Expression) expr); \n} \n`}</code></pre>\n    <p>{`It call the Visit method of the ExpressionExpander from the Expression.`}</p>\n    <p>{`In short, what you have to remember it the use of LinqKit.dll make you life really easier when you manipulate dynamic expression.`}</p>\n    <p>{`So you have appended two Linq To Entity expression `}<a parentName=\"p\" {...{\n        \"href\": \"http://stackoverflow.com/questions/1266742/append-to-an-expression-linq-c\"\n      }}>{`http://stackoverflow.com/questions/1266742/append-to-an-expression-linq-c`}</a></p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}