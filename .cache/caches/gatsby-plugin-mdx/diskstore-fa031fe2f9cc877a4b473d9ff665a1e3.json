{"expireTime":9007200886478390000,"key":"gatsby-plugin-mdx-entire-payload-0406a7d41072627f678aa48d26c39aae--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"AutoMapper","position":{"start":{"line":2,"column":3,"offset":3},"end":{"line":2,"column":13,"offset":13},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":15,"offset":15},"indent":[]}},{"type":"text","value":" lets you map from one class to another class your object. It works fine until you want to map from a class to an abstract class. The reason is that ","position":{"start":{"line":2,"column":15,"offset":15},"end":{"line":2,"column":164,"offset":164},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"AutoMapper","position":{"start":{"line":2,"column":166,"offset":166},"end":{"line":2,"column":176,"offset":176},"indent":[]}}],"position":{"start":{"line":2,"column":164,"offset":164},"end":{"line":2,"column":178,"offset":178},"indent":[]}},{"type":"text","value":" instantiates the desired class type and since an abstract class cannot be instantiate will crash.","position":{"start":{"line":2,"column":178,"offset":178},"end":{"line":2,"column":276,"offset":276},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":276,"offset":276},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" //Mapping Mapper.CreateMap<SelectorItem, OrderType>() //Use the mapping var model = AutoMapper.Mapper.Map<SelectorItem, OrderType>(viewModel); ","position":{"start":{"line":5,"column":1,"offset":279},"end":{"line":7,"column":4,"offset":437},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The code create the map from SelectorItem that is a normal class and OrderType that is an abstract class. The use of this map will not work. To fix this problem the mapping configuration must be changed to specify to ","position":{"start":{"line":9,"column":1,"offset":439},"end":{"line":9,"column":218,"offset":656},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"AutoMapper","position":{"start":{"line":9,"column":220,"offset":658},"end":{"line":9,"column":230,"offset":668},"indent":[]}}],"position":{"start":{"line":9,"column":218,"offset":656},"end":{"line":9,"column":232,"offset":670},"indent":[]}},{"type":"text","value":" how to instantiate the OrderType class, the abstract class.","position":{"start":{"line":9,"column":232,"offset":670},"end":{"line":9,"column":292,"offset":730},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":439},"end":{"line":9,"column":292,"offset":730},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" Mapper.CreateMap<SelectorItem, OrderType>() .ConstructUsing(OrderTypeCreator); ","position":{"start":{"line":12,"column":1,"offset":733},"end":{"line":14,"column":4,"offset":827},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The mapping requires the use of ConstructUsing method that has two signatures.","position":{"start":{"line":16,"column":1,"offset":829},"end":{"line":16,"column":79,"offset":907},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":829},"end":{"line":16,"column":79,"offset":907},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" IMappingExpression<TSource, TDestination> ConstructUsing(Func<TSource, TDestination> ctor); IMappingExpression<TSource, TDestination> ConstructUsing(Func<ResolutionContext, TDestination> ctor); ","position":{"start":{"line":19,"column":1,"offset":910},"end":{"line":21,"column":4,"offset":1119},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The first one is easy to use. It takes a method that has the source which is the class we start with and return a destination class that is the abstract class.","position":{"start":{"line":23,"column":1,"offset":1121},"end":{"line":23,"column":160,"offset":1280},"indent":[]}}],"position":{"start":{"line":23,"column":1,"offset":1121},"end":{"line":23,"column":160,"offset":1280},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" private OrderType OrderTypeCreator(SelectorItem arg) { return OrderType.GetFromId(arg.Id); } ","position":{"start":{"line":26,"column":1,"offset":1283},"end":{"line":28,"column":4,"offset":1391},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This example takes from the concrete class the ID and use a factory to return the correct concrete class that inherit form the abstract OrderType class.","position":{"start":{"line":30,"column":1,"offset":1393},"end":{"line":30,"column":153,"offset":1545},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":1393},"end":{"line":30,"column":153,"offset":1545},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This way, we have AutoMapper that can map to abstract Class without problem.","position":{"start":{"line":32,"column":1,"offset":1547},"end":{"line":32,"column":77,"offset":1623},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":1547},"end":{"line":32,"column":77,"offset":1623},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Using AutoMapper to Map Abstract Classes\",\"date\":\"2014-03-20\",\"categories\":[\"automapper\",\"c-sharp\"]}","position":{"start":{"line":35,"column":1,"offset":1626},"end":{"line":35,"column":139,"offset":1764},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":35,"column":139,"offset":1764}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Using AutoMapper to Map Abstract Classes\",\n  \"date\": \"2014-03-20\",\n  \"categories\": [\"automapper\", \"c-sharp\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AutoMapper\"), \" lets you map from one class to another class your object. It works fine until you want to map from a class to an abstract class. The reason is that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AutoMapper\"), \" instantiates the desired class type and since an abstract class cannot be instantiate will crash.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" //Mapping Mapper.CreateMap<SelectorItem, OrderType>() //Use the mapping var model = AutoMapper.Mapper.Map<SelectorItem, OrderType>(viewModel); \\n\")), mdx(\"p\", null, \"The code create the map from SelectorItem that is a normal class and OrderType that is an abstract class. The use of this map will not work. To fix this problem the mapping configuration must be changed to specify to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AutoMapper\"), \" how to instantiate the OrderType class, the abstract class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" Mapper.CreateMap<SelectorItem, OrderType>() .ConstructUsing(OrderTypeCreator); \\n\")), mdx(\"p\", null, \"The mapping requires the use of ConstructUsing method that has two signatures.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" IMappingExpression<TSource, TDestination> ConstructUsing(Func<TSource, TDestination> ctor); IMappingExpression<TSource, TDestination> ConstructUsing(Func<ResolutionContext, TDestination> ctor); \\n\")), mdx(\"p\", null, \"The first one is easy to use. It takes a method that has the source which is the class we start with and return a destination class that is the abstract class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" private OrderType OrderTypeCreator(SelectorItem arg) { return OrderType.GetFromId(arg.Id); } \\n\")), mdx(\"p\", null, \"This example takes from the concrete class the ID and use a factory to return the correct concrete class that inherit form the abstract OrderType class.\"), mdx(\"p\", null, \"This way, we have AutoMapper that can map to abstract Class without problem.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Using AutoMapper to Map Abstract Classes\",\n  \"date\": \"2014-03-20\",\n  \"categories\": [\"automapper\", \"c-sharp\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p><strong parentName=\"p\">{`AutoMapper`}</strong>{` lets you map from one class to another class your object. It works fine until you want to map from a class to an abstract class. The reason is that `}<strong parentName=\"p\">{`AutoMapper`}</strong>{` instantiates the desired class type and since an abstract class cannot be instantiate will crash.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` //Mapping Mapper.CreateMap<SelectorItem, OrderType>() //Use the mapping var model = AutoMapper.Mapper.Map<SelectorItem, OrderType>(viewModel); \n`}</code></pre>\n    <p>{`The code create the map from SelectorItem that is a normal class and OrderType that is an abstract class. The use of this map will not work. To fix this problem the mapping configuration must be changed to specify to `}<strong parentName=\"p\">{`AutoMapper`}</strong>{` how to instantiate the OrderType class, the abstract class.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` Mapper.CreateMap<SelectorItem, OrderType>() .ConstructUsing(OrderTypeCreator); \n`}</code></pre>\n    <p>{`The mapping requires the use of ConstructUsing method that has two signatures.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` IMappingExpression<TSource, TDestination> ConstructUsing(Func<TSource, TDestination> ctor); IMappingExpression<TSource, TDestination> ConstructUsing(Func<ResolutionContext, TDestination> ctor); \n`}</code></pre>\n    <p>{`The first one is easy to use. It takes a method that has the source which is the class we start with and return a destination class that is the abstract class.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` private OrderType OrderTypeCreator(SelectorItem arg) { return OrderType.GetFromId(arg.Id); } \n`}</code></pre>\n    <p>{`This example takes from the concrete class the ID and use a factory to return the correct concrete class that inherit form the abstract OrderType class.`}</p>\n    <p>{`This way, we have AutoMapper that can map to abstract Class without problem.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}