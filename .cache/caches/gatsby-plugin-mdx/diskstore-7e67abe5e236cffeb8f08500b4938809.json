{"expireTime":9007200886478385000,"key":"gatsby-plugin-mdx-entire-payload-e558e7b6cedc1b94d5c5b16c8561d4ff--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Unit tests are something that everyone agree to do, but not a lot write correctly. I found more and more code that has unit tests for the \"happy path\" and more common scenario while ignoring all other possible cases. Let's take the following small method.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":256,"offset":256},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":256,"offset":256},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"public smallSimpleOneLineMethod (abc: string): boolean { return this.zzz && (this.zzz === abc); } ","position":{"start":{"line":4,"column":1,"offset":258},"end":{"line":6,"column":5,"offset":375},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This method is broken because we specify to return a boolean but it can return null. This is not possible in C#, but in TypeScript since it is converted to JavaScript it is.","position":{"start":{"line":9,"column":1,"offset":378},"end":{"line":9,"column":174,"offset":551},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":378},"end":{"line":9,"column":174,"offset":551},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This is where Unit Test come to the rescue. We expect that method to return ","position":{"start":{"line":11,"column":1,"offset":553},"end":{"line":11,"column":77,"offset":629},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"true","position":{"start":{"line":11,"column":79,"offset":631},"end":{"line":11,"column":83,"offset":635},"indent":[]}}],"position":{"start":{"line":11,"column":77,"offset":629},"end":{"line":11,"column":85,"offset":637},"indent":[]}},{"type":"text","value":" when ","position":{"start":{"line":11,"column":85,"offset":637},"end":{"line":11,"column":91,"offset":643},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"abc","position":{"start":{"line":11,"column":92,"offset":644},"end":{"line":11,"column":95,"offset":647},"indent":[]}}],"position":{"start":{"line":11,"column":91,"offset":643},"end":{"line":11,"column":96,"offset":648},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":11,"column":96,"offset":648},"end":{"line":11,"column":101,"offset":653},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"zzz","position":{"start":{"line":11,"column":102,"offset":654},"end":{"line":11,"column":105,"offset":657},"indent":[]}}],"position":{"start":{"line":11,"column":101,"offset":653},"end":{"line":11,"column":106,"offset":658},"indent":[]}},{"type":"text","value":" is different; ","position":{"start":{"line":11,"column":106,"offset":658},"end":{"line":11,"column":121,"offset":673},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"false","position":{"start":{"line":11,"column":123,"offset":675},"end":{"line":11,"column":128,"offset":680},"indent":[]}}],"position":{"start":{"line":11,"column":121,"offset":673},"end":{"line":11,"column":130,"offset":682},"indent":[]}},{"type":"text","value":" when the same. If ","position":{"start":{"line":11,"column":130,"offset":682},"end":{"line":11,"column":149,"offset":701},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"zzz","position":{"start":{"line":11,"column":150,"offset":702},"end":{"line":11,"column":153,"offset":705},"indent":[]}}],"position":{"start":{"line":11,"column":149,"offset":701},"end":{"line":11,"column":154,"offset":706},"indent":[]}},{"type":"text","value":" is ","position":{"start":{"line":11,"column":154,"offset":706},"end":{"line":11,"column":158,"offset":710},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"null","position":{"start":{"line":11,"column":160,"offset":712},"end":{"line":11,"column":164,"offset":716},"indent":[]}}],"position":{"start":{"line":11,"column":158,"offset":710},"end":{"line":11,"column":166,"offset":718},"indent":[]}},{"type":"text","value":", we expect to return ","position":{"start":{"line":11,"column":166,"offset":718},"end":{"line":11,"column":188,"offset":740},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"false","position":{"start":{"line":11,"column":190,"offset":742},"end":{"line":11,"column":195,"offset":747},"indent":[]}}],"position":{"start":{"line":11,"column":188,"offset":740},"end":{"line":11,"column":197,"offset":749},"indent":[]}},{"type":"text","value":". Simple, no need unit test… The problem is that ","position":{"start":{"line":11,"column":197,"offset":749},"end":{"line":11,"column":246,"offset":798},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"this.zzz","position":{"start":{"line":11,"column":247,"offset":799},"end":{"line":11,"column":255,"offset":807},"indent":[]}}],"position":{"start":{"line":11,"column":246,"offset":798},"end":{"line":11,"column":256,"offset":808},"indent":[]}},{"type":"text","value":" if ","position":{"start":{"line":11,"column":256,"offset":808},"end":{"line":11,"column":260,"offset":812},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"null","position":{"start":{"line":11,"column":262,"offset":814},"end":{"line":11,"column":266,"offset":818},"indent":[]}}],"position":{"start":{"line":11,"column":260,"offset":812},"end":{"line":11,"column":268,"offset":820},"indent":[]}},{"type":"text","value":" will remain ","position":{"start":{"line":11,"column":268,"offset":820},"end":{"line":11,"column":281,"offset":833},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"null","position":{"start":{"line":11,"column":283,"offset":835},"end":{"line":11,"column":287,"offset":839},"indent":[]}}],"position":{"start":{"line":11,"column":281,"offset":833},"end":{"line":11,"column":289,"offset":841},"indent":[]}},{"type":"text","value":" in the first part of the ","position":{"start":{"line":11,"column":289,"offset":841},"end":{"line":11,"column":315,"offset":867},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"&&","position":{"start":{"line":11,"column":317,"offset":869},"end":{"line":11,"column":319,"offset":871},"indent":[]}}],"position":{"start":{"line":11,"column":315,"offset":867},"end":{"line":11,"column":321,"offset":873},"indent":[]}},{"type":"text","value":" condition, not ","position":{"start":{"line":11,"column":321,"offset":873},"end":{"line":11,"column":337,"offset":889},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"false","position":{"start":{"line":11,"column":339,"offset":891},"end":{"line":11,"column":344,"offset":896},"indent":[]}}],"position":{"start":{"line":11,"column":337,"offset":889},"end":{"line":11,"column":346,"offset":898},"indent":[]}},{"type":"text","value":". It means that we do : null && (true|false). What does that mean? It means that all the time, if ","position":{"start":{"line":11,"column":346,"offset":898},"end":{"line":11,"column":444,"offset":996},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"zzz","position":{"start":{"line":11,"column":445,"offset":997},"end":{"line":11,"column":448,"offset":1000},"indent":[]}}],"position":{"start":{"line":11,"column":444,"offset":996},"end":{"line":11,"column":449,"offset":1001},"indent":[]}},{"type":"text","value":" is null that that method return ","position":{"start":{"line":11,"column":449,"offset":1001},"end":{"line":11,"column":482,"offset":1034},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"null","position":{"start":{"line":11,"column":484,"offset":1036},"end":{"line":11,"column":488,"offset":1040},"indent":[]}}],"position":{"start":{"line":11,"column":482,"offset":1034},"end":{"line":11,"column":490,"offset":1042},"indent":[]}},{"type":"text","value":", not ","position":{"start":{"line":11,"column":490,"offset":1042},"end":{"line":11,"column":496,"offset":1048},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"false","position":{"start":{"line":11,"column":498,"offset":1050},"end":{"line":11,"column":503,"offset":1055},"indent":[]}}],"position":{"start":{"line":11,"column":496,"offset":1048},"end":{"line":11,"column":505,"offset":1057},"indent":[]}},{"type":"text","value":" or ","position":{"start":{"line":11,"column":505,"offset":1057},"end":{"line":11,"column":509,"offset":1061},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"true","position":{"start":{"line":11,"column":511,"offset":1063},"end":{"line":11,"column":515,"offset":1067},"indent":[]}}],"position":{"start":{"line":11,"column":509,"offset":1061},"end":{"line":11,"column":517,"offset":1069},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":11,"column":517,"offset":1069},"end":{"line":11,"column":518,"offset":1070},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":553},"end":{"line":11,"column":518,"offset":1070},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This method needs to be refactored to : ```typescript\npublic simpleMethod (abc: string): boolean { return !!this.zzz && (this.zzz === abc); } ","position":{"start":{"line":13,"column":1,"offset":1072},"end":{"line":14,"column":89,"offset":1214},"indent":[1]}}],"position":{"start":{"line":13,"column":1,"offset":1072},"end":{"line":14,"column":89,"offset":1214},"indent":[1]}},{"type":"code","lang":null,"meta":null,"value":"\n\nTo sum up that post, unit test every conditions, even simple one. It’s not because it works today that it won’t fail tomorrow. Tests all possible routes that your code allows. The _simpleMethod_ has now 4 unit tests that test null from the parameter, from the this variable and with and without the same string variable.\n\n\nexport const _frontmatter = {\"title\":\"Unit Tests Simple Method\",\"date\":\"2016-01-18\",\"categories\":[\"javascript\",\"typescript\"],\"tags\":[\"test\",\"unittest\"]}","position":{"start":{"line":15,"column":1,"offset":1215},"end":{"line":21,"column":153,"offset":1697},"indent":[1,1,1,1,1,1]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":21,"column":153,"offset":1697}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Unit tests are something that everyone agree to do, but not a lot write correctly. I found more and more code that has unit tests for the \\\"happy path\\\" and more common scenario while ignoring all other possible cases. Let's take the following small method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"public smallSimpleOneLineMethod (abc: string): boolean { return this.zzz && (this.zzz === abc); } \\n\")), mdx(\"p\", null, \"This method is broken because we specify to return a boolean but it can return null. This is not possible in C#, but in TypeScript since it is converted to JavaScript it is.\"), mdx(\"p\", null, \"This is where Unit Test come to the rescue. We expect that method to return \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"true\"), \" when \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"abc\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"zzz\"), \" is different; \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"false\"), \" when the same. If \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"zzz\"), \" is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \", we expect to return \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"false\"), \". Simple, no need unit test\\u2026 The problem is that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"this.zzz\"), \" if \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \" will remain \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \" in the first part of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"&&\"), \" condition, not \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"false\"), \". It means that we do : null && (true|false). What does that mean? It means that all the time, if \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"zzz\"), \" is null that that method return \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \", not \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"false\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"true\"), \".\"), mdx(\"p\", null, \"This method needs to be refactored to : ```typescript\\npublic simpleMethod (abc: string): boolean { return !!this.zzz && (this.zzz === abc); } \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\n\\nTo sum up that post, unit test every conditions, even simple one. It\\u2019s not because it works today that it won\\u2019t fail tomorrow. Tests all possible routes that your code allows. The _simpleMethod_ has now 4 unit tests that test null from the parameter, from the this variable and with and without the same string variable.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"Unit Tests Simple Method\\\",\\\"date\\\":\\\"2016-01-18\\\",\\\"categories\\\":[\\\"javascript\\\",\\\"typescript\\\"],\\\"tags\\\":[\\\"test\\\",\\\"unittest\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Unit tests are something that everyone agree to do, but not a lot write correctly. I found more and more code that has unit tests for the \"happy path\" and more common scenario while ignoring all other possible cases. Let's take the following small method.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`public smallSimpleOneLineMethod (abc: string): boolean { return this.zzz && (this.zzz === abc); } \n`}</code></pre>\n    <p>{`This method is broken because we specify to return a boolean but it can return null. This is not possible in C#, but in TypeScript since it is converted to JavaScript it is.`}</p>\n    <p>{`This is where Unit Test come to the rescue. We expect that method to return `}<strong parentName=\"p\">{`true`}</strong>{` when `}<em parentName=\"p\">{`abc`}</em>{` and `}<em parentName=\"p\">{`zzz`}</em>{` is different; `}<strong parentName=\"p\">{`false`}</strong>{` when the same. If `}<em parentName=\"p\">{`zzz`}</em>{` is `}<strong parentName=\"p\">{`null`}</strong>{`, we expect to return `}<strong parentName=\"p\">{`false`}</strong>{`. Simple, no need unit test… The problem is that `}<em parentName=\"p\">{`this.zzz`}</em>{` if `}<strong parentName=\"p\">{`null`}</strong>{` will remain `}<strong parentName=\"p\">{`null`}</strong>{` in the first part of the `}<strong parentName=\"p\">{`&&`}</strong>{` condition, not `}<strong parentName=\"p\">{`false`}</strong>{`. It means that we do : null && (true|false). What does that mean? It means that all the time, if `}<em parentName=\"p\">{`zzz`}</em>{` is null that that method return `}<strong parentName=\"p\">{`null`}</strong>{`, not `}<strong parentName=\"p\">{`false`}</strong>{` or `}<strong parentName=\"p\">{`true`}</strong>{`.`}</p>\n    <p>{`This method needs to be refactored to : \\`\\`\\`typescript\npublic simpleMethod (abc: string): boolean { return !!this.zzz && (this.zzz === abc); } `}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`\n\nTo sum up that post, unit test every conditions, even simple one. It’s not because it works today that it won’t fail tomorrow. Tests all possible routes that your code allows. The _simpleMethod_ has now 4 unit tests that test null from the parameter, from the this variable and with and without the same string variable.\n\n\nexport const _frontmatter = {\"title\":\"Unit Tests Simple Method\",\"date\":\"2016-01-18\",\"categories\":[\"javascript\",\"typescript\"],\"tags\":[\"test\",\"unittest\"]}\n`}</code></pre>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}