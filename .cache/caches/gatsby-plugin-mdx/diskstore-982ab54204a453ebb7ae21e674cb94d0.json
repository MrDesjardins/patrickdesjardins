{"expireTime":9007200886478397000,"key":"gatsby-plugin-mdx-entire-payload-74b203979aa3899dff20419c3b62ed02--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"It's possible to create a custom generic ","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":42,"offset":42},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Html Extension Helper","position":{"start":{"line":2,"column":44,"offset":44},"end":{"line":2,"column":65,"offset":65},"indent":[]}}],"position":{"start":{"line":2,"column":42,"offset":42},"end":{"line":2,"column":67,"offset":67},"indent":[]}},{"type":"text","value":" with the use of Expression Helper and if required the ModelMetadata to get the value.","position":{"start":{"line":2,"column":67,"offset":67},"end":{"line":2,"column":153,"offset":153},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":153,"offset":153},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public static string MyExtensionFor<TModel, TProperty>(this HtmlHelper<TModel> htmlHelper, Expression<Func<TModel, TProperty>> property) { var meta = ModelMetadata.FromLambdaExpression(property, this.HtmlHelper.ViewData); string fullPropertyName = HtmlHelper.ViewContext.ViewData.TemplateInfo.GetFullHtmlFieldName(ExpressionHelper.GetExpressionText(property)); //Do what you need to do } \n``` The variable **fullPropertyName**meta data contain the value of the property if required. @Html.MyExtensionFor(x=>x.MyClassProperty1)\n\nWith little or no code you can setup Html Helper that is strongly typed. This has the advantage to not write string. This of course is better to reduce the change to write a wrong string but also help the refactoring because all refactoring tools works with property name change.\n\n\nexport const _frontmatter = {\"title\":\"Html Extension Helper with generic access to object property\",\"date\":\"2012-04-25\",\"categories\":[\"asp-mvc\",\"c-sharp\"]}","position":{"start":{"line":5,"column":1,"offset":156},"end":{"line":12,"column":156,"offset":1132},"indent":[1,1,1,1,1,1,1]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":12,"column":156,"offset":1132}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"It's possible to create a custom generic \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Html Extension Helper\"), \" with the use of Expression Helper and if required the ModelMetadata to get the value.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public static string MyExtensionFor<TModel, TProperty>(this HtmlHelper<TModel> htmlHelper, Expression<Func<TModel, TProperty>> property) { var meta = ModelMetadata.FromLambdaExpression(property, this.HtmlHelper.ViewData); string fullPropertyName = HtmlHelper.ViewContext.ViewData.TemplateInfo.GetFullHtmlFieldName(ExpressionHelper.GetExpressionText(property)); //Do what you need to do } \\n``` The variable **fullPropertyName**meta data contain the value of the property if required. @Html.MyExtensionFor(x=>x.MyClassProperty1)\\n\\nWith little or no code you can setup Html Helper that is strongly typed. This has the advantage to not write string. This of course is better to reduce the change to write a wrong string but also help the refactoring because all refactoring tools works with property name change.\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"Html Extension Helper with generic access to object property\\\",\\\"date\\\":\\\"2012-04-25\\\",\\\"categories\\\":[\\\"asp-mvc\\\",\\\"c-sharp\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`It's possible to create a custom generic `}<strong parentName=\"p\">{`Html Extension Helper`}</strong>{` with the use of Expression Helper and if required the ModelMetadata to get the value.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public static string MyExtensionFor<TModel, TProperty>(this HtmlHelper<TModel> htmlHelper, Expression<Func<TModel, TProperty>> property) { var meta = ModelMetadata.FromLambdaExpression(property, this.HtmlHelper.ViewData); string fullPropertyName = HtmlHelper.ViewContext.ViewData.TemplateInfo.GetFullHtmlFieldName(ExpressionHelper.GetExpressionText(property)); //Do what you need to do } \n\\`\\`\\` The variable **fullPropertyName**meta data contain the value of the property if required. @Html.MyExtensionFor(x=>x.MyClassProperty1)\n\nWith little or no code you can setup Html Helper that is strongly typed. This has the advantage to not write string. This of course is better to reduce the change to write a wrong string but also help the refactoring because all refactoring tools works with property name change.\n\n\nexport const _frontmatter = {\"title\":\"Html Extension Helper with generic access to object property\",\"date\":\"2012-04-25\",\"categories\":[\"asp-mvc\",\"c-sharp\"]}\n`}</code></pre>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}