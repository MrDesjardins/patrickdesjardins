{"expireTime":9007200886478395000,"key":"gatsby-plugin-mdx-entire-payload-8787b2bf68dc35cc02429813c6ce4b6b--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"You may have anonymous function that you want to call later in the same method (or to pass this one by parameter and call this one later). To be able to have a reference to this anonymous function, you need to use a variable that will keep a reference to this anonymous function. Later, when you want to use it, you simply need to call it by writing the variable name with parentheses.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":386,"offset":386},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":386,"offset":386},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var anonymous= function(){ alert(\"Test123\"); }; anonymous(); ","position":{"start":{"line":4,"column":1,"offset":388},"end":{"line":6,"column":5,"offset":468},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Pretty simple, isn't?","position":{"start":{"line":9,"column":1,"offset":471},"end":{"line":9,"column":22,"offset":492},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":471},"end":{"line":9,"column":22,"offset":492},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"From here you can have more complex prototype (Javascript class mechanism).","position":{"start":{"line":11,"column":1,"offset":494},"end":{"line":11,"column":76,"offset":569},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":494},"end":{"line":11,"column":76,"offset":569},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function MyClass(val1, val2){ this.val1 = val1; this.val2 = val2; this.function1 = function() { alert(this.val1); } } //... var x = new MyClass('Test','Hello'); x.function1(); ","position":{"start":{"line":13,"column":1,"offset":571},"end":{"line":15,"column":5,"offset":766},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":" This example show you that you can have an anonymous function that can be called later like the previous example.","position":{"start":{"line":16,"column":1,"offset":767},"end":{"line":16,"column":115,"offset":881},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":767},"end":{"line":16,"column":115,"offset":881},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"How to call anonymous function in Javascript?\",\"date\":\"2012-05-19\",\"categories\":[\"javascript\"]}","position":{"start":{"line":19,"column":1,"offset":884},"end":{"line":19,"column":134,"offset":1017},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":19,"column":134,"offset":1017}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to call anonymous function in Javascript?\",\n  \"date\": \"2012-05-19\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"You may have anonymous function that you want to call later in the same method (or to pass this one by parameter and call this one later). To be able to have a reference to this anonymous function, you need to use a variable that will keep a reference to this anonymous function. Later, when you want to use it, you simply need to call it by writing the variable name with parentheses.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var anonymous= function(){ alert(\\\"Test123\\\"); }; anonymous(); \\n\")), mdx(\"p\", null, \"Pretty simple, isn't?\"), mdx(\"p\", null, \"From here you can have more complex prototype (Javascript class mechanism).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function MyClass(val1, val2){ this.val1 = val1; this.val2 = val2; this.function1 = function() { alert(this.val1); } } //... var x = new MyClass('Test','Hello'); x.function1(); \\n\")), mdx(\"p\", null, \" This example show you that you can have an anonymous function that can be called later like the previous example.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"How to call anonymous function in Javascript?\",\n  \"date\": \"2012-05-19\",\n  \"categories\": [\"javascript\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`You may have anonymous function that you want to call later in the same method (or to pass this one by parameter and call this one later). To be able to have a reference to this anonymous function, you need to use a variable that will keep a reference to this anonymous function. Later, when you want to use it, you simply need to call it by writing the variable name with parentheses.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var anonymous= function(){ alert(\"Test123\"); }; anonymous(); \n`}</code></pre>\n    <p>{`Pretty simple, isn't?`}</p>\n    <p>{`From here you can have more complex prototype (Javascript class mechanism).`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function MyClass(val1, val2){ this.val1 = val1; this.val2 = val2; this.function1 = function() { alert(this.val1); } } //... var x = new MyClass('Test','Hello'); x.function1(); \n`}</code></pre>\n    <p>{` This example show you that you can have an anonymous function that can be called later like the previous example.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}