{"expireTime":9007200886478382000,"key":"gatsby-plugin-mdx-entire-payload-28c250bf394b2e4aef368013b41f574f--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"JavaScript is a prototype language. Every object has a prototype which share properties between the same kind of object.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":121,"offset":121},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":121,"offset":121},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The minimal prototype an object has is the default Object.prototype. However, any object can add members or function to its own object prototype by using \".prototype.\". The following code shows that an object type \"myTest\" with no member is having \"member1\" dynamically added as well as a member2 with the value \"m2\". We create a second instance and only member2, from the prototype is available. The member1 was added to the instance, not the prototype.","position":{"start":{"line":4,"column":1,"offset":123},"end":{"line":4,"column":455,"offset":577},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":123},"end":{"line":4,"column":455,"offset":577},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var myTest = {};\nvar myTestInstance1 = Object.create(myTest);\nmyTestInstance1.member1 = \"m1\";\nmyTestInstance1.__proto__.member2 = \"m2\";\n\nvar myTestInstance2 = Object.create(myTest);\n\nconsole.log(\"instance1.member2:\" + myTestInstance1.member2); //m2\nconsole.log(\"instance2.member2:\" + myTestInstance2.member2); //m2\nconsole.log(\"instance1.member1:\" + myTestInstance2.member1); //m1\nconsole.log(\"instance2.member1:\" + myTestInstance2.member1); //undefined","position":{"start":{"line":6,"column":1,"offset":579},"end":{"line":18,"column":4,"offset":1050},"indent":[1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Prototype inheritance bring method and function. At anytime, it's possible for the instance to override the prototype member. Here is an example that the prototype is defined in a member to show \"m2\" and the first instance override it with \"Override\" string. When a new instance is created, the member will have the value of the prototype.","position":{"start":{"line":20,"column":1,"offset":1052},"end":{"line":20,"column":340,"offset":1391},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":1052},"end":{"line":20,"column":340,"offset":1391},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var myTest = {};\nvar myTestInstance1 = Object.create(myTest);\nmyTestInstance1.__proto__.member2 = \"m2\";\nmyTestInstance1.member2 = \"OVERRIDE\";\n\nvar myTestInstance2 = Object.create(myTest);\n\nconsole.log(\"instance1.member2:\" + myTestInstance1.member2); //Override\nconsole.log(\"instance2.member2:\" + myTestInstance2.member2); //m2","position":{"start":{"line":22,"column":1,"offset":1393},"end":{"line":32,"column":4,"offset":1737},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"It's also possible to change the prototype at any time in the life of the object and have every object changed. In the following example, two instances are created and the prototype is defined afterward. The data is still accessible by both instance after the assignation.","position":{"start":{"line":34,"column":1,"offset":1739},"end":{"line":34,"column":273,"offset":2011},"indent":[]}}],"position":{"start":{"line":34,"column":1,"offset":1739},"end":{"line":34,"column":273,"offset":2011},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var myTest = {};\nvar myTestInstance1 = Object.create(myTest);\nvar myTestInstance2 = Object.create(myTest);\nmyTestInstance1.__proto__.member2 = \"m2\";\n\nconsole.log(\"instance1.member2:\" + myTestInstance1.member2); //m2 console.log(\"instance2.member2:\"+myTestInstance2.member2);//m2","position":{"start":{"line":36,"column":1,"offset":2013},"end":{"line":43,"column":4,"offset":2309},"indent":[1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"So far, the instance of the object was created by using create, but it's also possible to do it with \"new\".","position":{"start":{"line":45,"column":1,"offset":2311},"end":{"line":45,"column":108,"offset":2418},"indent":[]}}],"position":{"start":{"line":45,"column":1,"offset":2311},"end":{"line":45,"column":108,"offset":2418},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var MyClass1 = function () {\n  this.member1 = \"m1\";\n};\n\nMyClass1.prototype.function1 = function () {\n  return \"return from function1\";\n};\n\nvar instance1 = new MyClass1();\n\nconsole.log(\"instance1.member1: \" + instance1.member1); //m1\nconsole.log(\"instance1.function1: \" + instance1.function1()); //return from function1","position":{"start":{"line":47,"column":1,"offset":2420},"end":{"line":60,"column":4,"offset":2756},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"JavaScript Prototype Part 1\",\"date\":\"2017-05-11\",\"categories\":[\"javascript\"]}","position":{"start":{"line":63,"column":1,"offset":2759},"end":{"line":63,"column":116,"offset":2874},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":63,"column":116,"offset":2874}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Prototype Part 1\",\n  \"date\": \"2017-05-11\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"JavaScript is a prototype language. Every object has a prototype which share properties between the same kind of object.\"), mdx(\"p\", null, \"The minimal prototype an object has is the default Object.prototype. However, any object can add members or function to its own object prototype by using \\\".prototype.\\\". The following code shows that an object type \\\"myTest\\\" with no member is having \\\"member1\\\" dynamically added as well as a member2 with the value \\\"m2\\\". We create a second instance and only member2, from the prototype is available. The member1 was added to the instance, not the prototype.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var myTest = {};\\nvar myTestInstance1 = Object.create(myTest);\\nmyTestInstance1.member1 = \\\"m1\\\";\\nmyTestInstance1.__proto__.member2 = \\\"m2\\\";\\n\\nvar myTestInstance2 = Object.create(myTest);\\n\\nconsole.log(\\\"instance1.member2:\\\" + myTestInstance1.member2); //m2\\nconsole.log(\\\"instance2.member2:\\\" + myTestInstance2.member2); //m2\\nconsole.log(\\\"instance1.member1:\\\" + myTestInstance2.member1); //m1\\nconsole.log(\\\"instance2.member1:\\\" + myTestInstance2.member1); //undefined\\n\")), mdx(\"p\", null, \"Prototype inheritance bring method and function. At anytime, it's possible for the instance to override the prototype member. Here is an example that the prototype is defined in a member to show \\\"m2\\\" and the first instance override it with \\\"Override\\\" string. When a new instance is created, the member will have the value of the prototype.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var myTest = {};\\nvar myTestInstance1 = Object.create(myTest);\\nmyTestInstance1.__proto__.member2 = \\\"m2\\\";\\nmyTestInstance1.member2 = \\\"OVERRIDE\\\";\\n\\nvar myTestInstance2 = Object.create(myTest);\\n\\nconsole.log(\\\"instance1.member2:\\\" + myTestInstance1.member2); //Override\\nconsole.log(\\\"instance2.member2:\\\" + myTestInstance2.member2); //m2\\n\")), mdx(\"p\", null, \"It's also possible to change the prototype at any time in the life of the object and have every object changed. In the following example, two instances are created and the prototype is defined afterward. The data is still accessible by both instance after the assignation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var myTest = {};\\nvar myTestInstance1 = Object.create(myTest);\\nvar myTestInstance2 = Object.create(myTest);\\nmyTestInstance1.__proto__.member2 = \\\"m2\\\";\\n\\nconsole.log(\\\"instance1.member2:\\\" + myTestInstance1.member2); //m2 console.log(\\\"instance2.member2:\\\"+myTestInstance2.member2);//m2\\n\")), mdx(\"p\", null, \"So far, the instance of the object was created by using create, but it's also possible to do it with \\\"new\\\".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var MyClass1 = function () {\\n  this.member1 = \\\"m1\\\";\\n};\\n\\nMyClass1.prototype.function1 = function () {\\n  return \\\"return from function1\\\";\\n};\\n\\nvar instance1 = new MyClass1();\\n\\nconsole.log(\\\"instance1.member1: \\\" + instance1.member1); //m1\\nconsole.log(\\\"instance1.function1: \\\" + instance1.function1()); //return from function1\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"JavaScript Prototype Part 1\",\n  \"date\": \"2017-05-11\",\n  \"categories\": [\"javascript\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`JavaScript is a prototype language. Every object has a prototype which share properties between the same kind of object.`}</p>\n    <p>{`The minimal prototype an object has is the default Object.prototype. However, any object can add members or function to its own object prototype by using \".prototype.\". The following code shows that an object type \"myTest\" with no member is having \"member1\" dynamically added as well as a member2 with the value \"m2\". We create a second instance and only member2, from the prototype is available. The member1 was added to the instance, not the prototype.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var myTest = {};\nvar myTestInstance1 = Object.create(myTest);\nmyTestInstance1.member1 = \"m1\";\nmyTestInstance1.__proto__.member2 = \"m2\";\n\nvar myTestInstance2 = Object.create(myTest);\n\nconsole.log(\"instance1.member2:\" + myTestInstance1.member2); //m2\nconsole.log(\"instance2.member2:\" + myTestInstance2.member2); //m2\nconsole.log(\"instance1.member1:\" + myTestInstance2.member1); //m1\nconsole.log(\"instance2.member1:\" + myTestInstance2.member1); //undefined\n`}</code></pre>\n    <p>{`Prototype inheritance bring method and function. At anytime, it's possible for the instance to override the prototype member. Here is an example that the prototype is defined in a member to show \"m2\" and the first instance override it with \"Override\" string. When a new instance is created, the member will have the value of the prototype.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var myTest = {};\nvar myTestInstance1 = Object.create(myTest);\nmyTestInstance1.__proto__.member2 = \"m2\";\nmyTestInstance1.member2 = \"OVERRIDE\";\n\nvar myTestInstance2 = Object.create(myTest);\n\nconsole.log(\"instance1.member2:\" + myTestInstance1.member2); //Override\nconsole.log(\"instance2.member2:\" + myTestInstance2.member2); //m2\n`}</code></pre>\n    <p>{`It's also possible to change the prototype at any time in the life of the object and have every object changed. In the following example, two instances are created and the prototype is defined afterward. The data is still accessible by both instance after the assignation.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var myTest = {};\nvar myTestInstance1 = Object.create(myTest);\nvar myTestInstance2 = Object.create(myTest);\nmyTestInstance1.__proto__.member2 = \"m2\";\n\nconsole.log(\"instance1.member2:\" + myTestInstance1.member2); //m2 console.log(\"instance2.member2:\"+myTestInstance2.member2);//m2\n`}</code></pre>\n    <p>{`So far, the instance of the object was created by using create, but it's also possible to do it with \"new\".`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var MyClass1 = function () {\n  this.member1 = \"m1\";\n};\n\nMyClass1.prototype.function1 = function () {\n  return \"return from function1\";\n};\n\nvar instance1 = new MyClass1();\n\nconsole.log(\"instance1.member1: \" + instance1.member1); //m1\nconsole.log(\"instance1.function1: \" + instance1.function1()); //return from function1\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}