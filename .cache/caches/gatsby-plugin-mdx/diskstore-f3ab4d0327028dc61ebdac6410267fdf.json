{"expireTime":9007200886478382000,"key":"gatsby-plugin-mdx-entire-payload-5ea4025bbedc8fdbc6b77d89a4fc6962--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Redux offers many ways to handle the flow of information in your system. One tool in the toolbox is using Middleware. I already discussed how we can ","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":150,"offset":150},"indent":[]}},{"type":"link","title":null,"url":"./react-and-redux-without-actioncreator","children":[{"type":"text","value":"leverage Middleware to do the heavy lifting instead of action creators","position":{"start":{"line":2,"column":151,"offset":151},"end":{"line":2,"column":221,"offset":221},"indent":[]}}],"position":{"start":{"line":2,"column":150,"offset":150},"end":{"line":2,"column":263,"offset":263},"indent":[]}},{"type":"text","value":". In this article, we will look at one question that you may stumble which is should I use next() or dispatch() withing my middleware?","position":{"start":{"line":2,"column":263,"offset":263},"end":{"line":2,"column":397,"offset":397},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":397,"offset":397},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Before digging into the main topic, let's illustrate the flow on which we will analyze the question.","position":{"start":{"line":4,"column":1,"offset":399},"end":{"line":4,"column":101,"offset":499},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":399},"end":{"line":4,"column":101,"offset":499},"indent":[]}},{"type":"paragraph","children":[{"type":"image","title":null,"url":"images/MiddlewareNextDispatch.png","alt":null,"position":{"start":{"line":6,"column":1,"offset":501},"end":{"line":6,"column":39,"offset":539},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":501},"end":{"line":6,"column":39,"offset":539},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The illustration works from top to bottom. A component dispatches an action with the ","position":{"start":{"line":8,"column":1,"offset":541},"end":{"line":8,"column":86,"offset":626},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"dispatch","position":{"start":{"line":8,"column":88,"offset":628},"end":{"line":8,"column":96,"offset":636},"indent":[]}}],"position":{"start":{"line":8,"column":86,"offset":626},"end":{"line":8,"column":98,"offset":638},"indent":[]}},{"type":"text","value":" function from Redux library. The action contains a type (string) and a payload (data). Middlewares are injected in the flow with Redux at the configuration stage of Redux with the function ","position":{"start":{"line":8,"column":98,"offset":638},"end":{"line":8,"column":288,"offset":828},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"applyMiddleware","position":{"start":{"line":8,"column":290,"offset":830},"end":{"line":8,"column":305,"offset":845},"indent":[]}}],"position":{"start":{"line":8,"column":288,"offset":828},"end":{"line":8,"column":307,"offset":847},"indent":[]}},{"type":"text","value":". For the hypothetic case illustrated, the configuration would be like the following code.","position":{"start":{"line":8,"column":307,"offset":847},"end":{"line":8,"column":397,"offset":937},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":541},"end":{"line":8,"column":397,"offset":937},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"import { createStore, applyMiddleware } from \"redux\";\nconst appliedMiddleware = applyMiddleware(\n  middleware1,\n  middleware2,\n  middleware3,\n  middleware4,\n  middleware5,\n  middleware6\n);\n\nconst reducers = { reducer1, reducer2, reducer3, reducer4 };\nconst reducers = combineReducers(reducersTyped);\n\nconst store: Store<YourAppState> = createStore(\n  reducers,\n  composeEnhancers(appliedMiddleware)\n);\nclass App extends React.Component<{}, YourAppState> {\n  public render(): JSX.Element {\n    return <Provider store={store}></Provider>;\n  }\n}","position":{"start":{"line":10,"column":1,"offset":939},"end":{"line":33,"column":4,"offset":1499},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The amount of middleware and reducer doesn't need to coincide. They are orthogonal concepts. At some point, an action will be invoked via the ","position":{"start":{"line":35,"column":1,"offset":1501},"end":{"line":35,"column":143,"offset":1643},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"dispatch","position":{"start":{"line":35,"column":145,"offset":1645},"end":{"line":35,"column":153,"offset":1653},"indent":[]}}],"position":{"start":{"line":35,"column":143,"offset":1643},"end":{"line":35,"column":155,"offset":1655},"indent":[]}},{"type":"text","value":" function provided by Redux. Let's call the action \"A\". When the action is dispatched, Redux will pass the object to the first middleware. This one is responsible to do something or not. The middleware can inspect the type (string) and look if it knows what to do with it. Or, it can look at the payload and do something with it -- it's very flexible and unopinionated about the selection logic. The default behavior, when nothing is required, is to pass to the next middleware the action. This is done by calling the ","position":{"start":{"line":35,"column":155,"offset":1655},"end":{"line":35,"column":673,"offset":2173},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"next","position":{"start":{"line":35,"column":675,"offset":2175},"end":{"line":35,"column":679,"offset":2179},"indent":[]}}],"position":{"start":{"line":35,"column":673,"offset":2173},"end":{"line":35,"column":681,"offset":2181},"indent":[]}},{"type":"text","value":" function. As you can see in the image, middleware1 next connect to middleware2 and so on.","position":{"start":{"line":35,"column":681,"offset":2181},"end":{"line":35,"column":771,"offset":2271},"indent":[]}}],"position":{"start":{"line":35,"column":1,"offset":1501},"end":{"line":35,"column":771,"offset":2271},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Imagine the scenario where you have an asynchronous call to an API in one of your middleware. This one should not block and must return something. Usually, you return the same action but before calling your API and wait for the response to come back (mostly wait the promise to be resolved). When the response comes back you have two choices: call ","position":{"start":{"line":37,"column":1,"offset":2273},"end":{"line":37,"column":349,"offset":2621},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"next","position":{"start":{"line":37,"column":351,"offset":2623},"end":{"line":37,"column":355,"offset":2627},"indent":[]}}],"position":{"start":{"line":37,"column":349,"offset":2621},"end":{"line":37,"column":357,"offset":2629},"indent":[]}},{"type":"text","value":" or ","position":{"start":{"line":37,"column":357,"offset":2629},"end":{"line":37,"column":361,"offset":2633},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"dispatch","position":{"start":{"line":37,"column":363,"offset":2635},"end":{"line":37,"column":371,"offset":2643},"indent":[]}}],"position":{"start":{"line":37,"column":361,"offset":2633},"end":{"line":37,"column":373,"offset":2645},"indent":[]}},{"type":"text","value":" a new action. The first option, calling next, will take the action you choose and pass it to the next middleware, bypassing all previous ones. Dispatching the action you choose will bring back the new action at the beginning of the stack to have this one move down the each middleware.","position":{"start":{"line":37,"column":373,"offset":2645},"end":{"line":37,"column":659,"offset":2931},"indent":[]}}],"position":{"start":{"line":37,"column":1,"offset":2273},"end":{"line":37,"column":659,"offset":2931},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There is not an absolute solution in this regard. It's a case by case solution. However, you mostly want to move the new action back to the front. In most cases, middleware might not do anything. For example, you may want to use next if your middleware is the last one and is doing the final manipulation to the data and doesn't require any other middleware to alter the data before reaching the reducers. You might want to use next in cases where the new data may start new work from a previous middleware. This can be the case if when fetching data from a middleware require another middleware to fetch more data while analyzing the response.","position":{"start":{"line":39,"column":1,"offset":2933},"end":{"line":39,"column":645,"offset":3577},"indent":[]}}],"position":{"start":{"line":39,"column":1,"offset":2933},"end":{"line":39,"column":645,"offset":3577},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Once the last middleware is reached and return for the last time ","position":{"start":{"line":41,"column":1,"offset":3579},"end":{"line":41,"column":66,"offset":3644},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"next","position":{"start":{"line":41,"column":68,"offset":3646},"end":{"line":41,"column":72,"offset":3650},"indent":[]}}],"position":{"start":{"line":41,"column":66,"offset":3644},"end":{"line":41,"column":74,"offset":3652},"indent":[]}},{"type":"text","value":". The reducers are called in sequence and depending on their selection pattern may take the payload of the action and alter the store. In the case of the component dispatching data that require having a response from an API which is asynchronous, reducers will receive the initial action with the payload that requests the data, hence may do nothing to the store or just change a boolean to indicate that something is loading. Later, when the middleware dispatch or next the response, reducers will be called again and they may do something.","position":{"start":{"line":41,"column":74,"offset":3652},"end":{"line":41,"column":615,"offset":4193},"indent":[]}}],"position":{"start":{"line":41,"column":1,"offset":3579},"end":{"line":41,"column":615,"offset":4193},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Finally, the loop is closed by having the store raising an event saying that the store has changed. From there Redux-React offers a \"Provider\" component that takes care to refresh the state or you can subscribe directly to the store to get notified a refresh the state manually. In both cases, the component is rendered and the changes are displayed to the user.","position":{"start":{"line":43,"column":1,"offset":4195},"end":{"line":43,"column":363,"offset":4557},"indent":[]}}],"position":{"start":{"line":43,"column":1,"offset":4195},"end":{"line":43,"column":363,"offset":4557},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Redux Middleware: Calling next or dispatch?\",\"date\":\"2017-11-14\",\"categories\":[\"react\",\"redux\"]}","position":{"start":{"line":46,"column":1,"offset":4560},"end":{"line":46,"column":135,"offset":4694},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":46,"column":135,"offset":4694}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Redux Middleware: Calling next or dispatch?\",\n  \"date\": \"2017-11-14\",\n  \"categories\": [\"react\", \"redux\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Redux offers many ways to handle the flow of information in your system. One tool in the toolbox is using Middleware. I already discussed how we can \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./react-and-redux-without-actioncreator\"\n  }, \"leverage Middleware to do the heavy lifting instead of action creators\"), \". In this article, we will look at one question that you may stumble which is should I use next() or dispatch() withing my middleware?\"), mdx(\"p\", null, \"Before digging into the main topic, let's illustrate the flow on which we will analyze the question.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"877px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/c7849b6aff5742862d305569daca589e/4b446/MiddlewareNextDispatch.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"82.66666666666667%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAACwElEQVQ4y42U3W7bRhCF+Sh9mT5eLwoU6FUvetG+QNskKNCgSJwWaSO5iQ0LgiTLlkRS4q9Ikdwf7u5XcCU7rp0AHeCQOzu7B4OzMxPUZcPiw5rp+Jrriw2yVQzmnLv/3+GhPY7fWVAVB5aXGyajGbeTCNXp40H7lMQ6hzEGa+1nSYPhY5wh3G5Is4THNhBorRFCoJRiu92SZdlnST3hJl/z+uIV0T46ZmLt/cWBROsea919rBOCtm3pe/OR9CEhziJEOyx8Nr1WFHlG29Ropeh77WMDRNey3++RUtC1Dc6eSE/EgTKwSgSzdckyPpBkBXEhiApNWPSkZUe0y1lENYuwIswVZdUQ5YLJMmUe1tSdOWY4aNhIx9/TgjcfIt7fdGRlw9Vtxdn7iD+vMtapIM4OvJ3k/HG55WojSYuai2XFm4uYv6YlUaHQSnqdg0GaTlmEsnTSeq2UtnTKeV/3x71h3YieVvT+oTo5rI3fk6r32jaH5qTh/zCpBdYZetujjaYfYPXJ71G9xjhLoOuO3bsZyXjukZ5fk54vPZLxgmQ05+rliHfPzli/nZKeL3ws++fmeG68IB3ujeaU0w0BxiKLGlUckAPSLW28Yr+aU4UhdRRT3M7YLSYcohVVtKNcLag3S2QSIvMSVTaeY0guGOqMjw+Pa8bsrn+m3f4KJgITU4fPaOLfoB0DLbp4TTT7CZm+BFf+R5pAKekFdydKKxP04ZqunKLaFKsqdLtENDc4GaNVi9jPPWx7i+tbjnX9oLB1dYm4+Q4X/4CTu1NHgNYGITX1NqGcL+hagRoK33x6UPgMfWZnX1J9H6BffIFTCacm88U6WPHiF6Kvv6Kv9ncMT6bQ/XBwRuDC53TTHzHp6BS0x+Y/Hapf/c7222+wQjyZLo8nUnDnKgtC43s5z3PCMPSVP/hSSt/TnyJ4bP8ClbUZCwTJMvIAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"MiddlewareNextDispatch\",\n    \"title\": \"MiddlewareNextDispatch\",\n    \"src\": \"/static/c7849b6aff5742862d305569daca589e/4b446/MiddlewareNextDispatch.png\",\n    \"srcSet\": [\"/static/c7849b6aff5742862d305569daca589e/5a46d/MiddlewareNextDispatch.png 300w\", \"/static/c7849b6aff5742862d305569daca589e/0a47e/MiddlewareNextDispatch.png 600w\", \"/static/c7849b6aff5742862d305569daca589e/4b446/MiddlewareNextDispatch.png 877w\"],\n    \"sizes\": \"(max-width: 877px) 100vw, 877px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The illustration works from top to bottom. A component dispatches an action with the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dispatch\"), \" function from Redux library. The action contains a type (string) and a payload (data). Middlewares are injected in the flow with Redux at the configuration stage of Redux with the function \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"applyMiddleware\"), \". For the hypothetic case illustrated, the configuration would be like the following code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"import { createStore, applyMiddleware } from \\\"redux\\\";\\nconst appliedMiddleware = applyMiddleware(\\n  middleware1,\\n  middleware2,\\n  middleware3,\\n  middleware4,\\n  middleware5,\\n  middleware6\\n);\\n\\nconst reducers = { reducer1, reducer2, reducer3, reducer4 };\\nconst reducers = combineReducers(reducersTyped);\\n\\nconst store: Store<YourAppState> = createStore(\\n  reducers,\\n  composeEnhancers(appliedMiddleware)\\n);\\nclass App extends React.Component<{}, YourAppState> {\\n  public render(): JSX.Element {\\n    return <Provider store={store}></Provider>;\\n  }\\n}\\n\")), mdx(\"p\", null, \"The amount of middleware and reducer doesn't need to coincide. They are orthogonal concepts. At some point, an action will be invoked via the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dispatch\"), \" function provided by Redux. Let's call the action \\\"A\\\". When the action is dispatched, Redux will pass the object to the first middleware. This one is responsible to do something or not. The middleware can inspect the type (string) and look if it knows what to do with it. Or, it can look at the payload and do something with it -- it's very flexible and unopinionated about the selection logic. The default behavior, when nothing is required, is to pass to the next middleware the action. This is done by calling the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"next\"), \" function. As you can see in the image, middleware1 next connect to middleware2 and so on.\"), mdx(\"p\", null, \"Imagine the scenario where you have an asynchronous call to an API in one of your middleware. This one should not block and must return something. Usually, you return the same action but before calling your API and wait for the response to come back (mostly wait the promise to be resolved). When the response comes back you have two choices: call \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"next\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dispatch\"), \" a new action. The first option, calling next, will take the action you choose and pass it to the next middleware, bypassing all previous ones. Dispatching the action you choose will bring back the new action at the beginning of the stack to have this one move down the each middleware.\"), mdx(\"p\", null, \"There is not an absolute solution in this regard. It's a case by case solution. However, you mostly want to move the new action back to the front. In most cases, middleware might not do anything. For example, you may want to use next if your middleware is the last one and is doing the final manipulation to the data and doesn't require any other middleware to alter the data before reaching the reducers. You might want to use next in cases where the new data may start new work from a previous middleware. This can be the case if when fetching data from a middleware require another middleware to fetch more data while analyzing the response.\"), mdx(\"p\", null, \"Once the last middleware is reached and return for the last time \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"next\"), \". The reducers are called in sequence and depending on their selection pattern may take the payload of the action and alter the store. In the case of the component dispatching data that require having a response from an API which is asynchronous, reducers will receive the initial action with the payload that requests the data, hence may do nothing to the store or just change a boolean to indicate that something is loading. Later, when the middleware dispatch or next the response, reducers will be called again and they may do something.\"), mdx(\"p\", null, \"Finally, the loop is closed by having the store raising an event saying that the store has changed. From there Redux-React offers a \\\"Provider\\\" component that takes care to refresh the state or you can subscribe directly to the store to get notified a refresh the state manually. In both cases, the component is rendered and the changes are displayed to the user.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Redux Middleware: Calling next or dispatch?\",\n  \"date\": \"2017-11-14\",\n  \"categories\": [\"react\", \"redux\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Redux offers many ways to handle the flow of information in your system. One tool in the toolbox is using Middleware. I already discussed how we can `}<a parentName=\"p\" {...{\n        \"href\": \"./react-and-redux-without-actioncreator\"\n      }}>{`leverage Middleware to do the heavy lifting instead of action creators`}</a>{`. In this article, we will look at one question that you may stumble which is should I use next() or dispatch() withing my middleware?`}</p>\n    <p>{`Before digging into the main topic, let's illustrate the flow on which we will analyze the question.`}</p>\n    <p><span parentName=\"p\" {...{\n        \"className\": \"gatsby-resp-image-wrapper\",\n        \"style\": {\n          \"position\": \"relative\",\n          \"display\": \"block\",\n          \"marginLeft\": \"auto\",\n          \"marginRight\": \"auto\",\n          \"maxWidth\": \"877px\"\n        }\n      }}>{`\n      `}<a parentName=\"span\" {...{\n          \"className\": \"gatsby-resp-image-link\",\n          \"href\": \"/static/c7849b6aff5742862d305569daca589e/4b446/MiddlewareNextDispatch.png\",\n          \"style\": {\n            \"display\": \"block\"\n          },\n          \"target\": \"_blank\",\n          \"rel\": \"noopener\"\n        }}>{`\n    `}<span parentName=\"a\" {...{\n            \"className\": \"gatsby-resp-image-background-image\",\n            \"style\": {\n              \"paddingBottom\": \"82.66666666666667%\",\n              \"position\": \"relative\",\n              \"bottom\": \"0\",\n              \"left\": \"0\",\n              \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAACwElEQVQ4y42U3W7bRhCF+Sh9mT5eLwoU6FUvetG+QNskKNCgSJwWaSO5iQ0LgiTLlkRS4q9Ikdwf7u5XcCU7rp0AHeCQOzu7B4OzMxPUZcPiw5rp+Jrriw2yVQzmnLv/3+GhPY7fWVAVB5aXGyajGbeTCNXp40H7lMQ6hzEGa+1nSYPhY5wh3G5Is4THNhBorRFCoJRiu92SZdlnST3hJl/z+uIV0T46ZmLt/cWBROsea919rBOCtm3pe/OR9CEhziJEOyx8Nr1WFHlG29Ropeh77WMDRNey3++RUtC1Dc6eSE/EgTKwSgSzdckyPpBkBXEhiApNWPSkZUe0y1lENYuwIswVZdUQ5YLJMmUe1tSdOWY4aNhIx9/TgjcfIt7fdGRlw9Vtxdn7iD+vMtapIM4OvJ3k/HG55WojSYuai2XFm4uYv6YlUaHQSnqdg0GaTlmEsnTSeq2UtnTKeV/3x71h3YieVvT+oTo5rI3fk6r32jaH5qTh/zCpBdYZetujjaYfYPXJ71G9xjhLoOuO3bsZyXjukZ5fk54vPZLxgmQ05+rliHfPzli/nZKeL3ws++fmeG68IB3ujeaU0w0BxiKLGlUckAPSLW28Yr+aU4UhdRRT3M7YLSYcohVVtKNcLag3S2QSIvMSVTaeY0guGOqMjw+Pa8bsrn+m3f4KJgITU4fPaOLfoB0DLbp4TTT7CZm+BFf+R5pAKekFdydKKxP04ZqunKLaFKsqdLtENDc4GaNVi9jPPWx7i+tbjnX9oLB1dYm4+Q4X/4CTu1NHgNYGITX1NqGcL+hagRoK33x6UPgMfWZnX1J9H6BffIFTCacm88U6WPHiF6Kvv6Kv9ncMT6bQ/XBwRuDC53TTHzHp6BS0x+Y/Hapf/c7222+wQjyZLo8nUnDnKgtC43s5z3PCMPSVP/hSSt/TnyJ4bP8ClbUZCwTJMvIAAAAASUVORK5CYII=')\",\n              \"backgroundSize\": \"cover\",\n              \"display\": \"block\"\n            }\n          }}></span>{`\n  `}<img parentName=\"a\" {...{\n            \"className\": \"gatsby-resp-image-image\",\n            \"alt\": \"MiddlewareNextDispatch\",\n            \"title\": \"MiddlewareNextDispatch\",\n            \"src\": \"/static/c7849b6aff5742862d305569daca589e/4b446/MiddlewareNextDispatch.png\",\n            \"srcSet\": [\"/static/c7849b6aff5742862d305569daca589e/5a46d/MiddlewareNextDispatch.png 300w\", \"/static/c7849b6aff5742862d305569daca589e/0a47e/MiddlewareNextDispatch.png 600w\", \"/static/c7849b6aff5742862d305569daca589e/4b446/MiddlewareNextDispatch.png 877w\"],\n            \"sizes\": \"(max-width: 877px) 100vw, 877px\",\n            \"style\": {\n              \"width\": \"100%\",\n              \"height\": \"100%\",\n              \"margin\": \"0\",\n              \"verticalAlign\": \"middle\",\n              \"position\": \"absolute\",\n              \"top\": \"0\",\n              \"left\": \"0\"\n            },\n            \"loading\": \"lazy\",\n            \"decoding\": \"async\"\n          }}></img>{`\n  `}</a>{`\n    `}</span></p>\n    <p>{`The illustration works from top to bottom. A component dispatches an action with the `}<strong parentName=\"p\">{`dispatch`}</strong>{` function from Redux library. The action contains a type (string) and a payload (data). Middlewares are injected in the flow with Redux at the configuration stage of Redux with the function `}<strong parentName=\"p\">{`applyMiddleware`}</strong>{`. For the hypothetic case illustrated, the configuration would be like the following code.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { createStore, applyMiddleware } from \"redux\";\nconst appliedMiddleware = applyMiddleware(\n  middleware1,\n  middleware2,\n  middleware3,\n  middleware4,\n  middleware5,\n  middleware6\n);\n\nconst reducers = { reducer1, reducer2, reducer3, reducer4 };\nconst reducers = combineReducers(reducersTyped);\n\nconst store: Store<YourAppState> = createStore(\n  reducers,\n  composeEnhancers(appliedMiddleware)\n);\nclass App extends React.Component<{}, YourAppState> {\n  public render(): JSX.Element {\n    return <Provider store={store}></Provider>;\n  }\n}\n`}</code></pre>\n    <p>{`The amount of middleware and reducer doesn't need to coincide. They are orthogonal concepts. At some point, an action will be invoked via the `}<strong parentName=\"p\">{`dispatch`}</strong>{` function provided by Redux. Let's call the action \"A\". When the action is dispatched, Redux will pass the object to the first middleware. This one is responsible to do something or not. The middleware can inspect the type (string) and look if it knows what to do with it. Or, it can look at the payload and do something with it -- it's very flexible and unopinionated about the selection logic. The default behavior, when nothing is required, is to pass to the next middleware the action. This is done by calling the `}<strong parentName=\"p\">{`next`}</strong>{` function. As you can see in the image, middleware1 next connect to middleware2 and so on.`}</p>\n    <p>{`Imagine the scenario where you have an asynchronous call to an API in one of your middleware. This one should not block and must return something. Usually, you return the same action but before calling your API and wait for the response to come back (mostly wait the promise to be resolved). When the response comes back you have two choices: call `}<strong parentName=\"p\">{`next`}</strong>{` or `}<strong parentName=\"p\">{`dispatch`}</strong>{` a new action. The first option, calling next, will take the action you choose and pass it to the next middleware, bypassing all previous ones. Dispatching the action you choose will bring back the new action at the beginning of the stack to have this one move down the each middleware.`}</p>\n    <p>{`There is not an absolute solution in this regard. It's a case by case solution. However, you mostly want to move the new action back to the front. In most cases, middleware might not do anything. For example, you may want to use next if your middleware is the last one and is doing the final manipulation to the data and doesn't require any other middleware to alter the data before reaching the reducers. You might want to use next in cases where the new data may start new work from a previous middleware. This can be the case if when fetching data from a middleware require another middleware to fetch more data while analyzing the response.`}</p>\n    <p>{`Once the last middleware is reached and return for the last time `}<strong parentName=\"p\">{`next`}</strong>{`. The reducers are called in sequence and depending on their selection pattern may take the payload of the action and alter the store. In the case of the component dispatching data that require having a response from an API which is asynchronous, reducers will receive the initial action with the payload that requests the data, hence may do nothing to the store or just change a boolean to indicate that something is loading. Later, when the middleware dispatch or next the response, reducers will be called again and they may do something.`}</p>\n    <p>{`Finally, the loop is closed by having the store raising an event saying that the store has changed. From there Redux-React offers a \"Provider\" component that takes care to refresh the state or you can subscribe directly to the store to get notified a refresh the state manually. In both cases, the component is rendered and the changes are displayed to the user.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}