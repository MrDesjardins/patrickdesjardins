{"expireTime":9007200886478383000,"key":"gatsby-plugin-mdx-entire-payload-c375a5b9eefdf0d511310800c3b9ffab--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"This is part three of three of TypeScript vs Flow. We previously saw the fundamental differences between TypeScript and Flow, then we saw some high-level differences in terms of features. Now, we will see at a much lower level the differences at the syntax.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":258,"offset":258},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":258,"offset":258},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Declaration","position":{"start":{"line":4,"column":4,"offset":263},"end":{"line":4,"column":15,"offset":274},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":260},"end":{"line":4,"column":15,"offset":274},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"TypeScript and Flow are exactly the same.","position":{"start":{"line":6,"column":1,"offset":276},"end":{"line":6,"column":42,"offset":317},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":276},"end":{"line":6,"column":42,"offset":317},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"Const \nlet \nvar","position":{"start":{"line":8,"column":1,"offset":319},"end":{"line":12,"column":4,"offset":352},"indent":[1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Primitive","position":{"start":{"line":14,"column":4,"offset":357},"end":{"line":14,"column":13,"offset":366},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":354},"end":{"line":14,"column":13,"offset":366},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Again, no difference.","position":{"start":{"line":16,"column":1,"offset":368},"end":{"line":16,"column":22,"offset":389},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":368},"end":{"line":16,"column":22,"offset":389},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"Number \nBoolean \nString \nNull \nUndefined \nVoid","position":{"start":{"line":18,"column":1,"offset":391},"end":{"line":25,"column":4,"offset":455},"indent":[1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Array","position":{"start":{"line":27,"column":4,"offset":460},"end":{"line":27,"column":9,"offset":465},"indent":[]}}],"position":{"start":{"line":27,"column":1,"offset":457},"end":{"line":27,"column":9,"offset":465},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"And again, no difference.","position":{"start":{"line":29,"column":1,"offset":467},"end":{"line":29,"column":26,"offset":492},"indent":[]}}],"position":{"start":{"line":29,"column":1,"offset":467},"end":{"line":29,"column":26,"offset":492},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"[] \nArray<T>","position":{"start":{"line":31,"column":1,"offset":494},"end":{"line":34,"column":4,"offset":524},"indent":[1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Enum","position":{"start":{"line":36,"column":4,"offset":529},"end":{"line":36,"column":8,"offset":533},"indent":[]}}],"position":{"start":{"line":36,"column":1,"offset":526},"end":{"line":36,"column":8,"offset":533},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"TypeScript is shorted:","position":{"start":{"line":38,"column":1,"offset":535},"end":{"line":38,"column":23,"offset":557},"indent":[]}}],"position":{"start":{"line":38,"column":1,"offset":535},"end":{"line":38,"column":23,"offset":557},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"// Language file:\nexport enum Language {\n English,\n French\n}\n// Use of Language file:\nimport { Language } from \"../general/Language\";\nexport class LocaleManager {\n public static GetLocale(language: Language): void {\n switch (language) {\n // ...\n }\n }\n}","position":{"start":{"line":40,"column":1,"offset":559},"end":{"line":55,"column":4,"offset":829},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Flow requires the value in const, and special import. It's more verbose.","position":{"start":{"line":57,"column":1,"offset":831},"end":{"line":57,"column":73,"offset":903},"indent":[]}}],"position":{"start":{"line":57,"column":1,"offset":831},"end":{"line":57,"column":73,"offset":903},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"// Language file:\n// @flow\nexport const LANGUAGES_VALUE = {\n FRENCH: \"French\",\n ENGLISH: \"English\"\n};","position":{"start":{"line":59,"column":1,"offset":905},"end":{"line":66,"column":4,"offset":1024},"indent":[1,1,1,1,1,1,1]}},{"type":"code","lang":"typescript","meta":null,"value":"export type Language = $Values<typeof LANGUAGES_VALUE>;\n// Use of Language file:\nimport type { Language } from \"../general/Language\";\nimport { LANGUAGES_VALUE } from \"../general/Language\";\n\nexport class LocaleManager {\n static GetLocale(language: Language): void {\n    switch (language) {\n    // ...\n    }\n }\n}","position":{"start":{"line":68,"column":1,"offset":1026},"end":{"line":81,"column":4,"offset":1354},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Maybe Argument","position":{"start":{"line":83,"column":4,"offset":1359},"end":{"line":83,"column":18,"offset":1373},"indent":[]}}],"position":{"start":{"line":83,"column":1,"offset":1356},"end":{"line":83,"column":18,"offset":1373},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Watch out the question mark in the few next examples. Flow distinguishes null and undefined between optional and maybe.","position":{"start":{"line":85,"column":1,"offset":1375},"end":{"line":85,"column":120,"offset":1494},"indent":[]}}],"position":{"start":{"line":85,"column":1,"offset":1375},"end":{"line":85,"column":120,"offset":1494},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"TypeScript:\n\n{ propertyName?: string } //Allow null & undefined\n","position":{"start":{"line":87,"column":1,"offset":1496},"end":{"line":92,"column":4,"offset":1578},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Flow:","position":{"start":{"line":93,"column":1,"offset":1579},"end":{"line":93,"column":6,"offset":1584},"indent":[]}}],"position":{"start":{"line":93,"column":1,"offset":1579},"end":{"line":93,"column":6,"offset":1584},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"{ propertyName: ?string } //Allow null & undefined \n","position":{"start":{"line":95,"column":1,"offset":1586},"end":{"line":98,"column":4,"offset":1656},"indent":[1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Optional Property","position":{"start":{"line":99,"column":4,"offset":1660},"end":{"line":99,"column":21,"offset":1677},"indent":[]}}],"position":{"start":{"line":99,"column":1,"offset":1657},"end":{"line":99,"column":21,"offset":1677},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"TypeScript:","position":{"start":{"line":101,"column":1,"offset":1679},"end":{"line":101,"column":12,"offset":1690},"indent":[]}}],"position":{"start":{"line":101,"column":1,"offset":1679},"end":{"line":101,"column":12,"offset":1690},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"{ propertyName?: string } //Allow null & undefined \n","position":{"start":{"line":103,"column":1,"offset":1692},"end":{"line":106,"column":4,"offset":1762},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Flow:","position":{"start":{"line":107,"column":1,"offset":1763},"end":{"line":107,"column":6,"offset":1768},"indent":[]}}],"position":{"start":{"line":107,"column":1,"offset":1763},"end":{"line":107,"column":6,"offset":1768},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"{ propertyName?: string } //Allow undefined \n","position":{"start":{"line":109,"column":1,"offset":1770},"end":{"line":112,"column":4,"offset":1833},"indent":[1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Optional Argument","position":{"start":{"line":113,"column":4,"offset":1837},"end":{"line":113,"column":21,"offset":1854},"indent":[]}}],"position":{"start":{"line":113,"column":1,"offset":1834},"end":{"line":113,"column":21,"offset":1854},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"TypeScript:","position":{"start":{"line":115,"column":1,"offset":1856},"end":{"line":115,"column":12,"offset":1867},"indent":[]}}],"position":{"start":{"line":115,"column":1,"offset":1856},"end":{"line":115,"column":12,"offset":1867},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"( propertyName?: string ) //Allow null & undefined\n","position":{"start":{"line":117,"column":1,"offset":1869},"end":{"line":120,"column":5,"offset":1941},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Flow:","position":{"start":{"line":121,"column":1,"offset":1942},"end":{"line":121,"column":6,"offset":1947},"indent":[]}}],"position":{"start":{"line":121,"column":1,"offset":1942},"end":{"line":121,"column":6,"offset":1947},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"( propertyName?: string ) //Allow undefined \n","position":{"start":{"line":123,"column":1,"offset":1949},"end":{"line":126,"column":4,"offset":2012},"indent":[1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Literal value as type","position":{"start":{"line":127,"column":4,"offset":2016},"end":{"line":127,"column":25,"offset":2037},"indent":[]}}],"position":{"start":{"line":127,"column":1,"offset":2013},"end":{"line":127,"column":25,"offset":2037},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In both cases, same syntax. For example, the code below only accepts the value of two. The difference is that TypeScript allows us to pass null or undefined. Flow doesn’t. To have Flow accept null you need to use the maybe concept which is to put a question mark right before the two.","position":{"start":{"line":129,"column":1,"offset":2039},"end":{"line":129,"column":285,"offset":2323},"indent":[]}}],"position":{"start":{"line":129,"column":1,"offset":2039},"end":{"line":129,"column":285,"offset":2323},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function funct(value: 2) {}\n// Flow to accept 2 and null and undefined:\nfunction funct(value: ?2) { }\n// Flow to accept 2 and undefined by not null:\nfunction funct(value?: 2) { }\n","position":{"start":{"line":131,"column":1,"offset":2325},"end":{"line":138,"column":4,"offset":2522},"indent":[1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Union type","position":{"start":{"line":139,"column":4,"offset":2526},"end":{"line":139,"column":14,"offset":2536},"indent":[]}}],"position":{"start":{"line":139,"column":1,"offset":2523},"end":{"line":139,"column":14,"offset":2536},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Union type are supported by both and have the same syntax. Indeed, TypeScript allows to pass null and undefined while Flow doesn't.","position":{"start":{"line":141,"column":1,"offset":2538},"end":{"line":141,"column":132,"offset":2669},"indent":[]}}],"position":{"start":{"line":141,"column":1,"offset":2538},"end":{"line":141,"column":132,"offset":2669},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function funct(arg1: \"a\" | \"b\" | \"c\") { }\n// Flow to have also null and undefined:\nfunction funct(arg1?: \"a\" | \"b\" | \"c\" | null) { }\n","position":{"start":{"line":143,"column":1,"offset":2671},"end":{"line":148,"column":4,"offset":2822},"indent":[1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Union primitive type","position":{"start":{"line":149,"column":4,"offset":2826},"end":{"line":149,"column":24,"offset":2846},"indent":[]}}],"position":{"start":{"line":149,"column":1,"offset":2823},"end":{"line":149,"column":24,"offset":2846},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Union with primitive work the same. TypeScript is consistent by letting null and undefined as well.","position":{"start":{"line":151,"column":1,"offset":2848},"end":{"line":151,"column":100,"offset":2947},"indent":[]}}],"position":{"start":{"line":151,"column":1,"offset":2848},"end":{"line":151,"column":100,"offset":2947},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"\nfunction funct(arg1: number | string) { }\n// Flow to accept null and undefined:\nfunction funct(arg1?: number | ?string) { }\nfunction funct(arg1?: number | string | null) { }\n","position":{"start":{"line":152,"column":1,"offset":2948},"end":{"line":159,"column":4,"offset":3141},"indent":[1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Mixed keyword","position":{"start":{"line":160,"column":4,"offset":3145},"end":{"line":160,"column":17,"offset":3158},"indent":[]}}],"position":{"start":{"line":160,"column":1,"offset":3142},"end":{"line":160,"column":17,"offset":3158},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Mixed doesn’t exist with TypeScript, so here is how it’s written in Flow. In TypeScript, you would use ","position":{"start":{"line":162,"column":1,"offset":3160},"end":{"line":162,"column":104,"offset":3263},"indent":[]}},{"type":"inlineCode","value":"any","position":{"start":{"line":162,"column":104,"offset":3263},"end":{"line":162,"column":109,"offset":3268},"indent":[]}},{"type":"text","value":" or an empty definition with the curly brace: {}. The difference is that with ","position":{"start":{"line":162,"column":109,"offset":3268},"end":{"line":162,"column":187,"offset":3346},"indent":[]}},{"type":"inlineCode","value":"any","position":{"start":{"line":162,"column":187,"offset":3346},"end":{"line":162,"column":192,"offset":3351},"indent":[]}},{"type":"text","value":" or curly brackets you can redefine the variable with any type once initialized. With Flow and the use of mixed, it’s any type until it’s defined. Once defined, the type is set for the life of the variable. Nice addition to the language, it’s a “dynamic any”.","position":{"start":{"line":162,"column":192,"offset":3351},"end":{"line":162,"column":451,"offset":3610},"indent":[]}}],"position":{"start":{"line":162,"column":1,"offset":3160},"end":{"line":162,"column":451,"offset":3610},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function funct(arg1: mixed) { }\n","position":{"start":{"line":164,"column":1,"offset":3612},"end":{"line":167,"column":4,"offset":3662},"indent":[1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Any type","position":{"start":{"line":168,"column":4,"offset":3666},"end":{"line":168,"column":12,"offset":3674},"indent":[]}}],"position":{"start":{"line":168,"column":1,"offset":3663},"end":{"line":168,"column":12,"offset":3674},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Same syntax.","position":{"start":{"line":170,"column":1,"offset":3676},"end":{"line":170,"column":13,"offset":3688},"indent":[]}}],"position":{"start":{"line":170,"column":1,"offset":3676},"end":{"line":170,"column":13,"offset":3688},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function funct(arg1: any) { }","position":{"start":{"line":172,"column":1,"offset":3690},"end":{"line":174,"column":4,"offset":3737},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Define return type","position":{"start":{"line":176,"column":4,"offset":3742},"end":{"line":176,"column":22,"offset":3760},"indent":[]}}],"position":{"start":{"line":176,"column":1,"offset":3739},"end":{"line":176,"column":22,"offset":3760},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Returning value is with the semi-colon followed by the type. If nothing, return void.","position":{"start":{"line":178,"column":1,"offset":3762},"end":{"line":178,"column":86,"offset":3847},"indent":[]}}],"position":{"start":{"line":178,"column":1,"offset":3762},"end":{"line":178,"column":86,"offset":3847},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function funct(): string { }","position":{"start":{"line":180,"column":1,"offset":3849},"end":{"line":182,"column":4,"offset":3895},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Function type","position":{"start":{"line":184,"column":4,"offset":3900},"end":{"line":184,"column":17,"offset":3913},"indent":[]}}],"position":{"start":{"line":184,"column":1,"offset":3897},"end":{"line":184,"column":17,"offset":3913},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The signature of a method is exactly the same. It uses the JavaScript keyword “function” with parentheses that contain the name followed by the type. After the semicolon, the type is returned.","position":{"start":{"line":186,"column":1,"offset":3915},"end":{"line":186,"column":193,"offset":4107},"indent":[]}}],"position":{"start":{"line":186,"column":1,"offset":3915},"end":{"line":186,"column":193,"offset":4107},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function funct(p1: string, p2?: boolean): void { }","position":{"start":{"line":188,"column":1,"offset":4109},"end":{"line":190,"column":4,"offset":4177},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Function w/o type","position":{"start":{"line":192,"column":4,"offset":4182},"end":{"line":192,"column":21,"offset":4199},"indent":[]}}],"position":{"start":{"line":192,"column":1,"offset":4179},"end":{"line":192,"column":21,"offset":4199},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Function returns void by default in both.","position":{"start":{"line":194,"column":1,"offset":4201},"end":{"line":194,"column":42,"offset":4242},"indent":[]}}],"position":{"start":{"line":194,"column":1,"offset":4201},"end":{"line":194,"column":42,"offset":4242},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function funct(p1, p2) { } ","position":{"start":{"line":196,"column":1,"offset":4244},"end":{"line":198,"column":4,"offset":4289},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Function fat arrow","position":{"start":{"line":200,"column":4,"offset":4294},"end":{"line":200,"column":22,"offset":4312},"indent":[]}}],"position":{"start":{"line":200,"column":1,"offset":4291},"end":{"line":200,"column":22,"offset":4312},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Fat arrow is a copy and paste between the two.","position":{"start":{"line":202,"column":1,"offset":4314},"end":{"line":202,"column":47,"offset":4360},"indent":[]}}],"position":{"start":{"line":202,"column":1,"offset":4314},"end":{"line":202,"column":47,"offset":4360},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"let funct = (p1, p2) => { }","position":{"start":{"line":204,"column":1,"offset":4362},"end":{"line":206,"column":4,"offset":4407},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Function with callback","position":{"start":{"line":208,"column":4,"offset":4412},"end":{"line":208,"column":26,"offset":4434},"indent":[]}}],"position":{"start":{"line":208,"column":1,"offset":4409},"end":{"line":208,"column":26,"offset":4434},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Callback arguments are written the same way in TypeScript or Flow.","position":{"start":{"line":210,"column":1,"offset":4436},"end":{"line":210,"column":67,"offset":4502},"indent":[]}}],"position":{"start":{"line":210,"column":1,"offset":4436},"end":{"line":210,"column":67,"offset":4502},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function funct(cb: (e: string | null, v: string | number) => void) { }","position":{"start":{"line":212,"column":1,"offset":4504},"end":{"line":214,"column":4,"offset":4592},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Funct with rest","position":{"start":{"line":216,"column":4,"offset":4597},"end":{"line":216,"column":19,"offset":4612},"indent":[]}}],"position":{"start":{"line":216,"column":1,"offset":4594},"end":{"line":216,"column":19,"offset":4612},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Both support the long and short version.","position":{"start":{"line":218,"column":1,"offset":4614},"end":{"line":218,"column":41,"offset":4654},"indent":[]}}],"position":{"start":{"line":218,"column":1,"offset":4614},"end":{"line":218,"column":41,"offset":4654},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function funct(...args: Array<number>) {}\nfunction funct2(...args: number[]) {}","position":{"start":{"line":220,"column":1,"offset":4656},"end":{"line":223,"column":4,"offset":4753},"indent":[1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Type Alias","position":{"start":{"line":225,"column":4,"offset":4758},"end":{"line":225,"column":14,"offset":4768},"indent":[]}}],"position":{"start":{"line":225,"column":1,"offset":4755},"end":{"line":225,"column":14,"offset":4768},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Aliases are written the same way in both case.","position":{"start":{"line":227,"column":1,"offset":4770},"end":{"line":227,"column":47,"offset":4816},"indent":[]}}],"position":{"start":{"line":227,"column":1,"offset":4770},"end":{"line":227,"column":47,"offset":4816},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var obj1: { foo: boolean } = { foo: true };\n// or\ntype MyType = { value: boolean };\nvar obj2: MyType;\n","position":{"start":{"line":229,"column":1,"offset":4818},"end":{"line":235,"column":4,"offset":4938},"indent":[1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Type Alias with Generic","position":{"start":{"line":236,"column":4,"offset":4942},"end":{"line":236,"column":27,"offset":4965},"indent":[]}}],"position":{"start":{"line":236,"column":1,"offset":4939},"end":{"line":236,"column":27,"offset":4965},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Generic doesn't change anything. TypeScript and Flow stays the same.","position":{"start":{"line":238,"column":1,"offset":4967},"end":{"line":238,"column":69,"offset":5035},"indent":[]}}],"position":{"start":{"line":238,"column":1,"offset":4967},"end":{"line":238,"column":69,"offset":5035},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"type MyObject<A, B, C> = {\n property: A,\n method(val: B): C,\n};\nvar x: MyObject<number, string, boolean> = { property: 1, method: (string) => { return\ntrue;}}\n","position":{"start":{"line":240,"column":1,"offset":5037},"end":{"line":248,"column":4,"offset":5214},"indent":[1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Subtype","position":{"start":{"line":249,"column":4,"offset":5218},"end":{"line":249,"column":11,"offset":5225},"indent":[]}}],"position":{"start":{"line":249,"column":1,"offset":5215},"end":{"line":249,"column":11,"offset":5225},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Defining your own type is the same in Flow or TypeScript.","position":{"start":{"line":251,"column":1,"offset":5227},"end":{"line":251,"column":58,"offset":5284},"indent":[]}}],"position":{"start":{"line":251,"column":1,"offset":5227},"end":{"line":251,"column":58,"offset":5284},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"type TypeLetters = \"A\" | \"B\" | \"C\";","position":{"start":{"line":253,"column":1,"offset":5286},"end":{"line":255,"column":4,"offset":5339},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Object as map","position":{"start":{"line":257,"column":4,"offset":5344},"end":{"line":257,"column":17,"offset":5357},"indent":[]}}],"position":{"start":{"line":257,"column":1,"offset":5341},"end":{"line":257,"column":17,"offset":5357},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The first part is the same. You can use a string between square bracket to access in read or write a member of an object.","position":{"start":{"line":259,"column":1,"offset":5359},"end":{"line":259,"column":122,"offset":5480},"indent":[]}}],"position":{"start":{"line":259,"column":1,"offset":5359},"end":{"line":259,"column":122,"offset":5480},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var o: { foo?:number } = {};\no[\"foo\"] = 0;","position":{"start":{"line":261,"column":1,"offset":5482},"end":{"line":264,"column":4,"offset":5542},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"However, TypeScript won’t allow dynamic adding of a member. In TypeScript, once a type is set to a variable, this one cannot change. The exception is the \"any\" type.","position":{"start":{"line":266,"column":1,"offset":5544},"end":{"line":266,"column":166,"offset":5709},"indent":[]}}],"position":{"start":{"line":266,"column":1,"offset":5544},"end":{"line":266,"column":166,"offset":5709},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var o: { foo?:number } = {};\no[\"foo\"] = 0;\no[“bar”] = 2; //This will work in Flow, but not in TypeScript\n","position":{"start":{"line":268,"column":1,"offset":5711},"end":{"line":273,"column":4,"offset":5834},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This is interesting since Flow is looser in this regard, and TypeScript is looser in term of the null/undefined. The justification of TypeScript to be strict is its structural typing.","position":{"start":{"line":275,"column":1,"offset":5838},"end":{"line":275,"column":184,"offset":6021},"indent":[]}}],"position":{"start":{"line":275,"column":1,"offset":5838},"end":{"line":275,"column":184,"offset":6021},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Array","position":{"start":{"line":277,"column":4,"offset":6026},"end":{"line":277,"column":9,"offset":6031},"indent":[]}}],"position":{"start":{"line":277,"column":1,"offset":6023},"end":{"line":277,"column":9,"offset":6031},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Pretty similar except the case of allowing Null. Here are all the similar scenarios.","position":{"start":{"line":279,"column":1,"offset":6033},"end":{"line":279,"column":85,"offset":6117},"indent":[]}}],"position":{"start":{"line":279,"column":1,"offset":6033},"end":{"line":279,"column":85,"offset":6117},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var x = [];\nvar y = [1, 2, 3];\nvar z = new Array();\nvar w: boolean[] = [true, false, true];\nvar v: Array<boolean> = [true, false, true];","position":{"start":{"line":281,"column":1,"offset":6119},"end":{"line":287,"column":4,"offset":6273},"indent":[1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Here is how TypeScript does with null (nothing to do) and how to add the possibility of null in Flow.","position":{"start":{"line":289,"column":1,"offset":6275},"end":{"line":289,"column":102,"offset":6376},"indent":[]}}],"position":{"start":{"line":289,"column":1,"offset":6275},"end":{"line":289,"column":102,"offset":6376},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var s: number[] = [1, 2, null];\nvar s: (?number)[] = [1, 2, null];","position":{"start":{"line":291,"column":1,"offset":6378},"end":{"line":294,"column":4,"offset":6462},"indent":[1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Tuple","position":{"start":{"line":296,"column":4,"offset":6467},"end":{"line":296,"column":9,"offset":6472},"indent":[]}}],"position":{"start":{"line":296,"column":1,"offset":6464},"end":{"line":296,"column":9,"offset":6472},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Same syntax for tuple.","position":{"start":{"line":298,"column":1,"offset":6474},"end":{"line":298,"column":23,"offset":6496},"indent":[]}}],"position":{"start":{"line":298,"column":1,"offset":6474},"end":{"line":298,"column":23,"offset":6496},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var tuple: [number, boolean, string] = [1, true, \"three\"];","position":{"start":{"line":300,"column":1,"offset":6498},"end":{"line":302,"column":4,"offset":6574},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Key interpolation","position":{"start":{"line":304,"column":4,"offset":6579},"end":{"line":304,"column":21,"offset":6596},"indent":[]}}],"position":{"start":{"line":304,"column":1,"offset":6576},"end":{"line":304,"column":21,"offset":6596},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var obj1: { foo: boolean } = { foo: true };\nobj1[\"foo\"] = false;","position":{"start":{"line":306,"column":1,"offset":6598},"end":{"line":309,"column":4,"offset":6680},"indent":[1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Opaque Type","position":{"start":{"line":311,"column":4,"offset":6685},"end":{"line":311,"column":15,"offset":6696},"indent":[]}}],"position":{"start":{"line":311,"column":1,"offset":6682},"end":{"line":311,"column":15,"offset":6696},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"With Flow you can define a type detail to be only available to a module. Here is an example. It can be used by an external module by importing it. However, the other file that imports won’t be able to assign it as Number, only as “MyType”. This feature can be interesting for people to enforce the use of their type. This is not available for TypeScript.","position":{"start":{"line":313,"column":1,"offset":6698},"end":{"line":313,"column":355,"offset":7052},"indent":[]}}],"position":{"start":{"line":313,"column":1,"offset":6698},"end":{"line":313,"column":355,"offset":7052},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"opaque type MyType = number;","position":{"start":{"line":315,"column":1,"offset":7054},"end":{"line":317,"column":4,"offset":7100},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Interface and Implementation","position":{"start":{"line":319,"column":4,"offset":7105},"end":{"line":319,"column":32,"offset":7133},"indent":[]}}],"position":{"start":{"line":319,"column":1,"offset":7102},"end":{"line":319,"column":32,"offset":7133},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Implementing an interface is the same in Flow or TypeScript.","position":{"start":{"line":321,"column":1,"offset":7135},"end":{"line":321,"column":61,"offset":7195},"indent":[]}}],"position":{"start":{"line":321,"column":1,"offset":7135},"end":{"line":321,"column":61,"offset":7195},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"interface Serializable {\n serialize(): string;\n}\nclass Foo implements Serializable {\n serialize() { return '[Foo]'; }\n}","position":{"start":{"line":323,"column":1,"offset":7197},"end":{"line":330,"column":4,"offset":7334},"indent":[1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Interface as map","position":{"start":{"line":332,"column":4,"offset":7339},"end":{"line":332,"column":20,"offset":7355},"indent":[]}}],"position":{"start":{"line":332,"column":1,"offset":7336},"end":{"line":332,"column":20,"offset":7355},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Both share the same syntax.","position":{"start":{"line":334,"column":1,"offset":7357},"end":{"line":334,"column":28,"offset":7384},"indent":[]}}],"position":{"start":{"line":334,"column":1,"offset":7357},"end":{"line":334,"column":28,"offset":7384},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"interface MyInterface {\n [key: string]: number;\n}\nvar x: MyInterface;\nx.key = 3;","position":{"start":{"line":336,"column":1,"offset":7386},"end":{"line":342,"column":4,"offset":7484},"indent":[1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Interface and object","position":{"start":{"line":344,"column":4,"offset":7489},"end":{"line":344,"column":24,"offset":7509},"indent":[]}}],"position":{"start":{"line":344,"column":1,"offset":7486},"end":{"line":344,"column":24,"offset":7509},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Both are the same for the first part.","position":{"start":{"line":346,"column":1,"offset":7511},"end":{"line":346,"column":38,"offset":7548},"indent":[]}}],"position":{"start":{"line":346,"column":1,"offset":7511},"end":{"line":346,"column":38,"offset":7548},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"interface MyInterface{\n  foo: string,\n  bar: number\n}\nvar x: MyInterface = {\n  foo : \"foo\",\n  bar : 1\n};\n","position":{"start":{"line":348,"column":1,"offset":7550},"end":{"line":358,"column":4,"offset":7673},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"However, TypeScript is more permissive since you do not have to define both members. You can just define the type, without defining any value at all, and later assign the value. By default, the value will be undefined.","position":{"start":{"line":359,"column":1,"offset":7674},"end":{"line":359,"column":219,"offset":7892},"indent":[]}}],"position":{"start":{"line":359,"column":1,"offset":7674},"end":{"line":359,"column":219,"offset":7892},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var x: MyInterface;\nx.foo = \"foo\";\nx.bar = 1;\n","position":{"start":{"line":361,"column":1,"offset":7894},"end":{"line":366,"column":4,"offset":7958},"indent":[1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Covariance property (readonly)","position":{"start":{"line":367,"column":4,"offset":7962},"end":{"line":367,"column":34,"offset":7992},"indent":[]}}],"position":{"start":{"line":367,"column":1,"offset":7959},"end":{"line":367,"column":34,"offset":7992},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The syntax is a little bit different. TypeScript is using a longer approach, similar to C# with the keyword \"readonly\". Flow is using the plus symbol.","position":{"start":{"line":369,"column":1,"offset":7994},"end":{"line":369,"column":151,"offset":8144},"indent":[]}}],"position":{"start":{"line":369,"column":1,"offset":7994},"end":{"line":369,"column":151,"offset":8144},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"interface MyInterface{\n readonly foo: string\n}\nvar x: MyInterface = { foo: \"bar\" };\nx.foo = \"123\"; // Blocked!\n","position":{"start":{"line":371,"column":1,"offset":8146},"end":{"line":378,"column":4,"offset":8275},"indent":[1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Flow:","position":{"start":{"line":379,"column":1,"offset":8276},"end":{"line":379,"column":6,"offset":8281},"indent":[]}}],"position":{"start":{"line":379,"column":1,"offset":8276},"end":{"line":379,"column":6,"offset":8281},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"interface MyInterface{\n +foo: string\n}\nvar x: MyInterface = { foo: \"bar\" };\nx.foo = \"123\"; // Blocked!\n","position":{"start":{"line":381,"column":1,"offset":8283},"end":{"line":388,"column":4,"offset":8404},"indent":[1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Contravariance","position":{"start":{"line":389,"column":4,"offset":8408},"end":{"line":389,"column":18,"offset":8422},"indent":[]}}],"position":{"start":{"line":389,"column":1,"offset":8405},"end":{"line":389,"column":18,"offset":8422},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"TypeScript needs to have the type to be defined to all possible value. In the following example, the field is of type number. However, in the code, it can be a number or a string. TypeScript blocks the code to compile since there is a possibility of being a string, so it says that it must be a number or a string.","position":{"start":{"line":391,"column":1,"offset":8424},"end":{"line":391,"column":315,"offset":8738},"indent":[]}}],"position":{"start":{"line":391,"column":1,"offset":8424},"end":{"line":391,"column":315,"offset":8738},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"interface Contravariant { writeOnly: number; }\nvar numberOrString = Math.random() > 0.5 ? 42 : 'forty-two';\nvar value2: Contravariant = { writeOnly: numberOrString }; // Doesn't work. Need to change the type number to be : number | string\n","position":{"start":{"line":393,"column":1,"offset":8740},"end":{"line":398,"column":4,"offset":8997},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"With Flow, with the same syntax, you get the same result. However, with the sign minus, you can make the code to be contravariant.","position":{"start":{"line":399,"column":1,"offset":8998},"end":{"line":399,"column":131,"offset":9128},"indent":[]}}],"position":{"start":{"line":399,"column":1,"offset":8998},"end":{"line":399,"column":131,"offset":9128},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"interface Contravariant { -writeOnly: number; }\nvar numberOrString = Math.random() > 0.5 ? 42 : 'forty-two';\nvar value2: Contravariant = { writeOnly: numberOrString }; // Works!\n","position":{"start":{"line":401,"column":1,"offset":9130},"end":{"line":406,"column":4,"offset":9326},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Again, this is a small syntax difference. At the end, isn't just simpler to just mark the type to \"string | number\" in both case?","position":{"start":{"line":407,"column":1,"offset":9327},"end":{"line":407,"column":130,"offset":9456},"indent":[]}}],"position":{"start":{"line":407,"column":1,"offset":9327},"end":{"line":407,"column":130,"offset":9456},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Generic Class","position":{"start":{"line":409,"column":4,"offset":9461},"end":{"line":409,"column":17,"offset":9474},"indent":[]}}],"position":{"start":{"line":409,"column":1,"offset":9458},"end":{"line":409,"column":17,"offset":9474},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Exact same syntax.","position":{"start":{"line":411,"column":1,"offset":9476},"end":{"line":411,"column":19,"offset":9494},"indent":[]}}],"position":{"start":{"line":411,"column":1,"offset":9476},"end":{"line":411,"column":19,"offset":9494},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"class Item<T> {\n prop: T;\n constructor(param: T) {\n this.prop = param;\n }\n}\nlet item1: Item<number> = new Item(42);\n","position":{"start":{"line":413,"column":1,"offset":9496},"end":{"line":422,"column":4,"offset":9630},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Generic Interface","position":{"start":{"line":423,"column":4,"offset":9634},"end":{"line":423,"column":21,"offset":9651},"indent":[]}}],"position":{"start":{"line":423,"column":1,"offset":9631},"end":{"line":423,"column":21,"offset":9651},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"As we saw earlier, TypeScript allows to declare a type and not instantiated completely or completely. Flow must declare and instantiate.","position":{"start":{"line":425,"column":1,"offset":9653},"end":{"line":425,"column":137,"offset":9789},"indent":[]}}],"position":{"start":{"line":425,"column":1,"offset":9653},"end":{"line":425,"column":137,"offset":9789},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"interface MyInterface<A, B, C> {\n foo: A,\n bar: B,\n baz: C,\n}","position":{"start":{"line":427,"column":1,"offset":9791},"end":{"line":433,"column":4,"offset":9870},"indent":[1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"// Flow and TypeScript:","position":{"start":{"line":435,"column":1,"offset":9872},"end":{"line":435,"column":24,"offset":9895},"indent":[]}}],"position":{"start":{"line":435,"column":1,"offset":9872},"end":{"line":435,"column":24,"offset":9895},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var x: MyInterface<string, number, boolean> = {foo:\"1\", bar:4, baz:true};\n","position":{"start":{"line":436,"column":1,"offset":9896},"end":{"line":439,"column":4,"offset":9988},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"// Only TypeScript:","position":{"start":{"line":440,"column":1,"offset":9989},"end":{"line":440,"column":20,"offset":10008},"indent":[]}}],"position":{"start":{"line":440,"column":1,"offset":9989},"end":{"line":440,"column":20,"offset":10008},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var x: MyInterface<string, number, boolean>; // Notice that we only declare.\nx.foo = \"123\";\n","position":{"start":{"line":441,"column":1,"offset":10009},"end":{"line":445,"column":4,"offset":10119},"indent":[1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Generic Type","position":{"start":{"line":446,"column":4,"offset":10123},"end":{"line":446,"column":16,"offset":10135},"indent":[]}}],"position":{"start":{"line":446,"column":1,"offset":10120},"end":{"line":446,"column":16,"offset":10135},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Both allows to have generic type in the same syntax.","position":{"start":{"line":448,"column":1,"offset":10137},"end":{"line":448,"column":53,"offset":10189},"indent":[]}}],"position":{"start":{"line":448,"column":1,"offset":10137},"end":{"line":448,"column":53,"offset":10189},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"type Item<T> = {\n prop: T,\n};","position":{"start":{"line":450,"column":1,"offset":10191},"end":{"line":454,"column":4,"offset":10238},"indent":[1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Generic Function","position":{"start":{"line":456,"column":4,"offset":10243},"end":{"line":456,"column":20,"offset":10259},"indent":[]}}],"position":{"start":{"line":456,"column":1,"offset":10240},"end":{"line":456,"column":20,"offset":10259},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Generic function share the same syntax between Flow and TypeScript.","position":{"start":{"line":458,"column":1,"offset":10261},"end":{"line":458,"column":68,"offset":10328},"indent":[]}}],"position":{"start":{"line":458,"column":1,"offset":10261},"end":{"line":458,"column":68,"offset":10328},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function funct1<T>(p1: T, p2 = \"Smith\") { }\n","position":{"start":{"line":460,"column":1,"offset":10330},"end":{"line":463,"column":4,"offset":10392},"indent":[1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Default parameter value","position":{"start":{"line":464,"column":4,"offset":10396},"end":{"line":464,"column":27,"offset":10419},"indent":[]}}],"position":{"start":{"line":464,"column":1,"offset":10393},"end":{"line":464,"column":27,"offset":10419},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Default parameter use the equal sign followed by the value in both cases.","position":{"start":{"line":466,"column":1,"offset":10421},"end":{"line":466,"column":74,"offset":10494},"indent":[]}}],"position":{"start":{"line":466,"column":1,"offset":10421},"end":{"line":466,"column":74,"offset":10494},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function funct1(p1: string, p2 = \"Smith\") { }","position":{"start":{"line":468,"column":1,"offset":10496},"end":{"line":470,"column":4,"offset":10559},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Generic Type with default type and value","position":{"start":{"line":472,"column":4,"offset":10564},"end":{"line":472,"column":44,"offset":10604},"indent":[]}}],"position":{"start":{"line":472,"column":1,"offset":10561},"end":{"line":472,"column":44,"offset":10604},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"TypeScript uses the keyword extends to have a generic type from a particular type. Default value is the same.","position":{"start":{"line":474,"column":1,"offset":10606},"end":{"line":474,"column":110,"offset":10715},"indent":[]}}],"position":{"start":{"line":474,"column":1,"offset":10606},"end":{"line":474,"column":110,"offset":10715},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"Type Item<T extends number = 1> = {\n prop: T,\n};","position":{"start":{"line":476,"column":1,"offset":10717},"end":{"line":480,"column":4,"offset":10783},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Flow uses the semicolon to enforce the generic type and equal sign for default.","position":{"start":{"line":482,"column":1,"offset":10785},"end":{"line":482,"column":80,"offset":10864},"indent":[]}}],"position":{"start":{"line":482,"column":1,"offset":10785},"end":{"line":482,"column":80,"offset":10864},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"type Item<T: number = 1> = {\n prop: T,\n};","position":{"start":{"line":484,"column":1,"offset":10866},"end":{"line":488,"column":4,"offset":10925},"indent":[1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Cast","position":{"start":{"line":490,"column":4,"offset":10930},"end":{"line":490,"column":8,"offset":10934},"indent":[]}}],"position":{"start":{"line":490,"column":1,"offset":10927},"end":{"line":490,"column":8,"offset":10934},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Cast is different. Require having parentheses and a semi colon in Flow. TypeScript uses \"as\" like in C#. Flow is a little bit more verbose and can become harder to see in a situation within the inner function with many parentheses and curly braces.","position":{"start":{"line":492,"column":1,"offset":10936},"end":{"line":492,"column":249,"offset":11184},"indent":[]}}],"position":{"start":{"line":492,"column":1,"offset":10936},"end":{"line":492,"column":249,"offset":11184},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"var x: number = otherVariable as number;\nvar x: number = (othervariable: number);\n","position":{"start":{"line":494,"column":1,"offset":11186},"end":{"line":498,"column":4,"offset":11286},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"While I was investigating Flow, I was getting more and more surprised by the similitude with TypeScript. In this third article, we can see that the syntax is so common with TypeScript that it’s hard to be very polarized about which one is really the best. There are few fundamental differences that we saw in terms of concept, but even there it’s not very deeply different. Indeed, Flow is checking more scenarios, and TypeScript is letting some scenarios be more “JavaScript-ish”, but still, in other scenarios allows a strong rigidity and better encapsulation.","position":{"start":{"line":499,"column":1,"offset":11287},"end":{"line":499,"column":563,"offset":11849},"indent":[]}}],"position":{"start":{"line":499,"column":1,"offset":11287},"end":{"line":499,"column":563,"offset":11849},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Every team is different. Every person has a different past. Flow and TypeScript should cover the need of having your code more strongly typed, less prone to error, and easier to understand by everyone who reads it. The choice of Flow or TypeScript is a matter of little details. At the end of my investigation, I was all open to going with Flow for our new project at Netflix. However, the last meeting tipped the decision to go with TypeScript. In our case, the number of supported third-party libraries was something that changed our mind.","position":{"start":{"line":501,"column":1,"offset":11851},"end":{"line":501,"column":542,"offset":12392},"indent":[]}}],"position":{"start":{"line":501,"column":1,"offset":11851},"end":{"line":501,"column":542,"offset":12392},"indent":[]}},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Parts of the serie:","position":{"start":{"line":503,"column":3,"offset":12396},"end":{"line":503,"column":22,"offset":12415},"indent":[]}}],"position":{"start":{"line":503,"column":1,"offset":12394},"end":{"line":503,"column":24,"offset":12417},"indent":[]}}],"position":{"start":{"line":503,"column":1,"offset":12394},"end":{"line":503,"column":24,"offset":12417},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"typescript-vs-flow-part-1-of-3-who-they-are","children":[{"type":"text","value":"TypeScript vs Flow (Part 1 of 3) – Who are they?","position":{"start":{"line":505,"column":4,"offset":12422},"end":{"line":505,"column":52,"offset":12470},"indent":[]}}],"position":{"start":{"line":505,"column":3,"offset":12421},"end":{"line":505,"column":98,"offset":12516},"indent":[]}}],"position":{"start":{"line":505,"column":3,"offset":12421},"end":{"line":505,"column":98,"offset":12516},"indent":[]}}],"position":{"start":{"line":505,"column":1,"offset":12419},"end":{"line":505,"column":98,"offset":12516},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"./typescript-vs-flow-part-2-of-3-high-level-coding","children":[{"type":"text","value":"TypeScript vs Flow (Part 2 of 3) – High Level Coding","position":{"start":{"line":506,"column":4,"offset":12520},"end":{"line":506,"column":56,"offset":12572},"indent":[]}}],"position":{"start":{"line":506,"column":3,"offset":12519},"end":{"line":506,"column":109,"offset":12625},"indent":[]}}],"position":{"start":{"line":506,"column":3,"offset":12519},"end":{"line":506,"column":109,"offset":12625},"indent":[]}}],"position":{"start":{"line":506,"column":1,"offset":12517},"end":{"line":506,"column":109,"offset":12625},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"./typescript-vs-flow-part-3-of-3-syntax-difference","children":[{"type":"text","value":"TypeScript vs Flow (Part 3 of 3) – Syntax Difference","position":{"start":{"line":507,"column":4,"offset":12629},"end":{"line":507,"column":56,"offset":12681},"indent":[]}}],"position":{"start":{"line":507,"column":3,"offset":12628},"end":{"line":507,"column":109,"offset":12734},"indent":[]}}],"position":{"start":{"line":507,"column":3,"offset":12628},"end":{"line":507,"column":109,"offset":12734},"indent":[]}}],"position":{"start":{"line":507,"column":1,"offset":12626},"end":{"line":507,"column":109,"offset":12734},"indent":[]}}],"position":{"start":{"line":505,"column":1,"offset":12419},"end":{"line":507,"column":109,"offset":12734},"indent":[1,1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"TypeScript vs Flow (Part 3 of 3) - Syntax Difference\",\"date\":\"2017-08-30\",\"categories\":[\"flow\",\"typescript\"]}","position":{"start":{"line":510,"column":1,"offset":12737},"end":{"line":510,"column":148,"offset":12884},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":510,"column":148,"offset":12884}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript vs Flow (Part 3 of 3) - Syntax Difference\",\n  \"date\": \"2017-08-30\",\n  \"categories\": [\"flow\", \"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is part three of three of TypeScript vs Flow. We previously saw the fundamental differences between TypeScript and Flow, then we saw some high-level differences in terms of features. Now, we will see at a much lower level the differences at the syntax.\"), mdx(\"h2\", null, \"Declaration\"), mdx(\"p\", null, \"TypeScript and Flow are exactly the same.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"Const \\nlet \\nvar\\n\")), mdx(\"h2\", null, \"Primitive\"), mdx(\"p\", null, \"Again, no difference.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"Number \\nBoolean \\nString \\nNull \\nUndefined \\nVoid\\n\")), mdx(\"h2\", null, \"Array\"), mdx(\"p\", null, \"And again, no difference.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"[] \\nArray<T>\\n\")), mdx(\"h2\", null, \"Enum\"), mdx(\"p\", null, \"TypeScript is shorted:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"// Language file:\\nexport enum Language {\\n English,\\n French\\n}\\n// Use of Language file:\\nimport { Language } from \\\"../general/Language\\\";\\nexport class LocaleManager {\\n public static GetLocale(language: Language): void {\\n switch (language) {\\n // ...\\n }\\n }\\n}\\n\")), mdx(\"p\", null, \"Flow requires the value in const, and special import. It's more verbose.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"// Language file:\\n// @flow\\nexport const LANGUAGES_VALUE = {\\n FRENCH: \\\"French\\\",\\n ENGLISH: \\\"English\\\"\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export type Language = $Values<typeof LANGUAGES_VALUE>;\\n// Use of Language file:\\nimport type { Language } from \\\"../general/Language\\\";\\nimport { LANGUAGES_VALUE } from \\\"../general/Language\\\";\\n\\nexport class LocaleManager {\\n static GetLocale(language: Language): void {\\n    switch (language) {\\n    // ...\\n    }\\n }\\n}\\n\")), mdx(\"h2\", null, \"Maybe Argument\"), mdx(\"p\", null, \"Watch out the question mark in the few next examples. Flow distinguishes null and undefined between optional and maybe.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"TypeScript:\\n\\n{ propertyName?: string } //Allow null & undefined\\n\\n\")), mdx(\"p\", null, \"Flow:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"{ propertyName: ?string } //Allow null & undefined \\n\\n\")), mdx(\"h2\", null, \"Optional Property\"), mdx(\"p\", null, \"TypeScript:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"{ propertyName?: string } //Allow null & undefined \\n\\n\")), mdx(\"p\", null, \"Flow:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"{ propertyName?: string } //Allow undefined \\n\\n\")), mdx(\"h2\", null, \"Optional Argument\"), mdx(\"p\", null, \"TypeScript:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"( propertyName?: string ) //Allow null & undefined\\n\\n\")), mdx(\"p\", null, \"Flow:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"( propertyName?: string ) //Allow undefined \\n\\n\")), mdx(\"h2\", null, \"Literal value as type\"), mdx(\"p\", null, \"In both cases, same syntax. For example, the code below only accepts the value of two. The difference is that TypeScript allows us to pass null or undefined. Flow doesn\\u2019t. To have Flow accept null you need to use the maybe concept which is to put a question mark right before the two.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function funct(value: 2) {}\\n// Flow to accept 2 and null and undefined:\\nfunction funct(value: ?2) { }\\n// Flow to accept 2 and undefined by not null:\\nfunction funct(value?: 2) { }\\n\\n\")), mdx(\"h2\", null, \"Union type\"), mdx(\"p\", null, \"Union type are supported by both and have the same syntax. Indeed, TypeScript allows to pass null and undefined while Flow doesn't.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function funct(arg1: \\\"a\\\" | \\\"b\\\" | \\\"c\\\") { }\\n// Flow to have also null and undefined:\\nfunction funct(arg1?: \\\"a\\\" | \\\"b\\\" | \\\"c\\\" | null) { }\\n\\n\")), mdx(\"h2\", null, \"Union primitive type\"), mdx(\"p\", null, \"Union with primitive work the same. TypeScript is consistent by letting null and undefined as well.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"\\nfunction funct(arg1: number | string) { }\\n// Flow to accept null and undefined:\\nfunction funct(arg1?: number | ?string) { }\\nfunction funct(arg1?: number | string | null) { }\\n\\n\")), mdx(\"h2\", null, \"Mixed keyword\"), mdx(\"p\", null, \"Mixed doesn\\u2019t exist with TypeScript, so here is how it\\u2019s written in Flow. In TypeScript, you would use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any\"), \" or an empty definition with the curly brace: {}. The difference is that with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any\"), \" or curly brackets you can redefine the variable with any type once initialized. With Flow and the use of mixed, it\\u2019s any type until it\\u2019s defined. Once defined, the type is set for the life of the variable. Nice addition to the language, it\\u2019s a \\u201Cdynamic any\\u201D.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function funct(arg1: mixed) { }\\n\\n\")), mdx(\"h2\", null, \"Any type\"), mdx(\"p\", null, \"Same syntax.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function funct(arg1: any) { }\\n\")), mdx(\"h2\", null, \"Define return type\"), mdx(\"p\", null, \"Returning value is with the semi-colon followed by the type. If nothing, return void.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function funct(): string { }\\n\")), mdx(\"h2\", null, \"Function type\"), mdx(\"p\", null, \"The signature of a method is exactly the same. It uses the JavaScript keyword \\u201Cfunction\\u201D with parentheses that contain the name followed by the type. After the semicolon, the type is returned.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function funct(p1: string, p2?: boolean): void { }\\n\")), mdx(\"h2\", null, \"Function w/o type\"), mdx(\"p\", null, \"Function returns void by default in both.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function funct(p1, p2) { } \\n\")), mdx(\"h2\", null, \"Function fat arrow\"), mdx(\"p\", null, \"Fat arrow is a copy and paste between the two.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"let funct = (p1, p2) => { }\\n\")), mdx(\"h2\", null, \"Function with callback\"), mdx(\"p\", null, \"Callback arguments are written the same way in TypeScript or Flow.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function funct(cb: (e: string | null, v: string | number) => void) { }\\n\")), mdx(\"h2\", null, \"Funct with rest\"), mdx(\"p\", null, \"Both support the long and short version.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function funct(...args: Array<number>) {}\\nfunction funct2(...args: number[]) {}\\n\")), mdx(\"h2\", null, \"Type Alias\"), mdx(\"p\", null, \"Aliases are written the same way in both case.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var obj1: { foo: boolean } = { foo: true };\\n// or\\ntype MyType = { value: boolean };\\nvar obj2: MyType;\\n\\n\")), mdx(\"h2\", null, \"Type Alias with Generic\"), mdx(\"p\", null, \"Generic doesn't change anything. TypeScript and Flow stays the same.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"type MyObject<A, B, C> = {\\n property: A,\\n method(val: B): C,\\n};\\nvar x: MyObject<number, string, boolean> = { property: 1, method: (string) => { return\\ntrue;}}\\n\\n\")), mdx(\"h2\", null, \"Subtype\"), mdx(\"p\", null, \"Defining your own type is the same in Flow or TypeScript.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"type TypeLetters = \\\"A\\\" | \\\"B\\\" | \\\"C\\\";\\n\")), mdx(\"h2\", null, \"Object as map\"), mdx(\"p\", null, \"The first part is the same. You can use a string between square bracket to access in read or write a member of an object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var o: { foo?:number } = {};\\no[\\\"foo\\\"] = 0;\\n\")), mdx(\"p\", null, \"However, TypeScript won\\u2019t allow dynamic adding of a member. In TypeScript, once a type is set to a variable, this one cannot change. The exception is the \\\"any\\\" type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var o: { foo?:number } = {};\\no[\\\"foo\\\"] = 0;\\no[\\u201Cbar\\u201D] = 2; //This will work in Flow, but not in TypeScript\\n\\n\")), mdx(\"p\", null, \"This is interesting since Flow is looser in this regard, and TypeScript is looser in term of the null/undefined. The justification of TypeScript to be strict is its structural typing.\"), mdx(\"h2\", null, \"Array\"), mdx(\"p\", null, \"Pretty similar except the case of allowing Null. Here are all the similar scenarios.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var x = [];\\nvar y = [1, 2, 3];\\nvar z = new Array();\\nvar w: boolean[] = [true, false, true];\\nvar v: Array<boolean> = [true, false, true];\\n\")), mdx(\"p\", null, \"Here is how TypeScript does with null (nothing to do) and how to add the possibility of null in Flow.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var s: number[] = [1, 2, null];\\nvar s: (?number)[] = [1, 2, null];\\n\")), mdx(\"h2\", null, \"Tuple\"), mdx(\"p\", null, \"Same syntax for tuple.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var tuple: [number, boolean, string] = [1, true, \\\"three\\\"];\\n\")), mdx(\"h2\", null, \"Key interpolation\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var obj1: { foo: boolean } = { foo: true };\\nobj1[\\\"foo\\\"] = false;\\n\")), mdx(\"h2\", null, \"Opaque Type\"), mdx(\"p\", null, \"With Flow you can define a type detail to be only available to a module. Here is an example. It can be used by an external module by importing it. However, the other file that imports won\\u2019t be able to assign it as Number, only as \\u201CMyType\\u201D. This feature can be interesting for people to enforce the use of their type. This is not available for TypeScript.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"opaque type MyType = number;\\n\")), mdx(\"h2\", null, \"Interface and Implementation\"), mdx(\"p\", null, \"Implementing an interface is the same in Flow or TypeScript.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface Serializable {\\n serialize(): string;\\n}\\nclass Foo implements Serializable {\\n serialize() { return '[Foo]'; }\\n}\\n\")), mdx(\"h2\", null, \"Interface as map\"), mdx(\"p\", null, \"Both share the same syntax.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface MyInterface {\\n [key: string]: number;\\n}\\nvar x: MyInterface;\\nx.key = 3;\\n\")), mdx(\"h2\", null, \"Interface and object\"), mdx(\"p\", null, \"Both are the same for the first part.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface MyInterface{\\n  foo: string,\\n  bar: number\\n}\\nvar x: MyInterface = {\\n  foo : \\\"foo\\\",\\n  bar : 1\\n};\\n\\n\")), mdx(\"p\", null, \"However, TypeScript is more permissive since you do not have to define both members. You can just define the type, without defining any value at all, and later assign the value. By default, the value will be undefined.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var x: MyInterface;\\nx.foo = \\\"foo\\\";\\nx.bar = 1;\\n\\n\")), mdx(\"h2\", null, \"Covariance property (readonly)\"), mdx(\"p\", null, \"The syntax is a little bit different. TypeScript is using a longer approach, similar to C# with the keyword \\\"readonly\\\". Flow is using the plus symbol.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface MyInterface{\\n readonly foo: string\\n}\\nvar x: MyInterface = { foo: \\\"bar\\\" };\\nx.foo = \\\"123\\\"; // Blocked!\\n\\n\")), mdx(\"p\", null, \"Flow:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface MyInterface{\\n +foo: string\\n}\\nvar x: MyInterface = { foo: \\\"bar\\\" };\\nx.foo = \\\"123\\\"; // Blocked!\\n\\n\")), mdx(\"h2\", null, \"Contravariance\"), mdx(\"p\", null, \"TypeScript needs to have the type to be defined to all possible value. In the following example, the field is of type number. However, in the code, it can be a number or a string. TypeScript blocks the code to compile since there is a possibility of being a string, so it says that it must be a number or a string.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface Contravariant { writeOnly: number; }\\nvar numberOrString = Math.random() > 0.5 ? 42 : 'forty-two';\\nvar value2: Contravariant = { writeOnly: numberOrString }; // Doesn't work. Need to change the type number to be : number | string\\n\\n\")), mdx(\"p\", null, \"With Flow, with the same syntax, you get the same result. However, with the sign minus, you can make the code to be contravariant.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface Contravariant { -writeOnly: number; }\\nvar numberOrString = Math.random() > 0.5 ? 42 : 'forty-two';\\nvar value2: Contravariant = { writeOnly: numberOrString }; // Works!\\n\\n\")), mdx(\"p\", null, \"Again, this is a small syntax difference. At the end, isn't just simpler to just mark the type to \\\"string | number\\\" in both case?\"), mdx(\"h2\", null, \"Generic Class\"), mdx(\"p\", null, \"Exact same syntax.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"class Item<T> {\\n prop: T;\\n constructor(param: T) {\\n this.prop = param;\\n }\\n}\\nlet item1: Item<number> = new Item(42);\\n\\n\")), mdx(\"h2\", null, \"Generic Interface\"), mdx(\"p\", null, \"As we saw earlier, TypeScript allows to declare a type and not instantiated completely or completely. Flow must declare and instantiate.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"interface MyInterface<A, B, C> {\\n foo: A,\\n bar: B,\\n baz: C,\\n}\\n\")), mdx(\"p\", null, \"// Flow and TypeScript:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var x: MyInterface<string, number, boolean> = {foo:\\\"1\\\", bar:4, baz:true};\\n\\n\")), mdx(\"p\", null, \"// Only TypeScript:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var x: MyInterface<string, number, boolean>; // Notice that we only declare.\\nx.foo = \\\"123\\\";\\n\\n\")), mdx(\"h2\", null, \"Generic Type\"), mdx(\"p\", null, \"Both allows to have generic type in the same syntax.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"type Item<T> = {\\n prop: T,\\n};\\n\")), mdx(\"h2\", null, \"Generic Function\"), mdx(\"p\", null, \"Generic function share the same syntax between Flow and TypeScript.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function funct1<T>(p1: T, p2 = \\\"Smith\\\") { }\\n\\n\")), mdx(\"h2\", null, \"Default parameter value\"), mdx(\"p\", null, \"Default parameter use the equal sign followed by the value in both cases.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function funct1(p1: string, p2 = \\\"Smith\\\") { }\\n\")), mdx(\"h2\", null, \"Generic Type with default type and value\"), mdx(\"p\", null, \"TypeScript uses the keyword extends to have a generic type from a particular type. Default value is the same.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"Type Item<T extends number = 1> = {\\n prop: T,\\n};\\n\")), mdx(\"p\", null, \"Flow uses the semicolon to enforce the generic type and equal sign for default.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"type Item<T: number = 1> = {\\n prop: T,\\n};\\n\")), mdx(\"h2\", null, \"Cast\"), mdx(\"p\", null, \"Cast is different. Require having parentheses and a semi colon in Flow. TypeScript uses \\\"as\\\" like in C#. Flow is a little bit more verbose and can become harder to see in a situation within the inner function with many parentheses and curly braces.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"var x: number = otherVariable as number;\\nvar x: number = (othervariable: number);\\n\\n\")), mdx(\"p\", null, \"While I was investigating Flow, I was getting more and more surprised by the similitude with TypeScript. In this third article, we can see that the syntax is so common with TypeScript that it\\u2019s hard to be very polarized about which one is really the best. There are few fundamental differences that we saw in terms of concept, but even there it\\u2019s not very deeply different. Indeed, Flow is checking more scenarios, and TypeScript is letting some scenarios be more \\u201CJavaScript-ish\\u201D, but still, in other scenarios allows a strong rigidity and better encapsulation.\"), mdx(\"p\", null, \"Every team is different. Every person has a different past. Flow and TypeScript should cover the need of having your code more strongly typed, less prone to error, and easier to understand by everyone who reads it. The choice of Flow or TypeScript is a matter of little details. At the end of my investigation, I was all open to going with Flow for our new project at Netflix. However, the last meeting tipped the decision to go with TypeScript. In our case, the number of supported third-party libraries was something that changed our mind.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Parts of the serie:\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"typescript-vs-flow-part-1-of-3-who-they-are\"\n  }, \"TypeScript vs Flow (Part 1 of 3) \\u2013 Who are they?\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-vs-flow-part-2-of-3-high-level-coding\"\n  }, \"TypeScript vs Flow (Part 2 of 3) \\u2013 High Level Coding\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./typescript-vs-flow-part-3-of-3-syntax-difference\"\n  }, \"TypeScript vs Flow (Part 3 of 3) \\u2013 Syntax Difference\"))));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"TypeScript vs Flow (Part 3 of 3) - Syntax Difference\",\n  \"date\": \"2017-08-30\",\n  \"categories\": [\"flow\", \"typescript\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`This is part three of three of TypeScript vs Flow. We previously saw the fundamental differences between TypeScript and Flow, then we saw some high-level differences in terms of features. Now, we will see at a much lower level the differences at the syntax.`}</p>\n    <h2>{`Declaration`}</h2>\n    <p>{`TypeScript and Flow are exactly the same.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`Const \nlet \nvar\n`}</code></pre>\n    <h2>{`Primitive`}</h2>\n    <p>{`Again, no difference.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`Number \nBoolean \nString \nNull \nUndefined \nVoid\n`}</code></pre>\n    <h2>{`Array`}</h2>\n    <p>{`And again, no difference.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`[] \nArray<T>\n`}</code></pre>\n    <h2>{`Enum`}</h2>\n    <p>{`TypeScript is shorted:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Language file:\nexport enum Language {\n English,\n French\n}\n// Use of Language file:\nimport { Language } from \"../general/Language\";\nexport class LocaleManager {\n public static GetLocale(language: Language): void {\n switch (language) {\n // ...\n }\n }\n}\n`}</code></pre>\n    <p>{`Flow requires the value in const, and special import. It's more verbose.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Language file:\n// @flow\nexport const LANGUAGES_VALUE = {\n FRENCH: \"French\",\n ENGLISH: \"English\"\n};\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`export type Language = $Values<typeof LANGUAGES_VALUE>;\n// Use of Language file:\nimport type { Language } from \"../general/Language\";\nimport { LANGUAGES_VALUE } from \"../general/Language\";\n\nexport class LocaleManager {\n static GetLocale(language: Language): void {\n    switch (language) {\n    // ...\n    }\n }\n}\n`}</code></pre>\n    <h2>{`Maybe Argument`}</h2>\n    <p>{`Watch out the question mark in the few next examples. Flow distinguishes null and undefined between optional and maybe.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`TypeScript:\n\n{ propertyName?: string } //Allow null & undefined\n\n`}</code></pre>\n    <p>{`Flow:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`{ propertyName: ?string } //Allow null & undefined \n\n`}</code></pre>\n    <h2>{`Optional Property`}</h2>\n    <p>{`TypeScript:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`{ propertyName?: string } //Allow null & undefined \n\n`}</code></pre>\n    <p>{`Flow:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`{ propertyName?: string } //Allow undefined \n\n`}</code></pre>\n    <h2>{`Optional Argument`}</h2>\n    <p>{`TypeScript:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`( propertyName?: string ) //Allow null & undefined\n\n`}</code></pre>\n    <p>{`Flow:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`( propertyName?: string ) //Allow undefined \n\n`}</code></pre>\n    <h2>{`Literal value as type`}</h2>\n    <p>{`In both cases, same syntax. For example, the code below only accepts the value of two. The difference is that TypeScript allows us to pass null or undefined. Flow doesn’t. To have Flow accept null you need to use the maybe concept which is to put a question mark right before the two.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function funct(value: 2) {}\n// Flow to accept 2 and null and undefined:\nfunction funct(value: ?2) { }\n// Flow to accept 2 and undefined by not null:\nfunction funct(value?: 2) { }\n\n`}</code></pre>\n    <h2>{`Union type`}</h2>\n    <p>{`Union type are supported by both and have the same syntax. Indeed, TypeScript allows to pass null and undefined while Flow doesn't.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function funct(arg1: \"a\" | \"b\" | \"c\") { }\n// Flow to have also null and undefined:\nfunction funct(arg1?: \"a\" | \"b\" | \"c\" | null) { }\n\n`}</code></pre>\n    <h2>{`Union primitive type`}</h2>\n    <p>{`Union with primitive work the same. TypeScript is consistent by letting null and undefined as well.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`\nfunction funct(arg1: number | string) { }\n// Flow to accept null and undefined:\nfunction funct(arg1?: number | ?string) { }\nfunction funct(arg1?: number | string | null) { }\n\n`}</code></pre>\n    <h2>{`Mixed keyword`}</h2>\n    <p>{`Mixed doesn’t exist with TypeScript, so here is how it’s written in Flow. In TypeScript, you would use `}<inlineCode parentName=\"p\">{`any`}</inlineCode>{` or an empty definition with the curly brace: {}. The difference is that with `}<inlineCode parentName=\"p\">{`any`}</inlineCode>{` or curly brackets you can redefine the variable with any type once initialized. With Flow and the use of mixed, it’s any type until it’s defined. Once defined, the type is set for the life of the variable. Nice addition to the language, it’s a “dynamic any”.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function funct(arg1: mixed) { }\n\n`}</code></pre>\n    <h2>{`Any type`}</h2>\n    <p>{`Same syntax.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function funct(arg1: any) { }\n`}</code></pre>\n    <h2>{`Define return type`}</h2>\n    <p>{`Returning value is with the semi-colon followed by the type. If nothing, return void.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function funct(): string { }\n`}</code></pre>\n    <h2>{`Function type`}</h2>\n    <p>{`The signature of a method is exactly the same. It uses the JavaScript keyword “function” with parentheses that contain the name followed by the type. After the semicolon, the type is returned.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function funct(p1: string, p2?: boolean): void { }\n`}</code></pre>\n    <h2>{`Function w/o type`}</h2>\n    <p>{`Function returns void by default in both.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function funct(p1, p2) { } \n`}</code></pre>\n    <h2>{`Function fat arrow`}</h2>\n    <p>{`Fat arrow is a copy and paste between the two.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`let funct = (p1, p2) => { }\n`}</code></pre>\n    <h2>{`Function with callback`}</h2>\n    <p>{`Callback arguments are written the same way in TypeScript or Flow.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function funct(cb: (e: string | null, v: string | number) => void) { }\n`}</code></pre>\n    <h2>{`Funct with rest`}</h2>\n    <p>{`Both support the long and short version.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function funct(...args: Array<number>) {}\nfunction funct2(...args: number[]) {}\n`}</code></pre>\n    <h2>{`Type Alias`}</h2>\n    <p>{`Aliases are written the same way in both case.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var obj1: { foo: boolean } = { foo: true };\n// or\ntype MyType = { value: boolean };\nvar obj2: MyType;\n\n`}</code></pre>\n    <h2>{`Type Alias with Generic`}</h2>\n    <p>{`Generic doesn't change anything. TypeScript and Flow stays the same.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type MyObject<A, B, C> = {\n property: A,\n method(val: B): C,\n};\nvar x: MyObject<number, string, boolean> = { property: 1, method: (string) => { return\ntrue;}}\n\n`}</code></pre>\n    <h2>{`Subtype`}</h2>\n    <p>{`Defining your own type is the same in Flow or TypeScript.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type TypeLetters = \"A\" | \"B\" | \"C\";\n`}</code></pre>\n    <h2>{`Object as map`}</h2>\n    <p>{`The first part is the same. You can use a string between square bracket to access in read or write a member of an object.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var o: { foo?:number } = {};\no[\"foo\"] = 0;\n`}</code></pre>\n    <p>{`However, TypeScript won’t allow dynamic adding of a member. In TypeScript, once a type is set to a variable, this one cannot change. The exception is the \"any\" type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var o: { foo?:number } = {};\no[\"foo\"] = 0;\no[“bar”] = 2; //This will work in Flow, but not in TypeScript\n\n`}</code></pre>\n    <p>{`This is interesting since Flow is looser in this regard, and TypeScript is looser in term of the null/undefined. The justification of TypeScript to be strict is its structural typing.`}</p>\n    <h2>{`Array`}</h2>\n    <p>{`Pretty similar except the case of allowing Null. Here are all the similar scenarios.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var x = [];\nvar y = [1, 2, 3];\nvar z = new Array();\nvar w: boolean[] = [true, false, true];\nvar v: Array<boolean> = [true, false, true];\n`}</code></pre>\n    <p>{`Here is how TypeScript does with null (nothing to do) and how to add the possibility of null in Flow.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var s: number[] = [1, 2, null];\nvar s: (?number)[] = [1, 2, null];\n`}</code></pre>\n    <h2>{`Tuple`}</h2>\n    <p>{`Same syntax for tuple.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var tuple: [number, boolean, string] = [1, true, \"three\"];\n`}</code></pre>\n    <h2>{`Key interpolation`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var obj1: { foo: boolean } = { foo: true };\nobj1[\"foo\"] = false;\n`}</code></pre>\n    <h2>{`Opaque Type`}</h2>\n    <p>{`With Flow you can define a type detail to be only available to a module. Here is an example. It can be used by an external module by importing it. However, the other file that imports won’t be able to assign it as Number, only as “MyType”. This feature can be interesting for people to enforce the use of their type. This is not available for TypeScript.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`opaque type MyType = number;\n`}</code></pre>\n    <h2>{`Interface and Implementation`}</h2>\n    <p>{`Implementing an interface is the same in Flow or TypeScript.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface Serializable {\n serialize(): string;\n}\nclass Foo implements Serializable {\n serialize() { return '[Foo]'; }\n}\n`}</code></pre>\n    <h2>{`Interface as map`}</h2>\n    <p>{`Both share the same syntax.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface MyInterface {\n [key: string]: number;\n}\nvar x: MyInterface;\nx.key = 3;\n`}</code></pre>\n    <h2>{`Interface and object`}</h2>\n    <p>{`Both are the same for the first part.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface MyInterface{\n  foo: string,\n  bar: number\n}\nvar x: MyInterface = {\n  foo : \"foo\",\n  bar : 1\n};\n\n`}</code></pre>\n    <p>{`However, TypeScript is more permissive since you do not have to define both members. You can just define the type, without defining any value at all, and later assign the value. By default, the value will be undefined.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var x: MyInterface;\nx.foo = \"foo\";\nx.bar = 1;\n\n`}</code></pre>\n    <h2>{`Covariance property (readonly)`}</h2>\n    <p>{`The syntax is a little bit different. TypeScript is using a longer approach, similar to C# with the keyword \"readonly\". Flow is using the plus symbol.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface MyInterface{\n readonly foo: string\n}\nvar x: MyInterface = { foo: \"bar\" };\nx.foo = \"123\"; // Blocked!\n\n`}</code></pre>\n    <p>{`Flow:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface MyInterface{\n +foo: string\n}\nvar x: MyInterface = { foo: \"bar\" };\nx.foo = \"123\"; // Blocked!\n\n`}</code></pre>\n    <h2>{`Contravariance`}</h2>\n    <p>{`TypeScript needs to have the type to be defined to all possible value. In the following example, the field is of type number. However, in the code, it can be a number or a string. TypeScript blocks the code to compile since there is a possibility of being a string, so it says that it must be a number or a string.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface Contravariant { writeOnly: number; }\nvar numberOrString = Math.random() > 0.5 ? 42 : 'forty-two';\nvar value2: Contravariant = { writeOnly: numberOrString }; // Doesn't work. Need to change the type number to be : number | string\n\n`}</code></pre>\n    <p>{`With Flow, with the same syntax, you get the same result. However, with the sign minus, you can make the code to be contravariant.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface Contravariant { -writeOnly: number; }\nvar numberOrString = Math.random() > 0.5 ? 42 : 'forty-two';\nvar value2: Contravariant = { writeOnly: numberOrString }; // Works!\n\n`}</code></pre>\n    <p>{`Again, this is a small syntax difference. At the end, isn't just simpler to just mark the type to \"string | number\" in both case?`}</p>\n    <h2>{`Generic Class`}</h2>\n    <p>{`Exact same syntax.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class Item<T> {\n prop: T;\n constructor(param: T) {\n this.prop = param;\n }\n}\nlet item1: Item<number> = new Item(42);\n\n`}</code></pre>\n    <h2>{`Generic Interface`}</h2>\n    <p>{`As we saw earlier, TypeScript allows to declare a type and not instantiated completely or completely. Flow must declare and instantiate.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface MyInterface<A, B, C> {\n foo: A,\n bar: B,\n baz: C,\n}\n`}</code></pre>\n    <p>{`// Flow and TypeScript:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var x: MyInterface<string, number, boolean> = {foo:\"1\", bar:4, baz:true};\n\n`}</code></pre>\n    <p>{`// Only TypeScript:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var x: MyInterface<string, number, boolean>; // Notice that we only declare.\nx.foo = \"123\";\n\n`}</code></pre>\n    <h2>{`Generic Type`}</h2>\n    <p>{`Both allows to have generic type in the same syntax.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type Item<T> = {\n prop: T,\n};\n`}</code></pre>\n    <h2>{`Generic Function`}</h2>\n    <p>{`Generic function share the same syntax between Flow and TypeScript.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function funct1<T>(p1: T, p2 = \"Smith\") { }\n\n`}</code></pre>\n    <h2>{`Default parameter value`}</h2>\n    <p>{`Default parameter use the equal sign followed by the value in both cases.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function funct1(p1: string, p2 = \"Smith\") { }\n`}</code></pre>\n    <h2>{`Generic Type with default type and value`}</h2>\n    <p>{`TypeScript uses the keyword extends to have a generic type from a particular type. Default value is the same.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`Type Item<T extends number = 1> = {\n prop: T,\n};\n`}</code></pre>\n    <p>{`Flow uses the semicolon to enforce the generic type and equal sign for default.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type Item<T: number = 1> = {\n prop: T,\n};\n`}</code></pre>\n    <h2>{`Cast`}</h2>\n    <p>{`Cast is different. Require having parentheses and a semi colon in Flow. TypeScript uses \"as\" like in C#. Flow is a little bit more verbose and can become harder to see in a situation within the inner function with many parentheses and curly braces.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`var x: number = otherVariable as number;\nvar x: number = (othervariable: number);\n\n`}</code></pre>\n    <p>{`While I was investigating Flow, I was getting more and more surprised by the similitude with TypeScript. In this third article, we can see that the syntax is so common with TypeScript that it’s hard to be very polarized about which one is really the best. There are few fundamental differences that we saw in terms of concept, but even there it’s not very deeply different. Indeed, Flow is checking more scenarios, and TypeScript is letting some scenarios be more “JavaScript-ish”, but still, in other scenarios allows a strong rigidity and better encapsulation.`}</p>\n    <p>{`Every team is different. Every person has a different past. Flow and TypeScript should cover the need of having your code more strongly typed, less prone to error, and easier to understand by everyone who reads it. The choice of Flow or TypeScript is a matter of little details. At the end of my investigation, I was all open to going with Flow for our new project at Netflix. However, the last meeting tipped the decision to go with TypeScript. In our case, the number of supported third-party libraries was something that changed our mind.`}</p>\n    <p><strong parentName=\"p\">{`Parts of the serie:`}</strong></p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"typescript-vs-flow-part-1-of-3-who-they-are\"\n        }}>{`TypeScript vs Flow (Part 1 of 3) – Who are they?`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"./typescript-vs-flow-part-2-of-3-high-level-coding\"\n        }}>{`TypeScript vs Flow (Part 2 of 3) – High Level Coding`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"./typescript-vs-flow-part-3-of-3-syntax-difference\"\n        }}>{`TypeScript vs Flow (Part 3 of 3) – Syntax Difference`}</a></li>\n    </ul>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}