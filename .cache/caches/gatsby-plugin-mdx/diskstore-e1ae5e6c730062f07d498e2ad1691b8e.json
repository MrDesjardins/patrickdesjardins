{"expireTime":9007200886478387000,"key":"gatsby-plugin-mdx-entire-payload-b8bd927e3fec4d237767de57dcb5149e--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"You may have a private constructor for your class. This is often useful if you want the developer to use a constructor but still have your ORM to be able to create your entity. The problem is when serializing and deserializing will use the public constructor and will pass null on every parameters. To have the deserializer user the private constructor, like the ORM, you need to tell Json.Net that it can use private constructor.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":431,"offset":431},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":431,"offset":431},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" new JsonSerializerSettings { ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor } ","position":{"start":{"line":5,"column":1,"offset":434},"end":{"line":7,"column":4,"offset":555},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":9,"column":1,"offset":557},"end":{"line":9,"column":5,"offset":561},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"JsonSerializerSettings","position":{"start":{"line":9,"column":7,"offset":563},"end":{"line":9,"column":29,"offset":585},"indent":[]}}],"position":{"start":{"line":9,"column":5,"offset":561},"end":{"line":9,"column":31,"offset":587},"indent":[]}},{"type":"text","value":" required is the ","position":{"start":{"line":9,"column":31,"offset":587},"end":{"line":9,"column":48,"offset":604},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"ConstructorHandling","position":{"start":{"line":9,"column":50,"offset":606},"end":{"line":9,"column":69,"offset":625},"indent":[]}}],"position":{"start":{"line":9,"column":48,"offset":604},"end":{"line":9,"column":71,"offset":627},"indent":[]}},{"type":"text","value":" which need to be set to ","position":{"start":{"line":9,"column":71,"offset":627},"end":{"line":9,"column":96,"offset":652},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"AllowNonPublicDefaultConstructor","position":{"start":{"line":9,"column":98,"offset":654},"end":{"line":9,"column":130,"offset":686},"indent":[]}}],"position":{"start":{"line":9,"column":96,"offset":652},"end":{"line":9,"column":132,"offset":688},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":9,"column":132,"offset":688},"end":{"line":9,"column":133,"offset":689},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":557},"end":{"line":9,"column":133,"offset":689},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Also, you may have public getter but private setter. Often the case when the property value must be set with private logic. However, when serializing and deserializing, these values will not be set. To allow Json.Net to use the private setter, you must set a new contract resolver.","position":{"start":{"line":11,"column":1,"offset":691},"end":{"line":11,"column":282,"offset":972},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":691},"end":{"line":11,"column":282,"offset":972},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Json.Net can have custom contract resolver. The trick is to tell to Json.Net that if the property has a private setter to use it.","position":{"start":{"line":13,"column":1,"offset":974},"end":{"line":13,"column":130,"offset":1103},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":974},"end":{"line":13,"column":130,"offset":1103},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" new JsonSerializerSettings { ContractResolver = new PrivateResolver() } //......... public class PrivateResolver : DefaultContractResolver { protected override JsonProperty CreateProperty(MemberInfo member , MemberSerialization memberSerialization) { var prop = base.CreateProperty(member, memberSerialization);\n\nif (!prop.Writable) { var property = member as PropertyInfo; if (property != null) { var hasPrivateSetter = property.GetSetMethod(true) != null; prop.Writable = hasPrivateSetter; } }\n\nreturn prop; } } \n``` This is it. ![](images/DefaultContract-400x222.png)\n\n\nexport const _frontmatter = {\"title\":\"How to Have Json.Net Deserialize Using Private Constructor and Private Setter\",\"date\":\"2015-10-07\",\"categories\":[\"c-sharp\"]}","position":{"start":{"line":16,"column":1,"offset":1106},"end":{"line":25,"column":163,"offset":1852},"indent":[1,1,1,1,1,1,1,1,1]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":25,"column":163,"offset":1852}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"You may have a private constructor for your class. This is often useful if you want the developer to use a constructor but still have your ORM to be able to create your entity. The problem is when serializing and deserializing will use the public constructor and will pass null on every parameters. To have the deserializer user the private constructor, like the ORM, you need to tell Json.Net that it can use private constructor.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" new JsonSerializerSettings { ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor } \\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"JsonSerializerSettings\"), \" required is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ConstructorHandling\"), \" which need to be set to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AllowNonPublicDefaultConstructor\"), \".\"), mdx(\"p\", null, \"Also, you may have public getter but private setter. Often the case when the property value must be set with private logic. However, when serializing and deserializing, these values will not be set. To allow Json.Net to use the private setter, you must set a new contract resolver.\"), mdx(\"p\", null, \"Json.Net can have custom contract resolver. The trick is to tell to Json.Net that if the property has a private setter to use it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" new JsonSerializerSettings { ContractResolver = new PrivateResolver() } //......... public class PrivateResolver : DefaultContractResolver { protected override JsonProperty CreateProperty(MemberInfo member , MemberSerialization memberSerialization) { var prop = base.CreateProperty(member, memberSerialization);\\n\\nif (!prop.Writable) { var property = member as PropertyInfo; if (property != null) { var hasPrivateSetter = property.GetSetMethod(true) != null; prop.Writable = hasPrivateSetter; } }\\n\\nreturn prop; } } \\n``` This is it. ![](images/DefaultContract-400x222.png)\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"How to Have Json.Net Deserialize Using Private Constructor and Private Setter\\\",\\\"date\\\":\\\"2015-10-07\\\",\\\"categories\\\":[\\\"c-sharp\\\"]}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`You may have a private constructor for your class. This is often useful if you want the developer to use a constructor but still have your ORM to be able to create your entity. The problem is when serializing and deserializing will use the public constructor and will pass null on every parameters. To have the deserializer user the private constructor, like the ORM, you need to tell Json.Net that it can use private constructor.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` new JsonSerializerSettings { ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor } \n`}</code></pre>\n    <p>{`The `}<strong parentName=\"p\">{`JsonSerializerSettings`}</strong>{` required is the `}<strong parentName=\"p\">{`ConstructorHandling`}</strong>{` which need to be set to `}<strong parentName=\"p\">{`AllowNonPublicDefaultConstructor`}</strong>{`.`}</p>\n    <p>{`Also, you may have public getter but private setter. Often the case when the property value must be set with private logic. However, when serializing and deserializing, these values will not be set. To allow Json.Net to use the private setter, you must set a new contract resolver.`}</p>\n    <p>{`Json.Net can have custom contract resolver. The trick is to tell to Json.Net that if the property has a private setter to use it.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` new JsonSerializerSettings { ContractResolver = new PrivateResolver() } //......... public class PrivateResolver : DefaultContractResolver { protected override JsonProperty CreateProperty(MemberInfo member , MemberSerialization memberSerialization) { var prop = base.CreateProperty(member, memberSerialization);\n\nif (!prop.Writable) { var property = member as PropertyInfo; if (property != null) { var hasPrivateSetter = property.GetSetMethod(true) != null; prop.Writable = hasPrivateSetter; } }\n\nreturn prop; } } \n\\`\\`\\` This is it. ![](images/DefaultContract-400x222.png)\n\n\nexport const _frontmatter = {\"title\":\"How to Have Json.Net Deserialize Using Private Constructor and Private Setter\",\"date\":\"2015-10-07\",\"categories\":[\"c-sharp\"]}\n`}</code></pre>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}