{"expireTime":9007200886478397000,"key":"gatsby-plugin-mdx-entire-payload-6e3aa823c0571861eebcad6041c6b4db--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Depending of what you want to do, you may want to group by id or by more values. A common case is to group by a unique idenfier but also want to get some connexe information like let say having the name. For example, if we want to group every jobs that every body had in their life, we would like to group by userid. But we may want to have their full name.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":358,"offset":358},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":358,"offset":358},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" var groupedList = nonGroupedList.GroupBy(g=> new MyCustomGroupingClass(g.UserId, g.UserFullName)); ","position":{"start":{"line":5,"column":1,"offset":361},"end":{"line":7,"column":4,"offset":475},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This won't work because every MyCustomGroupingClass will be different from C# perspective. This is because Linq will compare every object and figure out that every MyCustomGroupingClass has a different object.","position":{"start":{"line":9,"column":1,"offset":477},"end":{"line":9,"column":210,"offset":686},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":477},"end":{"line":9,"column":210,"offset":686},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" var groupedList = nonGroupedList.GroupBy(g=> g.UserId); ","position":{"start":{"line":12,"column":1,"offset":689},"end":{"line":14,"column":4,"offset":760},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This would work, because an integer is comparable but it doesn't solve the need to have the user name.","position":{"start":{"line":16,"column":1,"offset":762},"end":{"line":16,"column":103,"offset":864},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":762},"end":{"line":16,"column":103,"offset":864},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The solution is hidden in the problem : comparing classes. We need to provide a way to compare. This can be done by providing an override to the Equals method of your grouping class.","position":{"start":{"line":18,"column":1,"offset":866},"end":{"line":18,"column":183,"offset":1048},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":866},"end":{"line":18,"column":183,"offset":1048},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public class MyCustomGroupingClass { public int ID { get; set; } public string FullName { get; set; }\n\npublic override bool Equals(object obj) { if (ReferenceEquals(null, obj)) return false; if (ReferenceEquals(this, obj)) return true; if (obj.GetType() != this.GetType()) return false; return Equals((MyCustomGroupingClass)obj); } protected bool Equals(MyCustomGroupingClass other) { return ID.Equals(other.ID) && string.Equals(FullName, other.FullName); } } ","position":{"start":{"line":21,"column":1,"offset":1051},"end":{"line":25,"column":4,"offset":1526},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"From here, you will be able to group without problem with Linq and your custom grouping class.","position":{"start":{"line":27,"column":1,"offset":1528},"end":{"line":27,"column":95,"offset":1622},"indent":[]}}],"position":{"start":{"line":27,"column":1,"offset":1528},"end":{"line":27,"column":95,"offset":1622},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Linq and grouping with custom object\",\"date\":\"2012-12-03\",\"categories\":[\"c-sharp\",\"linq\"]}","position":{"start":{"line":30,"column":1,"offset":1625},"end":{"line":30,"column":129,"offset":1753},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":30,"column":129,"offset":1753}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Linq and grouping with custom object\",\n  \"date\": \"2012-12-03\",\n  \"categories\": [\"c-sharp\", \"linq\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Depending of what you want to do, you may want to group by id or by more values. A common case is to group by a unique idenfier but also want to get some connexe information like let say having the name. For example, if we want to group every jobs that every body had in their life, we would like to group by userid. But we may want to have their full name.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var groupedList = nonGroupedList.GroupBy(g=> new MyCustomGroupingClass(g.UserId, g.UserFullName)); \\n\")), mdx(\"p\", null, \"This won't work because every MyCustomGroupingClass will be different from C# perspective. This is because Linq will compare every object and figure out that every MyCustomGroupingClass has a different object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" var groupedList = nonGroupedList.GroupBy(g=> g.UserId); \\n\")), mdx(\"p\", null, \"This would work, because an integer is comparable but it doesn't solve the need to have the user name.\"), mdx(\"p\", null, \"The solution is hidden in the problem : comparing classes. We need to provide a way to compare. This can be done by providing an override to the Equals method of your grouping class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public class MyCustomGroupingClass { public int ID { get; set; } public string FullName { get; set; }\\n\\npublic override bool Equals(object obj) { if (ReferenceEquals(null, obj)) return false; if (ReferenceEquals(this, obj)) return true; if (obj.GetType() != this.GetType()) return false; return Equals((MyCustomGroupingClass)obj); } protected bool Equals(MyCustomGroupingClass other) { return ID.Equals(other.ID) && string.Equals(FullName, other.FullName); } } \\n\")), mdx(\"p\", null, \"From here, you will be able to group without problem with Linq and your custom grouping class.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Linq and grouping with custom object\",\n  \"date\": \"2012-12-03\",\n  \"categories\": [\"c-sharp\", \"linq\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Depending of what you want to do, you may want to group by id or by more values. A common case is to group by a unique idenfier but also want to get some connexe information like let say having the name. For example, if we want to group every jobs that every body had in their life, we would like to group by userid. But we may want to have their full name.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` var groupedList = nonGroupedList.GroupBy(g=> new MyCustomGroupingClass(g.UserId, g.UserFullName)); \n`}</code></pre>\n    <p>{`This won't work because every MyCustomGroupingClass will be different from C# perspective. This is because Linq will compare every object and figure out that every MyCustomGroupingClass has a different object.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` var groupedList = nonGroupedList.GroupBy(g=> g.UserId); \n`}</code></pre>\n    <p>{`This would work, because an integer is comparable but it doesn't solve the need to have the user name.`}</p>\n    <p>{`The solution is hidden in the problem : comparing classes. We need to provide a way to compare. This can be done by providing an override to the Equals method of your grouping class.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public class MyCustomGroupingClass { public int ID { get; set; } public string FullName { get; set; }\n\npublic override bool Equals(object obj) { if (ReferenceEquals(null, obj)) return false; if (ReferenceEquals(this, obj)) return true; if (obj.GetType() != this.GetType()) return false; return Equals((MyCustomGroupingClass)obj); } protected bool Equals(MyCustomGroupingClass other) { return ID.Equals(other.ID) && string.Equals(FullName, other.FullName); } } \n`}</code></pre>\n    <p>{`From here, you will be able to group without problem with Linq and your custom grouping class.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}