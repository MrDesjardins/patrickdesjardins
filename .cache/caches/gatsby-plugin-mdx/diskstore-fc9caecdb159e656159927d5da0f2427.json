{"expireTime":9007200886478392000,"key":"gatsby-plugin-mdx-entire-payload-2ac68d9e306537e910cc45d80f149c89--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Let say you have an entity that can but doesn't mean will have a relation to another entity. This is a 0..1 to 1 or 0..1 to many.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":130,"offset":130},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":130,"offset":130},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In this example, we show a scenario where we have one entity that has a relation to a second entity. The second entity doesn't have any reference to the first one.","position":{"start":{"line":4,"column":1,"offset":132},"end":{"line":4,"column":164,"offset":295},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":132},"end":{"line":4,"column":164,"offset":295},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"At first, we may think than this code below works.","position":{"start":{"line":6,"column":1,"offset":297},"end":{"line":6,"column":51,"offset":347},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":297},"end":{"line":6,"column":51,"offset":347},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" modelBuilder .Entity<EntityOne>() .HasOptional(d => d.EntityTwo) .WithOptionalDependent(); ","position":{"start":{"line":9,"column":1,"offset":350},"end":{"line":11,"column":4,"offset":456},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":13,"column":1,"offset":458},"end":{"line":13,"column":5,"offset":462},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"WithOptionalDependent","position":{"start":{"line":13,"column":7,"offset":464},"end":{"line":13,"column":28,"offset":485},"indent":[]}}],"position":{"start":{"line":13,"column":5,"offset":462},"end":{"line":13,"column":30,"offset":487},"indent":[]}},{"type":"text","value":" tells EF (Entity Framework) that EntityOne is the one of the two entities that hold the reference which is optional as stated with the ","position":{"start":{"line":13,"column":30,"offset":487},"end":{"line":13,"column":166,"offset":623},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"HasOptional","position":{"start":{"line":13,"column":168,"offset":625},"end":{"line":13,"column":179,"offset":636},"indent":[]}}],"position":{"start":{"line":13,"column":166,"offset":623},"end":{"line":13,"column":181,"offset":638},"indent":[]}},{"type":"text","value":" property. No! This raise an error that tell that it cannot find EntityTwo_ID key. This is problematic because in the scenario we are talking about the foreign key has a special name. So, we have to configure the foreign key. Of course, if your FK is named EntityTwo_ID than you are all fine.","position":{"start":{"line":13,"column":181,"offset":638},"end":{"line":13,"column":473,"offset":930},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":458},"end":{"line":13,"column":473,"offset":930},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" modelBuilder .Entity<EntityOne>() .HasOptional(d => d.EntityTwo) .WithOptionalDependent() .Map(d => d.MapKey(\"EntityTwoID\"); ","position":{"start":{"line":16,"column":1,"offset":933},"end":{"line":18,"column":4,"offset":1073},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":20,"column":1,"offset":1075},"end":{"line":20,"column":5,"offset":1079},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"HasForeignKey","position":{"start":{"line":20,"column":7,"offset":1081},"end":{"line":20,"column":20,"offset":1094},"indent":[]}}],"position":{"start":{"line":20,"column":5,"offset":1079},"end":{"line":20,"column":22,"offset":1096},"indent":[]}},{"type":"text","value":" is not available from ","position":{"start":{"line":20,"column":22,"offset":1096},"end":{"line":20,"column":45,"offset":1119},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"WithOptionalDependant","position":{"start":{"line":20,"column":47,"offset":1121},"end":{"line":20,"column":68,"offset":1142},"indent":[]}}],"position":{"start":{"line":20,"column":45,"offset":1119},"end":{"line":20,"column":70,"offset":1144},"indent":[]}},{"type":"text","value":", but with Map we can setup the foreign key name. Unfortunately, this won't work either. The error is an invalid column name. From here, we can realise that the ","position":{"start":{"line":20,"column":70,"offset":1144},"end":{"line":20,"column":231,"offset":1305},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"MapKey","position":{"start":{"line":20,"column":233,"offset":1307},"end":{"line":20,"column":239,"offset":1313},"indent":[]}}],"position":{"start":{"line":20,"column":231,"offset":1305},"end":{"line":20,"column":241,"offset":1315},"indent":[]}},{"type":"text","value":" is used by the principal entity and not the dependent.","position":{"start":{"line":20,"column":241,"offset":1315},"end":{"line":20,"column":296,"offset":1370},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":1075},"end":{"line":20,"column":296,"offset":1370},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Still, we want to have 0..1 relation. How can we setup this optional relation ship with Entity Framework without having on the other side the property to the other entity? We need to use HasOption and threat the whole situation not as 0..1 to 1 but 0..1 to many. ","position":{"start":{"line":22,"column":1,"offset":1372},"end":{"line":22,"column":264,"offset":1635},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":1372},"end":{"line":22,"column":264,"offset":1635},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" modelBuilder .Entity<EntityOne>() .HasOptional(d => d.EntityTwo) .WithMany() .HasForeignKey(d => d.EntityTwoID) ; ","position":{"start":{"line":23,"column":1,"offset":1636},"end":{"line":25,"column":4,"offset":1765},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"To make it works, we use ","position":{"start":{"line":27,"column":1,"offset":1767},"end":{"line":27,"column":26,"offset":1792},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"WithMany","position":{"start":{"line":27,"column":28,"offset":1794},"end":{"line":27,"column":36,"offset":1802},"indent":[]}}],"position":{"start":{"line":27,"column":26,"offset":1792},"end":{"line":27,"column":38,"offset":1804},"indent":[]}},{"type":"text","value":" without specifying the other side property (since we do not have it) and we use ","position":{"start":{"line":27,"column":38,"offset":1804},"end":{"line":27,"column":119,"offset":1885},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"HasForeignKey","position":{"start":{"line":27,"column":121,"offset":1887},"end":{"line":27,"column":134,"offset":1900},"indent":[]}}],"position":{"start":{"line":27,"column":119,"offset":1885},"end":{"line":27,"column":136,"offset":1902},"indent":[]}},{"type":"text","value":" to specify the correct foreign key. And that's it! It works!","position":{"start":{"line":27,"column":136,"offset":1902},"end":{"line":27,"column":197,"offset":1963},"indent":[]}}],"position":{"start":{"line":27,"column":1,"offset":1767},"end":{"line":27,"column":197,"offset":1963},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"How to setup Entity Framework Code first to have only one side 0 to 1 relationship\",\"date\":\"2013-10-29\",\"categories\":[\"entity-framework\"]}","position":{"start":{"line":30,"column":1,"offset":1966},"end":{"line":30,"column":177,"offset":2142},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":30,"column":177,"offset":2142}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to setup Entity Framework Code first to have only one side 0 to 1 relationship\",\n  \"date\": \"2013-10-29\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Let say you have an entity that can but doesn't mean will have a relation to another entity. This is a 0..1 to 1 or 0..1 to many.\"), mdx(\"p\", null, \"In this example, we show a scenario where we have one entity that has a relation to a second entity. The second entity doesn't have any reference to the first one.\"), mdx(\"p\", null, \"At first, we may think than this code below works.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" modelBuilder .Entity<EntityOne>() .HasOptional(d => d.EntityTwo) .WithOptionalDependent(); \\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"WithOptionalDependent\"), \" tells EF (Entity Framework) that EntityOne is the one of the two entities that hold the reference which is optional as stated with the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"HasOptional\"), \" property. No! This raise an error that tell that it cannot find EntityTwo_ID key. This is problematic because in the scenario we are talking about the foreign key has a special name. So, we have to configure the foreign key. Of course, if your FK is named EntityTwo_ID than you are all fine.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" modelBuilder .Entity<EntityOne>() .HasOptional(d => d.EntityTwo) .WithOptionalDependent() .Map(d => d.MapKey(\\\"EntityTwoID\\\"); \\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"HasForeignKey\"), \" is not available from \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"WithOptionalDependant\"), \", but with Map we can setup the foreign key name. Unfortunately, this won't work either. The error is an invalid column name. From here, we can realise that the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"MapKey\"), \" is used by the principal entity and not the dependent.\"), mdx(\"p\", null, \"Still, we want to have 0..1 relation. How can we setup this optional relation ship with Entity Framework without having on the other side the property to the other entity? We need to use HasOption and threat the whole situation not as 0..1 to 1 but 0..1 to many. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" modelBuilder .Entity<EntityOne>() .HasOptional(d => d.EntityTwo) .WithMany() .HasForeignKey(d => d.EntityTwoID) ; \\n\")), mdx(\"p\", null, \"To make it works, we use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"WithMany\"), \" without specifying the other side property (since we do not have it) and we use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"HasForeignKey\"), \" to specify the correct foreign key. And that's it! It works!\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"How to setup Entity Framework Code first to have only one side 0 to 1 relationship\",\n  \"date\": \"2013-10-29\",\n  \"categories\": [\"entity-framework\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Let say you have an entity that can but doesn't mean will have a relation to another entity. This is a 0..1 to 1 or 0..1 to many.`}</p>\n    <p>{`In this example, we show a scenario where we have one entity that has a relation to a second entity. The second entity doesn't have any reference to the first one.`}</p>\n    <p>{`At first, we may think than this code below works.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` modelBuilder .Entity<EntityOne>() .HasOptional(d => d.EntityTwo) .WithOptionalDependent(); \n`}</code></pre>\n    <p>{`The `}<strong parentName=\"p\">{`WithOptionalDependent`}</strong>{` tells EF (Entity Framework) that EntityOne is the one of the two entities that hold the reference which is optional as stated with the `}<strong parentName=\"p\">{`HasOptional`}</strong>{` property. No! This raise an error that tell that it cannot find EntityTwo_ID key. This is problematic because in the scenario we are talking about the foreign key has a special name. So, we have to configure the foreign key. Of course, if your FK is named EntityTwo_ID than you are all fine.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` modelBuilder .Entity<EntityOne>() .HasOptional(d => d.EntityTwo) .WithOptionalDependent() .Map(d => d.MapKey(\"EntityTwoID\"); \n`}</code></pre>\n    <p>{`The `}<strong parentName=\"p\">{`HasForeignKey`}</strong>{` is not available from `}<strong parentName=\"p\">{`WithOptionalDependant`}</strong>{`, but with Map we can setup the foreign key name. Unfortunately, this won't work either. The error is an invalid column name. From here, we can realise that the `}<strong parentName=\"p\">{`MapKey`}</strong>{` is used by the principal entity and not the dependent.`}</p>\n    <p>{`Still, we want to have 0..1 relation. How can we setup this optional relation ship with Entity Framework without having on the other side the property to the other entity? We need to use HasOption and threat the whole situation not as 0..1 to 1 but 0..1 to many. `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` modelBuilder .Entity<EntityOne>() .HasOptional(d => d.EntityTwo) .WithMany() .HasForeignKey(d => d.EntityTwoID) ; \n`}</code></pre>\n    <p>{`To make it works, we use `}<strong parentName=\"p\">{`WithMany`}</strong>{` without specifying the other side property (since we do not have it) and we use `}<strong parentName=\"p\">{`HasForeignKey`}</strong>{` to specify the correct foreign key. And that's it! It works!`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}