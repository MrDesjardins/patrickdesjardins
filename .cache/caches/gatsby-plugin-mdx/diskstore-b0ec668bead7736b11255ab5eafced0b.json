{"expireTime":9007200886478384000,"key":"gatsby-plugin-mdx-entire-payload-13cb59862b73397a300a20303420ccf0--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Application Insights is awesome. It allows to query your system for events that you define. For example, when your user login you could create a new event to send data to Application Insights and then query it to know how many of your user did a valid login and how many failed.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":279,"offset":279},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":279,"offset":279},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In C#, you can have something that record if the login was successful and if not giving a reason why. This could be \"wrong login\" or \"account not validated\" or \"too many tentative\" etc. However, when the login is successful we do not need reason. ","position":{"start":{"line":4,"column":1,"offset":281},"end":{"line":4,"column":248,"offset":528},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":281},"end":{"line":4,"column":248,"offset":528},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public void SendLogin(bool isValidLogin, string reason = \"\") { var properties = new Dictionary<string, string> { {\"IsValidLogin\" , isValidLogin.ToString()} ,{\"LoginDetail\" , reason} }; this.telemetry.TrackEvent(\"LoginRequestSuccess\", properties); } ","position":{"start":{"line":5,"column":1,"offset":529},"end":{"line":7,"column":4,"offset":793},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The end result desired is a graph that gives the number of successful login, and the number of failed tentative by reason. The challenge is that the ","position":{"start":{"line":9,"column":1,"offset":795},"end":{"line":9,"column":150,"offset":944},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"customDimension","position":{"start":{"line":9,"column":151,"offset":945},"end":{"line":9,"column":166,"offset":960},"indent":[]}}],"position":{"start":{"line":9,"column":150,"offset":944},"end":{"line":9,"column":167,"offset":961},"indent":[]}},{"type":"text","value":" property of a success will not have any reason. A solution is to check if the custom dimension is defined, which mean null, and assign a temporary string for detail. By assigning a string, we can group by this detailed reason and then by time to spread the result on a time x-axis.","position":{"start":{"line":9,"column":167,"offset":961},"end":{"line":9,"column":449,"offset":1243},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":795},"end":{"line":9,"column":449,"offset":1243},"indent":[]}},{"type":"code","lang":null,"meta":null,"value":"customEvents | where name == \"LoginRequestSuccess\" | where timestamp >= ago(14d) | extend d=parsejson(customDimensions) | extend isValidLogin = d.IsValidLogin | extend detail = iff(isnull(d.LoginDetail), \"Okay\", tostring(d.LoginDetail)) | project detail, timestamp | summarize count(detail) by detail, bin(timestamp, 1d) | order by timestamp asc ","position":{"start":{"line":11,"column":1,"offset":1245},"end":{"line":13,"column":5,"offset":1600},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The important line if the one that extend detail. This on-the-fly column is getting the login detail which is provided when the login fail. Since it's not provided when success, we do a check with ","position":{"start":{"line":15,"column":1,"offset":1602},"end":{"line":15,"column":198,"offset":1799},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"isnull","position":{"start":{"line":15,"column":200,"offset":1801},"end":{"line":15,"column":206,"offset":1807},"indent":[]}}],"position":{"start":{"line":15,"column":198,"offset":1799},"end":{"line":15,"column":208,"offset":1809},"indent":[]}},{"type":"text","value":". If it is null, we set a temporary string, otherwise, we cast the provided login detail. The cast is required because the custom dimension is a dynamic type, not a string. The ","position":{"start":{"line":15,"column":208,"offset":1809},"end":{"line":15,"column":385,"offset":1986},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"iff","position":{"start":{"line":15,"column":387,"offset":1988},"end":{"line":15,"column":390,"offset":1991},"indent":[]}}],"position":{"start":{"line":15,"column":385,"offset":1986},"end":{"line":15,"column":392,"offset":1993},"indent":[]}},{"type":"text","value":" must return the same type for each condition. The first one is a hard-coded string, thus, the second must be a string.","position":{"start":{"line":15,"column":392,"offset":1993},"end":{"line":15,"column":511,"offset":2112},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":1602},"end":{"line":15,"column":511,"offset":2112},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Application Insights How to Handle undefined Custom Dimension property\",\"date\":\"2016-11-08\",\"categories\":[\"azure\"]}","position":{"start":{"line":18,"column":1,"offset":2115},"end":{"line":18,"column":154,"offset":2268},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":18,"column":154,"offset":2268}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Application Insights How to Handle undefined Custom Dimension property\",\n  \"date\": \"2016-11-08\",\n  \"categories\": [\"azure\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Application Insights is awesome. It allows to query your system for events that you define. For example, when your user login you could create a new event to send data to Application Insights and then query it to know how many of your user did a valid login and how many failed.\"), mdx(\"p\", null, \"In C#, you can have something that record if the login was successful and if not giving a reason why. This could be \\\"wrong login\\\" or \\\"account not validated\\\" or \\\"too many tentative\\\" etc. However, when the login is successful we do not need reason. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public void SendLogin(bool isValidLogin, string reason = \\\"\\\") { var properties = new Dictionary<string, string> { {\\\"IsValidLogin\\\" , isValidLogin.ToString()} ,{\\\"LoginDetail\\\" , reason} }; this.telemetry.TrackEvent(\\\"LoginRequestSuccess\\\", properties); } \\n\")), mdx(\"p\", null, \"The end result desired is a graph that gives the number of successful login, and the number of failed tentative by reason. The challenge is that the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"customDimension\"), \" property of a success will not have any reason. A solution is to check if the custom dimension is defined, which mean null, and assign a temporary string for detail. By assigning a string, we can group by this detailed reason and then by time to spread the result on a time x-axis.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"customEvents | where name == \\\"LoginRequestSuccess\\\" | where timestamp >= ago(14d) | extend d=parsejson(customDimensions) | extend isValidLogin = d.IsValidLogin | extend detail = iff(isnull(d.LoginDetail), \\\"Okay\\\", tostring(d.LoginDetail)) | project detail, timestamp | summarize count(detail) by detail, bin(timestamp, 1d) | order by timestamp asc \\n\")), mdx(\"p\", null, \"The important line if the one that extend detail. This on-the-fly column is getting the login detail which is provided when the login fail. Since it's not provided when success, we do a check with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"isnull\"), \". If it is null, we set a temporary string, otherwise, we cast the provided login detail. The cast is required because the custom dimension is a dynamic type, not a string. The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"iff\"), \" must return the same type for each condition. The first one is a hard-coded string, thus, the second must be a string.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Application Insights How to Handle undefined Custom Dimension property\",\n  \"date\": \"2016-11-08\",\n  \"categories\": [\"azure\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Application Insights is awesome. It allows to query your system for events that you define. For example, when your user login you could create a new event to send data to Application Insights and then query it to know how many of your user did a valid login and how many failed.`}</p>\n    <p>{`In C#, you can have something that record if the login was successful and if not giving a reason why. This could be \"wrong login\" or \"account not validated\" or \"too many tentative\" etc. However, when the login is successful we do not need reason. `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public void SendLogin(bool isValidLogin, string reason = \"\") { var properties = new Dictionary<string, string> { {\"IsValidLogin\" , isValidLogin.ToString()} ,{\"LoginDetail\" , reason} }; this.telemetry.TrackEvent(\"LoginRequestSuccess\", properties); } \n`}</code></pre>\n    <p>{`The end result desired is a graph that gives the number of successful login, and the number of failed tentative by reason. The challenge is that the `}<em parentName=\"p\">{`customDimension`}</em>{` property of a success will not have any reason. A solution is to check if the custom dimension is defined, which mean null, and assign a temporary string for detail. By assigning a string, we can group by this detailed reason and then by time to spread the result on a time x-axis.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`customEvents | where name == \"LoginRequestSuccess\" | where timestamp >= ago(14d) | extend d=parsejson(customDimensions) | extend isValidLogin = d.IsValidLogin | extend detail = iff(isnull(d.LoginDetail), \"Okay\", tostring(d.LoginDetail)) | project detail, timestamp | summarize count(detail) by detail, bin(timestamp, 1d) | order by timestamp asc \n`}</code></pre>\n    <p>{`The important line if the one that extend detail. This on-the-fly column is getting the login detail which is provided when the login fail. Since it's not provided when success, we do a check with `}<strong parentName=\"p\">{`isnull`}</strong>{`. If it is null, we set a temporary string, otherwise, we cast the provided login detail. The cast is required because the custom dimension is a dynamic type, not a string. The `}<strong parentName=\"p\">{`iff`}</strong>{` must return the same type for each condition. The first one is a hard-coded string, thus, the second must be a string.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}