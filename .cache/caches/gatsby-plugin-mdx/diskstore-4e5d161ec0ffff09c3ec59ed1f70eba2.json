{"expireTime":9007200886478383000,"key":"gatsby-plugin-mdx-entire-payload-b04af9d9a3554ae786cb4330a5e33a69--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"If you are using a dictionary or map in TypeScript you may want to know how many elements are mapped. This can be done with Object.Entries(myMappedObject).length. However, the default Typescript configuration won't let use this latest function because it's only available in EcmaScript 2017. To get access to it, you need to change the tsconfig.json. Tsconfig.json has a portion called \"lib\" which increments TypeScript with libraries. To have access to Object.Entries, you need to add \"es2017.object\".","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":503,"offset":503},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":503,"offset":503},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":" \"lib\": [ \"es6\", \"dom\", \"es2017.object\" ]","position":{"start":{"line":4,"column":1,"offset":505},"end":{"line":6,"column":4,"offset":564},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"If you are curious about the TypeScript generic way to have a dictionary, you can use this interface:","position":{"start":{"line":8,"column":1,"offset":566},"end":{"line":8,"column":102,"offset":667},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":566},"end":{"line":8,"column":102,"offset":667},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"export interface MyMap<T> {\n  [id: string]: T;\n}","position":{"start":{"line":10,"column":1,"offset":669},"end":{"line":14,"column":4,"offset":735},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"From there you can do:","position":{"start":{"line":16,"column":1,"offset":737},"end":{"line":16,"column":23,"offset":759},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":737},"end":{"line":16,"column":23,"offset":759},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"const c: MyMap<MyObject> = {};\nc[\"myId1\"] = myObject1;\nc[\"myId2\"] = myObject2;\nc[\"myId3\"] = myObject3;\nconst numberOfElementInDictionary = Object.entries(c).length;","position":{"start":{"line":18,"column":1,"offset":761},"end":{"line":24,"column":4,"offset":943},"indent":[1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"TypeScript and Object.Entries\",\"date\":\"2017-11-30\",\"categories\":[\"typescript\"]}","position":{"start":{"line":27,"column":1,"offset":946},"end":{"line":27,"column":118,"offset":1063},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":27,"column":118,"offset":1063}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"TypeScript and Object.Entries\",\n  \"date\": \"2017-11-30\",\n  \"categories\": [\"typescript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you are using a dictionary or map in TypeScript you may want to know how many elements are mapped. This can be done with Object.Entries(myMappedObject).length. However, the default Typescript configuration won't let use this latest function because it's only available in EcmaScript 2017. To get access to it, you need to change the tsconfig.json. Tsconfig.json has a portion called \\\"lib\\\" which increments TypeScript with libraries. To have access to Object.Entries, you need to add \\\"es2017.object\\\".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \" \\\"lib\\\": [ \\\"es6\\\", \\\"dom\\\", \\\"es2017.object\\\" ]\\n\")), mdx(\"p\", null, \"If you are curious about the TypeScript generic way to have a dictionary, you can use this interface:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"export interface MyMap<T> {\\n  [id: string]: T;\\n}\\n\")), mdx(\"p\", null, \"From there you can do:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const c: MyMap<MyObject> = {};\\nc[\\\"myId1\\\"] = myObject1;\\nc[\\\"myId2\\\"] = myObject2;\\nc[\\\"myId3\\\"] = myObject3;\\nconst numberOfElementInDictionary = Object.entries(c).length;\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"TypeScript and Object.Entries\",\n  \"date\": \"2017-11-30\",\n  \"categories\": [\"typescript\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`If you are using a dictionary or map in TypeScript you may want to know how many elements are mapped. This can be done with Object.Entries(myMappedObject).length. However, the default Typescript configuration won't let use this latest function because it's only available in EcmaScript 2017. To get access to it, you need to change the tsconfig.json. Tsconfig.json has a portion called \"lib\" which increments TypeScript with libraries. To have access to Object.Entries, you need to add \"es2017.object\".`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{` \"lib\": [ \"es6\", \"dom\", \"es2017.object\" ]\n`}</code></pre>\n    <p>{`If you are curious about the TypeScript generic way to have a dictionary, you can use this interface:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`export interface MyMap<T> {\n  [id: string]: T;\n}\n`}</code></pre>\n    <p>{`From there you can do:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const c: MyMap<MyObject> = {};\nc[\"myId1\"] = myObject1;\nc[\"myId2\"] = myObject2;\nc[\"myId3\"] = myObject3;\nconst numberOfElementInDictionary = Object.entries(c).length;\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}