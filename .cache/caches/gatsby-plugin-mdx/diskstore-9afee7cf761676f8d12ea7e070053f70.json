{"expireTime":9007200886478382000,"key":"gatsby-plugin-mdx-entire-payload-2724518f6c623d0ff9f76f233f6bb526--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Quick sort divide the array in multiple sequence, hence is a very good candidate for recursivity. The asymptotic analysis gives a O(log(n^2)) in average and a worse time of O(n^2). The algorithm can be implemented in different flavor depending of where you start the initial pivot. Then, there is a second way to customize the quick sort and it's by defining how we partition.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":377,"offset":377},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":377,"offset":377},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function swap(array, left, right) {\n  var temp = array[left];\n  array[left] = array[right];\n  array[right] = temp;\n}\n\nfunction partition(arrayToSort, left, right) {\n  var i = left;\n  var j = right;\n  var pivot = arrayToSort[Math.floor((left + right) / 2)]; // Middle\n\n  while (i <= j) {\n    while (arrayToSort[i] < pivot) {\n      i++;\n    }\n    while (arrayToSort[j] > pivot) {\n      j--;\n    }\n    if (i <= j) {\n      swap(arrayToSort, i, j);\n      i++;\n      j--;\n    }\n  }\n\n  return i;\n}\n\nfunction quickSort(arrayToSort, left, right) {\n  var index = partition(arrayToSort, left, right);\n  if (left < index - 1) {\n    quickSort(arrayToSort, left, index - 1);\n  }\n  if (right > index) {\n    quickSort(arrayToSort, index, right);\n  }\n}","position":{"start":{"line":4,"column":1,"offset":379},"end":{"line":42,"column":4,"offset":1132},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The algorithm divide the array in two (pivot) and go to each extremity of a partition which is between left to right where left or right is determined by the pivot. Most of the heavy-lifting is done by the partition function that will swap element if this one found that a number at the right of the pivot is bigger than one of the left side of the pivot. The algorithm goes from swap until the two extremity touch and then move back to the other side of the partition. Every call to quickSort function bring a new partition which divide the array in smaller and smaller array to partition.","position":{"start":{"line":44,"column":1,"offset":1134},"end":{"line":44,"column":591,"offset":1724},"indent":[]}}],"position":{"start":{"line":44,"column":1,"offset":1134},"end":{"line":44,"column":591,"offset":1724},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The choice of the pivot will change the way the algorithm performs. The most in the middle, the best it is. This is something that we cannot know since this would require to traverse the whole array. This is why we can randomly choose a value, or in that case, taking the element in the middle.","position":{"start":{"line":46,"column":1,"offset":1726},"end":{"line":46,"column":295,"offset":2020},"indent":[]}}],"position":{"start":{"line":46,"column":1,"offset":1726},"end":{"line":46,"column":295,"offset":2020},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The partition goal is to ensure that everything before the pivot is smaller than the pivot. By going recursively, at some point everything is sorted.","position":{"start":{"line":48,"column":1,"offset":2022},"end":{"line":48,"column":150,"offset":2171},"indent":[]}}],"position":{"start":{"line":48,"column":1,"offset":2022},"end":{"line":48,"column":150,"offset":2171},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"JavaScript Quick Sort\",\"date\":\"2017-07-10\",\"categories\":[\"javascript\"]}","position":{"start":{"line":51,"column":1,"offset":2174},"end":{"line":51,"column":110,"offset":2283},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":51,"column":110,"offset":2283}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Quick Sort\",\n  \"date\": \"2017-07-10\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Quick sort divide the array in multiple sequence, hence is a very good candidate for recursivity. The asymptotic analysis gives a O(log(n^2)) in average and a worse time of O(n^2). The algorithm can be implemented in different flavor depending of where you start the initial pivot. Then, there is a second way to customize the quick sort and it's by defining how we partition.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function swap(array, left, right) {\\n  var temp = array[left];\\n  array[left] = array[right];\\n  array[right] = temp;\\n}\\n\\nfunction partition(arrayToSort, left, right) {\\n  var i = left;\\n  var j = right;\\n  var pivot = arrayToSort[Math.floor((left + right) / 2)]; // Middle\\n\\n  while (i <= j) {\\n    while (arrayToSort[i] < pivot) {\\n      i++;\\n    }\\n    while (arrayToSort[j] > pivot) {\\n      j--;\\n    }\\n    if (i <= j) {\\n      swap(arrayToSort, i, j);\\n      i++;\\n      j--;\\n    }\\n  }\\n\\n  return i;\\n}\\n\\nfunction quickSort(arrayToSort, left, right) {\\n  var index = partition(arrayToSort, left, right);\\n  if (left < index - 1) {\\n    quickSort(arrayToSort, left, index - 1);\\n  }\\n  if (right > index) {\\n    quickSort(arrayToSort, index, right);\\n  }\\n}\\n\")), mdx(\"p\", null, \"The algorithm divide the array in two (pivot) and go to each extremity of a partition which is between left to right where left or right is determined by the pivot. Most of the heavy-lifting is done by the partition function that will swap element if this one found that a number at the right of the pivot is bigger than one of the left side of the pivot. The algorithm goes from swap until the two extremity touch and then move back to the other side of the partition. Every call to quickSort function bring a new partition which divide the array in smaller and smaller array to partition.\"), mdx(\"p\", null, \"The choice of the pivot will change the way the algorithm performs. The most in the middle, the best it is. This is something that we cannot know since this would require to traverse the whole array. This is why we can randomly choose a value, or in that case, taking the element in the middle.\"), mdx(\"p\", null, \"The partition goal is to ensure that everything before the pivot is smaller than the pivot. By going recursively, at some point everything is sorted.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"JavaScript Quick Sort\",\n  \"date\": \"2017-07-10\",\n  \"categories\": [\"javascript\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Quick sort divide the array in multiple sequence, hence is a very good candidate for recursivity. The asymptotic analysis gives a O(log(n^2)) in average and a worse time of O(n^2). The algorithm can be implemented in different flavor depending of where you start the initial pivot. Then, there is a second way to customize the quick sort and it's by defining how we partition.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function swap(array, left, right) {\n  var temp = array[left];\n  array[left] = array[right];\n  array[right] = temp;\n}\n\nfunction partition(arrayToSort, left, right) {\n  var i = left;\n  var j = right;\n  var pivot = arrayToSort[Math.floor((left + right) / 2)]; // Middle\n\n  while (i <= j) {\n    while (arrayToSort[i] < pivot) {\n      i++;\n    }\n    while (arrayToSort[j] > pivot) {\n      j--;\n    }\n    if (i <= j) {\n      swap(arrayToSort, i, j);\n      i++;\n      j--;\n    }\n  }\n\n  return i;\n}\n\nfunction quickSort(arrayToSort, left, right) {\n  var index = partition(arrayToSort, left, right);\n  if (left < index - 1) {\n    quickSort(arrayToSort, left, index - 1);\n  }\n  if (right > index) {\n    quickSort(arrayToSort, index, right);\n  }\n}\n`}</code></pre>\n    <p>{`The algorithm divide the array in two (pivot) and go to each extremity of a partition which is between left to right where left or right is determined by the pivot. Most of the heavy-lifting is done by the partition function that will swap element if this one found that a number at the right of the pivot is bigger than one of the left side of the pivot. The algorithm goes from swap until the two extremity touch and then move back to the other side of the partition. Every call to quickSort function bring a new partition which divide the array in smaller and smaller array to partition.`}</p>\n    <p>{`The choice of the pivot will change the way the algorithm performs. The most in the middle, the best it is. This is something that we cannot know since this would require to traverse the whole array. This is why we can randomly choose a value, or in that case, taking the element in the middle.`}</p>\n    <p>{`The partition goal is to ensure that everything before the pivot is smaller than the pivot. By going recursively, at some point everything is sorted.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}