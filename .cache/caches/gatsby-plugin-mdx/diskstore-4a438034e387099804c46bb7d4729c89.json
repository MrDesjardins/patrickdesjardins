{"expireTime":9007200886478397000,"key":"gatsby-plugin-mdx-entire-payload-1d86c2f497ec743551991349b845e7c7--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Linq to Entity doesn't execute directly the SQL query to the database when the query is done. This is called ","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":110,"offset":110},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Deffered execution","position":{"start":{"line":2,"column":112,"offset":112},"end":{"line":2,"column":130,"offset":130},"indent":[]}}],"position":{"start":{"line":2,"column":110,"offset":110},"end":{"line":2,"column":132,"offset":132},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":2,"column":132,"offset":132},"end":{"line":2,"column":133,"offset":133},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":133,"offset":133},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The SQL will be executed when the code will loop through it with a foreach or if the code use .ToArray(), .ToList(), .ToDictionary() or .ToLookup().","position":{"start":{"line":4,"column":1,"offset":135},"end":{"line":4,"column":149,"offset":283},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":135},"end":{"line":4,"column":149,"offset":283},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Here is an example, mostly taken from MSDN showing when the data is loaded from the SQL server. ","position":{"start":{"line":6,"column":1,"offset":285},"end":{"line":6,"column":97,"offset":381},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":285},"end":{"line":6,"column":97,"offset":381},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" using (AdventureWorksEntities context = new AdventureWorksEntities()) { IQueryable<Product> productsQuery = context.Products; //productsQuery is not loaded yet IQueryable<Product> largeProducts = productsQuery.Where(p => p.Size == \"L\"); //largeProducts is not loaded yet foreach (var product in largeProducts) //Execution is here at the beginning of this code { Console.WriteLine(product.Name); } } ","position":{"start":{"line":7,"column":1,"offset":382},"end":{"line":9,"column":4,"offset":796},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This is a second example where the deferred is not taking long since we are using ToList() which call the database. ","position":{"start":{"line":11,"column":1,"offset":798},"end":{"line":11,"column":117,"offset":914},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":798},"end":{"line":11,"column":117,"offset":914},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" using (AdventureWorksEntities context = new AdventureWorksEntities()) { var productsQuery = context.Products.Where(p=>p.Size ==\"L\").ToList(); //Executed here } ","position":{"start":{"line":12,"column":1,"offset":915},"end":{"line":14,"column":4,"offset":1090},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"One advantage is that you can refined the query in a later stage without affecting the performance since it will be executed once. It also let you have the flexibility to build the query in multiple steps. Finally, it let you execute the query at the later stage possible which is good to have the latest version of the data.","position":{"start":{"line":16,"column":1,"offset":1092},"end":{"line":16,"column":326,"offset":1417},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":1092},"end":{"line":16,"column":326,"offset":1417},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Linq to Entity doesn't load data right after calling the context\",\"date\":\"2012-03-23\",\"categories\":[\"entity-framework\"]}","position":{"start":{"line":19,"column":1,"offset":1420},"end":{"line":19,"column":159,"offset":1578},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":19,"column":159,"offset":1578}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Linq to Entity doesn't load data right after calling the context\",\n  \"date\": \"2012-03-23\",\n  \"categories\": [\"entity-framework\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Linq to Entity doesn't execute directly the SQL query to the database when the query is done. This is called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Deffered execution\"), \".\"), mdx(\"p\", null, \"The SQL will be executed when the code will loop through it with a foreach or if the code use .ToArray(), .ToList(), .ToDictionary() or .ToLookup().\"), mdx(\"p\", null, \"Here is an example, mostly taken from MSDN showing when the data is loaded from the SQL server. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" using (AdventureWorksEntities context = new AdventureWorksEntities()) { IQueryable<Product> productsQuery = context.Products; //productsQuery is not loaded yet IQueryable<Product> largeProducts = productsQuery.Where(p => p.Size == \\\"L\\\"); //largeProducts is not loaded yet foreach (var product in largeProducts) //Execution is here at the beginning of this code { Console.WriteLine(product.Name); } } \\n\")), mdx(\"p\", null, \"This is a second example where the deferred is not taking long since we are using ToList() which call the database. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" using (AdventureWorksEntities context = new AdventureWorksEntities()) { var productsQuery = context.Products.Where(p=>p.Size ==\\\"L\\\").ToList(); //Executed here } \\n\")), mdx(\"p\", null, \"One advantage is that you can refined the query in a later stage without affecting the performance since it will be executed once. It also let you have the flexibility to build the query in multiple steps. Finally, it let you execute the query at the later stage possible which is good to have the latest version of the data.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Linq to Entity doesn't load data right after calling the context\",\n  \"date\": \"2012-03-23\",\n  \"categories\": [\"entity-framework\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Linq to Entity doesn't execute directly the SQL query to the database when the query is done. This is called `}<strong parentName=\"p\">{`Deffered execution`}</strong>{`.`}</p>\n    <p>{`The SQL will be executed when the code will loop through it with a foreach or if the code use .ToArray(), .ToList(), .ToDictionary() or .ToLookup().`}</p>\n    <p>{`Here is an example, mostly taken from MSDN showing when the data is loaded from the SQL server. `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` using (AdventureWorksEntities context = new AdventureWorksEntities()) { IQueryable<Product> productsQuery = context.Products; //productsQuery is not loaded yet IQueryable<Product> largeProducts = productsQuery.Where(p => p.Size == \"L\"); //largeProducts is not loaded yet foreach (var product in largeProducts) //Execution is here at the beginning of this code { Console.WriteLine(product.Name); } } \n`}</code></pre>\n    <p>{`This is a second example where the deferred is not taking long since we are using ToList() which call the database. `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` using (AdventureWorksEntities context = new AdventureWorksEntities()) { var productsQuery = context.Products.Where(p=>p.Size ==\"L\").ToList(); //Executed here } \n`}</code></pre>\n    <p>{`One advantage is that you can refined the query in a later stage without affecting the performance since it will be executed once. It also let you have the flexibility to build the query in multiple steps. Finally, it let you execute the query at the later stage possible which is good to have the latest version of the data.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}