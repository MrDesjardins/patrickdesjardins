{"expireTime":9007200886478381000,"key":"gatsby-plugin-mdx-entire-payload-f70f7c582e0f2d12f3df9cd417b33024--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Insertion sort name is confusing. It won't swap in the same manner that the bubble sort or the selection sort did, however, it won't insert new element in the array neither. It will save the value to position in a variable and go down the array to find the proper place to swap the value. During the progress of going down the array, many swapping can occur.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":359,"offset":359},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":359,"offset":359},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The idea is : Position at the beginning of the array by moving previous value up and finally swap once reach the correct spot.","position":{"start":{"line":4,"column":1,"offset":361},"end":{"line":4,"column":127,"offset":487},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":361},"end":{"line":4,"column":127,"offset":487},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function insertionSort(arrayToSort) {\n  var key;\n  var length = arrayToSort.length;\n  for (var i = 1; i < length; i++) {\n    key = arrayToSort[i];\n    var j = i - 1;\n    while (j >= 0 && arrayToSort[j] > key) {\n      arrayToSort[j + 1] = arrayToSort[j];\n      j = j - 1;\n    }\n    arrayToSort[j + 1] = key;\n  }\n}","position":{"start":{"line":6,"column":1,"offset":489},"end":{"line":20,"column":4,"offset":819},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Insertion sort is O(n^2) with its double imbricated loop.","position":{"start":{"line":22,"column":1,"offset":821},"end":{"line":22,"column":58,"offset":878},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":821},"end":{"line":22,"column":58,"offset":878},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"JavaScript Insertion Sort\",\"date\":\"2017-07-12\",\"categories\":[\"javascript\"]}","position":{"start":{"line":25,"column":1,"offset":881},"end":{"line":25,"column":114,"offset":994},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":25,"column":114,"offset":994}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript Insertion Sort\",\n  \"date\": \"2017-07-12\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Insertion sort name is confusing. It won't swap in the same manner that the bubble sort or the selection sort did, however, it won't insert new element in the array neither. It will save the value to position in a variable and go down the array to find the proper place to swap the value. During the progress of going down the array, many swapping can occur.\"), mdx(\"p\", null, \"The idea is : Position at the beginning of the array by moving previous value up and finally swap once reach the correct spot.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"function insertionSort(arrayToSort) {\\n  var key;\\n  var length = arrayToSort.length;\\n  for (var i = 1; i < length; i++) {\\n    key = arrayToSort[i];\\n    var j = i - 1;\\n    while (j >= 0 && arrayToSort[j] > key) {\\n      arrayToSort[j + 1] = arrayToSort[j];\\n      j = j - 1;\\n    }\\n    arrayToSort[j + 1] = key;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Insertion sort is O(n^2) with its double imbricated loop.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"JavaScript Insertion Sort\",\n  \"date\": \"2017-07-12\",\n  \"categories\": [\"javascript\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Insertion sort name is confusing. It won't swap in the same manner that the bubble sort or the selection sort did, however, it won't insert new element in the array neither. It will save the value to position in a variable and go down the array to find the proper place to swap the value. During the progress of going down the array, many swapping can occur.`}</p>\n    <p>{`The idea is : Position at the beginning of the array by moving previous value up and finally swap once reach the correct spot.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function insertionSort(arrayToSort) {\n  var key;\n  var length = arrayToSort.length;\n  for (var i = 1; i < length; i++) {\n    key = arrayToSort[i];\n    var j = i - 1;\n    while (j >= 0 && arrayToSort[j] > key) {\n      arrayToSort[j + 1] = arrayToSort[j];\n      j = j - 1;\n    }\n    arrayToSort[j + 1] = key;\n  }\n}\n`}</code></pre>\n    <p>{`Insertion sort is O(n^2) with its double imbricated loop.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}