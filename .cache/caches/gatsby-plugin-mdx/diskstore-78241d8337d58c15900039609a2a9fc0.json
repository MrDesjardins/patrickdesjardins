{"expireTime":9007200886478395000,"key":"gatsby-plugin-mdx-entire-payload-03452aa5b513da036b88c6899132bf40--undefined","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"You may want to have a specific master page for a specific page. This can be handled in many way.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":98,"offset":98},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":98,"offset":98},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The first way is the simplest and can be good enough for few pages that need a specific master page. This is done by returning the view with the master page parameter.","position":{"start":{"line":4,"column":1,"offset":100},"end":{"line":4,"column":168,"offset":267},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":100},"end":{"line":4,"column":168,"offset":267},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public ActionResult Index() { return View(\"Index\", \"MasterPageCustom\"); } ","position":{"start":{"line":7,"column":1,"offset":270},"end":{"line":9,"column":4,"offset":359},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"You could also use the View object and setting the master page name with a setter.","position":{"start":{"line":11,"column":1,"offset":361},"end":{"line":11,"column":83,"offset":443},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":361},"end":{"line":11,"column":83,"offset":443},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" public ActionResult SomeOtherPage() { var view = View(\"Index\"); view.MasterName = \"MasterPageCustom\"; return view; } ","position":{"start":{"line":14,"column":1,"offset":446},"end":{"line":16,"column":4,"offset":578},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Generally, if you have a bigger website, you would prefer to handle master page at a higher level like the controller. This can be done by using the OnActionExecuted. Right after the action is executed, the controller can change the master page of the returned view.","position":{"start":{"line":18,"column":1,"offset":580},"end":{"line":18,"column":267,"offset":846},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":580},"end":{"line":18,"column":267,"offset":846},"indent":[]}},{"type":"code","lang":"csharp","meta":null,"value":" protected override void OnActionExecuted(ActionExecutedContext filterContext) { var action = filterContext.Result as ViewResult; //Verify that nothing has been previously set. This give the possibility to //still be able to set the master page at a more atomic position (action). if (action != null && String.IsNullOrEmpty(action.MasterName)) { action.MasterName = \"MasterPageCustom\"; } //Default stuff base.OnActionExecuted(filterContext); } ","position":{"start":{"line":21,"column":1,"offset":849},"end":{"line":23,"column":4,"offset":1307},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The later solution is the best one in the case that you have multiple action methods that use the same master page. It also give the flexibility to change it for specific action. The first solution should be used if the master page is used for few actions only.","position":{"start":{"line":25,"column":1,"offset":1309},"end":{"line":25,"column":262,"offset":1570},"indent":[]}}],"position":{"start":{"line":25,"column":1,"offset":1309},"end":{"line":25,"column":262,"offset":1570},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"How to change master page for a specific view with Asp.Net MVC\",\"date\":\"2012-06-17\",\"categories\":[\"asp-mvc\"]}","position":{"start":{"line":28,"column":1,"offset":1573},"end":{"line":28,"column":148,"offset":1720},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":28,"column":148,"offset":1720}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to change master page for a specific view with Asp.Net MVC\",\n  \"date\": \"2012-06-17\",\n  \"categories\": [\"asp-mvc\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"You may want to have a specific master page for a specific page. This can be handled in many way.\"), mdx(\"p\", null, \"The first way is the simplest and can be good enough for few pages that need a specific master page. This is done by returning the view with the master page parameter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public ActionResult Index() { return View(\\\"Index\\\", \\\"MasterPageCustom\\\"); } \\n\")), mdx(\"p\", null, \"You could also use the View object and setting the master page name with a setter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" public ActionResult SomeOtherPage() { var view = View(\\\"Index\\\"); view.MasterName = \\\"MasterPageCustom\\\"; return view; } \\n\")), mdx(\"p\", null, \"Generally, if you have a bigger website, you would prefer to handle master page at a higher level like the controller. This can be done by using the OnActionExecuted. Right after the action is executed, the controller can change the master page of the returned view.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \" protected override void OnActionExecuted(ActionExecutedContext filterContext) { var action = filterContext.Result as ViewResult; //Verify that nothing has been previously set. This give the possibility to //still be able to set the master page at a more atomic position (action). if (action != null && String.IsNullOrEmpty(action.MasterName)) { action.MasterName = \\\"MasterPageCustom\\\"; } //Default stuff base.OnActionExecuted(filterContext); } \\n\")), mdx(\"p\", null, \"The later solution is the best one in the case that you have multiple action methods that use the same master page. It also give the flexibility to change it for specific action. The first solution should be used if the master page is used for few actions only.\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"How to change master page for a specific view with Asp.Net MVC\",\n  \"date\": \"2012-06-17\",\n  \"categories\": [\"asp-mvc\"]\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`You may want to have a specific master page for a specific page. This can be handled in many way.`}</p>\n    <p>{`The first way is the simplest and can be good enough for few pages that need a specific master page. This is done by returning the view with the master page parameter.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public ActionResult Index() { return View(\"Index\", \"MasterPageCustom\"); } \n`}</code></pre>\n    <p>{`You could also use the View object and setting the master page name with a setter.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` public ActionResult SomeOtherPage() { var view = View(\"Index\"); view.MasterName = \"MasterPageCustom\"; return view; } \n`}</code></pre>\n    <p>{`Generally, if you have a bigger website, you would prefer to handle master page at a higher level like the controller. This can be done by using the OnActionExecuted. Right after the action is executed, the controller can change the master page of the returned view.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-csharp\"\n      }}>{` protected override void OnActionExecuted(ActionExecutedContext filterContext) { var action = filterContext.Result as ViewResult; //Verify that nothing has been previously set. This give the possibility to //still be able to set the master page at a more atomic position (action). if (action != null && String.IsNullOrEmpty(action.MasterName)) { action.MasterName = \"MasterPageCustom\"; } //Default stuff base.OnActionExecuted(filterContext); } \n`}</code></pre>\n    <p>{`The later solution is the best one in the case that you have multiple action methods that use the same master page. It also give the flexibility to change it for specific action. The first solution should be used if the master page is used for few actions only.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}