<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="/images/blog/GraphQLServers-NodesAndVertices-1.png"/><link rel="stylesheet" href="/_next/static/css/4f3d065c9e2d01e0.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/53b43e0c4d52a797.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-cb060a6df4d56a9e.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-cc48c28d170fddc2.js" async="" crossorigin=""></script><script src="/_next/static/chunks/69-c7efea4b65083e7f.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-f550f103b66f998a.js" async="" crossorigin=""></script><script src="/_next/static/chunks/250-d7e0a94ebe194dac.js" async=""></script><script src="/_next/static/chunks/79-2d03397107aae3f1.js" async=""></script><script src="/_next/static/chunks/app/blog/%5Bslug%5D/page-105baf7eecf41e41.js" async=""></script><title>Patrick Desjardins Blog - GraphQL Resolvers with Apollo</title><meta name="description" content="GraphQL Resolvers with Apollo"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body class="layout_bodystyle__4ncsS"><div class="__className_aaf875"><div class="layout_container__Tovb9"><header class="layout_siteTitle__k5U8g">Patrick Desjardins Blog</header><nav><ul class="layout_navLinks__mf70r"><li class="layout_navLinkItem__1L8fB"><a class="layout_navLinkText__bt28R" href="/">Main Page</a><a class="layout_navLinkText__bt28R" href="/blog">Blog</a><a class="layout_navLinkText__bt28R" href="/blog/for/2024">2024</a><a class="layout_navLinkText__bt28R" href="/blog/for/2023">2023</a><a class="layout_navLinkText__bt28R" href="/blog/for/2022">2022</a><a class="layout_navLinkText__bt28R" href="/blog/for/2021">2021</a><a class="layout_navLinkText__bt28R" href="/blog/for/2020">2020</a><a class="layout_navLinkText__bt28R" href="/blog/for/2019">2019</a><a class="layout_navLinkText__bt28R" href="/blog/for/2018">2018</a><a class="layout_navLinkText__bt28R" href="/blog/for/2017">2017</a><a class="layout_navLinkText__bt28R" href="/blog/for/2016">2016</a><a class="layout_navLinkText__bt28R" href="/blog/for/2015">2015</a><a class="layout_navLinkText__bt28R" href="/blog/for/2014">2014</a><a class="layout_navLinkText__bt28R" href="/blog/for/2013">2013</a><a class="layout_navLinkText__bt28R" href="/blog/for/2012">2012</a><a class="layout_navLinkText__bt28R" href="/blog/for/2011">2011</a></li></ul></nav><div class="layout_blogPictureContainer__XC7nK"><img alt="Patrick Desjardins picture from a conference" loading="lazy" width="800" height="260" decoding="async" data-nimg="1" class="layout_blogTopPicture__RJHNN" style="color:transparent" src="/images/backgrounds/patrickdesjardins_conference_bw.jpeg"/></div><main class="layout_main__mXTwS"><h1>GraphQL Resolvers with Apollo</h1><div class="layout_blogPostContainer__WYELx"><p class="layout_blogPostDate__LUvx5">Posted on: <!-- -->2019-02-26</p><p>In this article, we will discuss about two topics that concern resolvers and performance. So far, and by default, everytime a resolver is invoked, this one execute its actions which is mostly be to fetch the data. The problem is that in a graph there is potentially redundant information that will be fetched several time causing performance issue.</p>
<p>For example, a query on an object that is cyclic with cyclic information will cause duplication of call. Imagine querying for obj1-&gt;obj2-&gt;obj1-&gt;obj2.</p>
<p>The problem becomes gargantuan with an array of object. Imagine that you have a single query for each type that is in a big array, you would perform many hundred or thousand of requests while in practice you probably would have use a special endpoint that return a batch of all the information.</p>
<p>The good news is that GraphQL has the concept of resolving at many levels. It is possible to resolve at the root level, which mean directly at the query level. But, alos at any edge which is great for an edge into an array of object or a heavy object that require special need. How, it is possible to resolve at the field level which can also be interesting in the case of a particular field that needs to be tackled differently of its general type.</p>
<p><img src="/images/blog/GraphQLServers-NodesAndVertices-1.png" alt=""/></p>
<p>Three different resolvers: Query, Edges andÂ Fields</p>
<p>The two concepts we will investigate is &quot;look-ahead&quot; and &quot;batching&quot;. The look ahead is the idea of looking in the query schema and performing chirurgical analysis of what is requested. Batching is the of collecting all the desired data to fetch and fetch it once we are done traversing the tree. It means that if in the graph we have several times the same entity to query that we will only do it once -- at the end. From these two summaries, it is clear that one is to optimize the query in term of figuring out which would be the best while the second is to avoid redundant calls. The former can help for avoiding calling several endpoints by redirecting the logic into a single endpoint while the latter removes querying the same element.</p>
<h2>Look-ahead</h2>
<p>A parent children is the common scenario. Imagine a parent who has many children. GraphQL by default will call the resolver for the parent and then will call a single resolver by children. If you have the resolver of the parent fetching the parent data (1 HTTP request) and then one fetch at each child (1 HTTP request multiplied by the number of children) it can become not performant. Even if the GraphQL is connected directly to a database, it would not be performant on a big list of children. The database scenario is often easier to visualize. Instead of making several SELECT statement with a WHERE clause that specify a single child ID, we would do a SELECT statement with a IN clause that specify the array of IDs. That way, it would return a single query response with many rows. In REST, if you have an endpoint that allows the parent to expand the children, you can use that endpoint instead of the one that only return the immediate parent attribute.</p>
<p>In GraphQL, you can peek at what is being queried. The look-ahead notion is the exploration of what the user specified in the query. The information is available in the fourth parameter of the query. The parameter&#x27;s type is &quot;GraphQLResolveInfo&quot;. You can use a NPM package named &quot;<a href="https://www.npmjs.com/package/graphql-fields">graphQLFields</a>&quot; that will give you an easy way to access the information.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#fff;color:#24292e" tabindex="0" data-language="typescript" data-theme="github-light"><code data-language="typescript" data-theme="github-light" style="display:grid"><span data-line=""><span>const fields = graphQLFields(graphQLResolveInfo);</span></span></code></pre></figure>
<p>Once you have extracted all the fields, you can check if the children node is being requested. If not, you can fetch the parent information without the additional payload (SELECT directly the ID without further data from children).</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#fff;color:#24292e" tabindex="0" data-language="typescript" data-theme="github-light"><code data-language="typescript" data-theme="github-light" style="display:grid"><span data-line=""><span> if (fields.sites !== undefined){</span></span>
<span data-line=""><span>    // Perform a more exhaustive query that will save us many small request</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>There is still one issue with the look-ahead: the children resolver is still called and will still perform the request. How can we notify the children that we already have everything we need in a clean way? This is where batching come in.</p>
<h2>Batching</h2>
<p>Batching is doing two things: cache and batch many ids. The whole idea is that instead of calling directly your SQL or REST endpoints, you call the <a href="https://github.com/facebook/dataloader">DataLoader</a>. It is a layer of abstraction that will check if we already have a promise for the key requested. If so, it returns the existing promise. The promise can be already resolved which would be very fast. Th<a href="https://github.com/facebook/dataloader">e DataLoader library is</a> <a href="https://github.com/facebook/dataloader">a NPM</a> <a href="https://github.com/facebook/dataloader">package</a> that has its own TypeScript definition file which is convenient if you are writing your code in TypeScript.</p>
<p>Naturally, the DataLoader is taking an array of the key. Even if you want to request for a single element, the DataLoader will presume that you query for a collection. I will not go in this article about pattern that you can use other than mentioning that you could look at the number of ids passed in the DataLoader and take a smart decision about how to fetch the data. Worth mentioning, the load function of the DataLoader that is needed to get the information from the cache or the code inside the data loader (to fetch) can be invoked multiple times. The DataLoader will coalesce all singular loads which occur within a single tick and then call your batch loading function.</p>
<p>An effective way to work with DataLoader is to have a single DataLoader by way to query the information. For example, if you query a &quot;parent&quot; entity by id, you would have a DataLoader for &quot;parent&quot; by &quot;id&quot;. You will have one for &quot;parent&quot; by &quot;name&quot; and one for &quot;child&quot; by &quot;id&quot;, etc. The separation might sound redundant but a single GraphQL query does not ask for many entities in a different way, hence does not duplicate much.</p>
<p>A good way to keep everything tidy up is to define a class into which we can inject the current user&#x27;s request. It gives all the security information like any authentication bearer token that the fetching code might need. The class trickle down the context information (user&#x27;s HTTP request) by having the request passed in its constructor parameter down to the service that will fetch the data. In the following code, you can see the pattern.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#fff;color:#24292e" tabindex="0" data-language="typescript" data-theme="github-light"><code data-language="typescript" data-theme="github-light" style="display:grid"><span data-line=""><span>export class DataLoaders {</span></span>
<span data-line=""><span>    private dataSources: GraphQLCustomDataSources;</span></span>
<span data-line=""><span>    public getParentByParentId: DataLoader&lt;number, Parent&gt;;</span></span>
<span data-line=""><span>    public getChildByChildId: DataLoader&lt;number, Child&gt;;</span></span>
<span data-line=""><span>    public getChildrenByParentId: DataLoader&lt;number, Child[]&gt;;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    public constructor(requestTyped: IUserRequest) {</span></span>
<span data-line=""><span>        this.dataSources = {</span></span>
<span data-line=""><span>            sourceApi1: new Api1HttpService(requestTyped),</span></span>
<span data-line=""><span>            sourceApi2: new Api2HttpService(requestTyped)</span></span>
<span data-line=""><span>        };</span></span>
<span data-line=""> </span>
<span data-line=""><span>        this.getParentByParentId = new DataLoader&lt;number, Cache[]&gt;(parentIds =&gt; {</span></span>
<span data-line=""><span>            const proms: Promise&lt;Parent[]&gt;[] = [];</span></span>
<span data-line=""><span>            for (let i = 0; i &lt; parentIds.length; i++) {</span></span>
<span data-line=""><span>                proms.push(this.dataSource.sourceApi1.getParent(parentIds[i]));</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>            return Promise.all(proms);</span></span>
<span data-line=""><span>        });</span></span>
<span data-line=""> </span>
<span data-line=""><span>        // And so on for each DataLoader...</span></span>
<span data-line=""> </span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>The code above is a short version of what it can be with two entities: <em>Parent</em> and <em>Child</em>. In reality, you would have way more DataLoader and might want to breakdown each detail into a separated file and use the DataLoaders class as a facade to all the logic. The goal here is to have a single point of initialization to get the HTTP request passed down to the implementation of the data source.</p>
<p>Still, there is an issue. We are caching the DataLoader of the <em>Parent</em> entity, not the <em>Child</em>Â entity. It means that when the GraphQL traverse and invokes the children resolver, that this one will call the DataLoader that request the child information by child id, not by parent ID. There are many patterns. You could invoke the parent DataLoader and check if the data is already present. You can also have the parent DataLoader <em>primes</em> the child DataLoader. Priming the data means to set in another cache the data. The following code can be added to the DataLoader previously built. Now, the GraphQL invokes the DataLoader of the parent, get the data and populate the parent&#x27;s cache. Because it has the information about the children, it loops the collection and primes the child&#x27;s DataLoader as well. The traversal continues and the child&#x27;s resolver calls the child&#x27;s DataLoader that has a promise resolved with the child data.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#fff;color:#24292e" tabindex="0" data-language="typescript" data-theme="github-light"><code data-language="typescript" data-theme="github-light" style="display:grid"><span data-line=""><span>children.forEach(c =&gt; {</span></span>
<span data-line=""><span>      this.getChildByChildId.prime(c.id, c);</span></span>
<span data-line=""><span>});</span></span>
<span data-line=""> </span></code></pre></figure>
<p>From there, you instantiate the class once in the Apollo&#x27;s server configuration. The instantiation will occur at every request, hence no data is mixed between users.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#fff;color:#24292e" tabindex="0" data-language="typescript" data-theme="github-light"><code data-language="typescript" data-theme="github-light" style="display:grid"><span data-line=""><span>async function apolloServerConfig() {</span></span>
<span data-line=""><span>    const serverConfig: ApolloServerConfig = {</span></span>
<span data-line=""><span>        schema: schemas,</span></span>
<span data-line=""><span>        context: (context: GraphQLCustomResolversContext) =&gt; {</span></span>
<span data-line=""><span>             const newContext: GraphQLCustomContext = {</span></span>
<span data-line=""><span>                loaders: new DataLoaders(requestTyped)</span></span>
<span data-line=""><span>            };</span></span>
<span data-line=""><span>            return newContext;</span></span>
<span data-line=""><span>        },</span></span>
<span data-line=""><span>    // ...</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<h2>Summary</h2>
<p>The DataLoader library is useful to cache data during a single request when GraphQL is traversing the tree. A parent node can look-ahead and load in batch information reducing the number of future requests. The DataLoader library cache the result for each DataLoader. In the code presented, the DataLoader was filling up the parent loader which might not be useful in the situation but by <em>priming</em> the child&#x27;s DataLoader jettisoned all costly subsequent in the child&#x27;s resolver.</p>
<h2>Related GraphQL Articles</h2>
<ul>
<li><a href="getting-started-with-graphql-for-netflix-open-connect">Getting Started with GraphQL for Netflix Open Connect</a></li>
<li><a href="install-apollo-server-to-host-a-graphql-service">Install Apollo Server to host a GraphQL service</a></li>
<li><a href="apollo-server-and-secured-playground">Apollo Server and Secured Playground</a></li>
<li><a href="graphql-context">GraphQL Context</a></li>
<li><a href="graphql-query-with-argument">GraphQL Query with Argument</a></li>
<li><a href="apollo-graphql-resolvers-and-data-source-separation">Apollo GraphQL Resolvers and Data Source separation</a></li>
<li><a href="how-to-setup-a-typescript-nodejs-express-apollo-server-to-easy-debugging-with-vscode">How to setup a TypeScript, NodeJS, Express Apollo Server to easy debugging with VsCode</a></li>
<li><a href="graphql-resolvers-with-apollo">GraphQL Resolvers with Apollo</a></li>
<li><a href="configuring-apollo-playground-and-api-on-two-different-url">Configuring Apollo Playground and API on two different URL</a></li>
<li><a href="how-to-automatically-generate-typescript-for-consumer-of-your-graphql">How to automatically generate TypeScript for consumers of your GraphQL</a></li>
<li><a href="graphql-extension-to-collect-http-and-resolvers-telemetry">GraphQL and HTTP Telemetry</a></li>
<li><a href="how-to-consume-graphql-in-typescript-and-react">GraphQL and TypeScript/React</a></li>
</ul></div></main><div class="layout_paginationBar__jnuuR"><div class="layout_paginationTitle__PsOw5">Chronological Blog Articles by Page</div><div class="layout_paginationLinks__LdBaH"><a class="" href="/blog/page/1">1</a><a class="" href="/blog/page/2">2</a><a class="" href="/blog/page/3">3</a><a class="" href="/blog/page/4">4</a><a class="" href="/blog/page/5">5</a><a class="" href="/blog/page/6">6</a><a class="" href="/blog/page/7">7</a><a class="" href="/blog/page/8">8</a><a class="" href="/blog/page/9">9</a><a class="" href="/blog/page/10">10</a><a class="" href="/blog/page/11">11</a><a class="" href="/blog/page/12">12</a><a class="" href="/blog/page/13">13</a><a class="" href="/blog/page/14">14</a><a class="" href="/blog/page/15">15</a><a class="" href="/blog/page/16">16</a><a class="" href="/blog/page/17">17</a><a class="" href="/blog/page/18">18</a><a class="" href="/blog/page/19">19</a><a class="" href="/blog/page/20">20</a><a class="" href="/blog/page/21">21</a><a class="" href="/blog/page/22">22</a><a class="" href="/blog/page/23">23</a><a class="" href="/blog/page/24">24</a><a class="" href="/blog/page/25">25</a><a class="" href="/blog/page/26">26</a><a class="" href="/blog/page/27">27</a><a class="" href="/blog/page/28">28</a><a class="" href="/blog/page/29">29</a><a class="" href="/blog/page/30">30</a><a class="" href="/blog/page/31">31</a><a class="" href="/blog/page/32">32</a><a class="" href="/blog/page/33">33</a><a class="" href="/blog/page/34">34</a><a class="" href="/blog/page/35">35</a><a class="" href="/blog/page/36">36</a><a class="" href="/blog/page/37">37</a><a class="" href="/blog/page/38">38</a><a class="" href="/blog/page/39">39</a><a class="" href="/blog/page/40">40</a><a class="" href="/blog/page/41">41</a><a class="" href="/blog/page/42">42</a><a class="" href="/blog/page/43">43</a><a class="" href="/blog/page/44">44</a><a class="" href="/blog/page/45">45</a><a class="" href="/blog/page/46">46</a><a class="" href="/blog/page/47">47</a><a class="" href="/blog/page/48">48</a><a class="" href="/blog/page/49">49</a><a class="" href="/blog/page/50">50</a><a class="" href="/blog/page/51">51</a><a class="" href="/blog/page/52">52</a><a class="" href="/blog/page/53">53</a><a class="" href="/blog/page/54">54</a><a class="" href="/blog/page/55">55</a><a class="" href="/blog/page/56">56</a><a class="" href="/blog/page/57">57</a><a class="" href="/blog/page/58">58</a><a class="" href="/blog/page/59">59</a><a class="" href="/blog/page/60">60</a><a class="" href="/blog/page/61">61</a><a class="" href="/blog/page/62">62</a><a class="" href="/blog/page/63">63</a><a class="" href="/blog/page/64">64</a><a class="" href="/blog/page/65">65</a><a class="" href="/blog/page/66">66</a><a class="" href="/blog/page/67">67</a><a class="" href="/blog/page/68">68</a><a class="" href="/blog/page/69">69</a><a class="" href="/blog/page/70">70</a><a class="" href="/blog/page/71">71</a><a class="" href="/blog/page/72">72</a><a class="" href="/blog/page/73">73</a><a class="" href="/blog/page/74">74</a><a class="" href="/blog/page/75">75</a><a class="" href="/blog/page/76">76</a><a class="" href="/blog/page/77">77</a></div></div></div></div><script src="/_next/static/chunks/webpack-cb060a6df4d56a9e.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/4f3d065c9e2d01e0.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n4:HL[\"/_next/static/css/53b43e0c4d52a797.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"5:I[7690,[],\"\"]\n8:I[5613,[],\"\"]\na:I[1778,[],\"\"]\nb:I[5250,[\"250\",\"static/chunks/250-d7e0a94ebe194dac.js\",\"79\",\"static/chunks/79-2d03397107aae3f1.js\",\"308\",\"static/chunks/app/blog/%5Bslug%5D/page-105baf7eecf41e41.js\"],\"\"]\nd:I[8955,[],\"\"]\n9:[\"slug\",\"graphql-resolvers-with-apollo\",\"d\"]\ne:[]\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/4f3d065c9e2d01e0.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"0xfz5hAOK8g8s4AOXOm7T\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/graphql-resolvers-with-apollo\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"graphql-resolvers-with-apollo\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"graphql-resolvers-with-apollo\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"graphql-resolvers-with-apollo\",\"d\"],{\"children\":[\"__PAGE__\",{},[\"$L6\",\"$L7\",null]]},[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$9\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/53b43e0c4d52a797.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]]},[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"layout_bodystyle__4ncsS\",\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"style\":{\"display\":\"flex\",\"alignItems\":\"center\",\"justifyContent\":\"center\",\"height\":\"100vh\"},\"children\":[\"$\",\"div\",null,{\"style\":{\"width\":\"50%\",\"height\":\"20%\",\"backgroundColor\":\"#ffeded\",\"borderRadius\":12,\"padding\":12,\"textAlign\":\"center\"},\"children\":[[\"$\",\"h1\",null,{\"children\":\"Not Found\"}],[\"$\",\"p\",null,{\"children\":\"Could not find requested resource\"}],[\"$\",\"$Lb\",null,{\"href\":\"/\",\"children\":\"Return Home\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}]}],null]],\"initialHead\":[false,\"$Lc\"],\"globalErrorComponent\":\"$d\",\"missingSlots\":\"$We\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[1749,[\"250\",\"static/chunks/250-d7e0a94ebe194dac.js\",\"79\",\"static/chunks/79-2d03397107aae3f1.js\",\"308\",\"static/chunks/app/blog/%5Bslug%5D/page-105baf7eecf41e41.js\"],\"Image\"]\nc:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Patrick Desjardins Blog - GraphQL Resolvers with Apollo\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"GraphQL Resolvers with Apollo\"}],[\"$\",\"meta\",\"4\",{\"name\":\"next-size-adju"])</script><script>self.__next_f.push([1,"st\"}]]\n6:null\n"])</script><script>self.__next_f.push([1,"7:[\"$\",\"div\",null,{\"className\":\"__className_aaf875\",\"children\":[\"$\",\"div\",null,{\"className\":\"layout_container__Tovb9\",\"children\":[[\"$\",\"header\",null,{\"className\":\"layout_siteTitle__k5U8g\",\"children\":\"Patrick Desjardins Blog\"}],[\"$\",\"nav\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"layout_navLinks__mf70r\",\"children\":[\"$\",\"li\",null,{\"className\":\"layout_navLinkItem__1L8fB\",\"children\":[[\"$\",\"$Lb\",null,{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/\",\"children\":\"Main Page\"}],[\"$\",\"$Lb\",null,{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog\",\"children\":\"Blog\"}],[[\"$\",\"$Lb\",\"2024\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2024\",\"children\":2024}],[\"$\",\"$Lb\",\"2023\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2023\",\"children\":2023}],[\"$\",\"$Lb\",\"2022\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2022\",\"children\":2022}],[\"$\",\"$Lb\",\"2021\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2021\",\"children\":2021}],[\"$\",\"$Lb\",\"2020\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2020\",\"children\":2020}],[\"$\",\"$Lb\",\"2019\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2019\",\"children\":2019}],[\"$\",\"$Lb\",\"2018\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2018\",\"children\":2018}],[\"$\",\"$Lb\",\"2017\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2017\",\"children\":2017}],[\"$\",\"$Lb\",\"2016\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2016\",\"children\":2016}],[\"$\",\"$Lb\",\"2015\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2015\",\"children\":2015}],[\"$\",\"$Lb\",\"2014\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2014\",\"children\":2014}],[\"$\",\"$Lb\",\"2013\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2013\",\"children\":2013}],[\"$\",\"$Lb\",\"2012\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2012\",\"children\":2012}],[\"$\",\"$Lb\",\"2011\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2011\",\"children\":2011}]]]}]}]}],[\"$\",\"div\",null,{\"className\":\"layout_blogPictureContainer__XC7nK\",\"children\":[\"$\",\"$Lf\",null,{\"className\":\"layout_blogTopPicture__RJHNN\",\"alt\":\"Patrick Desjardins picture from a conference\",\"src\":\"/images/backgrounds/patrickdesjardins_conference_bw.jpeg\",\"width\":800,\"height\":260}]}],[\"$\",\"main\",null,{\"className\":\"layout_main__mXTwS\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"GraphQL Resolvers with Apollo\"}],[\"$\",\"div\",null,{\"className\":\"layout_blogPostContainer__WYELx\",\"children\":[[\"$\",\"p\",null,{\"className\":\"layout_blogPostDate__LUvx5\",\"children\":[\"Posted on: \",\"2019-02-26\"]}],[[\"$\",\"p\",null,{\"children\":\"In this article, we will discuss about two topics that concern resolvers and performance. So far, and by default, everytime a resolver is invoked, this one execute its actions which is mostly be to fetch the data. The problem is that in a graph there is potentially redundant information that will be fetched several time causing performance issue.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"For example, a query on an object that is cyclic with cyclic information will cause duplication of call. Imagine querying for obj1-\u003eobj2-\u003eobj1-\u003eobj2.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The problem becomes gargantuan with an array of object. Imagine that you have a single query for each type that is in a big array, you would perform many hundred or thousand of requests while in practice you probably would have use a special endpoint that return a batch of all the information.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The good news is that GraphQL has the concept of resolving at many levels. It is possible to resolve at the root level, which mean directly at the query level. But, alos at any edge which is great for an edge into an array of object or a heavy object that require special need. How, it is possible to resolve at the field level which can also be interesting in the case of a particular field that needs to be tackled differently of its general type.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"/images/blog/GraphQLServers-NodesAndVertices-1.png\",\"alt\":\"\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Three different resolvers: Query, Edges andÂ Fields\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The two concepts we will investigate is \\\"look-ahead\\\" and \\\"batching\\\". The look ahead is the idea of looking in the query schema and performing chirurgical analysis of what is requested. Batching is the of collecting all the desired data to fetch and fetch it once we are done traversing the tree. It means that if in the graph we have several times the same entity to query that we will only do it once -- at the end. From these two summaries, it is clear that one is to optimize the query in term of figuring out which would be the best while the second is to avoid redundant calls. The former can help for avoiding calling several endpoints by redirecting the logic into a single endpoint while the latter removes querying the same element.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Look-ahead\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"A parent children is the common scenario. Imagine a parent who has many children. GraphQL by default will call the resolver for the parent and then will call a single resolver by children. If you have the resolver of the parent fetching the parent data (1 HTTP request) and then one fetch at each child (1 HTTP request multiplied by the number of children) it can become not performant. Even if the GraphQL is connected directly to a database, it would not be performant on a big list of children. The database scenario is often easier to visualize. Instead of making several SELECT statement with a WHERE clause that specify a single child ID, we would do a SELECT statement with a IN clause that specify the array of IDs. That way, it would return a single query response with many rows. In REST, if you have an endpoint that allows the parent to expand the children, you can use that endpoint instead of the one that only return the immediate parent attribute.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"In GraphQL, you can peek at what is being queried. The look-ahead notion is the exploration of what the user specified in the query. The information is available in the fourth parameter of the query. The parameter's type is \\\"GraphQLResolveInfo\\\". You can use a NPM package named \\\"\",[\"$\",\"a\",null,{\"href\":\"https://www.npmjs.com/package/graphql-fields\",\"children\":\"graphQLFields\"}],\"\\\" that will give you an easy way to access the information.\"]}],\"\\n\",[\"$\",\"figure\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"pre\",null,{\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"tabIndex\":\"0\",\"data-language\":\"typescript\",\"data-theme\":\"github-light\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"typescript\",\"data-theme\":\"github-light\",\"style\":{\"display\":\"grid\"},\"children\":[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"const fields = graphQLFields(graphQLResolveInfo);\"}]}]}]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Once you have extracted all the fields, you can check if the children node is being requested. If not, you can fetch the parent information without the additional payload (SELECT directly the ID without further data from children).\"}],\"\\n\",[\"$\",\"figure\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"pre\",null,{\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"tabIndex\":\"0\",\"data-language\":\"typescript\",\"data-theme\":\"github-light\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"typescript\",\"data-theme\":\"github-light\",\"style\":{\"display\":\"grid\"},\"children\":[[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\" if (fields.sites !== undefined){\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    // Perform a more exhaustive query that will save us many small request\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"}\"}]}]]}]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"There is still one issue with the look-ahead: the children resolver is still called and will still perform the request. How can we notify the children that we already have everything we need in a clean way? This is where batching come in.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Batching\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Batching is doing two things: cache and batch many ids. The whole idea is that instead of calling directly your SQL or REST endpoints, you call the \",[\"$\",\"a\",null,{\"href\":\"https://github.com/facebook/dataloader\",\"children\":\"DataLoader\"}],\". It is a layer of abstraction that will check if we already have a promise for the key requested. If so, it returns the existing promise. The promise can be already resolved which would be very fast. Th\",[\"$\",\"a\",null,{\"href\":\"https://github.com/facebook/dataloader\",\"children\":\"e DataLoader library is\"}],\" \",[\"$\",\"a\",null,{\"href\":\"https://github.com/facebook/dataloader\",\"children\":\"a NPM\"}],\" \",[\"$\",\"a\",null,{\"href\":\"https://github.com/facebook/dataloader\",\"children\":\"package\"}],\" that has its own TypeScript definition file which is convenient if you are writing your code in TypeScript.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Naturally, the DataLoader is taking an array of the key. Even if you want to request for a single element, the DataLoader will presume that you query for a collection. I will not go in this article about pattern that you can use other than mentioning that you could look at the number of ids passed in the DataLoader and take a smart decision about how to fetch the data. Worth mentioning, the load function of the DataLoader that is needed to get the information from the cache or the code inside the data loader (to fetch) can be invoked multiple times. The DataLoader will coalesce all singular loads which occur within a single tick and then call your batch loading function.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"An effective way to work with DataLoader is to have a single DataLoader by way to query the information. For example, if you query a \\\"parent\\\" entity by id, you would have a DataLoader for \\\"parent\\\" by \\\"id\\\". You will have one for \\\"parent\\\" by \\\"name\\\" and one for \\\"child\\\" by \\\"id\\\", etc. The separation might sound redundant but a single GraphQL query does not ask for many entities in a different way, hence does not duplicate much.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"A good way to keep everything tidy up is to define a class into which we can inject the current user's request. It gives all the security information like any authentication bearer token that the fetching code might need. The class trickle down the context information (user's HTTP request) by having the request passed in its constructor parameter down to the service that will fetch the data. In the following code, you can see the pattern.\"}],\"\\n\",[\"$\",\"figure\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"pre\",null,{\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"tabIndex\":\"0\",\"data-language\":\"typescript\",\"data-theme\":\"github-light\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"typescript\",\"data-theme\":\"github-light\",\"style\":{\"display\":\"grid\"},\"children\":[[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"export class DataLoaders {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    private dataSources: GraphQLCustomDataSources;\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    public getParentByParentId: DataLoader\u003cnumber, Parent\u003e;\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    public getChildByChildId: DataLoader\u003cnumber, Child\u003e;\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    public getChildrenByParentId: DataLoader\u003cnumber, Child[]\u003e;\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    public constructor(requestTyped: IUserRequest) {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        this.dataSources = {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            sourceApi1: new Api1HttpService(requestTyped),\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            sourceApi2: new Api2HttpService(requestTyped)\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        };\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        this.getParentByParentId = new DataLoader\u003cnumber, Cache[]\u003e(parentIds =\u003e {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            const proms: Promise\u003cParent[]\u003e[] = [];\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            for (let i = 0; i \u003c parentIds.length; i++) {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"                proms.push(this.dataSource.sourceApi1.getParent(parentIds[i]));\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            }\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            return Promise.all(proms);\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        });\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        // And so on for each DataLoader...\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    }\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"}\"}]}]]}]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The code above is a short version of what it can be with two entities: \",[\"$\",\"em\",null,{\"children\":\"Parent\"}],\" and \",[\"$\",\"em\",null,{\"children\":\"Child\"}],\". In reality, you would have way more DataLoader and might want to breakdown each detail into a separated file and use the DataLoaders class as a facade to all the logic. The goal here is to have a single point of initialization to get the HTTP request passed down to the implementation of the data source.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Still, there is an issue. We are caching the DataLoader of the \",[\"$\",\"em\",null,{\"children\":\"Parent\"}],\" entity, not the \",[\"$\",\"em\",null,{\"children\":\"Child\"}],\"Â entity. It means that when the GraphQL traverse and invokes the children resolver, that this one will call the DataLoader that request the child information by child id, not by parent ID. There are many patterns. You could invoke the parent DataLoader and check if the data is already present. You can also have the parent DataLoader \",[\"$\",\"em\",null,{\"children\":\"primes\"}],\" the child DataLoader. Priming the data means to set in another cache the data. The following code can be added to the DataLoader previously built. Now, the GraphQL invokes the DataLoader of the parent, get the data and populate the parent's cache. Because it has the information about the children, it loops the collection and primes the child's DataLoader as well. The traversal continues and the child's resolver calls the child's DataLoader that has a promise resolved with the child data.\"]}],\"\\n\",[\"$\",\"figure\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"pre\",null,{\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"tabIndex\":\"0\",\"data-language\":\"typescript\",\"data-theme\":\"github-light\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"typescript\",\"data-theme\":\"github-light\",\"style\":{\"display\":\"grid\"},\"children\":[[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"children.forEach(c =\u003e {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"      this.getChildByChildId.prime(c.id, c);\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"});\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}]]}]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"From there, you instantiate the class once in the Apollo's server configuration. The instantiation will occur at every request, hence no data is mixed between users.\"}],\"\\n\",[\"$\",\"figure\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"pre\",null,{\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"tabIndex\":\"0\",\"data-language\":\"typescript\",\"data-theme\":\"github-light\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"typescript\",\"data-theme\":\"github-light\",\"style\":{\"display\":\"grid\"},\"children\":[[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"async function apolloServerConfig() {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    const serverConfig: ApolloServerConfig = {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        schema: schemas,\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        context: (context: GraphQLCustomResolversContext) =\u003e {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"             const newContext: GraphQLCustomContext = {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"                loaders: new DataLoaders(requestTyped)\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            };\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            return newContext;\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        },\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    // ...\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    }\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"}\"}]}]]}]}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Summary\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The DataLoader library is useful to cache data during a single request when GraphQL is traversing the tree. A parent node can look-ahead and load in batch information reducing the number of future requests. The DataLoader library cache the result for each DataLoader. In the code presented, the DataLoader was filling up the parent loader which might not be useful in the situation but by \",[\"$\",\"em\",null,{\"children\":\"priming\"}],\" the child's DataLoader jettisoned all costly subsequent in the child's resolver.\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Related GraphQL Articles\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"getting-started-with-graphql-for-netflix-open-connect\",\"children\":\"Getting Started with GraphQL for Netflix Open Connect\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"install-apollo-server-to-host-a-graphql-service\",\"children\":\"Install Apollo Server to host a GraphQL service\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"apollo-server-and-secured-playground\",\"children\":\"Apollo Server and Secured Playground\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"graphql-context\",\"children\":\"GraphQL Context\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"graphql-query-with-argument\",\"children\":\"GraphQL Query with Argument\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"apollo-graphql-resolvers-and-data-source-separation\",\"children\":\"Apollo GraphQL Resolvers and Data Source separation\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"how-to-setup-a-typescript-nodejs-express-apollo-server-to-easy-debugging-with-vscode\",\"children\":\"How to setup a TypeScript, NodeJS, Express Apollo Server to easy debugging with VsCode\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"graphql-resolvers-with-apollo\",\"children\":\"GraphQL Resolvers with Apollo\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"configuring-apollo-playground-and-api-on-two-different-url\",\"children\":\"Configuring Apollo Playground and API on two different URL\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"how-to-automatically-generate-typescript-for-consumer-of-your-graphql\",\"children\":\"How to automatically generate TypeScript for consumers of your GraphQL\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"graphql-extension-to-collect-http-and-resolvers-telemetry\",\"children\":\"GraphQL and HTTP Telemetry\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"how-to-consume-graphql-in-typescript-and-react\",\"children\":\"GraphQL and TypeScript/React\"}]}],\"\\n\"]}]]]}]]}],[\"$\",\"div\",null,{\"className\":\"layout_paginationBar__jnuuR\",\"children\":[[\"$\",\"div\",null,{\"className\":\"layout_paginationTitle__PsOw5\",\"children\":\"Chronological Blog Articles by Page\"}],[\"$\",\"div\",null,{\"className\":\"layout_paginationLinks__LdBaH\",\"children\":[[\"$\",\"$Lb\",\"1\",{\"className\":\"\",\"href\":\"/blog/page/1\",\"children\":1}],[\"$\",\"$Lb\",\"2\",{\"className\":\"\",\"href\":\"/blog/page/2\",\"children\":2}],[\"$\",\"$Lb\",\"3\",{\"className\":\"\",\"href\":\"/blog/page/3\",\"children\":3}],[\"$\",\"$Lb\",\"4\",{\"className\":\"\",\"href\":\"/blog/page/4\",\"children\":4}],[\"$\",\"$Lb\",\"5\",{\"className\":\"\",\"href\":\"/blog/page/5\",\"children\":5}],[\"$\",\"$Lb\",\"6\",{\"className\":\"\",\"href\":\"/blog/page/6\",\"children\":6}],[\"$\",\"$Lb\",\"7\",{\"className\":\"\",\"href\":\"/blog/page/7\",\"children\":7}],[\"$\",\"$Lb\",\"8\",{\"className\":\"\",\"href\":\"/blog/page/8\",\"children\":8}],[\"$\",\"$Lb\",\"9\",{\"className\":\"\",\"href\":\"/blog/page/9\",\"children\":9}],[\"$\",\"$Lb\",\"10\",{\"className\":\"\",\"href\":\"/blog/page/10\",\"children\":10}],[\"$\",\"$Lb\",\"11\",{\"className\":\"\",\"href\":\"/blog/page/11\",\"children\":11}],[\"$\",\"$Lb\",\"12\",{\"className\":\"\",\"href\":\"/blog/page/12\",\"children\":12}],[\"$\",\"$Lb\",\"13\",{\"className\":\"\",\"href\":\"/blog/page/13\",\"children\":13}],[\"$\",\"$Lb\",\"14\",{\"className\":\"\",\"href\":\"/blog/page/14\",\"children\":14}],[\"$\",\"$Lb\",\"15\",{\"className\":\"\",\"href\":\"/blog/page/15\",\"children\":15}],[\"$\",\"$Lb\",\"16\",{\"className\":\"\",\"href\":\"/blog/page/16\",\"children\":16}],[\"$\",\"$Lb\",\"17\",{\"className\":\"\",\"href\":\"/blog/page/17\",\"children\":17}],[\"$\",\"$Lb\",\"18\",{\"className\":\"\",\"href\":\"/blog/page/18\",\"children\":18}],[\"$\",\"$Lb\",\"19\",{\"className\":\"\",\"href\":\"/blog/page/19\",\"children\":19}],[\"$\",\"$Lb\",\"20\",{\"className\":\"\",\"href\":\"/blog/page/20\",\"children\":20}],[\"$\",\"$Lb\",\"21\",{\"className\":\"\",\"href\":\"/blog/page/21\",\"children\":21}],[\"$\",\"$Lb\",\"22\",{\"className\":\"\",\"href\":\"/blog/page/22\",\"children\":22}],[\"$\",\"$Lb\",\"23\",{\"className\":\"\",\"href\":\"/blog/page/23\",\"children\":23}],[\"$\",\"$Lb\",\"24\",{\"className\":\"\",\"href\":\"/blog/page/24\",\"children\":24}],[\"$\",\"$Lb\",\"25\",{\"className\":\"\",\"href\":\"/blog/page/25\",\"children\":25}],[\"$\",\"$Lb\",\"26\",{\"className\":\"\",\"href\":\"/blog/page/26\",\"children\":26}],[\"$\",\"$Lb\",\"27\",{\"className\":\"\",\"href\":\"/blog/page/27\",\"children\":27}],[\"$\",\"$Lb\",\"28\",{\"className\":\"\",\"href\":\"/blog/page/28\",\"children\":28}],[\"$\",\"$Lb\",\"29\",{\"className\":\"\",\"href\":\"/blog/page/29\",\"children\":29}],[\"$\",\"$Lb\",\"30\",{\"className\":\"\",\"href\":\"/blog/page/30\",\"children\":30}],[\"$\",\"$Lb\",\"31\",{\"className\":\"\",\"href\":\"/blog/page/31\",\"children\":31}],[\"$\",\"$Lb\",\"32\",{\"className\":\"\",\"href\":\"/blog/page/32\",\"children\":32}],[\"$\",\"$Lb\",\"33\",{\"className\":\"\",\"href\":\"/blog/page/33\",\"children\":33}],[\"$\",\"$Lb\",\"34\",{\"className\":\"\",\"href\":\"/blog/page/34\",\"children\":34}],[\"$\",\"$Lb\",\"35\",{\"className\":\"\",\"href\":\"/blog/page/35\",\"children\":35}],[\"$\",\"$Lb\",\"36\",{\"className\":\"\",\"href\":\"/blog/page/36\",\"children\":36}],[\"$\",\"$Lb\",\"37\",{\"className\":\"\",\"href\":\"/blog/page/37\",\"children\":37}],[\"$\",\"$Lb\",\"38\",{\"className\":\"\",\"href\":\"/blog/page/38\",\"children\":38}],[\"$\",\"$Lb\",\"39\",{\"className\":\"\",\"href\":\"/blog/page/39\",\"children\":39}],[\"$\",\"$Lb\",\"40\",{\"className\":\"\",\"href\":\"/blog/page/40\",\"children\":40}],[\"$\",\"$Lb\",\"41\",{\"className\":\"\",\"href\":\"/blog/page/41\",\"children\":41}],[\"$\",\"$Lb\",\"42\",{\"className\":\"\",\"href\":\"/blog/page/42\",\"children\":42}],[\"$\",\"$Lb\",\"43\",{\"className\":\"\",\"href\":\"/blog/page/43\",\"children\":43}],[\"$\",\"$Lb\",\"44\",{\"className\":\"\",\"href\":\"/blog/page/44\",\"children\":44}],[\"$\",\"$Lb\",\"45\",{\"className\":\"\",\"href\":\"/blog/page/45\",\"children\":45}],[\"$\",\"$Lb\",\"46\",{\"className\":\"\",\"href\":\"/blog/page/46\",\"children\":46}],[\"$\",\"$Lb\",\"47\",{\"className\":\"\",\"href\":\"/blog/page/47\",\"children\":47}],[\"$\",\"$Lb\",\"48\",{\"className\":\"\",\"href\":\"/blog/page/48\",\"children\":48}],[\"$\",\"$Lb\",\"49\",{\"className\":\"\",\"href\":\"/blog/page/49\",\"children\":49}],[\"$\",\"$Lb\",\"50\",{\"className\":\"\",\"href\":\"/blog/page/50\",\"children\":50}],[\"$\",\"$Lb\",\"51\",{\"className\":\"\",\"href\":\"/blog/page/51\",\"children\":51}],[\"$\",\"$Lb\",\"52\",{\"className\":\"\",\"href\":\"/blog/page/52\",\"children\":52}],[\"$\",\"$Lb\",\"53\",{\"className\":\"\",\"href\":\"/blog/page/53\",\"children\":53}],[\"$\",\"$Lb\",\"54\",{\"className\":\"\",\"href\":\"/blog/page/54\",\"children\":54}],[\"$\",\"$Lb\",\"55\",{\"className\":\"\",\"href\":\"/blog/page/55\",\"children\":55}],[\"$\",\"$Lb\",\"56\",{\"className\":\"\",\"href\":\"/blog/page/56\",\"children\":56}],[\"$\",\"$Lb\",\"57\",{\"className\":\"\",\"href\":\"/blog/page/57\",\"children\":57}],[\"$\",\"$Lb\",\"58\",{\"className\":\"\",\"href\":\"/blog/page/58\",\"children\":58}],[\"$\",\"$Lb\",\"59\",{\"className\":\"\",\"href\":\"/blog/page/59\",\"children\":59}],[\"$\",\"$Lb\",\"60\",{\"className\":\"\",\"href\":\"/blog/page/60\",\"children\":60}],[\"$\",\"$Lb\",\"61\",{\"className\":\"\",\"href\":\"/blog/page/61\",\"children\":61}],[\"$\",\"$Lb\",\"62\",{\"className\":\"\",\"href\":\"/blog/page/62\",\"children\":62}],[\"$\",\"$Lb\",\"63\",{\"className\":\"\",\"href\":\"/blog/page/63\",\"children\":63}],[\"$\",\"$Lb\",\"64\",{\"className\":\"\",\"href\":\"/blog/page/64\",\"children\":64}],[\"$\",\"$Lb\",\"65\",{\"className\":\"\",\"href\":\"/blog/page/65\",\"children\":65}],[\"$\",\"$Lb\",\"66\",{\"className\":\"\",\"href\":\"/blog/page/66\",\"children\":66}],[\"$\",\"$Lb\",\"67\",{\"className\":\"\",\"href\":\"/blog/page/67\",\"children\":67}],[\"$\",\"$Lb\",\"68\",{\"className\":\"\",\"href\":\"/blog/page/68\",\"children\":68}],[\"$\",\"$Lb\",\"69\",{\"className\":\"\",\"href\":\"/blog/page/69\",\"children\":69}],[\"$\",\"$Lb\",\"70\",{\"className\":\"\",\"href\":\"/blog/page/70\",\"children\":70}],[\"$\",\"$Lb\",\"71\",{\"className\":\"\",\"href\":\"/blog/page/71\",\"children\":71}],[\"$\",\"$Lb\",\"72\",{\"className\":\"\",\"href\":\"/blog/page/72\",\"children\":72}],[\"$\",\"$Lb\",\"73\",{\"className\":\"\",\"href\":\"/blog/page/73\",\"children\":73}],[\"$\",\"$Lb\",\"74\",{\"className\":\"\",\"href\":\"/blog/page/74\",\"children\":74}],[\"$\",\"$Lb\",\"75\",{\"className\":\"\",\"href\":\"/blog/page/75\",\"children\":75}],[\"$\",\"$Lb\",\"76\",{\"className\":\"\",\"href\":\"/blog/page/76\",\"children\":76}],[\"$\",\"$Lb\",\"77\",{\"className\":\"\",\"href\":\"/blog/page/77\",\"children\":77}]]}]]}]]}]}]\n"])</script><script>self.__next_f.push([1,""])</script></body></html>