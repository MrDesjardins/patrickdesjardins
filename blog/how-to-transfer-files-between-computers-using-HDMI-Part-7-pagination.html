<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="/images/blog/hdmi_article7_pagination.png"/><link rel="preload" as="image" href="/images/blog/hdmi_article7_pagination2.png"/><link rel="preload" as="image" href="/images/blog/hdmi_article7_framenotfull.png"/><link rel="stylesheet" href="/_next/static/css/f7004a68ac8d367c.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/e917b4f00bcb2347.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-692a33e6ebc06ff4.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-cc48c28d170fddc2.js" async="" crossorigin=""></script><script src="/_next/static/chunks/69-c7efea4b65083e7f.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-f550f103b66f998a.js" async="" crossorigin=""></script><script src="/_next/static/chunks/674-a46cce5ee161a346.js" async=""></script><script src="/_next/static/chunks/app/blog/%5Bslug%5D/page-e23445258eb56deb.js" async=""></script><title>Patrick Desjardins Website and Blog</title><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body class="layout_bodystyle__4ncsS"><div class="__className_aaf875"><div class="layout_container__Tovb9"><header class="layout_siteTitle__k5U8g">Patrick Desjardins Blog</header><nav><ul class="layout_navLinks__mf70r"><li class="layout_navLinkItem__1L8fB"><a class="layout_navLinkText__bt28R" href="/">Main Page</a><a class="layout_navLinkText__bt28R" href="/blog">Blog</a><a class="layout_navLinkText__bt28R" href="/blog/for/2024">2024</a><a class="layout_navLinkText__bt28R" href="/blog/for/2023">2023</a><a class="layout_navLinkText__bt28R" href="/blog/for/2022">2022</a><a class="layout_navLinkText__bt28R" href="/blog/for/2021">2021</a><a class="layout_navLinkText__bt28R" href="/blog/for/2020">2020</a><a class="layout_navLinkText__bt28R" href="/blog/for/2019">2019</a><a class="layout_navLinkText__bt28R" href="/blog/for/2018">2018</a><a class="layout_navLinkText__bt28R" href="/blog/for/2017">2017</a><a class="layout_navLinkText__bt28R" href="/blog/for/2016">2016</a><a class="layout_navLinkText__bt28R" href="/blog/for/2015">2015</a><a class="layout_navLinkText__bt28R" href="/blog/for/2014">2014</a><a class="layout_navLinkText__bt28R" href="/blog/for/2013">2013</a><a class="layout_navLinkText__bt28R" href="/blog/for/2012">2012</a><a class="layout_navLinkText__bt28R" href="/blog/for/2011">2011</a></li></ul></nav><div><img alt="Patrick Desjardins picture from a conference" loading="lazy" width="1000" height="300" decoding="async" data-nimg="1" class="layout_blogTopPicture__RJHNN" style="color:transparent" src="/images/backgrounds/patrickdesjardins_conference_bw.jpeg"/></div><main class="layout_main__mXTwS"><h1>How to Transfer Files Between Computers Using HDMI (Part 7: Pagination)</h1><div class="layout_blogPostContainer__WYELx"><p class="layout_blogPostDate__LUvx5">Posted on: <!-- -->2023-07-08</p><p>Transferring data using the HDMI cable and the capture card continues to demonstrate how easily corruption can cause the file to be unusable.</p>
<p>Let&#x27;s review a few points that demonstrate that we have some inconsistancy around frames.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#fff;color:#24292e" tabindex="0" data-language="sh" data-theme="github-light"><code data-language="sh" data-theme="github-light" style="display:grid"><span data-line=""><span>ffmpeg -f dshow -list_options true -i video=&quot;USB Video&quot;</span></span></code></pre></figure>
<p>Shows <span data-rehype-pretty-code-figure=""><code data-language="plaintext" data-theme="github-light" style="background-color:#fff;color:#24292e"><span data-line=""><span>vcodec=mjpeg</span></span></code></span>. The codec is a compressed one, and we have tackled the issue using a less space efficient way, using black and white with more than a single pixel to hold the information.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#fff;color:#24292e" tabindex="0" data-language="sh" data-theme="github-light"><code data-language="sh" data-theme="github-light" style="display:grid"><span data-line=""><span>ffmpeg  -r 15 -f dshow -s 1920x1080 -vcodec mjpeg -rtbufsize 200M -i video=&quot;USB Video&quot; -r 15 out_fps15_size10px.mp4</span></span></code></pre></figure>
<p>The command above uses a lower speed of 15 frames per second (fps) to ensure we give some pace to the whole process. Encoding the file in 15 fps was also required, but it still needs to be fixed. During the command, additional information like the following gives a hint that the fps is inconsistent on reading.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#fff;color:#24292e" tabindex="0" data-language="sh" data-theme="github-light"><code data-language="sh" data-theme="github-light" style="display:grid"><span data-line=""><span>Input #0, dshow, from &#x27;video=USB Video&#x27;:</span></span>
<span data-line=""><span>  Duration: N/A, start: 613320.254228, bitrate: N/A</span></span>
<span data-line=""><span>  Stream #0:0: Video: mjpeg (Baseline) (MJPG / 0x47504A4D), yuvj422p(pc, bt470bg/bt709/unknown), 1920x1080, 15 fps, 15 tbr, 10000k tbn</span></span>
<span data-line=""><span>Stream mapping:</span></span>
<span data-line=""><span>  Stream #0:0 -&gt; #0:0 (mjpeg (native) -&gt; h264 (libx264))</span></span>
<span data-line=""> </span>
<span data-line=""><span>[libx264 @ 000001cd3023be80] using cpu capabilities: MMX2 SSE2Fast SSSE3 SSE4.2 AVX FMA3 BMI2 AVX2 AVX512</span></span>
<span data-line=""><span>[libx264 @ 000001cd3023be80] profile High 4:2:2, level 4.0, 4:2:2, 8-bit</span></span>
<span data-line=""><span>[libx264 @ 000001cd3023be80] 264 - core 164 r3106 eaa68fa - H.264/MPEG-4 AVC codec - Copyleft 2003-2023 - http://www.videolan.org/x264.html - options: cabac=1 ref=3 deblock=1:0:0 analyse=0x3:0x113 me=hex subme=7 psy=1 psy_rd=1.00:0.00 mixed_ref=1 me_range=16 chroma_me=1 trellis=1 8x8dct=1 cqm=0 deadzone=21,11 fast_pskip=1 chroma_qp_offset=-2 threads=24 lookahead_threads=4 sliced_threads=0 nr=0 decimate=1 interlaced=0 bluray_compat=0 constrained_intra=0 bframes=3 b_pyramid=2 b_adapt=1 b_bias=0 direct=1 weightb=1 open_gop=0 weightp=2 keyint=250 keyint_min=15 scenecut=40 intra_refresh=0 rc_lookahead=40 rc=crf mbtree=1 crf=23.0 qcomp=0.60 qpmin=0 qpmax=69 qpstep=4 ip_ratio=1.40 aq=1:1.00</span></span>
<span data-line=""><span>Output #0, mp4, to &#x27;out_fps15_size10px.mp4&#x27;:</span></span>
<span data-line=""><span>  Metadata:</span></span>
<span data-line=""><span>    encoder         : Lavf60.3.100</span></span>
<span data-line=""><span>  Stream #0:0: Video: h264 (avc1 / 0x31637661), yuvj422p(pc, bt470bg/bt709/unknown, progressive), 1920x1080, q=2-31, 15 fps, 15360 tbn</span></span>
<span data-line=""><span>    Metadata:</span></span>
<span data-line=""><span>      encoder         : Lavc60.3.100 libx264</span></span>
<span data-line=""><span>    Side data:</span></span>
<span data-line=""><span>      cpb: bitrate max/min/avg: 0/0/0 buffer size: 0 vbv_delay: N/A</span></span>
<span data-line=""><span>frame=  674 fps= 15 q=27.0 size=  221952kB time=00:00:44.80 bitrate=40585.5kbits/s speed=0.978x</span></span></code></pre></figure>
<p>Zooming toward the encoding portion, we see that there is a mix of mjpeg and h264. At the moment, I only suspect there is more compression than anticipated but we should be cover.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#fff;color:#24292e" tabindex="0" data-language="sh" data-theme="github-light"><code data-language="sh" data-theme="github-light" style="display:grid"><span data-line=""><span>Stream #0:0: Video: mjpeg (Baseline) (MJPG / 0x47504A4D), yuvj422p(pc, bt470bg/bt709/unknown), 1920x1080, 15 fps, 15 tbr, 10000k tbn</span></span>
<span data-line=""><span>Stream #0:0 -&gt; #0:0 (mjpeg (native) -&gt; h264 (libx264))</span></span>
<span data-line=""><span>Stream #0:0: Video: h264 (avc1 / 0x31637661), yuvj422p(pc, bt470bg/bt709/unknown, progressive), 1920x1080, q=2-31, 15 fps, 15360 tbn</span></span></code></pre></figure>
<p>To this point, outside compression that might cause issue there might be another detail escaping us. One hint is the fps of the capture in ffmpg. An hypothesis might be that we are missing some frames. Even missing a single frame will cause the whole file not to be readable. We now rely on a single red frame to indicate the starting point. After the red frame, we assume the next frame is the first one with the instruction frame that gives the number of bytes for the actual content. However, what happens if the frame transfer after the red one fails to be transmitted or read? Also, there is no way to ensure we read all the frames.</p>
<h1>Adaptation: Pagination</h1>
<p>The next idea is to add a reserved 64 bits of space to every frame, similar to the instruction. Also, modifying the instruction to be the <strong>first</strong> 64 bits of the red frame. The reason is that once we figure out the structure to be the starting one (the red one) we do not need to rely on the next frame to be the instruction -- the red frame will always have the instruction. Thus, we can still know the total amount of bytes to recuperate, but now we can do it more reliably.</p>
<p><img src="/images/blog/hdmi_article7_pagination.png" alt=""/></p>
<p>The central concept remains that we generate one starting (red) frame and then the frames for the data. However, With the addition of the pagination, we can read (watch) the whole video several times and use a dictionary (hash map) to accumulate the missing frames on each pass. If we notice missing frames after capturing the footage twice, we could continue to loop the video for longer and see if we can collect all frames.</p>
<p><img src="/images/blog/hdmi_article7_pagination2.png" alt=""/></p>
<p>The illustration shows that the first time the system reads the video, it receives frame #2. It saves it into the map. Then, it captures frame #3. Because the map does not have frame #3, it adds it. Then the instruction is read, telling it needs x amount of bytes. Then, it continues to read and capture frame #1. The order does not matter. The program continues to read frames, but they are all already there, thus does not save anything until the capture is over. On completion, it knows that frame 1 is the first, and so on, until it cannot find the data. In that case, fetching frame #4 would return nothing, which signals to stop concatenating the frame&#x27;s byte. Finally, the stop is to look at the instruction to know the number of relevant bytes to build the original file.</p>
<p>This new solution should fix the current limitation of the algorithm.</p>
<h1>Testing Locally</h1>
<p>The modification worked perfectly locally. I added integration tests in Rust which is a matter of creating a folder called <span data-rehype-pretty-code-figure=""><code data-language="plaintext" data-theme="github-light" style="background-color:#fff;color:#24292e"><span data-line=""><span>tests</span></span></code></span> at the project&#x27;s root. To run only the integration test, we call <span data-rehype-pretty-code-figure=""><code data-language="plaintext" data-theme="github-light" style="background-color:#fff;color:#24292e"><span data-line=""><span>cargo test --test &quot;*&quot;</span></span></code></span>. Generating the video and reading it back using the Rust program works well. A small change visually in the video is that the frame does not use any character and thus is <span data-rehype-pretty-code-figure=""><code data-language="plaintext" data-theme="github-light" style="background-color:#fff;color:#24292e"><span data-line=""><span>null</span></span></code></span> for a frame that is not full of data. Similarly, the starting red frame now contains some white and black in the first 64 pixels (if the size is set to 1). It is the data, including the number of bytes to extract.</p>
<p><img src="/images/blog/hdmi_article7_framenotfull.png" alt=""/></p>
<h1>Testing with Remote Computer</h1>
<p>The ultimate test is to generate the video on a remote machine, play the video and extract using FFmpeg. The same steps as before are required with FFmpeg.</p>
<p>The first test was with a size of 2 using a zip file encoded at 30fps. With the new pagination mechanism, if FFmpeg cannot read at 30fps all frames (some are skipped), the whole sequence would be there within a few loops. I let the FFmpeg loops about 5 times and the result was a video of about 80 megs. However, the code that is reading the video was breaking after two frames.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#fff;color:#24292e" tabindex="0" data-language="rust" data-theme="github-light"><code data-language="rust" data-theme="github-light" style="display:grid"><span data-line=""><span>pub fn video_to_frames(extract_options: &amp;ExtractOptions) -&gt; Vec&lt;VideoFrame&gt; {</span></span>
<span data-line=""><span>    let mut video = VideoCapture::from_file(&amp;extract_options.video_file_path, CAP_ANY)</span></span>
<span data-line=""><span>        .expect(&quot;Could not open video path&quot;);</span></span>
<span data-line=""><span>    let mut all_frames = Vec::new();</span></span>
<span data-line=""><span>    loop {</span></span>
<span data-line=""><span>        let mut frame = Mat::default();</span></span>
<span data-line=""><span>        video</span></span>
<span data-line=""><span>            .read(&amp;mut frame)</span></span>
<span data-line=""><span>            .expect(&quot;Reading frame shouldn&#x27;t crash&quot;);</span></span>
<span data-line=""> </span>
<span data-line=""><span>        if frame.cols() == 0 {</span></span>
<span data-line="" data-highlighted-line=""><span>            break; // &lt;------------------- Here</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""> </span>
<span data-line=""><span>        let source = VideoFrame::from(frame, extract_options.size);</span></span>
<span data-line=""><span>        match source {</span></span>
<span data-line=""><span>            Ok(frame) =&gt; {</span></span>
<span data-line=""><span>                all_frames.push(frame);</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>            Err(err) =&gt; {</span></span>
<span data-line=""><span>                panic!(&quot;Reading from VideoFrame: {:?}&quot;, err);</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    all_frames</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""><span>```</span></span>
<span data-line=""> </span>
<span data-line=""><span>After trying several differen ways to open the video like using the ffmpeg wrapper for Rust I was unsuccessful. The video produced can be open with software like VLC but the Open CV couldn&#x27;t. The ffmpeg (using the ffmpeg_next) was not compiling after 30 minutes of try so I gave up.</span></span>
<span data-line=""> </span>
<span data-line=""><span># Codec</span></span>
<span data-line=""> </span>
<span data-line=""><span>The command to read the video stream from the video card uses the `-vcodec mjpeg`. As discussed in a previous post, this is because the ffmpeg specify that this is what the device is providing.</span></span>
<span data-line=""> </span>
<span data-line=""><span>```sh</span></span>
<span data-line=""><span>ffmpeg -f dshow -list_options true -i video=&quot;USB Video&quot;</span></span>
<span data-line=""><span>[dshow @ 0000022277b00100]   vcodec=mjpeg  min s=1920x1080 fps=10 max s=1920x1080 fps=60.0002</span></span>
<span data-line=""><span>[dshow @ 0000022277b00100]   vcodec=mjpeg  min s=1920x1080 fps=10 max s=1920x1080 fps=60.0002 (pc, bt470bg/bt709/unknown, center)</span></span>
<span data-line=""><span>[dshow @ 0000022277b00100]   pixel_format=yuyv422  min s=1920x1080 fps=5 max s=1920x1080 fps=5</span></span>
<span data-line=""><span>[dshow @ 0000022277b00100]   pixel_format=yuyv422  min s=1920x1080 fps=5 max s=1920x1080 fps=5 (tv, bt470bg/bt709/unknown, topleft)</span></span>
<span data-line=""><span>```</span></span>
<span data-line=""> </span>
<span data-line=""><span>However, we could convert into a different format when saving to the file which could be open by Open CV.</span></span>
<span data-line=""> </span>
<span data-line=""><span>While the codev and pixel format were good values compared to the Windows ffmpeg commands below:</span></span>
<span data-line=""> </span>
<span data-line=""><span>```sh</span></span>
<span data-line=""><span>ffmpeg -codecs &gt; codec.txt</span></span>
<span data-line=""><span>ffmpeg -pix_fmts &gt; pix.txt</span></span>
<span data-line=""><span>```</span></span>
<span data-line=""><span>The command to read the capture card kept giving me buffer size limit issue or setting issues. I decided to avoid codec with raw data. It does create a huge file but I was able to read the file using VLC!</span></span>
<span data-line=""> </span>
<span data-line=""><span>```sh</span></span>
<span data-line=""><span>ffmpeg -f dshow -video_size 1920x1080 -i video=&quot;USB Video&quot; -rtbufsize 200M -framerate 30 -c:v copy output.mp4</span></span>
<span data-line=""><span>```</span></span>
<span data-line=""><span>Using the Rust code on the raw output worked! The raw 167 megs of under 12 seconds generated a perfect 2 meg image in 3 minutes 49 seconds. The same as the source.</span></span>
<span data-line=""> </span>
<span data-line=""><span>Let&#x27;s use a codec and see how we can optimize the overall transformation time.</span></span>
<span data-line=""> </span>
<span data-line=""><span>```sh</span></span>
<span data-line=""><span>ffmpeg -f dshow -video_size 1920x1080 -i video=&quot;USB Video&quot; -rtbufsize 200M -framerate 30 -c:v copy input.mp4</span></span>
<span data-line=""><span>ffmpeg -i input.mp4 -c:v libx264 -crf 23 -preset medium -c:a aac -b:a 128k output.mp4</span></span>
<span data-line=""><span>```</span></span>
<span data-line=""><span>The time was not better (I stopped the Rust script after 5 minutes, it wasn&#x27;t even at 25%) and actually added potential issue with the compression. Also, while running the second command, the console is flooded with the following error. Still, the file can be read by VLC and by the Rust program.</span></span>
<span data-line=""> </span>
<span data-line=""><span>&gt; [mjpeg @ 0000025116f78740] Found EOI before any SOF, ignoring</span></span>
<span data-line=""><span>&gt; [mjpeg @ 0000025116f78740] No JPEG data found in image</span></span>
<span data-line=""><span>&gt; Error while decoding stream #0:0: Invalid data found when processing input</span></span>
<span data-line=""> </span>
<span data-line=""><span># No Compression, 1 size pixel zip file</span></span>
<span data-line=""> </span>
<span data-line=""><span>The ultimate test was to use a zip file with the most black and white information density of each bit using 1 pixel.</span></span>
<span data-line=""> </span>
<span data-line=""><span>```sh</span></span>
<span data-line=""><span>ffmpeg -f dshow -video_size 1920x1080 -i video=&quot;USB Video&quot; -rtbufsize 200M -framerate 30 -c:v copy input_zip.mp4</span></span>
<span data-line=""><span>cargo run --release -- -m extract -i outputs/input_zip.mp4 -o outputs/PictureFiles.zip --fps 30 --height 1080 --width 1920 --size 1 -p true -a bw</span></span>
<span data-line=""><span>```</span></span>
<span data-line=""><span>I let the recording watch the video twice. It produced a file of 328 megs (16 seconds). The Rust script ran for 1 minute and 6 seconds an failed with missing frame:</span></span>
<span data-line=""> </span>
<span data-line=""><span>&gt; We have not receive all frames. We received 6 frames for a total of 1555152 bytes and we expected 54347552 bytes</span></span>
<span data-line=""> </span>
<span data-line=""><span>I captured again, this time let about 12 iterations of the movie to be recorded. I could see my personal laptop that was running the video being not smooth and the fan running super hard. I suspect frames are skipping as visually I can see some freeze. The generated file was about 850 megs. Unfortunately, the same 6 frames were missing.</span></span></code></pre></figure></div></main><div class="layout_paginationBar__jnuuR"><div class="layout_paginationTitle__PsOw5">Chronological Blog Articles by Page</div><div class="layout_paginationLinks__LdBaH"><a class="" href="/blog/page/1">1</a><a class="" href="/blog/page/2">2</a><a class="" href="/blog/page/3">3</a><a class="" href="/blog/page/4">4</a><a class="" href="/blog/page/5">5</a><a class="" href="/blog/page/6">6</a><a class="" href="/blog/page/7">7</a><a class="" href="/blog/page/8">8</a><a class="" href="/blog/page/9">9</a><a class="" href="/blog/page/10">10</a><a class="" href="/blog/page/11">11</a><a class="" href="/blog/page/12">12</a><a class="" href="/blog/page/13">13</a><a class="" href="/blog/page/14">14</a><a class="" href="/blog/page/15">15</a><a class="" href="/blog/page/16">16</a><a class="" href="/blog/page/17">17</a><a class="" href="/blog/page/18">18</a><a class="" href="/blog/page/19">19</a><a class="" href="/blog/page/20">20</a><a class="" href="/blog/page/21">21</a><a class="" href="/blog/page/22">22</a><a class="" href="/blog/page/23">23</a><a class="" href="/blog/page/24">24</a><a class="" href="/blog/page/25">25</a><a class="" href="/blog/page/26">26</a><a class="" href="/blog/page/27">27</a><a class="" href="/blog/page/28">28</a><a class="" href="/blog/page/29">29</a><a class="" href="/blog/page/30">30</a><a class="" href="/blog/page/31">31</a><a class="" href="/blog/page/32">32</a><a class="" href="/blog/page/33">33</a><a class="" href="/blog/page/34">34</a><a class="" href="/blog/page/35">35</a><a class="" href="/blog/page/36">36</a><a class="" href="/blog/page/37">37</a><a class="" href="/blog/page/38">38</a><a class="" href="/blog/page/39">39</a><a class="" href="/blog/page/40">40</a><a class="" href="/blog/page/41">41</a><a class="" href="/blog/page/42">42</a><a class="" href="/blog/page/43">43</a><a class="" href="/blog/page/44">44</a><a class="" href="/blog/page/45">45</a><a class="" href="/blog/page/46">46</a><a class="" href="/blog/page/47">47</a><a class="" href="/blog/page/48">48</a><a class="" href="/blog/page/49">49</a><a class="" href="/blog/page/50">50</a><a class="" href="/blog/page/51">51</a><a class="" href="/blog/page/52">52</a><a class="" href="/blog/page/53">53</a><a class="" href="/blog/page/54">54</a><a class="" href="/blog/page/55">55</a><a class="" href="/blog/page/56">56</a><a class="" href="/blog/page/57">57</a><a class="" href="/blog/page/58">58</a><a class="" href="/blog/page/59">59</a><a class="" href="/blog/page/60">60</a><a class="" href="/blog/page/61">61</a><a class="" href="/blog/page/62">62</a><a class="" href="/blog/page/63">63</a><a class="" href="/blog/page/64">64</a><a class="" href="/blog/page/65">65</a><a class="" href="/blog/page/66">66</a><a class="" href="/blog/page/67">67</a><a class="" href="/blog/page/68">68</a><a class="" href="/blog/page/69">69</a><a class="" href="/blog/page/70">70</a><a class="" href="/blog/page/71">71</a><a class="" href="/blog/page/72">72</a><a class="" href="/blog/page/73">73</a><a class="" href="/blog/page/74">74</a><a class="" href="/blog/page/75">75</a><a class="" href="/blog/page/76">76</a><a class="" href="/blog/page/77">77</a></div></div></div></div><script src="/_next/static/chunks/webpack-692a33e6ebc06ff4.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/f7004a68ac8d367c.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n4:HL[\"/_next/static/css/e917b4f00bcb2347.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"5:I[7690,[],\"\"]\n8:I[5613,[],\"\"]\na:I[1778,[],\"\"]\nc:I[8955,[],\"\"]\n9:[\"slug\",\"how-to-transfer-files-between-computers-using-HDMI-Part-7-pagination\",\"d\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/f7004a68ac8d367c.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"U9WHEHP9m9dAVmOepwIU5\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/how-to-transfer-files-between-computers-using-HDMI-Part-7-pagination\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"how-to-transfer-files-between-computers-using-HDMI-Part-7-pagination\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"how-to-transfer-files-between-computers-using-HDMI-Part-7-pagination\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"how-to-transfer-files-between-computers-using-HDMI-Part-7-pagination\",\"d\"],{\"children\":[\"__PAGE__\",{},[\"$L6\",\"$L7\",null]]},[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$9\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e917b4f00bcb2347.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]]},[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"title\",null,{\"children\":\"Patrick Desjardins Website and Blog\"}],[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1, shrink-to-fit=no\"}]]}],[\"$\",\"body\",null,{\"className\":\"layout_bodystyle__4ncsS\",\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}]}]]}],null]],\"initialHead\":[false,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:I[5250,[\"674\",\"static/chunks/674-a46cce5ee161a346.js\",\"308\",\"static/chunks/app/blog/%5Bslug%5D/page-e23445258eb56deb.js\"],\"\"]\nf:I[1749,[\"674\",\"static/chunks/674-a46cce5ee161a346.js\",\"308\",\"static/chunks/app/blog/%5Bslug%5D/page-e23445258eb56deb.js\"],\"Image\"]\nb:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"2\",{\"name\":\"next-size-adjust\"}]]\n6:null\n"])</script><script>self.__next_f.push([1,"7:[\"$\",\"div\",null,{\"className\":\"__className_aaf875\",\"children\":[\"$\",\"div\",null,{\"className\":\"layout_container__Tovb9\",\"children\":[[\"$\",\"header\",null,{\"className\":\"layout_siteTitle__k5U8g\",\"children\":\"Patrick Desjardins Blog\"}],[\"$\",\"nav\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"layout_navLinks__mf70r\",\"children\":[\"$\",\"li\",null,{\"className\":\"layout_navLinkItem__1L8fB\",\"children\":[[\"$\",\"$Le\",null,{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/\",\"children\":\"Main Page\"}],[\"$\",\"$Le\",null,{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog\",\"children\":\"Blog\"}],[[\"$\",\"$Le\",\"2024\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2024\",\"children\":2024}],[\"$\",\"$Le\",\"2023\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2023\",\"children\":2023}],[\"$\",\"$Le\",\"2022\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2022\",\"children\":2022}],[\"$\",\"$Le\",\"2021\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2021\",\"children\":2021}],[\"$\",\"$Le\",\"2020\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2020\",\"children\":2020}],[\"$\",\"$Le\",\"2019\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2019\",\"children\":2019}],[\"$\",\"$Le\",\"2018\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2018\",\"children\":2018}],[\"$\",\"$Le\",\"2017\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2017\",\"children\":2017}],[\"$\",\"$Le\",\"2016\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2016\",\"children\":2016}],[\"$\",\"$Le\",\"2015\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2015\",\"children\":2015}],[\"$\",\"$Le\",\"2014\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2014\",\"children\":2014}],[\"$\",\"$Le\",\"2013\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2013\",\"children\":2013}],[\"$\",\"$Le\",\"2012\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2012\",\"children\":2012}],[\"$\",\"$Le\",\"2011\",{\"className\":\"layout_navLinkText__bt28R\",\"href\":\"/blog/for/2011\",\"children\":2011}]]]}]}]}],[\"$\",\"div\",null,{\"children\":[\"$\",\"$Lf\",null,{\"className\":\"layout_blogTopPicture__RJHNN\",\"alt\":\"Patrick Desjardins picture from a conference\",\"src\":\"/images/backgrounds/patrickdesjardins_conference_bw.jpeg\",\"width\":1000,\"height\":300}]}],[\"$\",\"main\",null,{\"className\":\"layout_main__mXTwS\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"How to Transfer Files Between Computers Using HDMI (Part 7: Pagination)\"}],[\"$\",\"div\",null,{\"className\":\"layout_blogPostContainer__WYELx\",\"children\":[[\"$\",\"p\",null,{\"className\":\"layout_blogPostDate__LUvx5\",\"children\":[\"Posted on: \",\"2023-07-08\"]}],[[\"$\",\"p\",null,{\"children\":\"Transferring data using the HDMI cable and the capture card continues to demonstrate how easily corruption can cause the file to be unusable.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Let's review a few points that demonstrate that we have some inconsistancy around frames.\"}],\"\\n\",[\"$\",\"figure\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"pre\",null,{\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"tabIndex\":\"0\",\"data-language\":\"sh\",\"data-theme\":\"github-light\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"sh\",\"data-theme\":\"github-light\",\"style\":{\"display\":\"grid\"},\"children\":[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"ffmpeg -f dshow -list_options true -i video=\\\"USB Video\\\"\"}]}]}]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Shows \",[\"$\",\"span\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"plaintext\",\"data-theme\":\"github-light\",\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"children\":[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"vcodec=mjpeg\"}]}]}]}],\". The codec is a compressed one, and we have tackled the issue using a less space efficient way, using black and white with more than a single pixel to hold the information.\"]}],\"\\n\",[\"$\",\"figure\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"pre\",null,{\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"tabIndex\":\"0\",\"data-language\":\"sh\",\"data-theme\":\"github-light\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"sh\",\"data-theme\":\"github-light\",\"style\":{\"display\":\"grid\"},\"children\":[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"ffmpeg  -r 15 -f dshow -s 1920x1080 -vcodec mjpeg -rtbufsize 200M -i video=\\\"USB Video\\\" -r 15 out_fps15_size10px.mp4\"}]}]}]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The command above uses a lower speed of 15 frames per second (fps) to ensure we give some pace to the whole process. Encoding the file in 15 fps was also required, but it still needs to be fixed. During the command, additional information like the following gives a hint that the fps is inconsistent on reading.\"}],\"\\n\",[\"$\",\"figure\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"pre\",null,{\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"tabIndex\":\"0\",\"data-language\":\"sh\",\"data-theme\":\"github-light\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"sh\",\"data-theme\":\"github-light\",\"style\":{\"display\":\"grid\"},\"children\":[[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"Input #0, dshow, from 'video=USB Video':\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"  Duration: N/A, start: 613320.254228, bitrate: N/A\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"  Stream #0:0: Video: mjpeg (Baseline) (MJPG / 0x47504A4D), yuvj422p(pc, bt470bg/bt709/unknown), 1920x1080, 15 fps, 15 tbr, 10000k tbn\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"Stream mapping:\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"  Stream #0:0 -\u003e #0:0 (mjpeg (native) -\u003e h264 (libx264))\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"[libx264 @ 000001cd3023be80] using cpu capabilities: MMX2 SSE2Fast SSSE3 SSE4.2 AVX FMA3 BMI2 AVX2 AVX512\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"[libx264 @ 000001cd3023be80] profile High 4:2:2, level 4.0, 4:2:2, 8-bit\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"[libx264 @ 000001cd3023be80] 264 - core 164 r3106 eaa68fa - H.264/MPEG-4 AVC codec - Copyleft 2003-2023 - http://www.videolan.org/x264.html - options: cabac=1 ref=3 deblock=1:0:0 analyse=0x3:0x113 me=hex subme=7 psy=1 psy_rd=1.00:0.00 mixed_ref=1 me_range=16 chroma_me=1 trellis=1 8x8dct=1 cqm=0 deadzone=21,11 fast_pskip=1 chroma_qp_offset=-2 threads=24 lookahead_threads=4 sliced_threads=0 nr=0 decimate=1 interlaced=0 bluray_compat=0 constrained_intra=0 bframes=3 b_pyramid=2 b_adapt=1 b_bias=0 direct=1 weightb=1 open_gop=0 weightp=2 keyint=250 keyint_min=15 scenecut=40 intra_refresh=0 rc_lookahead=40 rc=crf mbtree=1 crf=23.0 qcomp=0.60 qpmin=0 qpmax=69 qpstep=4 ip_ratio=1.40 aq=1:1.00\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"Output #0, mp4, to 'out_fps15_size10px.mp4':\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"  Metadata:\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    encoder         : Lavf60.3.100\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"  Stream #0:0: Video: h264 (avc1 / 0x31637661), yuvj422p(pc, bt470bg/bt709/unknown, progressive), 1920x1080, q=2-31, 15 fps, 15360 tbn\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    Metadata:\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"      encoder         : Lavc60.3.100 libx264\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    Side data:\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"      cpb: bitrate max/min/avg: 0/0/0 buffer size: 0 vbv_delay: N/A\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"frame=  674 fps= 15 q=27.0 size=  221952kB time=00:00:44.80 bitrate=40585.5kbits/s speed=0.978x\"}]}]]}]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Zooming toward the encoding portion, we see that there is a mix of mjpeg and h264. At the moment, I only suspect there is more compression than anticipated but we should be cover.\"}],\"\\n\",[\"$\",\"figure\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"pre\",null,{\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"tabIndex\":\"0\",\"data-language\":\"sh\",\"data-theme\":\"github-light\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"sh\",\"data-theme\":\"github-light\",\"style\":{\"display\":\"grid\"},\"children\":[[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"Stream #0:0: Video: mjpeg (Baseline) (MJPG / 0x47504A4D), yuvj422p(pc, bt470bg/bt709/unknown), 1920x1080, 15 fps, 15 tbr, 10000k tbn\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"Stream #0:0 -\u003e #0:0 (mjpeg (native) -\u003e h264 (libx264))\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"Stream #0:0: Video: h264 (avc1 / 0x31637661), yuvj422p(pc, bt470bg/bt709/unknown, progressive), 1920x1080, q=2-31, 15 fps, 15360 tbn\"}]}]]}]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"To this point, outside compression that might cause issue there might be another detail escaping us. One hint is the fps of the capture in ffmpg. An hypothesis might be that we are missing some frames. Even missing a single frame will cause the whole file not to be readable. We now rely on a single red frame to indicate the starting point. After the red frame, we assume the next frame is the first one with the instruction frame that gives the number of bytes for the actual content. However, what happens if the frame transfer after the red one fails to be transmitted or read? Also, there is no way to ensure we read all the frames.\"}],\"\\n\",[\"$\",\"h1\",null,{\"children\":\"Adaptation: Pagination\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The next idea is to add a reserved 64 bits of space to every frame, similar to the instruction. Also, modifying the instruction to be the \",[\"$\",\"strong\",null,{\"children\":\"first\"}],\" 64 bits of the red frame. The reason is that once we figure out the structure to be the starting one (the red one) we do not need to rely on the next frame to be the instruction -- the red frame will always have the instruction. Thus, we can still know the total amount of bytes to recuperate, but now we can do it more reliably.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"/images/blog/hdmi_article7_pagination.png\",\"alt\":\"\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The central concept remains that we generate one starting (red) frame and then the frames for the data. However, With the addition of the pagination, we can read (watch) the whole video several times and use a dictionary (hash map) to accumulate the missing frames on each pass. If we notice missing frames after capturing the footage twice, we could continue to loop the video for longer and see if we can collect all frames.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"/images/blog/hdmi_article7_pagination2.png\",\"alt\":\"\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The illustration shows that the first time the system reads the video, it receives frame #2. It saves it into the map. Then, it captures frame #3. Because the map does not have frame #3, it adds it. Then the instruction is read, telling it needs x amount of bytes. Then, it continues to read and capture frame #1. The order does not matter. The program continues to read frames, but they are all already there, thus does not save anything until the capture is over. On completion, it knows that frame 1 is the first, and so on, until it cannot find the data. In that case, fetching frame #4 would return nothing, which signals to stop concatenating the frame's byte. Finally, the stop is to look at the instruction to know the number of relevant bytes to build the original file.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This new solution should fix the current limitation of the algorithm.\"}],\"\\n\",[\"$\",\"h1\",null,{\"children\":\"Testing Locally\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The modification worked perfectly locally. I added integration tests in Rust which is a matter of creating a folder called \",[\"$\",\"span\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"plaintext\",\"data-theme\":\"github-light\",\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"children\":[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"tests\"}]}]}]}],\" at the project's root. To run only the integration test, we call \",[\"$\",\"span\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"plaintext\",\"data-theme\":\"github-light\",\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"children\":[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"cargo test --test \\\"*\\\"\"}]}]}]}],\". Generating the video and reading it back using the Rust program works well. A small change visually in the video is that the frame does not use any character and thus is \",[\"$\",\"span\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"plaintext\",\"data-theme\":\"github-light\",\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"children\":[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"null\"}]}]}]}],\" for a frame that is not full of data. Similarly, the starting red frame now contains some white and black in the first 64 pixels (if the size is set to 1). It is the data, including the number of bytes to extract.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"/images/blog/hdmi_article7_framenotfull.png\",\"alt\":\"\"}]}],\"\\n\",[\"$\",\"h1\",null,{\"children\":\"Testing with Remote Computer\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The ultimate test is to generate the video on a remote machine, play the video and extract using FFmpeg. The same steps as before are required with FFmpeg.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The first test was with a size of 2 using a zip file encoded at 30fps. With the new pagination mechanism, if FFmpeg cannot read at 30fps all frames (some are skipped), the whole sequence would be there within a few loops. I let the FFmpeg loops about 5 times and the result was a video of about 80 megs. However, the code that is reading the video was breaking after two frames.\"}],\"\\n\",[\"$\",\"figure\",null,{\"data-rehype-pretty-code-figure\":\"\",\"children\":[\"$\",\"pre\",null,{\"style\":{\"backgroundColor\":\"#fff\",\"color\":\"#24292e\"},\"tabIndex\":\"0\",\"data-language\":\"rust\",\"data-theme\":\"github-light\",\"children\":[\"$\",\"code\",null,{\"data-language\":\"rust\",\"data-theme\":\"github-light\",\"style\":{\"display\":\"grid\"},\"children\":[[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"pub fn video_to_frames(extract_options: \u0026ExtractOptions) -\u003e Vec\u003cVideoFrame\u003e {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    let mut video = VideoCapture::from_file(\u0026extract_options.video_file_path, CAP_ANY)\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        .expect(\\\"Could not open video path\\\");\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    let mut all_frames = Vec::new();\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    loop {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        let mut frame = Mat::default();\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        video\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            .read(\u0026mut frame)\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            .expect(\\\"Reading frame shouldn't crash\\\");\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        if frame.cols() == 0 {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"data-highlighted-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            break; // \u003c------------------- Here\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        }\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        let source = VideoFrame::from(frame, extract_options.size);\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        match source {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            Ok(frame) =\u003e {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"                all_frames.push(frame);\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            }\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            Err(err) =\u003e {\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"                panic!(\\\"Reading from VideoFrame: {:?}\\\", err);\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"            }\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"        }\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    }\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"    all_frames\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"}\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"```\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"After trying several differen ways to open the video like using the ffmpeg wrapper for Rust I was unsuccessful. The video produced can be open with software like VLC but the Open CV couldn't. The ffmpeg (using the ffmpeg_next) was not compiling after 30 minutes of try so I gave up.\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"# Codec\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"The command to read the video stream from the video card uses the `-vcodec mjpeg`. As discussed in a previous post, this is because the ffmpeg specify that this is what the device is providing.\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"```sh\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"ffmpeg -f dshow -list_options true -i video=\\\"USB Video\\\"\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"[dshow @ 0000022277b00100]   vcodec=mjpeg  min s=1920x1080 fps=10 max s=1920x1080 fps=60.0002\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"[dshow @ 0000022277b00100]   vcodec=mjpeg  min s=1920x1080 fps=10 max s=1920x1080 fps=60.0002 (pc, bt470bg/bt709/unknown, center)\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"[dshow @ 0000022277b00100]   pixel_format=yuyv422  min s=1920x1080 fps=5 max s=1920x1080 fps=5\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"[dshow @ 0000022277b00100]   pixel_format=yuyv422  min s=1920x1080 fps=5 max s=1920x1080 fps=5 (tv, bt470bg/bt709/unknown, topleft)\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"```\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"However, we could convert into a different format when saving to the file which could be open by Open CV.\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"While the codev and pixel format were good values compared to the Windows ffmpeg commands below:\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"```sh\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"ffmpeg -codecs \u003e codec.txt\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"ffmpeg -pix_fmts \u003e pix.txt\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"```\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"The command to read the capture card kept giving me buffer size limit issue or setting issues. I decided to avoid codec with raw data. It does create a huge file but I was able to read the file using VLC!\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"```sh\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"ffmpeg -f dshow -video_size 1920x1080 -i video=\\\"USB Video\\\" -rtbufsize 200M -framerate 30 -c:v copy output.mp4\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"```\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"Using the Rust code on the raw output worked! The raw 167 megs of under 12 seconds generated a perfect 2 meg image in 3 minutes 49 seconds. The same as the source.\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"Let's use a codec and see how we can optimize the overall transformation time.\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"```sh\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"ffmpeg -f dshow -video_size 1920x1080 -i video=\\\"USB Video\\\" -rtbufsize 200M -framerate 30 -c:v copy input.mp4\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"ffmpeg -i input.mp4 -c:v libx264 -crf 23 -preset medium -c:a aac -b:a 128k output.mp4\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"```\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"The time was not better (I stopped the Rust script after 5 minutes, it wasn't even at 25%) and actually added potential issue with the compression. Also, while running the second command, the console is flooded with the following error. Still, the file can be read by VLC and by the Rust program.\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"\u003e [mjpeg @ 0000025116f78740] Found EOI before any SOF, ignoring\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"\u003e [mjpeg @ 0000025116f78740] No JPEG data found in image\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"\u003e Error while decoding stream #0:0: Invalid data found when processing input\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"# No Compression, 1 size pixel zip file\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"The ultimate test was to use a zip file with the most black and white information density of each bit using 1 pixel.\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"```sh\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"ffmpeg -f dshow -video_size 1920x1080 -i video=\\\"USB Video\\\" -rtbufsize 200M -framerate 30 -c:v copy input_zip.mp4\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"cargo run --release -- -m extract -i outputs/input_zip.mp4 -o outputs/PictureFiles.zip --fps 30 --height 1080 --width 1920 --size 1 -p true -a bw\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"```\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"I let the recording watch the video twice. It produced a file of 328 megs (16 seconds). The Rust script ran for 1 minute and 6 seconds an failed with missing frame:\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"\u003e We have not receive all frames. We received 6 frames for a total of 1555152 bytes and we expected 54347552 bytes\"}]}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":\" \"}],\"\\n\",[\"$\",\"span\",null,{\"data-line\":\"\",\"children\":[\"$\",\"span\",null,{\"children\":\"I captured again, this time let about 12 iterations of the movie to be recorded. I could see my personal laptop that was running the video being not smooth and the fan running super hard. I suspect frames are skipping as visually I can see some freeze. The generated file was about 850 megs. Unfortunately, the same 6 frames were missing.\"}]}]]}]}]}]]]}]]}],[\"$\",\"div\",null,{\"className\":\"layout_paginationBar__jnuuR\",\"children\":[[\"$\",\"div\",null,{\"className\":\"layout_paginationTitle__PsOw5\",\"children\":\"Chronological Blog Articles by Page\"}],[\"$\",\"div\",null,{\"className\":\"layout_paginationLinks__LdBaH\",\"children\":[[\"$\",\"$Le\",\"1\",{\"className\":\"\",\"href\":\"/blog/page/1\",\"children\":1}],[\"$\",\"$Le\",\"2\",{\"className\":\"\",\"href\":\"/blog/page/2\",\"children\":2}],[\"$\",\"$Le\",\"3\",{\"className\":\"\",\"href\":\"/blog/page/3\",\"children\":3}],[\"$\",\"$Le\",\"4\",{\"className\":\"\",\"href\":\"/blog/page/4\",\"children\":4}],[\"$\",\"$Le\",\"5\",{\"className\":\"\",\"href\":\"/blog/page/5\",\"children\":5}],[\"$\",\"$Le\",\"6\",{\"className\":\"\",\"href\":\"/blog/page/6\",\"children\":6}],[\"$\",\"$Le\",\"7\",{\"className\":\"\",\"href\":\"/blog/page/7\",\"children\":7}],[\"$\",\"$Le\",\"8\",{\"className\":\"\",\"href\":\"/blog/page/8\",\"children\":8}],[\"$\",\"$Le\",\"9\",{\"className\":\"\",\"href\":\"/blog/page/9\",\"children\":9}],[\"$\",\"$Le\",\"10\",{\"className\":\"\",\"href\":\"/blog/page/10\",\"children\":10}],[\"$\",\"$Le\",\"11\",{\"className\":\"\",\"href\":\"/blog/page/11\",\"children\":11}],[\"$\",\"$Le\",\"12\",{\"className\":\"\",\"href\":\"/blog/page/12\",\"children\":12}],[\"$\",\"$Le\",\"13\",{\"className\":\"\",\"href\":\"/blog/page/13\",\"children\":13}],[\"$\",\"$Le\",\"14\",{\"className\":\"\",\"href\":\"/blog/page/14\",\"children\":14}],[\"$\",\"$Le\",\"15\",{\"className\":\"\",\"href\":\"/blog/page/15\",\"children\":15}],[\"$\",\"$Le\",\"16\",{\"className\":\"\",\"href\":\"/blog/page/16\",\"children\":16}],[\"$\",\"$Le\",\"17\",{\"className\":\"\",\"href\":\"/blog/page/17\",\"children\":17}],[\"$\",\"$Le\",\"18\",{\"className\":\"\",\"href\":\"/blog/page/18\",\"children\":18}],[\"$\",\"$Le\",\"19\",{\"className\":\"\",\"href\":\"/blog/page/19\",\"children\":19}],[\"$\",\"$Le\",\"20\",{\"className\":\"\",\"href\":\"/blog/page/20\",\"children\":20}],[\"$\",\"$Le\",\"21\",{\"className\":\"\",\"href\":\"/blog/page/21\",\"children\":21}],[\"$\",\"$Le\",\"22\",{\"className\":\"\",\"href\":\"/blog/page/22\",\"children\":22}],[\"$\",\"$Le\",\"23\",{\"className\":\"\",\"href\":\"/blog/page/23\",\"children\":23}],[\"$\",\"$Le\",\"24\",{\"className\":\"\",\"href\":\"/blog/page/24\",\"children\":24}],[\"$\",\"$Le\",\"25\",{\"className\":\"\",\"href\":\"/blog/page/25\",\"children\":25}],[\"$\",\"$Le\",\"26\",{\"className\":\"\",\"href\":\"/blog/page/26\",\"children\":26}],[\"$\",\"$Le\",\"27\",{\"className\":\"\",\"href\":\"/blog/page/27\",\"children\":27}],[\"$\",\"$Le\",\"28\",{\"className\":\"\",\"href\":\"/blog/page/28\",\"children\":28}],[\"$\",\"$Le\",\"29\",{\"className\":\"\",\"href\":\"/blog/page/29\",\"children\":29}],[\"$\",\"$Le\",\"30\",{\"className\":\"\",\"href\":\"/blog/page/30\",\"children\":30}],[\"$\",\"$Le\",\"31\",{\"className\":\"\",\"href\":\"/blog/page/31\",\"children\":31}],[\"$\",\"$Le\",\"32\",{\"className\":\"\",\"href\":\"/blog/page/32\",\"children\":32}],[\"$\",\"$Le\",\"33\",{\"className\":\"\",\"href\":\"/blog/page/33\",\"children\":33}],[\"$\",\"$Le\",\"34\",{\"className\":\"\",\"href\":\"/blog/page/34\",\"children\":34}],[\"$\",\"$Le\",\"35\",{\"className\":\"\",\"href\":\"/blog/page/35\",\"children\":35}],[\"$\",\"$Le\",\"36\",{\"className\":\"\",\"href\":\"/blog/page/36\",\"children\":36}],[\"$\",\"$Le\",\"37\",{\"className\":\"\",\"href\":\"/blog/page/37\",\"children\":37}],[\"$\",\"$Le\",\"38\",{\"className\":\"\",\"href\":\"/blog/page/38\",\"children\":38}],[\"$\",\"$Le\",\"39\",{\"className\":\"\",\"href\":\"/blog/page/39\",\"children\":39}],[\"$\",\"$Le\",\"40\",{\"className\":\"\",\"href\":\"/blog/page/40\",\"children\":40}],[\"$\",\"$Le\",\"41\",{\"className\":\"\",\"href\":\"/blog/page/41\",\"children\":41}],[\"$\",\"$Le\",\"42\",{\"className\":\"\",\"href\":\"/blog/page/42\",\"children\":42}],[\"$\",\"$Le\",\"43\",{\"className\":\"\",\"href\":\"/blog/page/43\",\"children\":43}],[\"$\",\"$Le\",\"44\",{\"className\":\"\",\"href\":\"/blog/page/44\",\"children\":44}],[\"$\",\"$Le\",\"45\",{\"className\":\"\",\"href\":\"/blog/page/45\",\"children\":45}],[\"$\",\"$Le\",\"46\",{\"className\":\"\",\"href\":\"/blog/page/46\",\"children\":46}],[\"$\",\"$Le\",\"47\",{\"className\":\"\",\"href\":\"/blog/page/47\",\"children\":47}],[\"$\",\"$Le\",\"48\",{\"className\":\"\",\"href\":\"/blog/page/48\",\"children\":48}],[\"$\",\"$Le\",\"49\",{\"className\":\"\",\"href\":\"/blog/page/49\",\"children\":49}],[\"$\",\"$Le\",\"50\",{\"className\":\"\",\"href\":\"/blog/page/50\",\"children\":50}],[\"$\",\"$Le\",\"51\",{\"className\":\"\",\"href\":\"/blog/page/51\",\"children\":51}],[\"$\",\"$Le\",\"52\",{\"className\":\"\",\"href\":\"/blog/page/52\",\"children\":52}],[\"$\",\"$Le\",\"53\",{\"className\":\"\",\"href\":\"/blog/page/53\",\"children\":53}],[\"$\",\"$Le\",\"54\",{\"className\":\"\",\"href\":\"/blog/page/54\",\"children\":54}],[\"$\",\"$Le\",\"55\",{\"className\":\"\",\"href\":\"/blog/page/55\",\"children\":55}],[\"$\",\"$Le\",\"56\",{\"className\":\"\",\"href\":\"/blog/page/56\",\"children\":56}],[\"$\",\"$Le\",\"57\",{\"className\":\"\",\"href\":\"/blog/page/57\",\"children\":57}],[\"$\",\"$Le\",\"58\",{\"className\":\"\",\"href\":\"/blog/page/58\",\"children\":58}],[\"$\",\"$Le\",\"59\",{\"className\":\"\",\"href\":\"/blog/page/59\",\"children\":59}],[\"$\",\"$Le\",\"60\",{\"className\":\"\",\"href\":\"/blog/page/60\",\"children\":60}],[\"$\",\"$Le\",\"61\",{\"className\":\"\",\"href\":\"/blog/page/61\",\"children\":61}],[\"$\",\"$Le\",\"62\",{\"className\":\"\",\"href\":\"/blog/page/62\",\"children\":62}],[\"$\",\"$Le\",\"63\",{\"className\":\"\",\"href\":\"/blog/page/63\",\"children\":63}],[\"$\",\"$Le\",\"64\",{\"className\":\"\",\"href\":\"/blog/page/64\",\"children\":64}],[\"$\",\"$Le\",\"65\",{\"className\":\"\",\"href\":\"/blog/page/65\",\"children\":65}],[\"$\",\"$Le\",\"66\",{\"className\":\"\",\"href\":\"/blog/page/66\",\"children\":66}],[\"$\",\"$Le\",\"67\",{\"className\":\"\",\"href\":\"/blog/page/67\",\"children\":67}],[\"$\",\"$Le\",\"68\",{\"className\":\"\",\"href\":\"/blog/page/68\",\"children\":68}],[\"$\",\"$Le\",\"69\",{\"className\":\"\",\"href\":\"/blog/page/69\",\"children\":69}],[\"$\",\"$Le\",\"70\",{\"className\":\"\",\"href\":\"/blog/page/70\",\"children\":70}],[\"$\",\"$Le\",\"71\",{\"className\":\"\",\"href\":\"/blog/page/71\",\"children\":71}],[\"$\",\"$Le\",\"72\",{\"className\":\"\",\"href\":\"/blog/page/72\",\"children\":72}],[\"$\",\"$Le\",\"73\",{\"className\":\"\",\"href\":\"/blog/page/73\",\"children\":73}],[\"$\",\"$Le\",\"74\",{\"className\":\"\",\"href\":\"/blog/page/74\",\"children\":74}],[\"$\",\"$Le\",\"75\",{\"className\":\"\",\"href\":\"/blog/page/75\",\"children\":75}],[\"$\",\"$Le\",\"76\",{\"className\":\"\",\"href\":\"/blog/page/76\",\"children\":76}],[\"$\",\"$Le\",\"77\",{\"className\":\"\",\"href\":\"/blog/page/77\",\"children\":77}]]}]]}]]}]}]\n"])</script><script>self.__next_f.push([1,""])</script></body></html>